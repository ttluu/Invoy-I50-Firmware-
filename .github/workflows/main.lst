CCS PCH C Compiler, Version 5.075, 39288               04-Feb-20 16:20

               Filename:   C:\I50\Invoy 50\main.lst

               ROM used:   61350 bytes (94%)
                           Largest free fragment is 4182
               RAM used:   1799 (46%) at main() level
                           2427 (62%) worst case
               Stack used: 10 locations (6 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   CEBE
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   0456
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   17E0
0006C:  BTFSS  FA3.5
0006E:  GOTO   0078
00072:  BTFSC  FA4.5
00074:  GOTO   041C
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVF   04,W
000BC:  MOVFF  06,FE0
000C0:  MOVFF  05,FD8
000C4:  RETFIE 0
....................  
.................... //////////////////////////////////////// 
....................  
.................... #include <main.h> 
.................... //Rev 5   - implement state code machine, add Ble disconnect to shutdown function 
.................... //        - add dynamic volume setting via bluetooth and RS232 
.................... //    55 - modify volume accumulation to accomodated multiples blow 
.................... //        - update state machine code and save results to EEPROM 
.................... //    61  - Allow firmware to detect no change in pressure during breath test 
.................... //    62  - Reduce the number of handle in bluetooth and size to 20 bytes max in each handle 
.................... //    62.1  - Update the firmware and fixes all bugs related to the BLE update, changes Invoy 5.0 to I50 
.................... //    62.2  - Add 3 commands to test the storage capacity 
.................... //    62.3  - Sent test time immediately after breath test.  No need to wait for cartridge removal. 
.................... //    63.0  - Add a 30 seconds delay prior to set the error at wet cartridge and remove cartridge. 
.................... //    64.0  - Add a reset command to clear all BLE handles data  
.................... //    65.0  - Modidy check_bad_or_used_cartridge to enhance detection and verifycation, update the breath volume before test init to 
.................... //          - avoid rebooting the app, update the breath attempt count. 
.................... //    65.1  - Optimize cartridge detection function to increase dectection better differentiate use & new cartridge 
.................... //    65.2  - Readjust the 588 led power level to 30% and only turn on 1/2 second every five seconds to notify user to blow 
.................... // 
.................... // 
.................... // 
....................  
....................  
....................  
.................... #define FIRMWARE_VERSION_MAJOR 00     // Changes due to requirements or baseline 
.................... #define FIRMWARE_VERSION_MINOR 65     // Changes to functionality 
.................... #define FIRMWARE_VERSION_REVISION 2   // Non-functional changes 
....................  
.................... #include <.\Devices\18LF46K22.h> 
.................... //////////// Standard Header file for the PIC18LF46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
00450:  BCF    FA4.5
00452:  GOTO   0078
*
00466:  BCF    F9E.0
00468:  GOTO   0078
.................... #device PIC18LF46K22 
*
000C6:  CLRF   FF7
000C8:  ADDLW  D6
000CA:  MOVWF  FF6
000CC:  MOVLW  00
000CE:  ADDWFC FF7,F
000D0:  TBLRD*+
000D2:  MOVF   FF5,W
000D4:  RETURN 0
000D6:  DATA 76,6F
000D8:  DATA 6C,74
000DA:  DATA 65,73
000DC:  DATA 74,00
000DE:  CLRF   FF7
000E0:  ADDLW  EE
000E2:  MOVWF  FF6
000E4:  MOVLW  00
000E6:  ADDWFC FF7,F
000E8:  TBLRD*+
000EA:  MOVF   FF5,W
000EC:  RETURN 0
000EE:  DATA 73,65
000F0:  DATA 6C,66
000F2:  DATA 74,65
000F4:  DATA 73,74
000F6:  DATA 00,00
000F8:  CLRF   FF7
000FA:  ADDLW  08
000FC:  MOVWF  FF6
000FE:  MOVLW  01
00100:  ADDWFC FF7,F
00102:  TBLRD*+
00104:  MOVF   FF5,W
00106:  RETURN 0
00108:  DATA 69,64
0010A:  DATA 65,6E
0010C:  DATA 74,69
0010E:  DATA 66,79
00110:  DATA 00,00
00112:  CLRF   FF7
00114:  ADDLW  22
00116:  MOVWF  FF6
00118:  MOVLW  01
0011A:  ADDWFC FF7,F
0011C:  TBLRD*+
0011E:  MOVF   FF5,W
00120:  RETURN 0
00122:  DATA 62,6C
00124:  DATA 65,2E
00126:  DATA 72,65
00128:  DATA 73,65
0012A:  DATA 74,00
0012C:  CLRF   FF7
0012E:  ADDLW  3C
00130:  MOVWF  FF6
00132:  MOVLW  01
00134:  ADDWFC FF7,F
00136:  TBLRD*+
00138:  MOVF   FF5,W
0013A:  RETURN 0
0013C:  DATA 73,65
0013E:  DATA 72,69
00140:  DATA 61,6C
00142:  DATA 3D,00
00144:  CLRF   FF7
00146:  ADDLW  54
00148:  MOVWF  FF6
0014A:  MOVLW  01
0014C:  ADDWFC FF7,F
0014E:  TBLRD*+
00150:  MOVF   FF5,W
00152:  RETURN 0
00154:  DATA 73,65
00156:  DATA 72,69
00158:  DATA 61,6C
0015A:  DATA 00,00
0015C:  CLRF   FF7
0015E:  ADDLW  6C
00160:  MOVWF  FF6
00162:  MOVLW  01
00164:  ADDWFC FF7,F
00166:  TBLRD*+
00168:  MOVF   FF5,W
0016A:  RETURN 0
0016C:  DATA 69,6E
0016E:  DATA 74,65
00170:  DATA 72,63
00172:  DATA 65,70
00174:  DATA 74,3D
00176:  DATA 00,00
00178:  CLRF   FF7
0017A:  ADDLW  88
0017C:  MOVWF  FF6
0017E:  MOVLW  01
00180:  ADDWFC FF7,F
00182:  TBLRD*+
00184:  MOVF   FF5,W
00186:  RETURN 0
00188:  DATA 69,6E
0018A:  DATA 74,65
0018C:  DATA 72,63
0018E:  DATA 65,70
00190:  DATA 74,00
00192:  CLRF   FF7
00194:  ADDLW  A2
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  TBLRD*+
0019E:  MOVF   FF5,W
001A0:  RETURN 0
001A2:  DATA 73,6C
001A4:  DATA 6F,70
001A6:  DATA 65,3D
001A8:  DATA 00,00
001AA:  CLRF   FF7
001AC:  ADDLW  BA
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  TBLRD*+
001B6:  MOVF   FF5,W
001B8:  RETURN 0
001BA:  DATA 63,6F
001BC:  DATA 6E,66
001BE:  DATA 69,67
001C0:  DATA 2E,65
001C2:  DATA 6E,61
001C4:  DATA 62,6C
001C6:  DATA 65,2E
001C8:  DATA 64,79
001CA:  DATA 6E,61
001CC:  DATA 6D,69
001CE:  DATA 63,77
001D0:  DATA 62,00
001D2:  CLRF   FF7
001D4:  ADDLW  E2
001D6:  MOVWF  FF6
001D8:  MOVLW  01
001DA:  ADDWFC FF7,F
001DC:  TBLRD*+
001DE:  MOVF   FF5,W
001E0:  RETURN 0
001E2:  DATA 63,6F
001E4:  DATA 6E,66
001E6:  DATA 69,67
001E8:  DATA 2E,64
001EA:  DATA 69,73
001EC:  DATA 61,62
001EE:  DATA 6C,65
001F0:  DATA 2E,64
001F2:  DATA 79,6E
001F4:  DATA 61,6D
001F6:  DATA 69,63
001F8:  DATA 77,62
001FA:  DATA 00,00
001FC:  CLRF   FF7
001FE:  ADDLW  0C
00200:  MOVWF  FF6
00202:  MOVLW  02
00204:  ADDWFC FF7,F
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 63,6F
0020E:  DATA 6E,66
00210:  DATA 69,67
00212:  DATA 2E,63
00214:  DATA 68,65
00216:  DATA 63,6B
00218:  DATA 2E,64
0021A:  DATA 79,6E
0021C:  DATA 61,6D
0021E:  DATA 69,63
00220:  DATA 77,62
00222:  DATA 00,00
00224:  CLRF   FF7
00226:  ADDLW  34
00228:  MOVWF  FF6
0022A:  MOVLW  02
0022C:  ADDWFC FF7,F
0022E:  TBLRD*+
00230:  MOVF   FF5,W
00232:  RETURN 0
00234:  DATA 72,65
00236:  DATA 61,64
00238:  DATA 69,6E
0023A:  DATA 67,2E
0023C:  DATA 73,69
0023E:  DATA 6D,75
00240:  DATA 6C,61
00242:  DATA 74,65
00244:  DATA 00,00
00246:  CLRF   FF7
00248:  ADDLW  56
0024A:  MOVWF  FF6
0024C:  MOVLW  02
0024E:  ADDWFC FF7,F
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 72,65
00258:  DATA 61,64
0025A:  DATA 69,6E
0025C:  DATA 67,73
0025E:  DATA 2E,70
00260:  DATA 72,69
00262:  DATA 6E,74
00264:  DATA 00,00
00266:  CLRF   FF7
00268:  ADDLW  76
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  TBLRD*+
00272:  MOVF   FF5,W
00274:  RETURN 0
00276:  DATA 72,65
00278:  DATA 61,64
0027A:  DATA 69,6E
0027C:  DATA 67,73
0027E:  DATA 2E,72
00280:  DATA 65,73
00282:  DATA 65,74
00284:  DATA 00,00
00286:  CLRF   FF7
00288:  ADDLW  96
0028A:  MOVWF  FF6
0028C:  MOVLW  02
0028E:  ADDWFC FF7,F
00290:  TBLRD*+
00292:  MOVF   FF5,W
00294:  RETURN 0
00296:  DATA 63,61
00298:  DATA 72,74
0029A:  DATA 72,69
0029C:  DATA 64,67
0029E:  DATA 65,00
002A0:  CLRF   FF7
002A2:  ADDLW  B0
002A4:  MOVWF  FF6
002A6:  MOVLW  02
002A8:  ADDWFC FF7,F
002AA:  TBLRD*+
002AC:  MOVF   FF5,W
002AE:  RETURN 0
002B0:  DATA 62,72
002B2:  DATA 69,67
002B4:  DATA 68,74
002B6:  DATA 37,33
002B8:  DATA 30,3D
002BA:  DATA 00,00
002BC:  CLRF   FF7
002BE:  ADDLW  CC
002C0:  MOVWF  FF6
002C2:  MOVLW  02
002C4:  ADDWFC FF7,F
002C6:  TBLRD*+
002C8:  MOVF   FF5,W
002CA:  RETURN 0
002CC:  DATA 62,72
002CE:  DATA 69,67
002D0:  DATA 68,74
002D2:  DATA 35,38
002D4:  DATA 38,3D
002D6:  DATA 00,00
002D8:  CLRF   FF7
002DA:  ADDLW  E8
002DC:  MOVWF  FF6
002DE:  MOVLW  02
002E0:  ADDWFC FF7,F
002E2:  TBLRD*+
002E4:  MOVF   FF5,W
002E6:  RETURN 0
002E8:  DATA 62,72
002EA:  DATA 69,67
002EC:  DATA 68,74
002EE:  DATA 34,37
002F0:  DATA 35,3D
002F2:  DATA 00,00
002F4:  CLRF   FF7
002F6:  ADDLW  04
002F8:  MOVWF  FF6
002FA:  MOVLW  03
002FC:  ADDWFC FF7,F
002FE:  TBLRD*+
00300:  MOVF   FF5,W
00302:  RETURN 0
00304:  DATA 62,72
00306:  DATA 69,67
00308:  DATA 68,74
0030A:  DATA 6E,65
0030C:  DATA 73,73
0030E:  DATA 00,00
00310:  CLRF   FF7
00312:  ADDLW  20
00314:  MOVWF  FF6
00316:  MOVLW  03
00318:  ADDWFC FF7,F
0031A:  TBLRD*+
0031C:  MOVF   FF5,W
0031E:  RETURN 0
00320:  DATA 6C,65
00322:  DATA 64,34
00324:  DATA 37,35
00326:  DATA 00,00
00328:  CLRF   FF7
0032A:  ADDLW  38
0032C:  MOVWF  FF6
0032E:  MOVLW  03
00330:  ADDWFC FF7,F
00332:  TBLRD*+
00334:  MOVF   FF5,W
00336:  RETURN 0
00338:  DATA 6C,65
0033A:  DATA 64,35
0033C:  DATA 38,38
0033E:  DATA 00,00
00340:  CLRF   FF7
00342:  ADDLW  50
00344:  MOVWF  FF6
00346:  MOVLW  03
00348:  ADDWFC FF7,F
0034A:  TBLRD*+
0034C:  MOVF   FF5,W
0034E:  RETURN 0
00350:  DATA 6C,65
00352:  DATA 64,37
00354:  DATA 33,30
00356:  DATA 00,00
00358:  CLRF   FF7
0035A:  ADDLW  68
0035C:  MOVWF  FF6
0035E:  MOVLW  03
00360:  ADDWFC FF7,F
00362:  TBLRD*+
00364:  MOVF   FF5,W
00366:  RETURN 0
00368:  DATA 6C,65
0036A:  DATA 64,6F
0036C:  DATA 66,66
0036E:  DATA 00,00
00370:  CLRF   FF7
00372:  ADDLW  80
00374:  MOVWF  FF6
00376:  MOVLW  03
00378:  ADDWFC FF7,F
0037A:  TBLRD*+
0037C:  MOVF   FF5,W
0037E:  RETURN 0
00380:  DATA 72,65
00382:  DATA 61,64
00384:  DATA 31,30
00386:  DATA 00,00
00388:  CLRF   FF7
0038A:  ADDLW  98
0038C:  MOVWF  FF6
0038E:  MOVLW  03
00390:  ADDWFC FF7,F
00392:  TBLRD*+
00394:  MOVF   FF5,W
00396:  RETURN 0
00398:  DATA 72,65
0039A:  DATA 61,64
0039C:  DATA 63,73
0039E:  DATA 76,00
003A0:  CLRF   FF7
003A2:  ADDLW  B0
003A4:  MOVWF  FF6
003A6:  MOVLW  03
003A8:  ADDWFC FF7,F
003AA:  TBLRD*+
003AC:  MOVF   FF5,W
003AE:  RETURN 0
003B0:  DATA 63,61
003B2:  DATA 6C,69
003B4:  DATA 62,72
003B6:  DATA 61,74
003B8:  DATA 65,00
003BA:  CLRF   FF7
003BC:  ADDLW  CA
003BE:  MOVWF  FF6
003C0:  MOVLW  03
003C2:  ADDWFC FF7,F
003C4:  TBLRD*+
003C6:  MOVF   FF5,W
003C8:  RETURN 0
003CA:  DATA 66,75
003CC:  DATA 6C,6C
003CE:  DATA 74,65
003D0:  DATA 73,74
003D2:  DATA 00,00
003D4:  CLRF   FF7
003D6:  ADDLW  E4
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  TBLRD*+
003E0:  MOVF   FF5,W
003E2:  RETURN 0
003E4:  DATA 72,65
003E6:  DATA 61,64
003E8:  DATA 69,6E
003EA:  DATA 67,00
003EC:  CLRF   FF7
003EE:  ADDLW  FC
003F0:  MOVWF  FF6
003F2:  MOVLW  03
003F4:  ADDWFC FF7,F
003F6:  TBLRD*+
003F8:  MOVF   FF5,W
003FA:  RETURN 0
003FC:  DATA 73,65
003FE:  DATA 74,6C
00400:  DATA 65,64
00402:  DATA 00,00
00404:  CLRF   FF7
00406:  ADDLW  14
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  TBLRD*+
00410:  MOVF   FF5,W
00412:  RETURN 0
00414:  DATA 63,61
00416:  DATA 6C,74
00418:  DATA 65,73
0041A:  DATA 74,00
0041C:  CLRF   FEA
0041E:  MOVLW  24
00420:  MOVWF  FE9
00422:  MOVF   1B,W
00424:  ADDWF  FE9,F
00426:  MOVLW  00
00428:  ADDWFC FEA,F
0042A:  MOVFF  F71,1A
0042E:  MOVFF  F74,FEF
00432:  BTFSS  1A.1
00434:  BRA    043C
00436:  BSF    1D.0
00438:  BCF    F71.4
0043A:  BSF    F71.4
0043C:  INCF   1B,F
0043E:  MOVLW  31
00440:  BSF    FD8.0
00442:  SUBFWB 1B,W
00444:  BC    0448
00446:  CLRF   1B
00448:  MOVF   1C,W
0044A:  SUBWF  1B,W
0044C:  BNZ   0450
0044E:  BSF    1D.1
*
00456:  MOVLW  01
00458:  ADDWF  56,F
0045A:  BTFSC  FD8.0
0045C:  INCF   57,F
0045E:  BTFSC  FD8.2
00460:  INCF   58,F
00462:  BTFSC  FD8.2
00464:  INCF   59,F
*
0046C:  DATA 5B,49
0046E:  DATA 35,30
00470:  DATA 20,56
00472:  DATA 25,6C
00474:  DATA 75,2E
00476:  DATA 25,6C
00478:  DATA 75,2E
0047A:  DATA 25,6C
0047C:  DATA 75,00
0047E:  DATA 0D,42
00480:  DATA 4C,45
00482:  DATA 20,42
00484:  DATA 6F,6F
00486:  DATA 74,20
00488:  DATA 45,76
0048A:  DATA 65,6E
0048C:  DATA 74,0D
0048E:  DATA 0A,00
00490:  DATA 0D,42
00492:  DATA 4C,45
00494:  DATA 20,48
00496:  DATA 65,6C
00498:  DATA 6C,6F
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 0D,42
004A0:  DATA 4C,45
004A2:  DATA 20,43
004A4:  DATA 6F,6E
004A6:  DATA 6E,65
004A8:  DATA 63,74
004AA:  DATA 69,6F
004AC:  DATA 6E,0D
004AE:  DATA 0A,00
004B0:  DATA 0D,42
004B2:  DATA 4C,45
004B4:  DATA 20,44
004B6:  DATA 69,73
004B8:  DATA 63,6F
004BA:  DATA 6E,6E
004BC:  DATA 65,63
004BE:  DATA 74,69
004C0:  DATA 6F,6E
004C2:  DATA 0D,0A
004C4:  DATA 00,00
004C6:  DATA 0D,42
004C8:  DATA 4C,45
004CA:  DATA 20,4D
004CC:  DATA 6F,64
004CE:  DATA 65,20
004D0:  DATA 43,68
004D2:  DATA 61,6E
004D4:  DATA 67,65
004D6:  DATA 64,2E
004D8:  DATA 20,45
004DA:  DATA 72,72
004DC:  DATA 6F,72
004DE:  DATA 20,3D
004E0:  DATA 20,25
004E2:  DATA 6C,75
004E4:  DATA 0D,0A
004E6:  DATA 00,00
004E8:  DATA 0D,42
004EA:  DATA 4C,45
004EC:  DATA 20,43
004EE:  DATA 6F,6E
004F0:  DATA 6E,65
004F2:  DATA 63,74
004F4:  DATA 69,6F
004F6:  DATA 6E,20
004F8:  DATA 53,74
004FA:  DATA 61,74
004FC:  DATA 75,73
004FE:  DATA 20,43
00500:  DATA 68,61
00502:  DATA 6E,67
00504:  DATA 65,64
00506:  DATA 3A,20
00508:  DATA 7B,25
0050A:  DATA 75,2C
0050C:  DATA 20,25
0050E:  DATA 75,2C
00510:  DATA 20,25
00512:  DATA 75,7D
00514:  DATA 0D,0A
00516:  DATA 00,00
00518:  DATA 0D,42
0051A:  DATA 4C,45
0051C:  DATA 20,57
0051E:  DATA 72,69
00520:  DATA 74,65
00522:  DATA 20,52
00524:  DATA 65,73
00526:  DATA 70,6F
00528:  DATA 6E,73
0052A:  DATA 65,2E
0052C:  DATA 20,4C
0052E:  DATA 65,6E
00530:  DATA 67,74
00532:  DATA 68,20
00534:  DATA 3D,20
00536:  DATA 25,75
00538:  DATA 2E,20
0053A:  DATA 52,65
0053C:  DATA 73,75
0053E:  DATA 6C,74
00540:  DATA 20,3D
00542:  DATA 20,25
00544:  DATA 6C,75
00546:  DATA 0D,0A
00548:  DATA 00,00
0054A:  DATA 0D,42
0054C:  DATA 4C,45
0054E:  DATA 20,56
00550:  DATA 61,6C
00552:  DATA 75,65
00554:  DATA 20,57
00556:  DATA 72,69
00558:  DATA 74,74
0055A:  DATA 65,6E
0055C:  DATA 2E,20
0055E:  DATA 4C,65
00560:  DATA 6E,67
00562:  DATA 74,68
00564:  DATA 20,3D
00566:  DATA 20,25
00568:  DATA 75,2E
0056A:  DATA 0D,0A
0056C:  DATA 00,00
0056E:  DATA 0D,46
00570:  DATA 65,74
00572:  DATA 63,68
00574:  DATA 69,6E
00576:  DATA 67,20
00578:  DATA 69,6E
0057A:  DATA 64,65
0057C:  DATA 78,3A
0057E:  DATA 20,25
00580:  DATA 6C,75
00582:  DATA 0D,0A
00584:  DATA 00,00
00586:  DATA 0D,56
00588:  DATA 61,6C
0058A:  DATA 75,65
0058C:  DATA 20,68
0058E:  DATA 61,73
00590:  DATA 20,63
00592:  DATA 68,61
00594:  DATA 6E,67
00596:  DATA 65,64
00598:  DATA 3A,20
0059A:  DATA 25,6C
0059C:  DATA 75,21
0059E:  DATA 0D,0A
005A0:  DATA 00,00
005A2:  DATA 0D,56
005A4:  DATA 61,6C
005A6:  DATA 75,65
005A8:  DATA 20,69
005AA:  DATA 6E,63
005AC:  DATA 72,65
005AE:  DATA 6D,65
005B0:  DATA 6E,74
005B2:  DATA 65,64
005B4:  DATA 2E,20
005B6:  DATA 53,68
005B8:  DATA 6F,75
005BA:  DATA 6C,64
005BC:  DATA 20,62
005BE:  DATA 65,3A
005C0:  DATA 20,25
005C2:  DATA 6C,75
005C4:  DATA 21,0D
005C6:  DATA 0A,00
005C8:  DATA 4E,65
005CA:  DATA 77,20
005CC:  DATA 76,6F
005CE:  DATA 6C,75
005D0:  DATA 6D,65
005D2:  DATA 20,73
005D4:  DATA 65,74
005D6:  DATA 74,69
005D8:  DATA 6E,67
005DA:  DATA 73,3A
005DC:  DATA 20,25
005DE:  DATA 6C,75
005E0:  DATA 20,0D
005E2:  DATA 0A,00
005E4:  DATA 0D,69
005E6:  DATA 4F,53
005E8:  DATA 20,41
005EA:  DATA 70,70
005EC:  DATA 20,6F
005EE:  DATA 70,63
005F0:  DATA 6F,64
005F2:  DATA 65,25
005F4:  DATA 64,0D
005F6:  DATA 0A,00
005F8:  DATA 0D,4B
005FA:  DATA 65,74
005FC:  DATA 6F,6E
005FE:  DATA 65,20
00600:  DATA 74,65
00602:  DATA 73,74
00604:  DATA 20,63
00606:  DATA 6D,64
00608:  DATA 20,72
0060A:  DATA 65,63
0060C:  DATA 65,69
0060E:  DATA 76,65
00610:  DATA 64,2E
00612:  DATA 0D,0A
00614:  DATA 00,00
00616:  DATA 0D,41
00618:  DATA 6D,6D
0061A:  DATA 6F,6E
0061C:  DATA 69,61
0061E:  DATA 20,74
00620:  DATA 65,73
00622:  DATA 74,20
00624:  DATA 63,6D
00626:  DATA 64,20
00628:  DATA 72,65
0062A:  DATA 63,65
0062C:  DATA 69,76
0062E:  DATA 65,64
00630:  DATA 2E,0D
00632:  DATA 0A,00
00634:  DATA 0D,52
00636:  DATA 65,73
00638:  DATA 65,74
0063A:  DATA 20,75
0063C:  DATA 73,65
0063E:  DATA 20,63
00640:  DATA 6F,75
00642:  DATA 6E,74
00644:  DATA 65,72
00646:  DATA 20,63
00648:  DATA 6D,64
0064A:  DATA 20,72
0064C:  DATA 65,63
0064E:  DATA 65,69
00650:  DATA 76,65
00652:  DATA 64,0D
00654:  DATA 0A,00
00656:  DATA 0D,43
00658:  DATA 6C,65
0065A:  DATA 61,72
0065C:  DATA 20,6D
0065E:  DATA 65,6D
00660:  DATA 6F,72
00662:  DATA 79,20
00664:  DATA 63,6D
00666:  DATA 64,20
00668:  DATA 72,65
0066A:  DATA 63,65
0066C:  DATA 69,76
0066E:  DATA 65,64
00670:  DATA 2E,0D
00672:  DATA 0A,00
00674:  DATA 0D,46
00676:  DATA 69,72
00678:  DATA 6D,77
0067A:  DATA 61,72
0067C:  DATA 65,20
0067E:  DATA 75,70
00680:  DATA 64,61
00682:  DATA 74,65
00684:  DATA 20,63
00686:  DATA 6D,64
00688:  DATA 20,64
0068A:  DATA 65,74
0068C:  DATA 65,63
0068E:  DATA 74,65
00690:  DATA 64,2E
00692:  DATA 0D,0A
00694:  DATA 00,00
00696:  DATA 0D,52
00698:  DATA 65,73
0069A:  DATA 65,74
0069C:  DATA 20,53
0069E:  DATA 74,61
006A0:  DATA 74,65
006A2:  DATA 20,4D
006A4:  DATA 61,63
006A6:  DATA 68,69
006A8:  DATA 6E,65
006AA:  DATA 20,63
006AC:  DATA 6D,64
006AE:  DATA 20,64
006B0:  DATA 65,74
006B2:  DATA 65,63
006B4:  DATA 74,65
006B6:  DATA 64,2E
006B8:  DATA 0D,0A
006BA:  DATA 00,00
006BC:  DATA 0D,5B
006BE:  DATA 4E,4F
006C0:  DATA 54,45
006C2:  DATA 5D,20
006C4:  DATA 55,6E
006C6:  DATA 73,75
006C8:  DATA 70,70
006CA:  DATA 6F,72
006CC:  DATA 74,65
006CE:  DATA 64,20
006D0:  DATA 63,6D
006D2:  DATA 64,20
006D4:  DATA 64,65
006D6:  DATA 74,65
006D8:  DATA 63,74
006DA:  DATA 65,64
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 0D,0A
006E2:  DATA 42,4C
006E4:  DATA 45,20
006E6:  DATA 4D,6F
006E8:  DATA 64,75
006EA:  DATA 6C,65
006EC:  DATA 20,49
006EE:  DATA 44,20
006F0:  DATA 63,61
006F2:  DATA 70,74
006F4:  DATA 75,72
006F6:  DATA 65,64
006F8:  DATA 20,25
006FA:  DATA 32,58
006FC:  DATA 25,32
006FE:  DATA 58,25
00700:  DATA 32,58
00702:  DATA 25,32
00704:  DATA 58,25
00706:  DATA 32,58
00708:  DATA 25,32
0070A:  DATA 58,0D
0070C:  DATA 0A,00
0070E:  DATA 0D,5B
00710:  DATA 4E,4F
00712:  DATA 54,45
00714:  DATA 5D,20
00716:  DATA 49,67
00718:  DATA 6E,6F
0071A:  DATA 72,65
0071C:  DATA 64,20
0071E:  DATA 42,4C
00720:  DATA 45,20
00722:  DATA 4D,65
00724:  DATA 73,73
00726:  DATA 61,67
00728:  DATA 65,20
0072A:  DATA 7B,25
0072C:  DATA 78,2C
0072E:  DATA 20,25
00730:  DATA 78,2C
00732:  DATA 20,25
00734:  DATA 78,2C
00736:  DATA 20,25
00738:  DATA 78,7D
0073A:  DATA 0D,0A
0073C:  DATA 00,00
*
00796:  MOVFF  CF,FEA
0079A:  MOVFF  CE,FE9
0079E:  MOVLB  9
007A0:  MOVFF  972,FEF
007A4:  INCF   FE9,F
007A6:  BTFSC  FD8.2
007A8:  INCF   FEA,F
007AA:  CLRF   FEF
007AC:  MOVLB  0
007AE:  INCF   xCE,F
007B0:  BTFSC  FD8.2
007B2:  INCF   xCF,F
007B4:  RETURN 0
007B6:  TBLRD*+
007B8:  MOVF   FF5,F
007BA:  BZ    07D4
007BC:  MOVFF  FF6,966
007C0:  MOVFF  FF7,967
007C4:  MOVFF  FF5,972
007C8:  RCALL  0796
007CA:  MOVFF  966,FF6
007CE:  MOVFF  967,FF7
007D2:  BRA    07B6
007D4:  RETURN 0
*
00804:  TBLRD*+
00806:  MOVFF  FF6,96B
0080A:  MOVFF  FF7,96C
0080E:  MOVFF  FF5,972
00812:  RCALL  0796
00814:  MOVFF  96B,FF6
00818:  MOVFF  96C,FF7
0081C:  MOVLB  9
0081E:  DECFSZ x6A,F
00820:  BRA    0824
00822:  BRA    0828
00824:  MOVLB  0
00826:  BRA    0804
00828:  MOVLB  0
0082A:  RETURN 0
0082C:  MOVFF  FEA,971
00830:  MOVFF  FE9,970
00834:  MOVLB  9
00836:  SWAPF  x6A,W
00838:  IORLW  F0
0083A:  MOVWF  x6C
0083C:  ADDWF  x6C,F
0083E:  ADDLW  E2
00840:  MOVWF  x6D
00842:  ADDLW  32
00844:  MOVWF  x6F
00846:  MOVF   x6A,W
00848:  ANDLW  0F
0084A:  ADDWF  x6D,F
0084C:  ADDWF  x6D,F
0084E:  ADDWF  x6F,F
00850:  ADDLW  E9
00852:  MOVWF  x6E
00854:  ADDWF  x6E,F
00856:  ADDWF  x6E,F
00858:  SWAPF  x69,W
0085A:  ANDLW  0F
0085C:  ADDWF  x6E,F
0085E:  ADDWF  x6F,F
00860:  RLCF   x6E,F
00862:  RLCF   x6F,F
00864:  COMF   x6F,F
00866:  RLCF   x6F,F
00868:  MOVF   x69,W
0086A:  ANDLW  0F
0086C:  ADDWF  x6F,F
0086E:  RLCF   x6C,F
00870:  MOVLW  07
00872:  MOVWF  x6B
00874:  MOVLW  0A
00876:  DECF   x6E,F
00878:  ADDWF  x6F,F
0087A:  BNC   0876
0087C:  DECF   x6D,F
0087E:  ADDWF  x6E,F
00880:  BNC   087C
00882:  DECF   x6C,F
00884:  ADDWF  x6D,F
00886:  BNC   0882
00888:  DECF   x6B,F
0088A:  ADDWF  x6C,F
0088C:  BNC   0888
0088E:  MOVLW  09
00890:  MOVWF  FEA
00892:  MOVLW  6B
00894:  MOVWF  FE9
00896:  MOVLW  07
00898:  ANDWF  x70,W
0089A:  BCF    x70.6
0089C:  ADDWF  FE9,F
0089E:  MOVLW  00
008A0:  ADDWFC FEA,F
008A2:  MOVF   FE9,W
008A4:  SUBLW  6F
008A6:  BNZ   08B0
008A8:  MOVF   FEA,W
008AA:  SUBLW  09
008AC:  BNZ   08B0
008AE:  BSF    x70.6
008B0:  MOVF   FEF,W
008B2:  MOVWF  00
008B4:  BNZ   08C6
008B6:  BTFSC  x70.6
008B8:  BRA    08C6
008BA:  BTFSC  x70.4
008BC:  BRA    08E8
008BE:  BTFSC  x70.3
008C0:  BRA    08C6
008C2:  MOVLW  20
008C4:  BRA    08CC
008C6:  BSF    x70.3
008C8:  BCF    x70.4
008CA:  MOVLW  30
008CC:  ADDWF  00,F
008CE:  MOVFF  FEA,96A
008D2:  MOVFF  FE9,969
008D6:  MOVFF  00,972
008DA:  MOVLB  0
008DC:  RCALL  0796
008DE:  MOVFF  96A,FEA
008E2:  MOVFF  969,FE9
008E6:  MOVLB  9
008E8:  MOVF   FEE,W
008EA:  BTFSS  x70.6
008EC:  BRA    08A2
008EE:  MOVLB  0
008F0:  RETURN 0
008F2:  MOVLB  9
008F4:  MOVF   x6D,W
008F6:  CLRF   01
008F8:  SUBWF  x6C,W
008FA:  BC    0902
008FC:  MOVFF  96C,00
00900:  BRA    091A
00902:  CLRF   00
00904:  MOVLW  08
00906:  MOVWF  x6E
00908:  RLCF   x6C,F
0090A:  RLCF   00,F
0090C:  MOVF   x6D,W
0090E:  SUBWF  00,W
00910:  BTFSC  FD8.0
00912:  MOVWF  00
00914:  RLCF   01,F
00916:  DECFSZ x6E,F
00918:  BRA    0908
0091A:  MOVLB  0
0091C:  RETURN 0
0091E:  MOVF   01,W
00920:  MOVFF  969,96C
00924:  MOVLW  64
00926:  MOVLB  9
00928:  MOVWF  x6D
0092A:  MOVLB  0
0092C:  RCALL  08F2
0092E:  MOVFF  00,969
00932:  MOVF   01,W
00934:  MOVLW  30
00936:  BNZ   0948
00938:  MOVLB  9
0093A:  BTFSS  x6A.1
0093C:  BRA    095C
0093E:  BTFSC  x6A.3
00940:  BRA    095C
00942:  BTFSC  x6A.4
00944:  MOVLW  20
00946:  BRA    0950
00948:  MOVLB  9
0094A:  BCF    x6A.3
0094C:  BCF    x6A.4
0094E:  BSF    x6A.0
00950:  ADDWF  01,F
00952:  MOVFF  01,972
00956:  MOVLB  0
00958:  RCALL  0796
0095A:  MOVLB  9
0095C:  MOVFF  969,96C
00960:  MOVLW  0A
00962:  MOVWF  x6D
00964:  MOVLB  0
00966:  RCALL  08F2
00968:  MOVFF  00,969
0096C:  MOVF   01,W
0096E:  MOVLW  30
00970:  BNZ   0982
00972:  MOVLB  9
00974:  BTFSC  x6A.3
00976:  BRA    098C
00978:  BTFSS  x6A.0
0097A:  BRA    098C
0097C:  BTFSC  x6A.4
0097E:  MOVLW  20
00980:  MOVLB  0
00982:  ADDWF  01,F
00984:  MOVFF  01,972
00988:  RCALL  0796
0098A:  MOVLB  9
0098C:  MOVLW  30
0098E:  ADDWF  x69,F
00990:  MOVFF  969,972
00994:  MOVLB  0
00996:  RCALL  0796
00998:  RETURN 0
0099A:  MOVLW  8E
0099C:  MOVWF  00
0099E:  MOVFF  967,01
009A2:  MOVFF  966,02
009A6:  CLRF   03
009A8:  MOVF   01,F
009AA:  BNZ   09BE
009AC:  MOVFF  02,01
009B0:  CLRF   02
009B2:  MOVLW  08
009B4:  SUBWF  00,F
009B6:  MOVF   01,F
009B8:  BNZ   09BE
009BA:  CLRF   00
009BC:  BRA    09CE
009BE:  BCF    FD8.0
009C0:  BTFSC  01.7
009C2:  BRA    09CC
009C4:  RLCF   02,F
009C6:  RLCF   01,F
009C8:  DECF   00,F
009CA:  BRA    09BE
009CC:  BCF    01.7
009CE:  RETURN 0
*
00AAC:  TBLRD*+
00AAE:  MOVFF  FF6,967
00AB2:  MOVFF  FF7,968
00AB6:  MOVF   FF5,W
00AB8:  BTFSS  FA4.4
00ABA:  BRA    0AB8
00ABC:  MOVWF  F73
00ABE:  MOVFF  967,FF6
00AC2:  MOVFF  968,FF7
00AC6:  MOVLB  9
00AC8:  DECFSZ x66,F
00ACA:  BRA    0ACE
00ACC:  BRA    0AD2
00ACE:  MOVLB  0
00AD0:  BRA    0AAC
00AD2:  MOVLB  0
00AD4:  RETURN 0
00AD6:  MOVFF  FEA,96E
00ADA:  MOVFF  FE9,96D
00ADE:  MOVLB  9
00AE0:  SWAPF  x67,W
00AE2:  IORLW  F0
00AE4:  MOVWF  x69
00AE6:  ADDWF  x69,F
00AE8:  ADDLW  E2
00AEA:  MOVWF  x6A
00AEC:  ADDLW  32
00AEE:  MOVWF  x6C
00AF0:  MOVF   x67,W
00AF2:  ANDLW  0F
00AF4:  ADDWF  x6A,F
00AF6:  ADDWF  x6A,F
00AF8:  ADDWF  x6C,F
00AFA:  ADDLW  E9
00AFC:  MOVWF  x6B
00AFE:  ADDWF  x6B,F
00B00:  ADDWF  x6B,F
00B02:  SWAPF  x66,W
00B04:  ANDLW  0F
00B06:  ADDWF  x6B,F
00B08:  ADDWF  x6C,F
00B0A:  RLCF   x6B,F
00B0C:  RLCF   x6C,F
00B0E:  COMF   x6C,F
00B10:  RLCF   x6C,F
00B12:  MOVF   x66,W
00B14:  ANDLW  0F
00B16:  ADDWF  x6C,F
00B18:  RLCF   x69,F
00B1A:  MOVLW  07
00B1C:  MOVWF  x68
00B1E:  MOVLW  0A
00B20:  DECF   x6B,F
00B22:  ADDWF  x6C,F
00B24:  BNC   0B20
00B26:  DECF   x6A,F
00B28:  ADDWF  x6B,F
00B2A:  BNC   0B26
00B2C:  DECF   x69,F
00B2E:  ADDWF  x6A,F
00B30:  BNC   0B2C
00B32:  DECF   x68,F
00B34:  ADDWF  x69,F
00B36:  BNC   0B32
00B38:  MOVLW  09
00B3A:  MOVWF  FEA
00B3C:  MOVLW  68
00B3E:  MOVWF  FE9
00B40:  MOVLW  07
00B42:  ANDWF  x6D,W
00B44:  BCF    x6D.6
00B46:  ADDWF  FE9,F
00B48:  MOVLW  00
00B4A:  ADDWFC FEA,F
00B4C:  MOVF   FE9,W
00B4E:  SUBLW  6C
00B50:  BNZ   0B5A
00B52:  MOVF   FEA,W
00B54:  SUBLW  09
00B56:  BNZ   0B5A
00B58:  BSF    x6D.6
00B5A:  MOVF   FEF,W
00B5C:  MOVWF  00
00B5E:  BNZ   0B70
00B60:  BTFSC  x6D.6
00B62:  BRA    0B70
00B64:  BTFSC  x6D.4
00B66:  BRA    0B80
00B68:  BTFSC  x6D.3
00B6A:  BRA    0B70
00B6C:  MOVLW  20
00B6E:  BRA    0B76
00B70:  BSF    x6D.3
00B72:  BCF    x6D.4
00B74:  MOVLW  30
00B76:  ADDWF  00,F
00B78:  MOVF   00,W
00B7A:  BTFSS  FA4.4
00B7C:  BRA    0B7A
00B7E:  MOVWF  F73
00B80:  MOVF   FEE,W
00B82:  BTFSS  x6D.6
00B84:  BRA    0B4C
00B86:  MOVLB  0
00B88:  RETURN 0
00B8A:  MOVLW  20
00B8C:  MOVLB  9
00B8E:  BTFSS  x67.4
00B90:  MOVLW  30
00B92:  MOVWF  x68
00B94:  MOVFF  966,00
00B98:  BTFSS  00.7
00B9A:  BRA    0BAC
00B9C:  COMF   00,F
00B9E:  INCF   00,F
00BA0:  MOVFF  00,966
00BA4:  MOVLW  2D
00BA6:  MOVWF  x68
00BA8:  BSF    x67.7
00BAA:  BSF    x67.0
00BAC:  MOVF   01,W
00BAE:  MOVFF  966,96C
00BB2:  MOVLW  64
00BB4:  MOVWF  x6D
00BB6:  MOVLB  0
00BB8:  RCALL  08F2
00BBA:  MOVFF  00,966
00BBE:  MOVLW  30
00BC0:  ADDWF  01,W
00BC2:  MOVLB  9
00BC4:  MOVWF  x69
00BC6:  MOVFF  966,96C
00BCA:  MOVLW  0A
00BCC:  MOVWF  x6D
00BCE:  MOVLB  0
00BD0:  RCALL  08F2
00BD2:  MOVLW  30
00BD4:  ADDWF  00,W
00BD6:  MOVLB  9
00BD8:  MOVWF  x6B
00BDA:  MOVLW  30
00BDC:  ADDWF  01,W
00BDE:  MOVWF  x6A
00BE0:  MOVFF  968,00
00BE4:  MOVLW  30
00BE6:  SUBWF  x69,W
00BE8:  BZ    0BF2
00BEA:  BSF    x67.1
00BEC:  BTFSC  x67.7
00BEE:  BSF    x67.2
00BF0:  BRA    0C16
00BF2:  MOVFF  968,969
00BF6:  MOVLW  20
00BF8:  MOVWF  x68
00BFA:  MOVLW  30
00BFC:  SUBWF  x6A,W
00BFE:  BZ    0C08
00C00:  BSF    x67.0
00C02:  BTFSC  x67.7
00C04:  BSF    x67.1
00C06:  BRA    0C16
00C08:  BTFSS  FD8.2
00C0A:  BSF    x67.0
00C0C:  BNZ   0C16
00C0E:  MOVFF  969,96A
00C12:  MOVLW  20
00C14:  MOVWF  x69
00C16:  BTFSC  x67.2
00C18:  BRA    0C24
00C1A:  BTFSC  x67.1
00C1C:  BRA    0C2C
00C1E:  BTFSC  x67.0
00C20:  BRA    0C34
00C22:  BRA    0C3C
00C24:  MOVFF  968,972
00C28:  MOVLB  0
00C2A:  RCALL  0796
00C2C:  MOVFF  969,972
00C30:  MOVLB  0
00C32:  RCALL  0796
00C34:  MOVFF  96A,972
00C38:  MOVLB  0
00C3A:  RCALL  0796
00C3C:  MOVFF  96B,972
00C40:  MOVLB  0
00C42:  RCALL  0796
00C44:  GOTO   1458 (RETURN)
00C48:  MOVLB  9
00C4A:  MOVF   x6B,W
00C4C:  XORWF  x6D,W
00C4E:  ANDLW  80
00C50:  MOVWF  x6F
00C52:  BTFSS  x6B.7
00C54:  BRA    0C60
00C56:  COMF   x6A,F
00C58:  COMF   x6B,F
00C5A:  INCF   x6A,F
00C5C:  BTFSC  FD8.2
00C5E:  INCF   x6B,F
00C60:  BTFSS  x6D.7
00C62:  BRA    0C6E
00C64:  COMF   x6C,F
00C66:  COMF   x6D,F
00C68:  INCF   x6C,F
00C6A:  BTFSC  FD8.2
00C6C:  INCF   x6D,F
00C6E:  MOVF   x6A,W
00C70:  MULWF  x6C
00C72:  MOVFF  FF3,01
00C76:  MOVFF  FF4,00
00C7A:  MULWF  x6D
00C7C:  MOVF   FF3,W
00C7E:  ADDWF  00,F
00C80:  MOVF   x6B,W
00C82:  MULWF  x6C
00C84:  MOVF   FF3,W
00C86:  ADDWFC 00,W
00C88:  MOVWF  02
00C8A:  BTFSS  x6F.7
00C8C:  BRA    0C98
00C8E:  COMF   01,F
00C90:  COMF   02,F
00C92:  INCF   01,F
00C94:  BTFSC  FD8.2
00C96:  INCF   02,F
00C98:  MOVLB  0
00C9A:  RETURN 0
00C9C:  MOVLB  9
00C9E:  BTFSC  x6B.7
00CA0:  BRA    0CC4
00CA2:  MOVLW  0F
00CA4:  MOVWF  00
00CA6:  SWAPF  x6A,W
00CA8:  ANDWF  00,F
00CAA:  MOVLW  0A
00CAC:  SUBWF  00,W
00CAE:  BC    0CB6
00CB0:  MOVLW  30
00CB2:  ADDWF  00,F
00CB4:  BRA    0CBA
00CB6:  MOVF   x6B,W
00CB8:  ADDWF  00,F
00CBA:  MOVFF  00,972
00CBE:  MOVLB  0
00CC0:  RCALL  0796
00CC2:  MOVLB  9
00CC4:  MOVLW  0F
00CC6:  ANDWF  x6A,F
00CC8:  MOVLW  0A
00CCA:  SUBWF  x6A,W
00CCC:  BC    0CD2
00CCE:  MOVLW  30
00CD0:  BRA    0CD6
00CD2:  BCF    x6B.7
00CD4:  MOVF   x6B,W
00CD6:  ADDWF  x6A,F
00CD8:  MOVFF  96A,972
00CDC:  MOVLB  0
00CDE:  RCALL  0796
00CE0:  RETURN 0
*
0183C:  DATA 42,6C
0183E:  DATA 75,65
01840:  DATA 74,6F
01842:  DATA 6F,74
01844:  DATA 68,20
01846:  DATA 49,6E
01848:  DATA 69,74
0184A:  DATA 69,61
0184C:  DATA 6C,69
0184E:  DATA 7A,65
01850:  DATA 64,20
01852:  DATA 0D,0A
01854:  DATA 00,00
01856:  DATA 53,68
01858:  DATA 75,74
0185A:  DATA 64,6F
0185C:  DATA 77,6E
0185E:  DATA 20,62
01860:  DATA 6C,75
01862:  DATA 65,74
01864:  DATA 6F,6F
01866:  DATA 74,68
01868:  DATA 20,0D
0186A:  DATA 0A,00
0186C:  DATA 52,65
0186E:  DATA 73,65
01870:  DATA 74,74
01872:  DATA 69,6E
01874:  DATA 67,20
01876:  DATA 42,4C
01878:  DATA 45,20
0187A:  DATA 25,6C
0187C:  DATA 75,20
0187E:  DATA 74,69
01880:  DATA 6D,65
01882:  DATA 73,2E
01884:  DATA 2E,2E
01886:  DATA 0D,0A
01888:  DATA 0D,0A
0188A:  DATA 00,00
0188C:  DATA 45,72
0188E:  DATA 72,6F
01890:  DATA 72,20
01892:  DATA 62,69
01894:  DATA 74,20
01896:  DATA 25,75
01898:  DATA 20,73
0189A:  DATA 65,74
0189C:  DATA 0D,0A
0189E:  DATA 00,00
018A0:  DATA 45,72
018A2:  DATA 72,6F
018A4:  DATA 72,20
018A6:  DATA 62,69
018A8:  DATA 74,73
018AA:  DATA 20,63
018AC:  DATA 6C,65
018AE:  DATA 61,72
018B0:  DATA 65,64
018B2:  DATA 0D,0A
018B4:  DATA 00,00
018B6:  DATA 45,72
018B8:  DATA 72,6F
018BA:  DATA 72,20
018BC:  DATA 62,69
018BE:  DATA 74,25
018C0:  DATA 75,20
018C2:  DATA 63,6C
018C4:  DATA 65,61
018C6:  DATA 72,65
018C8:  DATA 64,0D
018CA:  DATA 0A,00
018CC:  DATA 53,74
018CE:  DATA 61,72
018D0:  DATA 74,20
018D2:  DATA 49,6E
018D4:  DATA 64,65
018D6:  DATA 78,3A
018D8:  DATA 20,25
018DA:  DATA 6C,75
018DC:  DATA 2E,20
018DE:  DATA 53,74
018E0:  DATA 6F,70
018E2:  DATA 20,49
018E4:  DATA 6E,64
018E6:  DATA 65,78
018E8:  DATA 3A,20
018EA:  DATA 30,78
018EC:  DATA 25,6C
018EE:  DATA 75,2E
018F0:  DATA 0D,0A
018F2:  DATA 00,00
018F4:  DATA 53,74
018F6:  DATA 61,72
018F8:  DATA 74,20
018FA:  DATA 49,6E
018FC:  DATA 64,65
018FE:  DATA 78,3A
01900:  DATA 20,25
01902:  DATA 6C,75
01904:  DATA 2E,20
01906:  DATA 53,74
01908:  DATA 6F,70
0190A:  DATA 20,49
0190C:  DATA 6E,64
0190E:  DATA 65,78
01910:  DATA 3A,20
01912:  DATA 30,78
01914:  DATA 25,6C
01916:  DATA 75,2E
01918:  DATA 0D,0A
0191A:  DATA 00,00
0191C:  DATA 53,69
0191E:  DATA 6D,75
01920:  DATA 6C,61
01922:  DATA 74,65
01924:  DATA 20,61
01926:  DATA 6E,64
01928:  DATA 20,73
0192A:  DATA 61,76
0192C:  DATA 65,20
0192E:  DATA 31,30
01930:  DATA 20,74
01932:  DATA 65,73
01934:  DATA 74,20
01936:  DATA 72,65
01938:  DATA 73,75
0193A:  DATA 6C,74
0193C:  DATA 73,0D
0193E:  DATA 0A,00
01940:  DATA 25,64
01942:  DATA 20,72
01944:  DATA 65,63
01946:  DATA 6F,72
01948:  DATA 64,0D
0194A:  DATA 0A,00
0194C:  DATA 53,74
0194E:  DATA 61,72
01950:  DATA 74,20
01952:  DATA 49,6E
01954:  DATA 64,65
01956:  DATA 78,3A
01958:  DATA 20,25
0195A:  DATA 6C,75
0195C:  DATA 2E,20
0195E:  DATA 53,74
01960:  DATA 6F,70
01962:  DATA 20,49
01964:  DATA 6E,64
01966:  DATA 65,78
01968:  DATA 3A,20
0196A:  DATA 25,6C
0196C:  DATA 75,2E
0196E:  DATA 0D,0A
01970:  DATA 00,00
01972:  DATA 53,74
01974:  DATA 61,72
01976:  DATA 74,20
01978:  DATA 49,6E
0197A:  DATA 64,65
0197C:  DATA 78,3A
0197E:  DATA 20,25
01980:  DATA 6C,75
01982:  DATA 2E,20
01984:  DATA 53,74
01986:  DATA 6F,70
01988:  DATA 20,49
0198A:  DATA 6E,64
0198C:  DATA 65,78
0198E:  DATA 3A,20
01990:  DATA 25,6C
01992:  DATA 75,2E
01994:  DATA 0D,0A
01996:  DATA 00,00
01998:  DATA 52,65
0199A:  DATA 63,6F
0199C:  DATA 72,64
0199E:  DATA 23,20
019A0:  DATA 54,65
019A2:  DATA 73,74
019A4:  DATA 20,4D
019A6:  DATA 6F,64
019A8:  DATA 65,20
019AA:  DATA 54,65
019AC:  DATA 73,74
019AE:  DATA 20,54
019B0:  DATA 69,6D
019B2:  DATA 65,20
019B4:  DATA 54,65
019B6:  DATA 73,74
019B8:  DATA 20,53
019BA:  DATA 63,6F
019BC:  DATA 72,65
019BE:  DATA 20,54
019C0:  DATA 65,73
019C2:  DATA 74,20
019C4:  DATA 53,74
019C6:  DATA 61,74
019C8:  DATA 75,73
019CA:  DATA 20,54
019CC:  DATA 65,73
019CE:  DATA 74,20
019D0:  DATA 53,74
019D2:  DATA 61,74
019D4:  DATA 65,20
019D6:  DATA 54,69
019D8:  DATA 6D,65
019DA:  DATA 20,53
019DC:  DATA 74,61
019DE:  DATA 6D,70
019E0:  DATA 00,00
019E2:  DATA 20,20
019E4:  DATA 25,64
019E6:  DATA 20,20
019E8:  DATA 20,20
019EA:  DATA 20,20
019EC:  DATA 20,20
019EE:  DATA 20,25
019F0:  DATA 6C,64
019F2:  DATA 20,20
019F4:  DATA 20,20
019F6:  DATA 20,20
019F8:  DATA 20,25
019FA:  DATA 6C,75
019FC:  DATA 20,20
019FE:  DATA 20,20
01A00:  DATA 20,20
01A02:  DATA 20,20
01A04:  DATA 20,25
01A06:  DATA 2E,34
01A08:  DATA 66,09
01A0A:  DATA 20,25
01A0C:  DATA 64,09
01A0E:  DATA 20,20
01A10:  DATA 20,20
01A12:  DATA 20,20
01A14:  DATA 25,64
01A16:  DATA 00,00
01A18:  DATA 20,20
01A1A:  DATA 20,20
01A1C:  DATA 20,20
01A1E:  DATA 20,25
01A20:  DATA 32,64
01A22:  DATA 3A,25
01A24:  DATA 32,64
01A26:  DATA 3A,25
01A28:  DATA 32,64
01A2A:  DATA 2C,20
01A2C:  DATA 44,20
01A2E:  DATA 25,32
01A30:  DATA 64,20
01A32:  DATA 4D,20
01A34:  DATA 25,32
01A36:  DATA 64,20
01A38:  DATA 59,20
01A3A:  DATA 25,32
01A3C:  DATA 64,20
01A3E:  DATA 00,00
01A40:  DATA 56,61
01A42:  DATA 6C,75
01A44:  DATA 65,3A
01A46:  DATA 20,00
01A48:  DATA 0D,0A
01A4A:  DATA 47,6F
01A4C:  DATA 74,20
01A4E:  DATA 69,74
01A50:  DATA 3A,20
01A52:  DATA 25,2E
01A54:  DATA 33,66
01A56:  DATA 0D,0A
01A58:  DATA 00,00
01A5A:  DATA 20,46
01A5C:  DATA 61,69
01A5E:  DATA 6C,65
01A60:  DATA 64,20
01A62:  DATA 73,65
01A64:  DATA 74,20
01A66:  DATA 6D,65
01A68:  DATA 6D,20
01A6A:  DATA 70,61
01A6C:  DATA 67,65
01A6E:  DATA 20,78
01A70:  DATA 78,78
01A72:  DATA 78,20
01A74:  DATA 0D,0A
01A76:  DATA 0D,0A
01A78:  DATA 00,00
01A7A:  DATA 20,46
01A7C:  DATA 61,69
01A7E:  DATA 6C,65
01A80:  DATA 64,20
01A82:  DATA 73,65
01A84:  DATA 74,20
01A86:  DATA 6D,65
01A88:  DATA 6D,20
01A8A:  DATA 70,61
01A8C:  DATA 67,65
01A8E:  DATA 20,0D
01A90:  DATA 0A,00
01A92:  DATA 55,6E
01A94:  DATA 69,74
01A96:  DATA 20,69
01A98:  DATA 73,20
01A9A:  DATA 72,65
01A9C:  DATA 61,64
01A9E:  DATA 79,20
01AA0:  DATA 66,6F
01AA2:  DATA 72,20
01AA4:  DATA 74,65
01AA6:  DATA 73,74
01AA8:  DATA 69,6E
01AAA:  DATA 67,2C
01AAC:  DATA 20,70
01AAE:  DATA 6C,65
01AB0:  DATA 61,73
01AB2:  DATA 65,20
01AB4:  DATA 73,74
01AB6:  DATA 61,72
01AB8:  DATA 74,20
01ABA:  DATA 62,72
01ABC:  DATA 65,61
01ABE:  DATA 74,68
01AC0:  DATA 69,6E
01AC2:  DATA 67,20
01AC4:  DATA 69,6E
01AC6:  DATA 74,6F
01AC8:  DATA 20,74
01ACA:  DATA 68,65
01ACC:  DATA 20,6D
01ACE:  DATA 6F,75
01AD0:  DATA 74,68
01AD2:  DATA 20,70
01AD4:  DATA 69,65
01AD6:  DATA 63,65
01AD8:  DATA 0D,0A
01ADA:  DATA 0D,0A
01ADC:  DATA 00,00
01ADE:  DATA 0D,0A
01AE0:  DATA 0D,0A
01AE2:  DATA 00,00
01AE4:  DATA 20,2A
01AE6:  DATA 2A,2A
01AE8:  DATA 2A,2A
01AEA:  DATA 2A,2A
01AEC:  DATA 20,42
01AEE:  DATA 4D,45
01AF0:  DATA 20,73
01AF2:  DATA 74,61
01AF4:  DATA 74,65
01AF6:  DATA 20,6D
01AF8:  DATA 61,63
01AFA:  DATA 68,69
01AFC:  DATA 6E,65
01AFE:  DATA 20,66
01B00:  DATA 61,69
01B02:  DATA 6C,65
01B04:  DATA 64,20
01B06:  DATA 2A,2A
01B08:  DATA 2A,2A
01B0A:  DATA 2A,2A
01B0C:  DATA 2A,00
01B0E:  DATA 25,6C
01B10:  DATA 75,20
01B12:  DATA 2F,20
01B14:  DATA 25,30
01B16:  DATA 35,6C
01B18:  DATA 75,20
01B1A:  DATA 6D,73
01B1C:  DATA 3A,20
01B1E:  DATA 73,74
01B20:  DATA 61,74
01B22:  DATA 65,20
01B24:  DATA 25,64
01B26:  DATA 2C,20
01B28:  DATA 25,6C
01B2A:  DATA 75,3B
01B2C:  DATA 20,54
01B2E:  DATA 65,6D
01B30:  DATA 70,20
01B32:  DATA 25,2E
01B34:  DATA 32,66
01B36:  DATA 3B,20
01B38:  DATA 43,75
01B3A:  DATA 72,72
01B3C:  DATA 65,6E
01B3E:  DATA 74,50
01B40:  DATA 72,65
01B42:  DATA 73,73
01B44:  DATA 75,72
01B46:  DATA 65,3A
01B48:  DATA 20,25
01B4A:  DATA 6C,75
01B4C:  DATA 3B,20
01B4E:  DATA 42,61
01B50:  DATA 73,65
01B52:  DATA 50,72
01B54:  DATA 65,73
01B56:  DATA 73,75
01B58:  DATA 72,65
01B5A:  DATA 3A,20
01B5C:  DATA 25,6C
01B5E:  DATA 75,3B
01B60:  DATA 20,64
01B62:  DATA 65,6C
01B64:  DATA 74,61
01B66:  DATA 50,3A
01B68:  DATA 20,25
01B6A:  DATA 6C,75
01B6C:  DATA 2F,25
01B6E:  DATA 6C,75
01B70:  DATA 3B,20
01B72:  DATA 66,6C
01B74:  DATA 6F,77
01B76:  DATA 4C,50
01B78:  DATA 4D,3A
01B7A:  DATA 20,25
01B7C:  DATA 2E,32
01B7E:  DATA 66,3B
01B80:  DATA 20,64
01B82:  DATA 65,6C
01B84:  DATA 74,61
01B86:  DATA 56,6F
01B88:  DATA 6C,3A
01B8A:  DATA 20,25
01B8C:  DATA 2E,32
01B8E:  DATA 66,3B
01B90:  DATA 20,41
01B92:  DATA 63,63
01B94:  DATA 75,6D
01B96:  DATA 75,6C
01B98:  DATA 61,74
01B9A:  DATA 65,64
01B9C:  DATA 56,6F
01B9E:  DATA 6C,75
01BA0:  DATA 6D,65
01BA2:  DATA 3A,20
01BA4:  DATA 25,2E
01BA6:  DATA 32,66
01BA8:  DATA 20,6D
01BAA:  DATA 6C,0D
01BAC:  DATA 0A,00
01BAE:  DATA 46,61
01BB0:  DATA 69,6C
01BB2:  DATA 65,64
01BB4:  DATA 20,42
01BB6:  DATA 4D,45
01BB8:  DATA 5F,53
01BBA:  DATA 4F,46
01BBC:  DATA 54,5F
01BBE:  DATA 52,45
01BC0:  DATA 53,45
01BC2:  DATA 54,20
01BC4:  DATA 0D,0A
01BC6:  DATA 00,00
01BC8:  DATA 42,4D
01BCA:  DATA 45,20
01BCC:  DATA 43,61
01BCE:  DATA 6C,69
01BD0:  DATA 62,20
01BD2:  DATA 49,6E
01BD4:  DATA 69,74
01BD6:  DATA 20,66
01BD8:  DATA 61,69
01BDA:  DATA 6C,65
01BDC:  DATA 64,20
01BDE:  DATA 0D,0A
01BE0:  DATA 00,00
01BE2:  DATA 42,61
01BE4:  DATA 74,74
01BE6:  DATA 65,72
01BE8:  DATA 79,20
01BEA:  DATA 72,65
01BEC:  DATA 61,64
01BEE:  DATA 69,6E
01BF0:  DATA 67,20
01BF2:  DATA 3D,20
01BF4:  DATA 25,6C
01BF6:  DATA 64,00
01BF8:  DATA 0D,0A
01BFA:  DATA 53,68
01BFC:  DATA 75,74
01BFE:  DATA 64,6F
01C00:  DATA 77,6E
01C02:  DATA 20,65
01C04:  DATA 78,74
01C06:  DATA 65,72
01C08:  DATA 6E,61
01C0A:  DATA 6C,20
01C0C:  DATA 64,65
01C0E:  DATA 76,69
01C10:  DATA 63,65
01C12:  DATA 73,2E
01C14:  DATA 2E,2E
01C16:  DATA 0D,0A
01C18:  DATA 00,00
01C1A:  DATA 0D,0A
01C1C:  DATA 53,68
01C1E:  DATA 75,74
01C20:  DATA 64,6F
01C22:  DATA 77,6E
01C24:  DATA 20,70
01C26:  DATA 72,6F
01C28:  DATA 63,65
01C2A:  DATA 73,73
01C2C:  DATA 6F,72
01C2E:  DATA 2E,2E
01C30:  DATA 2E,0D
01C32:  DATA 0A,00
01C34:  DATA 48,61
01C36:  DATA 72,64
01C38:  DATA 77,61
01C3A:  DATA 72,65
01C3C:  DATA 20,66
01C3E:  DATA 61,69
01C40:  DATA 6C,75
01C42:  DATA 72,65
01C44:  DATA 20,63
01C46:  DATA 6F,64
01C48:  DATA 65,20
01C4A:  DATA 25,6C
01C4C:  DATA 75,0D
01C4E:  DATA 0A,00
01C50:  DATA 48,61
01C52:  DATA 72,64
01C54:  DATA 77,61
01C56:  DATA 72,65
01C58:  DATA 20,66
01C5A:  DATA 61,69
01C5C:  DATA 6C,75
01C5E:  DATA 72,65
01C60:  DATA 2C,20
01C62:  DATA 75,6E
01C64:  DATA 69,74
01C66:  DATA 20,69
01C68:  DATA 73,20
01C6A:  DATA 73,68
01C6C:  DATA 75,74
01C6E:  DATA 74,69
01C70:  DATA 6E,67
01C72:  DATA 20,64
01C74:  DATA 6F,77
01C76:  DATA 6E,0D
01C78:  DATA 0A,00
01C7A:  DATA 42,72
01C7C:  DATA 69,67
01C7E:  DATA 68,74
01C80:  DATA 6E,65
01C82:  DATA 73,73
01C84:  DATA 20,6E
01C86:  DATA 6F,74
01C88:  DATA 20,63
01C8A:  DATA 61,6C
01C8C:  DATA 69,62
01C8E:  DATA 72,61
01C90:  DATA 74,65
01C92:  DATA 64,20
01C94:  DATA 2D,20
01C96:  DATA 30,78
01C98:  DATA 25,78
01C9A:  DATA 0D,0A
01C9C:  DATA 00,00
01C9E:  DATA 25,6C
01CA0:  DATA 64,20
01CA2:  DATA 40,20
01CA4:  DATA 25,6C
01CA6:  DATA 64,00
01CA8:  DATA 25,6C
01CAA:  DATA 64,20
01CAC:  DATA 40,20
01CAE:  DATA 25,6C
01CB0:  DATA 64,00
01CB2:  DATA 25,6C
01CB4:  DATA 64,20
01CB6:  DATA 40,20
01CB8:  DATA 25,6C
01CBA:  DATA 64,00
01CBC:  DATA 57,68
01CBE:  DATA 69,74
01CC0:  DATA 65,62
01CC2:  DATA 61,6C
01CC4:  DATA 61,6E
01CC6:  DATA 63,65
01CC8:  DATA 3A,20
01CCA:  DATA 00,00
01CCC:  DATA 57,42
01CCE:  DATA 20,43
01CD0:  DATA 6F,65
01CD2:  DATA 66,66
01CD4:  DATA 66,69
01CD6:  DATA 63,69
01CD8:  DATA 65,6E
01CDA:  DATA 74,73
01CDC:  DATA 3A,20
01CDE:  DATA 00,00
01CE0:  DATA 4D,65
01CE2:  DATA 61,73
01CE4:  DATA 75,72
01CE6:  DATA 69,6E
01CE8:  DATA 67,20
01CEA:  DATA 62,72
01CEC:  DATA 65,61
01CEE:  DATA 74,68
01CF0:  DATA 20,73
01CF2:  DATA 61,6D
01CF4:  DATA 70,6C
01CF6:  DATA 65,2E
01CF8:  DATA 2E,2E
01CFA:  DATA 0D,0A
01CFC:  DATA 54,69
01CFE:  DATA 6D,65
01D00:  DATA 28,73
01D02:  DATA 29,2C
01D04:  DATA 20,52
01D06:  DATA 65,64
01D08:  DATA 20,37
01D0A:  DATA 33,30
01D0C:  DATA 2C,20
01D0E:  DATA 4F,72
01D10:  DATA 61,6E
01D12:  DATA 67,65
01D14:  DATA 20,35
01D16:  DATA 38,38
01D18:  DATA 2C,20
01D1A:  DATA 42,6C
01D1C:  DATA 75,65
01D1E:  DATA 20,34
01D20:  DATA 37,35
01D22:  DATA 0D,0A
01D24:  DATA 00,00
01D26:  DATA 0D,0A
01D28:  DATA 0D,0A
01D2A:  DATA 2A,2A
01D2C:  DATA 2A,2A
01D2E:  DATA 2A,43
01D30:  DATA 61,72
01D32:  DATA 74,72
01D34:  DATA 69,64
01D36:  DATA 67,65
01D38:  DATA 20,72
01D3A:  DATA 65,6D
01D3C:  DATA 6F,76
01D3E:  DATA 65,64
01D40:  DATA 20,64
01D42:  DATA 75,72
01D44:  DATA 69,6E
01D46:  DATA 67,20
01D48:  DATA 72,65
01D4A:  DATA 61,64
01D4C:  DATA 69,6E
01D4E:  DATA 67,2A
01D50:  DATA 2A,2A
01D52:  DATA 2A,2A
01D54:  DATA 0D,0A
01D56:  DATA 0D,0A
01D58:  DATA 00,00
01D5A:  DATA 0D,0A
01D5C:  DATA 41,6E
01D5E:  DATA 61,6C
01D60:  DATA 79,7A
01D62:  DATA 69,6E
01D64:  DATA 67,20
01D66:  DATA 77,65
01D68:  DATA 74,20
01D6A:  DATA 63,61
01D6C:  DATA 72,74
01D6E:  DATA 72,69
01D70:  DATA 64,67
01D72:  DATA 65,2E
01D74:  DATA 2E,2E
01D76:  DATA 0D,0A
01D78:  DATA 54,69
01D7A:  DATA 6D,65
01D7C:  DATA 28,73
01D7E:  DATA 29,2C
01D80:  DATA 20,52
01D82:  DATA 65,64
01D84:  DATA 20,37
01D86:  DATA 33,30
01D88:  DATA 2C,20
01D8A:  DATA 4F,72
01D8C:  DATA 61,6E
01D8E:  DATA 67,65
01D90:  DATA 20,35
01D92:  DATA 38,38
01D94:  DATA 2C,20
01D96:  DATA 42,6C
01D98:  DATA 75,65
01D9A:  DATA 20,34
01D9C:  DATA 37,35
01D9E:  DATA 0D,0A
01DA0:  DATA 00,00
01DA2:  DATA 44,69
01DA4:  DATA 66,66
01DA6:  DATA 31,3D
01DA8:  DATA 20,25
01DAA:  DATA 2E,34
01DAC:  DATA 66,0D
01DAE:  DATA 0A,00
01DB0:  DATA 0D,0A
01DB2:  DATA 41,6E
01DB4:  DATA 61,6C
01DB6:  DATA 79,7A
01DB8:  DATA 69,6E
01DBA:  DATA 67,20
01DBC:  DATA 69,6E
01DBE:  DATA 69,74
01DC0:  DATA 69,61
01DC2:  DATA 6C,20
01DC4:  DATA 63,61
01DC6:  DATA 72,74
01DC8:  DATA 72,69
01DCA:  DATA 64,67
01DCC:  DATA 65,2E
01DCE:  DATA 2E,2E
01DD0:  DATA 0D,0A
01DD2:  DATA 54,69
01DD4:  DATA 6D,65
01DD6:  DATA 28,73
01DD8:  DATA 29,2C
01DDA:  DATA 20,52
01DDC:  DATA 65,64
01DDE:  DATA 20,37
01DE0:  DATA 33,30
01DE2:  DATA 2C,20
01DE4:  DATA 4F,72
01DE6:  DATA 61,6E
01DE8:  DATA 67,65
01DEA:  DATA 20,35
01DEC:  DATA 38,38
01DEE:  DATA 2C,20
01DF0:  DATA 42,6C
01DF2:  DATA 75,65
01DF4:  DATA 20,34
01DF6:  DATA 37,35
01DF8:  DATA 0D,0A
01DFA:  DATA 00,00
01DFC:  DATA 44,69
01DFE:  DATA 66,66
01E00:  DATA 32,3D
01E02:  DATA 20,25
01E04:  DATA 2E,34
01E06:  DATA 66,0D
01E08:  DATA 0A,00
01E0A:  DATA 0D,0A
01E0C:  DATA 41,6E
01E0E:  DATA 61,6C
01E10:  DATA 79,7A
01E12:  DATA 69,6E
01E14:  DATA 67,20
01E16:  DATA 66,69
01E18:  DATA 6E,61
01E1A:  DATA 6C,20
01E1C:  DATA 63,61
01E1E:  DATA 72,74
01E20:  DATA 72,69
01E22:  DATA 64,67
01E24:  DATA 65,2E
01E26:  DATA 2E,2E
01E28:  DATA 0D,0A
01E2A:  DATA 54,69
01E2C:  DATA 6D,65
01E2E:  DATA 28,73
01E30:  DATA 29,2C
01E32:  DATA 20,52
01E34:  DATA 65,64
01E36:  DATA 20,37
01E38:  DATA 33,30
01E3A:  DATA 2C,20
01E3C:  DATA 4F,72
01E3E:  DATA 61,6E
01E40:  DATA 67,65
01E42:  DATA 20,35
01E44:  DATA 38,38
01E46:  DATA 2C,20
01E48:  DATA 42,6C
01E4A:  DATA 75,65
01E4C:  DATA 20,34
01E4E:  DATA 37,35
01E50:  DATA 0D,0A
01E52:  DATA 00,00
01E54:  DATA 44,69
01E56:  DATA 66,66
01E58:  DATA 33,3D
01E5A:  DATA 20,25
01E5C:  DATA 2E,34
01E5E:  DATA 66,0D
01E60:  DATA 0A,00
01E62:  DATA 0D,41
01E64:  DATA 44,31
01E66:  DATA 3D,25
01E68:  DATA 2E,34
01E6A:  DATA 66,2C
01E6C:  DATA 20,41
01E6E:  DATA 44,32
01E70:  DATA 3D,25
01E72:  DATA 2E,34
01E74:  DATA 66,2C
01E76:  DATA 20,41
01E78:  DATA 44,5F
01E7A:  DATA 46,69
01E7C:  DATA 6E,61
01E7E:  DATA 6C,3D
01E80:  DATA 25,2E
01E82:  DATA 34,66
01E84:  DATA 0D,0A
01E86:  DATA 00,00
01E88:  DATA 43,6F
01E8A:  DATA 6E,63
01E8C:  DATA 31,20
01E8E:  DATA 3D,20
01E90:  DATA 28,41
01E92:  DATA 44,32
01E94:  DATA 20,2D
01E96:  DATA 20,30
01E98:  DATA 2E,30
01E9A:  DATA 33,29
01E9C:  DATA 20,2F
01E9E:  DATA 20,30
01EA0:  DATA 2E,30
01EA2:  DATA 32,20
01EA4:  DATA 3D,20
01EA6:  DATA 25,2E
01EA8:  DATA 34,66
01EAA:  DATA 20,3D
01EAC:  DATA 3E,20
01EAE:  DATA 43,6F
01EB0:  DATA 6E,63
01EB2:  DATA 65,6E
01EB4:  DATA 74,72
01EB6:  DATA 61,74
01EB8:  DATA 69,6F
01EBA:  DATA 6E,3D
01EBC:  DATA 20,25
01EBE:  DATA 2E,34
01EC0:  DATA 66,0D
01EC2:  DATA 0A,00
01EC4:  DATA 43,6F
01EC6:  DATA 6E,63
01EC8:  DATA 32,20
01ECA:  DATA 3D,20
01ECC:  DATA 28,41
01ECE:  DATA 44,32
01ED0:  DATA 20,2D
01ED2:  DATA 20,30
01ED4:  DATA 2E,30
01ED6:  DATA 35,29
01ED8:  DATA 20,2F
01EDA:  DATA 20,30
01EDC:  DATA 2E,30
01EDE:  DATA 32,20
01EE0:  DATA 3D,20
01EE2:  DATA 25,2E
01EE4:  DATA 34,66
01EE6:  DATA 20,3D
01EE8:  DATA 3E,20
01EEA:  DATA 43,6F
01EEC:  DATA 6E,63
01EEE:  DATA 65,6E
01EF0:  DATA 74,72
01EF2:  DATA 61,74
01EF4:  DATA 69,6F
01EF6:  DATA 6E,3D
01EF8:  DATA 20,25
01EFA:  DATA 2E,34
01EFC:  DATA 66,0D
01EFE:  DATA 0A,00
01F00:  DATA 43,6F
01F02:  DATA 6E,63
01F04:  DATA 33,20
01F06:  DATA 3D,20
01F08:  DATA 28,41
01F0A:  DATA 44,32
01F0C:  DATA 20,2D
01F0E:  DATA 20,30
01F10:  DATA 2E,30
01F12:  DATA 39,29
01F14:  DATA 20,2F
01F16:  DATA 20,30
01F18:  DATA 2E,30
01F1A:  DATA 32,20
01F1C:  DATA 3D,20
01F1E:  DATA 25,2E
01F20:  DATA 34,66
01F22:  DATA 20,3D
01F24:  DATA 3E,20
01F26:  DATA 43,6F
01F28:  DATA 6E,63
01F2A:  DATA 65,6E
01F2C:  DATA 74,72
01F2E:  DATA 61,74
01F30:  DATA 69,6F
01F32:  DATA 6E,3D
01F34:  DATA 20,25
01F36:  DATA 2E,34
01F38:  DATA 66,0D
01F3A:  DATA 0A,00
01F3C:  DATA 43,6F
01F3E:  DATA 6E,63
01F40:  DATA 20,3D
01F42:  DATA 20,28
01F44:  DATA 41,44
01F46:  DATA 32,20
01F48:  DATA 2D,20
01F4A:  DATA 25,2E
01F4C:  DATA 34,66
01F4E:  DATA 29,20
01F50:  DATA 2F,20
01F52:  DATA 25,2E
01F54:  DATA 34,66
01F56:  DATA 20,3D
01F58:  DATA 20,25
01F5A:  DATA 2E,34
01F5C:  DATA 66,20
01F5E:  DATA 3D,3E
01F60:  DATA 20,43
01F62:  DATA 6F,6E
01F64:  DATA 63,65
01F66:  DATA 6E,74
01F68:  DATA 72,61
01F6A:  DATA 74,69
01F6C:  DATA 6F,6E
01F6E:  DATA 3D,20
01F70:  DATA 25,66
01F72:  DATA 0D,0A
01F74:  DATA 00,00
01F76:  DATA 0D,0A
01F78:  DATA 2A,2A
01F7A:  DATA 2A,2A
01F7C:  DATA 20,43
01F7E:  DATA 68,65
01F80:  DATA 63,6B
01F82:  DATA 20,66
01F84:  DATA 6F,72
01F86:  DATA 20,63
01F88:  DATA 61,72
01F8A:  DATA 74,72
01F8C:  DATA 69,64
01F8E:  DATA 67,65
01F90:  DATA 20,2A
01F92:  DATA 2A,2A
01F94:  DATA 2A,0D
01F96:  DATA 0A,00
01F98:  DATA 4B,65
01F9A:  DATA 74,6F
01F9C:  DATA 6E,65
01F9E:  DATA 20,72
01FA0:  DATA 65,61
01FA2:  DATA 64,69
01FA4:  DATA 6E,67
01FA6:  DATA 20,65
01FA8:  DATA 72,72
01FAA:  DATA 6F,72
01FAC:  DATA 2C,20
01FAE:  DATA 72,65
01FB0:  DATA 70,6C
01FB2:  DATA 61,63
01FB4:  DATA 65,20
01FB6:  DATA 63,61
01FB8:  DATA 74,72
01FBA:  DATA 69,64
01FBC:  DATA 67,65
01FBE:  DATA 20,61
01FC0:  DATA 6E,64
01FC2:  DATA 20,72
01FC4:  DATA 65,74
01FC6:  DATA 65,73
01FC8:  DATA 74,2E
01FCA:  DATA 0D,0A
01FCC:  DATA 00,00
01FCE:  DATA 46,75
01FD0:  DATA 6C,6C
01FD2:  DATA 54,65
01FD4:  DATA 73,74
01FD6:  DATA 20,66
01FD8:  DATA 69,6E
01FDA:  DATA 69,73
01FDC:  DATA 68,65
01FDE:  DATA 64,20
01FE0:  DATA 73,75
01FE2:  DATA 63,63
01FE4:  DATA 65,73
01FE6:  DATA 73,66
01FE8:  DATA 75,6C
01FEA:  DATA 6C,79
01FEC:  DATA 2E,0D
01FEE:  DATA 0A,00
01FF0:  DATA 43,61
01FF2:  DATA 6C,69
01FF4:  DATA 62,72
01FF6:  DATA 61,74
01FF8:  DATA 69,6F
01FFA:  DATA 6E,20
01FFC:  DATA 66,69
01FFE:  DATA 6E,69
02000:  DATA 73,68
02002:  DATA 65,64
02004:  DATA 20,73
02006:  DATA 75,63
02008:  DATA 63,65
0200A:  DATA 73,73
0200C:  DATA 66,75
0200E:  DATA 6C,6C
02010:  DATA 79,2E
02012:  DATA 0D,0A
02014:  DATA 00,00
02016:  DATA 42,72
02018:  DATA 65,61
0201A:  DATA 74,68
0201C:  DATA 20,74
0201E:  DATA 65,73
02020:  DATA 74,20
02022:  DATA 73,74
02024:  DATA 61,72
02026:  DATA 74,65
02028:  DATA 64,0D
0202A:  DATA 0A,00
0202C:  DATA 49,6E
0202E:  DATA 69,74
02030:  DATA 69,61
02032:  DATA 6C,20
02034:  DATA 4C,69
02036:  DATA 67,68
02038:  DATA 74,2D
0203A:  DATA 43,6F
0203C:  DATA 6E,64
0203E:  DATA 69,74
02040:  DATA 69,6F
02042:  DATA 6E,73
02044:  DATA 3A,00
02046:  DATA 42,72
02048:  DATA 69,67
0204A:  DATA 68,74
0204C:  DATA 6E,65
0204E:  DATA 73,73
02050:  DATA 20,6C
02052:  DATA 65,76
02054:  DATA 65,6C
02056:  DATA 73,3A
02058:  DATA 0D,0A
0205A:  DATA 37,33
0205C:  DATA 30,6E
0205E:  DATA 6D,2C
02060:  DATA 20,35
02062:  DATA 38,38
02064:  DATA 6E,6D
02066:  DATA 2C,20
02068:  DATA 34,37
0206A:  DATA 35,6E
0206C:  DATA 6D,0D
0206E:  DATA 25,75
02070:  DATA 2C,20
02072:  DATA 25,75
02074:  DATA 2C,20
02076:  DATA 25,75
02078:  DATA 0D,0A
0207A:  DATA 00,00
0207C:  DATA 2A,2A
0207E:  DATA 2A,2A
02080:  DATA 2A,20
02082:  DATA 4C,45
02084:  DATA 44,20
02086:  DATA 62,72
02088:  DATA 69,67
0208A:  DATA 68,74
0208C:  DATA 6E,65
0208E:  DATA 73,73
02090:  DATA 20,73
02092:  DATA 65,74
02094:  DATA 74,69
02096:  DATA 6E,67
02098:  DATA 20,66
0209A:  DATA 61,69
0209C:  DATA 6C,65
0209E:  DATA 64,20
020A0:  DATA 2A,2A
020A2:  DATA 2A,2A
020A4:  DATA 2A,0D
020A6:  DATA 0A,00
020A8:  DATA 4B,65
020AA:  DATA 74,6F
020AC:  DATA 6E,65
020AE:  DATA 20,00
020B0:  DATA 41,6D
020B2:  DATA 6D,6F
020B4:  DATA 6E,69
020B6:  DATA 61,20
020B8:  DATA 00,00
020BA:  DATA 43,61
020BC:  DATA 6C,69
020BE:  DATA 62,72
020C0:  DATA 61,74
020C2:  DATA 69,6F
020C4:  DATA 6E,20
020C6:  DATA 00,00
020C8:  DATA 2E,2E
020CA:  DATA 2E,2E
020CC:  DATA 53,74
020CE:  DATA 61,72
020D0:  DATA 74,20
020D2:  DATA 62,72
020D4:  DATA 65,61
020D6:  DATA 74,68
020D8:  DATA 69,6E
020DA:  DATA 67,20
020DC:  DATA 69,6E
020DE:  DATA 74,6F
020E0:  DATA 20,74
020E2:  DATA 68,65
020E4:  DATA 20,6D
020E6:  DATA 6F,75
020E8:  DATA 74,68
020EA:  DATA 20,70
020EC:  DATA 69,65
020EE:  DATA 63,65
020F0:  DATA 2E,2E
020F2:  DATA 2E,0D
020F4:  DATA 0A,00
020F6:  DATA 42,72
020F8:  DATA 65,61
020FA:  DATA 74,68
020FC:  DATA 20,76
020FE:  DATA 6F,6C
02100:  DATA 75,6D
02102:  DATA 65,20
02104:  DATA 73,65
02106:  DATA 74,74
02108:  DATA 69,6E
0210A:  DATA 67,73
0210C:  DATA 20,25
0210E:  DATA 6C,75
02110:  DATA 0D,0A
02112:  DATA 00,00
02114:  DATA 2A,2A
02116:  DATA 2A,2A
02118:  DATA 2A,20
0211A:  DATA 49,6E
0211C:  DATA 73,75
0211E:  DATA 66,66
02120:  DATA 69,63
02122:  DATA 69,65
02124:  DATA 6E,74
02126:  DATA 20,62
02128:  DATA 72,65
0212A:  DATA 61,74
0212C:  DATA 68,20
0212E:  DATA 76,6F
02130:  DATA 6C,75
02132:  DATA 6D,65
02134:  DATA 20,2A
02136:  DATA 2A,2A
02138:  DATA 2A,2A
0213A:  DATA 0D,0A
0213C:  DATA 00,00
0213E:  DATA 49,6E
02140:  DATA 73,65
02142:  DATA 72,74
02144:  DATA 20,63
02146:  DATA 61,74
02148:  DATA 72,69
0214A:  DATA 64,67
0214C:  DATA 65,20
0214E:  DATA 77,69
02150:  DATA 74,68
02152:  DATA 20,6B
02154:  DATA 6E,6F
02156:  DATA 77,6E
02158:  DATA 20,67
0215A:  DATA 61,73
0215C:  DATA 20,73
0215E:  DATA 61,6D
02160:  DATA 70,6C
02162:  DATA 65,73
02164:  DATA 20,66
02166:  DATA 6F,72
02168:  DATA 20,63
0216A:  DATA 61,6C
0216C:  DATA 69,62
0216E:  DATA 72,61
02170:  DATA 74,69
02172:  DATA 6F,6E
02174:  DATA 20,69
02176:  DATA 6E,74
02178:  DATA 6F,20
0217A:  DATA 75,6E
0217C:  DATA 69,74
0217E:  DATA 20,77
02180:  DATA 68,65
02182:  DATA 6E,20
02184:  DATA 64,6F
02186:  DATA 6E,65
02188:  DATA 0D,0A
0218A:  DATA 00,00
0218C:  DATA 25,64
0218E:  DATA 20,73
02190:  DATA 65,63
02192:  DATA 6F,6E
02194:  DATA 64,73
02196:  DATA 20,74
02198:  DATA 6F,20
0219A:  DATA 6B,65
0219C:  DATA 74,6F
0219E:  DATA 6E,65
021A0:  DATA 20,61
021A2:  DATA 6E,61
021A4:  DATA 6C,79
021A6:  DATA 73,69
021A8:  DATA 73,0D
021AA:  DATA 0A,00
021AC:  DATA 55,70
021AE:  DATA 64,61
021B0:  DATA 74,65
021B2:  DATA 20,74
021B4:  DATA 68,65
021B6:  DATA 20,42
021B8:  DATA 4C,45
021BA:  DATA 20,69
021BC:  DATA 6E,66
021BE:  DATA 6F,0D
021C0:  DATA 0A,00
021C2:  DATA 42,4C
021C4:  DATA 45,20
021C6:  DATA 69,6E
021C8:  DATA 66,6F
021CA:  DATA 20,75
021CC:  DATA 70,64
021CE:  DATA 61,74
021D0:  DATA 65,64
021D2:  DATA 0D,0A
021D4:  DATA 00,00
021D6:  DATA 2A,2A
021D8:  DATA 2A,2A
021DA:  DATA 50,6C
021DC:  DATA 65,61
021DE:  DATA 73,65
021E0:  DATA 20,72
021E2:  DATA 65,6D
021E4:  DATA 6F,76
021E6:  DATA 65,73
021E8:  DATA 20,63
021EA:  DATA 61,72
021EC:  DATA 74,72
021EE:  DATA 69,64
021F0:  DATA 67,65
021F2:  DATA 2A,2A
021F4:  DATA 2A,2A
021F6:  DATA 0D,0A
021F8:  DATA 00,00
021FA:  DATA 0D,0A
021FC:  DATA 42,72
021FE:  DATA 65,61
02200:  DATA 74,68
02202:  DATA 20,76
02204:  DATA 6F,6C
02206:  DATA 75,6D
02208:  DATA 65,20
0220A:  DATA 6D,75
0220C:  DATA 73,74
0220E:  DATA 20,62
02210:  DATA 65,20
02212:  DATA 62,65
02214:  DATA 74,77
02216:  DATA 65,65
02218:  DATA 6E,20
0221A:  DATA 33,30
0221C:  DATA 30,2D
0221E:  DATA 31,30
02220:  DATA 30,30
02222:  DATA 20,6D
02224:  DATA 6C,0D
02226:  DATA 0A,00
02228:  DATA 0D,0A
0222A:  DATA 42,4C
0222C:  DATA 45,20
0222E:  DATA 49,44
02230:  DATA 20,3A
02232:  DATA 20,30
02234:  DATA 78,00
02236:  DATA 42,4C
02238:  DATA 45,20
0223A:  DATA 00,00
0223C:  DATA 42,4D
0223E:  DATA 45,00
02240:  DATA 42,4D
02242:  DATA 45,00
02244:  DATA 42,61
02246:  DATA 74,74
02248:  DATA 65,72
0224A:  DATA 79,20
0224C:  DATA 4C,65
0224E:  DATA 76,65
02250:  DATA 6C,20
02252:  DATA 3D,20
02254:  DATA 25,6C
02256:  DATA 75,25
02258:  DATA 25,00
0225A:  DATA 45,45
0225C:  DATA 50,52
0225E:  DATA 4F,4D
02260:  DATA 20,00
02262:  DATA 53,6C
02264:  DATA 6F,70
02266:  DATA 65,3A
02268:  DATA 20,25
0226A:  DATA 2E,33
0226C:  DATA 66,0D
0226E:  DATA 0A,00
02270:  DATA 49,6E
02272:  DATA 74,65
02274:  DATA 72,63
02276:  DATA 65,70
02278:  DATA 74,3A
0227A:  DATA 20,25
0227C:  DATA 2E,33
0227E:  DATA 66,0D
02280:  DATA 0A,00
02282:  DATA 56,6F
02284:  DATA 6C,75
02286:  DATA 6D,65
02288:  DATA 20,53
0228A:  DATA 65,74
0228C:  DATA 74,69
0228E:  DATA 6E,67
02290:  DATA 73,20
02292:  DATA 3A,20
02294:  DATA 25,6C
02296:  DATA 75,20
02298:  DATA 6D,6C
0229A:  DATA 20,0D
0229C:  DATA 0A,0D
0229E:  DATA 0A,00
022A0:  DATA 49,6E
022A2:  DATA 76,6F
022A4:  DATA 79,20
022A6:  DATA 35,2E
022A8:  DATA 30,20
022AA:  DATA 56,65
022AC:  DATA 72,73
022AE:  DATA 69,6F
022B0:  DATA 6E,20
022B2:  DATA 4D,61
022B4:  DATA 6A,6F
022B6:  DATA 72,20
022B8:  DATA 25,64
022BA:  DATA 2E,20
022BC:  DATA 4D,69
022BE:  DATA 6E,6F
022C0:  DATA 72,20
022C2:  DATA 25,64
022C4:  DATA 2E,20
022C6:  DATA 52,65
022C8:  DATA 76,69
022CA:  DATA 73,69
022CC:  DATA 6F,6E
022CE:  DATA 20,25
022D0:  DATA 64,0D
022D2:  DATA 0A,0D
022D4:  DATA 0A,00
022D6:  DATA 0D,0A
022D8:  DATA 2A,2A
022DA:  DATA 2A,2A
022DC:  DATA 44,65
022DE:  DATA 76,69
022E0:  DATA 63,65
022E2:  DATA 20,69
022E4:  DATA 6E,61
022E6:  DATA 63,74
022E8:  DATA 69,76
022EA:  DATA 69,74
022EC:  DATA 79,20
022EE:  DATA 64,65
022F0:  DATA 74,65
022F2:  DATA 63,74
022F4:  DATA 65,64
022F6:  DATA 2A,2A
022F8:  DATA 2A,2A
022FA:  DATA 2A,0D
022FC:  DATA 0A,00
022FE:  DATA 2A,2A
02300:  DATA 2A,2A
02302:  DATA 25,6C
02304:  DATA 75,20
02306:  DATA 73,65
02308:  DATA 63,6F
0230A:  DATA 6E,64
0230C:  DATA 28,73
0230E:  DATA 29,20
02310:  DATA 74,6F
02312:  DATA 20,70
02314:  DATA 6F,77
02316:  DATA 65,72
02318:  DATA 64,6F
0231A:  DATA 77,6E
0231C:  DATA 2A,2A
0231E:  DATA 2A,2A
02320:  DATA 0D,0A
02322:  DATA 0D,0A
02324:  DATA 00,00
02326:  DATA 0D,0A
02328:  DATA 2A,2A
0232A:  DATA 2A,2A
0232C:  DATA 45,78
0232E:  DATA 63,65
02330:  DATA 65,64
02332:  DATA 20,69
02334:  DATA 6E,61
02336:  DATA 63,74
02338:  DATA 69,76
0233A:  DATA 69,74
0233C:  DATA 79,20
0233E:  DATA 74,69
02340:  DATA 6D,65
02342:  DATA 20,6C
02344:  DATA 69,6D
02346:  DATA 69,74
02348:  DATA 2C,20
0234A:  DATA 65,6E
0234C:  DATA 74,65
0234E:  DATA 72,69
02350:  DATA 6E,67
02352:  DATA 20,73
02354:  DATA 6C,65
02356:  DATA 65,70
02358:  DATA 20,6D
0235A:  DATA 6F,64
0235C:  DATA 65,2A
0235E:  DATA 2A,2A
02360:  DATA 2A,0D
02362:  DATA 0A,0D
02364:  DATA 0A,00
02366:  DATA 4B,65
02368:  DATA 74,6F
0236A:  DATA 6E,65
0236C:  DATA 20,74
0236E:  DATA 65,73
02370:  DATA 74,20
02372:  DATA 73,74
02374:  DATA 61,72
02376:  DATA 74,65
02378:  DATA 64,0D
0237A:  DATA 0A,00
0237C:  DATA 41,6D
0237E:  DATA 6D,6F
02380:  DATA 6E,69
02382:  DATA 61,20
02384:  DATA 74,65
02386:  DATA 73,74
02388:  DATA 20,73
0238A:  DATA 74,61
0238C:  DATA 72,74
0238E:  DATA 65,64
02390:  DATA 0D,0A
02392:  DATA 00,00
02394:  DATA 52,65
02396:  DATA 73,65
02398:  DATA 74,69
0239A:  DATA 6E,67
0239C:  DATA 20,72
0239E:  DATA 65,61
023A0:  DATA 64,69
023A2:  DATA 6E,67
023A4:  DATA 73,0D
023A6:  DATA 0A,00
023A8:  DATA 46,69
023AA:  DATA 72,6D
023AC:  DATA 77,61
023AE:  DATA 72,65
023B0:  DATA 20,75
023B2:  DATA 70,64
023B4:  DATA 61,74
023B6:  DATA 65,20
023B8:  DATA 73,74
023BA:  DATA 61,72
023BC:  DATA 74,65
023BE:  DATA 64,0D
023C0:  DATA 0A,00
023C2:  DATA 0D,0A
023C4:  DATA 2A,2A
023C6:  DATA 2A,2A
023C8:  DATA 53,6C
023CA:  DATA 65,65
023CC:  DATA 70,20
023CE:  DATA 4D,6F
023D0:  DATA 64,65
023D2:  DATA 2A,2A
023D4:  DATA 2A,2A
023D6:  DATA 0D,0A
023D8:  DATA 00,00
023DA:  DATA 20,0D
023DC:  DATA 0A,0D
023DE:  DATA 0A,20
023E0:  DATA 20,54
023E2:  DATA 79,70
023E4:  DATA 65,20
023E6:  DATA 74,68
023E8:  DATA 65,20
023EA:  DATA 66,6F
023EC:  DATA 6C,6C
023EE:  DATA 6F,77
023F0:  DATA 69,6E
023F2:  DATA 67,20
023F4:  DATA 63,6F
023F6:  DATA 6D,6D
023F8:  DATA 61,6E
023FA:  DATA 64,20
023FC:  DATA 0D,0A
023FE:  DATA 00,00
02400:  DATA 2D,2D
02402:  DATA 2D,2D
02404:  DATA 2D,2D
02406:  DATA 2D,2D
02408:  DATA 2D,2D
0240A:  DATA 2D,2D
0240C:  DATA 2D,2D
0240E:  DATA 2D,2D
02410:  DATA 2D,2D
02412:  DATA 2D,2D
02414:  DATA 2D,2D
02416:  DATA 2D,2D
02418:  DATA 2D,2D
0241A:  DATA 2D,2D
0241C:  DATA 2D,2D
0241E:  DATA 0D,0A
02420:  DATA 0D,0A
02422:  DATA 00,00
02424:  DATA 20,20
02426:  DATA 62,72
02428:  DATA 69,67
0242A:  DATA 68,74
0242C:  DATA 37,33
0242E:  DATA 30,3D
02430:  DATA 20,20
02432:  DATA 2D,20
02434:  DATA 73,65
02436:  DATA 74,20
02438:  DATA 74,68
0243A:  DATA 65,20
0243C:  DATA 6C,65
0243E:  DATA 64,20
02440:  DATA 37,33
02442:  DATA 30,20
02444:  DATA 62,72
02446:  DATA 69,67
02448:  DATA 68,74
0244A:  DATA 6E,65
0244C:  DATA 73,73
0244E:  DATA 20,0D
02450:  DATA 0A,00
02452:  DATA 20,20
02454:  DATA 62,72
02456:  DATA 69,67
02458:  DATA 68,74
0245A:  DATA 35,38
0245C:  DATA 38,3D
0245E:  DATA 20,20
02460:  DATA 2D,20
02462:  DATA 73,65
02464:  DATA 74,20
02466:  DATA 74,68
02468:  DATA 65,20
0246A:  DATA 6C,65
0246C:  DATA 64,20
0246E:  DATA 35,38
02470:  DATA 38,20
02472:  DATA 62,72
02474:  DATA 69,67
02476:  DATA 68,74
02478:  DATA 6E,65
0247A:  DATA 73,73
0247C:  DATA 20,0D
0247E:  DATA 0A,00
02480:  DATA 20,20
02482:  DATA 62,72
02484:  DATA 69,67
02486:  DATA 68,74
02488:  DATA 34,37
0248A:  DATA 35,3D
0248C:  DATA 20,20
0248E:  DATA 2D,20
02490:  DATA 73,65
02492:  DATA 74,20
02494:  DATA 74,68
02496:  DATA 65,20
02498:  DATA 6C,65
0249A:  DATA 64,20
0249C:  DATA 34,37
0249E:  DATA 35,20
024A0:  DATA 62,72
024A2:  DATA 69,67
024A4:  DATA 68,74
024A6:  DATA 6E,65
024A8:  DATA 73,73
024AA:  DATA 20,0D
024AC:  DATA 0A,00
024AE:  DATA 20,20
024B0:  DATA 62,74
024B2:  DATA 20,20
024B4:  DATA 20,20
024B6:  DATA 20,20
024B8:  DATA 20,20
024BA:  DATA 20,20
024BC:  DATA 2D,20
024BE:  DATA 67,65
024C0:  DATA 74,20
024C2:  DATA 74,68
024C4:  DATA 65,20
024C6:  DATA 6C,65
024C8:  DATA 64,20
024CA:  DATA 62,72
024CC:  DATA 69,67
024CE:  DATA 68,74
024D0:  DATA 6E,65
024D2:  DATA 73,73
024D4:  DATA 20,76
024D6:  DATA 61,6C
024D8:  DATA 75,65
024DA:  DATA 73,20
024DC:  DATA 0D,0A
024DE:  DATA 00,00
024E0:  DATA 20,20
024E2:  DATA 63,61
024E4:  DATA 6C,69
024E6:  DATA 62,72
024E8:  DATA 61,74
024EA:  DATA 65,20
024EC:  DATA 20,20
024EE:  DATA 2D,20
024F0:  DATA 63,61
024F2:  DATA 6C,69
024F4:  DATA 62,72
024F6:  DATA 61,74
024F8:  DATA 65,20
024FA:  DATA 74,68
024FC:  DATA 65,20
024FE:  DATA 75,6E
02500:  DATA 69,74
02502:  DATA 20,0D
02504:  DATA 0A,00
02506:  DATA 20,20
02508:  DATA 63,74
0250A:  DATA 20,20
0250C:  DATA 20,20
0250E:  DATA 20,20
02510:  DATA 20,20
02512:  DATA 20,20
02514:  DATA 2D,20
02516:  DATA 63,68
02518:  DATA 65,63
0251A:  DATA 6B,20
0251C:  DATA 74,68
0251E:  DATA 65,20
02520:  DATA 63,61
02522:  DATA 72,74
02524:  DATA 72,69
02526:  DATA 64,67
02528:  DATA 65,20
0252A:  DATA 63,6F
0252C:  DATA 6E,64
0252E:  DATA 69,74
02530:  DATA 69,6F
02532:  DATA 6E,20
02534:  DATA 0D,0A
02536:  DATA 00,00
02538:  DATA 20,20
0253A:  DATA 66,74
0253C:  DATA 20,20
0253E:  DATA 20,20
02540:  DATA 20,20
02542:  DATA 20,20
02544:  DATA 20,20
02546:  DATA 2D,20
02548:  DATA 70,65
0254A:  DATA 72,66
0254C:  DATA 6F,72
0254E:  DATA 6D,20
02550:  DATA 6B,65
02552:  DATA 74,6F
02554:  DATA 6E,65
02556:  DATA 20,74
02558:  DATA 65,73
0255A:  DATA 74,20
0255C:  DATA 0D,0A
0255E:  DATA 00,00
02560:  DATA 20,20
02562:  DATA 69,64
02564:  DATA 65,6E
02566:  DATA 74,69
02568:  DATA 66,79
0256A:  DATA 20,20
0256C:  DATA 20,20
0256E:  DATA 2D,20
02570:  DATA 69,64
02572:  DATA 65,6E
02574:  DATA 74,69
02576:  DATA 66,79
02578:  DATA 20,75
0257A:  DATA 6E,69
0257C:  DATA 74,20
0257E:  DATA 0D,0A
02580:  DATA 00,00
02582:  DATA 20,20
02584:  DATA 62,6C
02586:  DATA 65,2E
02588:  DATA 72,65
0258A:  DATA 73,65
0258C:  DATA 74,20
0258E:  DATA 20,20
02590:  DATA 2D,20
02592:  DATA 72,65
02594:  DATA 73,65
02596:  DATA 74,20
02598:  DATA 62,6C
0259A:  DATA 75,65
0259C:  DATA 74,6F
0259E:  DATA 6F,74
025A0:  DATA 68,20
025A2:  DATA 0D,0A
025A4:  DATA 00,00
025A6:  DATA 20,20
025A8:  DATA 69,6E
025AA:  DATA 74,65
025AC:  DATA 72,63
025AE:  DATA 65,70
025B0:  DATA 74,3D
025B2:  DATA 20,20
025B4:  DATA 2D,20
025B6:  DATA 73,65
025B8:  DATA 74,20
025BA:  DATA 74,68
025BC:  DATA 65,20
025BE:  DATA 69,6E
025C0:  DATA 74,65
025C2:  DATA 72,63
025C4:  DATA 65,70
025C6:  DATA 74,20
025C8:  DATA 76,61
025CA:  DATA 6C,75
025CC:  DATA 65,20
025CE:  DATA 0D,0A
025D0:  DATA 00,00
025D2:  DATA 20,20
025D4:  DATA 69,6E
025D6:  DATA 74,65
025D8:  DATA 72,63
025DA:  DATA 65,70
025DC:  DATA 74,20
025DE:  DATA 20,20
025E0:  DATA 2D,20
025E2:  DATA 67,65
025E4:  DATA 74,20
025E6:  DATA 74,68
025E8:  DATA 65,20
025EA:  DATA 69,6E
025EC:  DATA 74,65
025EE:  DATA 72,63
025F0:  DATA 65,70
025F2:  DATA 74,20
025F4:  DATA 76,61
025F6:  DATA 6C,75
025F8:  DATA 65,20
025FA:  DATA 0D,0A
025FC:  DATA 00,00
025FE:  DATA 20,20
02600:  DATA 70,6C
02602:  DATA 61,79
02604:  DATA 20,20
02606:  DATA 20,20
02608:  DATA 20,20
0260A:  DATA 20,20
0260C:  DATA 2D,20
0260E:  DATA 63,68
02610:  DATA 65,63
02612:  DATA 6B,20
02614:  DATA 74,68
02616:  DATA 65,20
02618:  DATA 73,6F
0261A:  DATA 75,6E
0261C:  DATA 64,20
0261E:  DATA 0D,0A
02620:  DATA 00,00
02622:  DATA 20,20
02624:  DATA 72,70
02626:  DATA 20,20
02628:  DATA 20,20
0262A:  DATA 20,20
0262C:  DATA 20,20
0262E:  DATA 20,20
02630:  DATA 2D,20
02632:  DATA 70,72
02634:  DATA 69,6E
02636:  DATA 74,20
02638:  DATA 61,6C
0263A:  DATA 6C,20
0263C:  DATA 73,61
0263E:  DATA 76,65
02640:  DATA 20,74
02642:  DATA 65,73
02644:  DATA 74,20
02646:  DATA 72,65
02648:  DATA 73,75
0264A:  DATA 6C,74
0264C:  DATA 73,20
0264E:  DATA 0D,0A
02650:  DATA 00,00
02652:  DATA 20,20
02654:  DATA 72,72
02656:  DATA 20,20
02658:  DATA 20,20
0265A:  DATA 20,20
0265C:  DATA 20,20
0265E:  DATA 20,20
02660:  DATA 2D,20
02662:  DATA 63,6C
02664:  DATA 65,61
02666:  DATA 72,20
02668:  DATA 61,6C
0266A:  DATA 6C,20
0266C:  DATA 73,61
0266E:  DATA 76,65
02670:  DATA 20,74
02672:  DATA 65,73
02674:  DATA 74,20
02676:  DATA 72,65
02678:  DATA 73,75
0267A:  DATA 6C,74
0267C:  DATA 73,20
0267E:  DATA 0D,0A
02680:  DATA 00,00
02682:  DATA 20,20
02684:  DATA 72,73
02686:  DATA 20,20
02688:  DATA 20,20
0268A:  DATA 20,20
0268C:  DATA 20,20
0268E:  DATA 20,20
02690:  DATA 2D,20
02692:  DATA 61,75
02694:  DATA 74,6F
02696:  DATA 20,67
02698:  DATA 65,6E
0269A:  DATA 65,72
0269C:  DATA 61,74
0269E:  DATA 65,20
026A0:  DATA 31,30
026A2:  DATA 20,74
026A4:  DATA 65,73
026A6:  DATA 74,20
026A8:  DATA 72,65
026AA:  DATA 73,75
026AC:  DATA 6C,74
026AE:  DATA 73,20
026B0:  DATA 66,6F
026B2:  DATA 72,20
026B4:  DATA 74,65
026B6:  DATA 73,74
026B8:  DATA 69,6E
026BA:  DATA 67,20
026BC:  DATA 70,75
026BE:  DATA 72,70
026C0:  DATA 6F,73
026C2:  DATA 65,20
026C4:  DATA 20,0D
026C6:  DATA 0A,00
026C8:  DATA 20,20
026CA:  DATA 73,62
026CC:  DATA 76,20
026CE:  DATA 20,20
026D0:  DATA 20,20
026D2:  DATA 20,20
026D4:  DATA 20,20
026D6:  DATA 2D,20
026D8:  DATA 73,65
026DA:  DATA 74,20
026DC:  DATA 6E,65
026DE:  DATA 77,20
026E0:  DATA 62,72
026E2:  DATA 65,61
026E4:  DATA 74,68
026E6:  DATA 20,76
026E8:  DATA 6F,6C
026EA:  DATA 75,6D
026EC:  DATA 65,20
026EE:  DATA 0D,0A
026F0:  DATA 00,00
026F2:  DATA 20,20
026F4:  DATA 73,65
026F6:  DATA 6C,66
026F8:  DATA 74,65
026FA:  DATA 73,74
026FC:  DATA 20,20
026FE:  DATA 20,20
02700:  DATA 2D,20
02702:  DATA 70,65
02704:  DATA 72,66
02706:  DATA 6F,72
02708:  DATA 6D,20
0270A:  DATA 61,20
0270C:  DATA 73,65
0270E:  DATA 6C,66
02710:  DATA 20,74
02712:  DATA 65,73
02714:  DATA 74,20
02716:  DATA 0D,0A
02718:  DATA 00,00
0271A:  DATA 20,20
0271C:  DATA 73,65
0271E:  DATA 72,69
02720:  DATA 61,6C
02722:  DATA 3D,20
02724:  DATA 20,20
02726:  DATA 20,20
02728:  DATA 2D,20
0272A:  DATA 73,65
0272C:  DATA 74,20
0272E:  DATA 74,68
02730:  DATA 65,20
02732:  DATA 75,6E
02734:  DATA 69,74
02736:  DATA 20,73
02738:  DATA 65,72
0273A:  DATA 69,61
0273C:  DATA 6C,20
0273E:  DATA 6E,75
02740:  DATA 6D,62
02742:  DATA 65,72
02744:  DATA 20,0D
02746:  DATA 0A,00
02748:  DATA 20,20
0274A:  DATA 73,65
0274C:  DATA 72,69
0274E:  DATA 61,6C
02750:  DATA 20,20
02752:  DATA 20,20
02754:  DATA 20,20
02756:  DATA 2D,20
02758:  DATA 67,65
0275A:  DATA 74,20
0275C:  DATA 74,68
0275E:  DATA 65,20
02760:  DATA 75,6E
02762:  DATA 69,74
02764:  DATA 20,73
02766:  DATA 65,72
02768:  DATA 69,61
0276A:  DATA 6C,20
0276C:  DATA 6E,75
0276E:  DATA 6D,62
02770:  DATA 65,72
02772:  DATA 20,0D
02774:  DATA 0A,00
02776:  DATA 20,20
02778:  DATA 73,65
0277A:  DATA 74,6C
0277C:  DATA 65,64
0277E:  DATA 20,20
02780:  DATA 20,20
02782:  DATA 20,20
02784:  DATA 2D,20
02786:  DATA 73,65
02788:  DATA 74,20
0278A:  DATA 74,68
0278C:  DATA 65,20
0278E:  DATA 6C,65
02790:  DATA 64,20
02792:  DATA 62,72
02794:  DATA 69,67
02796:  DATA 68,74
02798:  DATA 6E,65
0279A:  DATA 73,73
0279C:  DATA 20,61
0279E:  DATA 75,74
027A0:  DATA 6F,6D
027A2:  DATA 61,74
027A4:  DATA 69,63
027A6:  DATA 61,6C
027A8:  DATA 6C,79
027AA:  DATA 20,0D
027AC:  DATA 0A,00
027AE:  DATA 20,20
027B0:  DATA 73,6C
027B2:  DATA 6F,70
027B4:  DATA 65,3D
027B6:  DATA 20,20
027B8:  DATA 20,20
027BA:  DATA 20,20
027BC:  DATA 2D,20
027BE:  DATA 73,65
027C0:  DATA 74,20
027C2:  DATA 74,68
027C4:  DATA 65,20
027C6:  DATA 73,6C
027C8:  DATA 6F,70
027CA:  DATA 65,20
027CC:  DATA 76,61
027CE:  DATA 6C,75
027D0:  DATA 65,20
027D2:  DATA 0D,0A
027D4:  DATA 00,00
027D6:  DATA 20,20
027D8:  DATA 73,6C
027DA:  DATA 6F,70
027DC:  DATA 65,20
027DE:  DATA 20,20
027E0:  DATA 20,20
027E2:  DATA 20,20
027E4:  DATA 2D,20
027E6:  DATA 67,65
027E8:  DATA 74,20
027EA:  DATA 74,68
027EC:  DATA 65,20
027EE:  DATA 73,6C
027F0:  DATA 6F,70
027F2:  DATA 65,20
027F4:  DATA 76,61
027F6:  DATA 6C,75
027F8:  DATA 65,20
027FA:  DATA 0D,0A
027FC:  DATA 00,00
027FE:  DATA 20,20
02800:  DATA 74,69
02802:  DATA 6D,65
02804:  DATA 3D,20
02806:  DATA 20,20
02808:  DATA 20,20
0280A:  DATA 20,20
0280C:  DATA 2D,20
0280E:  DATA 73,65
02810:  DATA 74,20
02812:  DATA 74,68
02814:  DATA 65,20
02816:  DATA 74,69
02818:  DATA 6D,65
0281A:  DATA 20,61
0281C:  DATA 6E,64
0281E:  DATA 20,64
02820:  DATA 61,74
02822:  DATA 65,20
02824:  DATA 0D,0A
02826:  DATA 00,00
02828:  DATA 20,20
0282A:  DATA 76,6F
0282C:  DATA 6C,74
0282E:  DATA 65,73
02830:  DATA 74,20
02832:  DATA 20,20
02834:  DATA 20,20
02836:  DATA 2D,20
02838:  DATA 63,6F
0283A:  DATA 6D,70
0283C:  DATA 75,74
0283E:  DATA 65,20
02840:  DATA 62,72
02842:  DATA 65,61
02844:  DATA 74,68
02846:  DATA 20,76
02848:  DATA 6F,6C
0284A:  DATA 75,6D
0284C:  DATA 65,20
0284E:  DATA 0D,0A
02850:  DATA 00,00
02852:  DATA 56,6F
02854:  DATA 79,61
02856:  DATA 67,65
02858:  DATA 72,20
0285A:  DATA 34,2E
0285C:  DATA 30,20
0285E:  DATA 50,72
02860:  DATA 6F,74
02862:  DATA 6F,74
02864:  DATA 79,70
02866:  DATA 65,2C
02868:  DATA 52,25
0286A:  DATA 64,2E
0286C:  DATA 25,64
0286E:  DATA 2E,25
02870:  DATA 64,2C
02872:  DATA 00,00
02874:  DATA 42,4C
02876:  DATA 45,20
02878:  DATA 52,65
0287A:  DATA 2D,41
0287C:  DATA 63,74
0287E:  DATA 69,76
02880:  DATA 61,74
02882:  DATA 65,64
02884:  DATA 0D,0A
02886:  DATA 00,00
02888:  DATA 0D,0A
0288A:  DATA 52,65
0288C:  DATA 73,65
0288E:  DATA 74,20
02890:  DATA 62,72
02892:  DATA 65,61
02894:  DATA 74,68
02896:  DATA 20,76
02898:  DATA 6F,6C
0289A:  DATA 75,6D
0289C:  DATA 65,20
0289E:  DATA 6E,65
028A0:  DATA 77,20
028A2:  DATA 76,61
028A4:  DATA 6C,75
028A6:  DATA 65,20
028A8:  DATA 3A,20
028AA:  DATA 25,6C
028AC:  DATA 64,20
028AE:  DATA 0D,0A
028B0:  DATA 00,00
028B2:  DATA 0D,0A
028B4:  DATA 42,72
028B6:  DATA 65,61
028B8:  DATA 74,68
028BA:  DATA 20,76
028BC:  DATA 6F,6C
028BE:  DATA 75,6D
028C0:  DATA 65,20
028C2:  DATA 73,65
028C4:  DATA 74,74
028C6:  DATA 69,6E
028C8:  DATA 67,73
028CA:  DATA 3A,20
028CC:  DATA 25,6C
028CE:  DATA 64,20
028D0:  DATA 0D,0A
028D2:  DATA 00,00
028D4:  DATA 0D,0A
028D6:  DATA 53,65
028D8:  DATA 72,69
028DA:  DATA 61,6C
028DC:  DATA 20,25
028DE:  DATA 75,20
028E0:  DATA 6F,66
028E2:  DATA 20,36
028E4:  DATA 3A,20
028E6:  DATA 00,00
028E8:  DATA 53,65
028EA:  DATA 72,69
028EC:  DATA 61,6C
028EE:  DATA 3A,20
028F0:  DATA 00,00
028F2:  DATA 49,6E
028F4:  DATA 74,65
028F6:  DATA 72,63
028F8:  DATA 65,70
028FA:  DATA 74,3A
028FC:  DATA 20,25
028FE:  DATA 2E,33
02900:  DATA 66,0D
02902:  DATA 0A,00
02904:  DATA 53,6C
02906:  DATA 6F,70
02908:  DATA 65,3A
0290A:  DATA 20,25
0290C:  DATA 2E,33
0290E:  DATA 66,0D
02910:  DATA 0A,00
02912:  DATA 44,79
02914:  DATA 61,6E
02916:  DATA 61,6D
02918:  DATA 69,63
0291A:  DATA 20,57
0291C:  DATA 68,69
0291E:  DATA 74,65
02920:  DATA 20,42
02922:  DATA 61,6C
02924:  DATA 61,6E
02926:  DATA 63,65
02928:  DATA 20,45
0292A:  DATA 6E,61
0292C:  DATA 62,6C
0292E:  DATA 65,64
02930:  DATA 3A,20
02932:  DATA 25,64
02934:  DATA 0D,0A
02936:  DATA 00,00
02938:  DATA 52,65
0293A:  DATA 73,65
0293C:  DATA 74,69
0293E:  DATA 6E,67
02940:  DATA 20,72
02942:  DATA 65,61
02944:  DATA 64,69
02946:  DATA 6E,67
02948:  DATA 73,0D
0294A:  DATA 0A,00
0294C:  DATA 4A,69
0294E:  DATA 6E,67
02950:  DATA 6C,65
02952:  DATA 20,62
02954:  DATA 65,6C
02956:  DATA 6C,73
02958:  DATA 0D,0A
0295A:  DATA 00,00
0295C:  DATA 4C,45
0295E:  DATA 44,20
02960:  DATA 34,37
02962:  DATA 35,20
02964:  DATA 6F,6E
02966:  DATA 0D,0A
02968:  DATA 00,00
0296A:  DATA 4C,45
0296C:  DATA 44,20
0296E:  DATA 35,38
02970:  DATA 38,20
02972:  DATA 6F,6E
02974:  DATA 0D,0A
02976:  DATA 00,00
02978:  DATA 4C,45
0297A:  DATA 44,20
0297C:  DATA 37,33
0297E:  DATA 30,20
02980:  DATA 6F,6E
02982:  DATA 0D,0A
02984:  DATA 00,00
02986:  DATA 4C,45
02988:  DATA 44,20
0298A:  DATA 6F,66
0298C:  DATA 66,0D
0298E:  DATA 0A,00
02990:  DATA 52,65
02992:  DATA 61,64
02994:  DATA 69,6E
02996:  DATA 67,3A
02998:  DATA 20,25
0299A:  DATA 6C,75
0299C:  DATA 0D,0A
0299E:  DATA 00,00
029A0:  DATA 52,65
029A2:  DATA 61,64
029A4:  DATA 69,6E
029A6:  DATA 67,20
029A8:  DATA 28,31
029AA:  DATA 30,2D
029AC:  DATA 61,76
029AE:  DATA 67,29
029B0:  DATA 3A,20
029B2:  DATA 25,2E
029B4:  DATA 34,66
029B6:  DATA 0D,0A
029B8:  DATA 00,00
029BA:  DATA 45,78
029BC:  DATA 65,63
029BE:  DATA 75,74
029C0:  DATA 69,6E
029C2:  DATA 67,20
029C4:  DATA 63,61
029C6:  DATA 6C,69
029C8:  DATA 62,72
029CA:  DATA 61,74
029CC:  DATA 69,6F
029CE:  DATA 6E,2E
029D0:  DATA 2E,2E
029D2:  DATA 0D,0A
029D4:  DATA 00,00
029D6:  DATA 2A,2A
029D8:  DATA 2A,2A
029DA:  DATA 2A,2A
029DC:  DATA 20,20
029DE:  DATA 4B,65
029E0:  DATA 74,6F
029E2:  DATA 6E,65
029E4:  DATA 20,44
029E6:  DATA 65,74
029E8:  DATA 65,63
029EA:  DATA 74,69
029EC:  DATA 6F,6E
029EE:  DATA 20,54
029F0:  DATA 65,73
029F2:  DATA 74,20
029F4:  DATA 66,61
029F6:  DATA 69,6C
029F8:  DATA 65,64
029FA:  DATA 20,20
029FC:  DATA 2A,2A
029FE:  DATA 2A,2A
02A00:  DATA 2A,2A
02A02:  DATA 0D,0A
02A04:  DATA 00,00
02A06:  DATA 44,75
02A08:  DATA 72,61
02A0A:  DATA 74,69
02A0C:  DATA 6F,6E
02A0E:  DATA 3A,20
02A10:  DATA 00,00
02A12:  DATA 0D,0A
02A14:  DATA 62,72
02A16:  DATA 69,67
02A18:  DATA 68,74
02A1A:  DATA 37,33
02A1C:  DATA 30,3A
02A1E:  DATA 20,00
02A20:  DATA 0D,0A
02A22:  DATA 62,72
02A24:  DATA 69,67
02A26:  DATA 68,74
02A28:  DATA 35,38
02A2A:  DATA 38,3A
02A2C:  DATA 20,00
02A2E:  DATA 0D,0A
02A30:  DATA 62,72
02A32:  DATA 69,67
02A34:  DATA 68,74
02A36:  DATA 34,37
02A38:  DATA 35,3A
02A3A:  DATA 20,00
02A3C:  DATA 0D,0A
02A3E:  DATA 69,6E
02A40:  DATA 64,65
02A42:  DATA 78,2C
02A44:  DATA 20,4C
02A46:  DATA 45,44
02A48:  DATA 37,33
02A4A:  DATA 30,2C
02A4C:  DATA 20,4C
02A4E:  DATA 45,44
02A50:  DATA 35,38
02A52:  DATA 38,2C
02A54:  DATA 20,4C
02A56:  DATA 45,44
02A58:  DATA 34,37
02A5A:  DATA 35,0D
02A5C:  DATA 0A,00
02A5E:  DATA 0D,0A
02A60:  DATA 53,65
02A62:  DATA 74,20
02A64:  DATA 4C,45
02A66:  DATA 44,20
02A68:  DATA 62,72
02A6A:  DATA 69,67
02A6C:  DATA 68,74
02A6E:  DATA 6E,65
02A70:  DATA 73,73
02A72:  DATA 20,69
02A74:  DATA 6E,64
02A76:  DATA 65,78
02A78:  DATA 0D,0A
02A7A:  DATA 00,00
02A7C:  DATA 2A,2A
02A7E:  DATA 2A,2A
02A80:  DATA 2A,2A
02A82:  DATA 2A,2A
02A84:  DATA 2A,2A
02A86:  DATA 2A,2A
02A88:  DATA 2A,2A
02A8A:  DATA 2A,2A
02A8C:  DATA 2A,2A
02A8E:  DATA 2A,2A
02A90:  DATA 2A,2A
02A92:  DATA 2A,2A
02A94:  DATA 2A,2A
02A96:  DATA 2A,2A
02A98:  DATA 0D,0A
02A9A:  DATA 00,00
02A9C:  DATA 2A,2A
02A9E:  DATA 2A,2A
02AA0:  DATA 2A,20
02AA2:  DATA 41,75
02AA4:  DATA 74,6F
02AA6:  DATA 20,62
02AA8:  DATA 72,69
02AAA:  DATA 67,68
02AAC:  DATA 74,6E
02AAE:  DATA 65,73
02AB0:  DATA 73,20
02AB2:  DATA 73,65
02AB4:  DATA 74,74
02AB6:  DATA 69,6E
02AB8:  DATA 67,20
02ABA:  DATA 66,6F
02ABC:  DATA 72,20
02ABE:  DATA 4C,45
02AC0:  DATA 44,37
02AC2:  DATA 33,30
02AC4:  DATA 2C,20
02AC6:  DATA 4C,45
02AC8:  DATA 44,35
02ACA:  DATA 38,38
02ACC:  DATA 2C,20
02ACE:  DATA 4C,45
02AD0:  DATA 44,34
02AD2:  DATA 37,35
02AD4:  DATA 20,66
02AD6:  DATA 61,69
02AD8:  DATA 6C,65
02ADA:  DATA 64,20
02ADC:  DATA 2A,2A
02ADE:  DATA 2A,2A
02AE0:  DATA 2A,0D
02AE2:  DATA 0A,00
*
02AEC:  MOVLW  20
02AEE:  MOVLB  8
02AF0:  BTFSS  x13.4
02AF2:  MOVLW  30
02AF4:  MOVWF  x14
02AF6:  MOVFF  812,00
02AFA:  BTFSS  00.7
02AFC:  BRA    2B0E
02AFE:  COMF   00,F
02B00:  INCF   00,F
02B02:  MOVFF  00,812
02B06:  MOVLW  2D
02B08:  MOVWF  x14
02B0A:  BSF    x13.7
02B0C:  BSF    x13.0
02B0E:  MOVF   01,W
02B10:  CLRF   19
02B12:  BTFSC  FF2.7
02B14:  BSF    19.7
02B16:  BCF    FF2.7
02B18:  MOVFF  812,96C
02B1C:  MOVLW  64
02B1E:  MOVLB  9
02B20:  MOVWF  x6D
02B22:  MOVLB  0
02B24:  CALL   08F2
02B28:  BTFSC  19.7
02B2A:  BSF    FF2.7
02B2C:  MOVFF  00,812
02B30:  MOVLW  30
02B32:  ADDWF  01,W
02B34:  MOVLB  8
02B36:  MOVWF  x15
02B38:  CLRF   19
02B3A:  BTFSC  FF2.7
02B3C:  BSF    19.7
02B3E:  BCF    FF2.7
02B40:  MOVFF  812,96C
02B44:  MOVLW  0A
02B46:  MOVLB  9
02B48:  MOVWF  x6D
02B4A:  MOVLB  0
02B4C:  CALL   08F2
02B50:  BTFSC  19.7
02B52:  BSF    FF2.7
02B54:  MOVLW  30
02B56:  ADDWF  00,W
02B58:  MOVLB  8
02B5A:  MOVWF  x17
02B5C:  MOVLW  30
02B5E:  ADDWF  01,W
02B60:  MOVWF  x16
02B62:  MOVFF  814,00
02B66:  MOVLW  30
02B68:  SUBWF  x15,W
02B6A:  BZ    2B74
02B6C:  BSF    x13.1
02B6E:  BTFSC  x13.7
02B70:  BSF    x13.2
02B72:  BRA    2B98
02B74:  MOVFF  814,815
02B78:  MOVLW  20
02B7A:  MOVWF  x14
02B7C:  MOVLW  30
02B7E:  SUBWF  x16,W
02B80:  BZ    2B8A
02B82:  BSF    x13.0
02B84:  BTFSC  x13.7
02B86:  BSF    x13.1
02B88:  BRA    2B98
02B8A:  BTFSS  FD8.2
02B8C:  BSF    x13.0
02B8E:  BNZ   2B98
02B90:  MOVFF  815,816
02B94:  MOVLW  20
02B96:  MOVWF  x15
02B98:  BTFSC  x13.2
02B9A:  BRA    2BA6
02B9C:  BTFSC  x13.1
02B9E:  BRA    2BAE
02BA0:  BTFSC  x13.0
02BA2:  BRA    2BB6
02BA4:  BRA    2BBE
02BA6:  MOVF   x14,W
02BA8:  BTFSS  FA4.4
02BAA:  BRA    2BA8
02BAC:  MOVWF  F73
02BAE:  MOVF   x15,W
02BB0:  BTFSS  FA4.4
02BB2:  BRA    2BB0
02BB4:  MOVWF  F73
02BB6:  MOVF   x16,W
02BB8:  BTFSS  FA4.4
02BBA:  BRA    2BB8
02BBC:  MOVWF  F73
02BBE:  MOVF   x17,W
02BC0:  BTFSS  FA4.4
02BC2:  BRA    2BC0
02BC4:  MOVWF  F73
02BC6:  MOVLB  0
02BC8:  RETURN 0
*
02CA0:  TBLRD*+
02CA2:  MOVF   FF5,F
02CA4:  BZ    2CC0
02CA6:  MOVFF  FF6,812
02CAA:  MOVFF  FF7,813
02CAE:  MOVF   FF5,W
02CB0:  BTFSS  FA4.4
02CB2:  BRA    2CB0
02CB4:  MOVWF  F73
02CB6:  MOVFF  812,FF6
02CBA:  MOVFF  813,FF7
02CBE:  BRA    2CA0
02CC0:  RETURN 0
02CC2:  MOVLB  7
02CC4:  BTFSC  x4C.7
02CC6:  BRA    2CE8
02CC8:  MOVLW  0F
02CCA:  MOVWF  00
02CCC:  SWAPF  x4B,W
02CCE:  ANDWF  00,F
02CD0:  MOVLW  0A
02CD2:  SUBWF  00,W
02CD4:  BC    2CDC
02CD6:  MOVLW  30
02CD8:  ADDWF  00,F
02CDA:  BRA    2CE0
02CDC:  MOVF   x4C,W
02CDE:  ADDWF  00,F
02CE0:  MOVF   00,W
02CE2:  BTFSS  FA4.4
02CE4:  BRA    2CE2
02CE6:  MOVWF  F73
02CE8:  MOVLW  0F
02CEA:  ANDWF  x4B,F
02CEC:  MOVLW  0A
02CEE:  SUBWF  x4B,W
02CF0:  BC    2CF6
02CF2:  MOVLW  30
02CF4:  BRA    2CFA
02CF6:  BCF    x4C.7
02CF8:  MOVF   x4C,W
02CFA:  ADDWF  x4B,F
02CFC:  MOVF   x4B,W
02CFE:  BTFSS  FA4.4
02D00:  BRA    2CFE
02D02:  MOVWF  F73
02D04:  MOVLB  0
02D06:  RETURN 0
02D08:  MOVF   FEF,F
02D0A:  BZ    2D2C
02D0C:  MOVFF  FEA,753
02D10:  MOVFF  FE9,752
02D14:  MOVF   FEF,W
02D16:  BTFSS  FA4.4
02D18:  BRA    2D16
02D1A:  MOVWF  F73
02D1C:  MOVFF  753,FEA
02D20:  MOVFF  752,FE9
02D24:  INCF   FE9,F
02D26:  BTFSC  FD8.2
02D28:  INCF   FEA,F
02D2A:  BRA    2D08
02D2C:  RETURN 0
*
034A0:  MOVLB  7
034A2:  MOVF   x5B,W
034A4:  XORWF  x5C,W
034A6:  ANDLW  80
034A8:  MOVWF  x5E
034AA:  BTFSS  x5B.7
034AC:  BRA    34B2
034AE:  COMF   x5B,F
034B0:  INCF   x5B,F
034B2:  BTFSS  x5C.7
034B4:  BRA    34BA
034B6:  COMF   x5C,F
034B8:  INCF   x5C,F
034BA:  MOVF   x5C,W
034BC:  CLRF   01
034BE:  SUBWF  x5B,W
034C0:  BC    34C8
034C2:  MOVFF  75B,00
034C6:  BRA    34E0
034C8:  CLRF   00
034CA:  MOVLW  08
034CC:  MOVWF  x5D
034CE:  RLCF   x5B,F
034D0:  RLCF   00,F
034D2:  MOVF   x5C,W
034D4:  SUBWF  00,W
034D6:  BTFSC  FD8.0
034D8:  MOVWF  00
034DA:  RLCF   01,F
034DC:  DECFSZ x5D,F
034DE:  BRA    34CE
034E0:  BTFSS  x5E.7
034E2:  BRA    34E8
034E4:  COMF   01,F
034E6:  INCF   01,F
034E8:  MOVLB  0
034EA:  GOTO   38F6 (RETURN)
*
039DC:  MOVF   01,W
039DE:  CLRF   19
039E0:  BTFSC  FF2.7
039E2:  BSF    19.7
039E4:  BCF    FF2.7
039E6:  MOVFF  813,96C
039EA:  MOVLW  64
039EC:  MOVLB  9
039EE:  MOVWF  x6D
039F0:  MOVLB  0
039F2:  CALL   08F2
039F6:  BTFSC  19.7
039F8:  BSF    FF2.7
039FA:  MOVFF  00,813
039FE:  MOVF   01,W
03A00:  MOVLW  30
03A02:  BNZ   3A14
03A04:  MOVLB  8
03A06:  BTFSS  x14.1
03A08:  BRA    3A26
03A0A:  BTFSC  x14.3
03A0C:  BRA    3A26
03A0E:  BTFSC  x14.4
03A10:  MOVLW  20
03A12:  BRA    3A1C
03A14:  MOVLB  8
03A16:  BCF    x14.3
03A18:  BCF    x14.4
03A1A:  BSF    x14.0
03A1C:  ADDWF  01,F
03A1E:  MOVF   01,W
03A20:  BTFSS  FA4.4
03A22:  BRA    3A20
03A24:  MOVWF  F73
03A26:  CLRF   19
03A28:  BTFSC  FF2.7
03A2A:  BSF    19.7
03A2C:  BCF    FF2.7
03A2E:  MOVFF  813,96C
03A32:  MOVLW  0A
03A34:  MOVLB  9
03A36:  MOVWF  x6D
03A38:  MOVLB  0
03A3A:  CALL   08F2
03A3E:  BTFSC  19.7
03A40:  BSF    FF2.7
03A42:  MOVFF  00,813
03A46:  MOVF   01,W
03A48:  MOVLW  30
03A4A:  BNZ   3A5C
03A4C:  MOVLB  8
03A4E:  BTFSC  x14.3
03A50:  BRA    3A68
03A52:  BTFSS  x14.0
03A54:  BRA    3A68
03A56:  BTFSC  x14.4
03A58:  MOVLW  20
03A5A:  MOVLB  0
03A5C:  ADDWF  01,F
03A5E:  MOVF   01,W
03A60:  BTFSS  FA4.4
03A62:  BRA    3A60
03A64:  MOVWF  F73
03A66:  MOVLB  8
03A68:  MOVLW  30
03A6A:  ADDWF  x13,F
03A6C:  MOVF   x13,W
03A6E:  BTFSS  FA4.4
03A70:  BRA    3A6E
03A72:  MOVWF  F73
03A74:  MOVLB  0
03A76:  RETURN 0
*
03B6C:  MOVLW  8E
03B6E:  MOVWF  00
03B70:  MOVLB  8
03B72:  MOVF   x12,W
03B74:  SUBWF  00,F
03B76:  MOVFF  813,02
03B7A:  MOVFF  814,01
03B7E:  BSF    02.7
03B80:  MOVF   00,F
03B82:  BZ    3B96
03B84:  BCF    FD8.0
03B86:  MOVF   02,F
03B88:  BNZ   3B8E
03B8A:  MOVF   01,F
03B8C:  BZ    3B96
03B8E:  RRCF   02,F
03B90:  RRCF   01,F
03B92:  DECFSZ 00,F
03B94:  BRA    3B84
03B96:  BTFSS  x13.7
03B98:  BRA    3BA4
03B9A:  COMF   01,F
03B9C:  COMF   02,F
03B9E:  INCF   01,F
03BA0:  BTFSC  FD8.2
03BA2:  INCF   02,F
03BA4:  MOVLB  0
03BA6:  RETURN 0
*
03C60:  MOVFF  FEA,753
03C64:  MOVFF  FE9,752
03C68:  MOVLB  7
03C6A:  BTFSS  x4C.7
03C6C:  BRA    3C7E
03C6E:  BSF    x52.7
03C70:  BTFSS  x52.4
03C72:  INCF   x52,F
03C74:  COMF   x4B,F
03C76:  COMF   x4C,F
03C78:  INCF   x4B,F
03C7A:  BTFSC  FD8.2
03C7C:  INCF   x4C,F
03C7E:  SWAPF  x4C,W
03C80:  IORLW  F0
03C82:  MOVWF  x4E
03C84:  ADDWF  x4E,F
03C86:  ADDLW  E2
03C88:  MOVWF  x4F
03C8A:  ADDLW  32
03C8C:  MOVWF  x51
03C8E:  MOVF   x4C,W
03C90:  ANDLW  0F
03C92:  ADDWF  x4F,F
03C94:  ADDWF  x4F,F
03C96:  ADDWF  x51,F
03C98:  ADDLW  E9
03C9A:  MOVWF  x50
03C9C:  ADDWF  x50,F
03C9E:  ADDWF  x50,F
03CA0:  SWAPF  x4B,W
03CA2:  ANDLW  0F
03CA4:  ADDWF  x50,F
03CA6:  ADDWF  x51,F
03CA8:  RLCF   x50,F
03CAA:  RLCF   x51,F
03CAC:  COMF   x51,F
03CAE:  RLCF   x51,F
03CB0:  MOVF   x4B,W
03CB2:  ANDLW  0F
03CB4:  ADDWF  x51,F
03CB6:  RLCF   x4E,F
03CB8:  MOVLW  07
03CBA:  MOVWF  x4D
03CBC:  MOVLW  0A
03CBE:  DECF   x50,F
03CC0:  ADDWF  x51,F
03CC2:  BNC   3CBE
03CC4:  DECF   x4F,F
03CC6:  ADDWF  x50,F
03CC8:  BNC   3CC4
03CCA:  DECF   x4E,F
03CCC:  ADDWF  x4F,F
03CCE:  BNC   3CCA
03CD0:  DECF   x4D,F
03CD2:  ADDWF  x4E,F
03CD4:  BNC   3CD0
03CD6:  MOVLW  07
03CD8:  MOVWF  FEA
03CDA:  MOVLW  4D
03CDC:  MOVWF  FE9
03CDE:  MOVLW  07
03CE0:  ANDWF  x52,W
03CE2:  BCF    x52.6
03CE4:  MOVF   FED,F
03CE6:  ANDWF  x52,W
03CE8:  BNZ   3CF8
03CEA:  BTFSC  x52.4
03CEC:  MOVF   FEE,F
03CEE:  BTFSC  x52.4
03CF0:  BRA    3CF8
03CF2:  MOVLW  20
03CF4:  MOVWF  00
03CF6:  BRA    3D3A
03CF8:  ADDWF  FE9,F
03CFA:  MOVLW  00
03CFC:  ADDWFC FEA,F
03CFE:  MOVF   FE9,W
03D00:  SUBLW  51
03D02:  BNZ   3D0C
03D04:  MOVF   FEA,W
03D06:  SUBLW  07
03D08:  BNZ   3D0C
03D0A:  BSF    x52.6
03D0C:  MOVF   FEF,W
03D0E:  MOVWF  00
03D10:  BNZ   3D22
03D12:  BTFSC  x52.6
03D14:  BRA    3D22
03D16:  BTFSC  x52.4
03D18:  BRA    3D42
03D1A:  BTFSC  x52.3
03D1C:  BRA    3D22
03D1E:  MOVLW  20
03D20:  BRA    3D38
03D22:  BTFSS  x52.7
03D24:  BRA    3D32
03D26:  MOVLW  2D
03D28:  MOVWF  00
03D2A:  MOVF   FED,W
03D2C:  BCF    x52.6
03D2E:  BCF    x52.7
03D30:  BRA    3D3A
03D32:  BSF    x52.3
03D34:  BCF    x52.4
03D36:  MOVLW  30
03D38:  ADDWF  00,F
03D3A:  MOVF   00,W
03D3C:  BTFSS  FA4.4
03D3E:  BRA    3D3C
03D40:  MOVWF  F73
03D42:  MOVF   FEE,W
03D44:  BTFSS  x52.6
03D46:  BRA    3CFE
03D48:  MOVLB  0
03D4A:  RETURN 0
*
03DEA:  MOVLB  7
03DEC:  MOVF   x51,W
03DEE:  MULWF  x53
03DF0:  MOVFF  FF3,01
03DF4:  MOVFF  FF4,00
03DF8:  MULWF  x54
03DFA:  MOVF   FF3,W
03DFC:  ADDWF  00,F
03DFE:  MOVF   x52,W
03E00:  MULWF  x53
03E02:  MOVF   FF3,W
03E04:  ADDWFC 00,W
03E06:  MOVWF  02
03E08:  MOVLB  0
03E0A:  RETURN 0
*
03EB6:  MOVFF  813,81A
03EBA:  MOVLB  8
03EBC:  MOVF   x17,W
03EBE:  XORWF  x1A,F
03EC0:  BTFSS  x1A.7
03EC2:  BRA    3ECE
03EC4:  BCF    FD8.2
03EC6:  BCF    FD8.0
03EC8:  BTFSC  x13.7
03ECA:  BSF    FD8.0
03ECC:  BRA    3F2C
03ECE:  MOVFF  813,81A
03ED2:  MOVFF  816,81B
03ED6:  MOVF   x12,W
03ED8:  SUBWF  x1B,F
03EDA:  BZ    3EE8
03EDC:  BTFSS  x1A.7
03EDE:  BRA    3F2C
03EE0:  MOVF   FD8,W
03EE2:  XORLW  01
03EE4:  MOVWF  FD8
03EE6:  BRA    3F2C
03EE8:  MOVFF  817,81B
03EEC:  MOVF   x13,W
03EEE:  SUBWF  x1B,F
03EF0:  BZ    3EFE
03EF2:  BTFSS  x1A.7
03EF4:  BRA    3F2C
03EF6:  MOVF   FD8,W
03EF8:  XORLW  01
03EFA:  MOVWF  FD8
03EFC:  BRA    3F2C
03EFE:  MOVFF  818,81B
03F02:  MOVF   x14,W
03F04:  SUBWF  x1B,F
03F06:  BZ    3F14
03F08:  BTFSS  x1A.7
03F0A:  BRA    3F2C
03F0C:  MOVF   FD8,W
03F0E:  XORLW  01
03F10:  MOVWF  FD8
03F12:  BRA    3F2C
03F14:  MOVFF  819,81B
03F18:  MOVF   x15,W
03F1A:  SUBWF  x1B,F
03F1C:  BZ    3F2A
03F1E:  BTFSS  x1A.7
03F20:  BRA    3F2C
03F22:  MOVF   FD8,W
03F24:  XORLW  01
03F26:  MOVWF  FD8
03F28:  BRA    3F2C
03F2A:  BCF    FD8.0
03F2C:  MOVLB  0
03F2E:  RETURN 0
03F30:  MOVLB  8
03F32:  MOVF   x32,W
03F34:  BTFSC  FD8.2
03F36:  BRA    401A
03F38:  MOVWF  00
03F3A:  MOVF   x36,W
03F3C:  BTFSC  FD8.2
03F3E:  BRA    401A
03F40:  ADDWF  00,F
03F42:  BNC   3F4C
03F44:  MOVLW  81
03F46:  ADDWF  00,F
03F48:  BC    401A
03F4A:  BRA    3F54
03F4C:  MOVLW  7F
03F4E:  SUBWF  00,F
03F50:  BNC   401A
03F52:  BZ    401A
03F54:  MOVFF  833,83A
03F58:  MOVF   x37,W
03F5A:  XORWF  x3A,F
03F5C:  BSF    x33.7
03F5E:  BSF    x37.7
03F60:  MOVF   x35,W
03F62:  MULWF  x39
03F64:  MOVFF  FF4,83C
03F68:  MOVF   x34,W
03F6A:  MULWF  x38
03F6C:  MOVFF  FF4,03
03F70:  MOVFF  FF3,83B
03F74:  MULWF  x39
03F76:  MOVF   FF3,W
03F78:  ADDWF  x3C,F
03F7A:  MOVF   FF4,W
03F7C:  ADDWFC x3B,F
03F7E:  MOVLW  00
03F80:  ADDWFC 03,F
03F82:  MOVF   x35,W
03F84:  MULWF  x38
03F86:  MOVF   FF3,W
03F88:  ADDWF  x3C,F
03F8A:  MOVF   FF4,W
03F8C:  ADDWFC x3B,F
03F8E:  MOVLW  00
03F90:  CLRF   02
03F92:  ADDWFC 03,F
03F94:  ADDWFC 02,F
03F96:  MOVF   x33,W
03F98:  MULWF  x39
03F9A:  MOVF   FF3,W
03F9C:  ADDWF  x3B,F
03F9E:  MOVF   FF4,W
03FA0:  ADDWFC 03,F
03FA2:  MOVLW  00
03FA4:  ADDWFC 02,F
03FA6:  MOVF   x33,W
03FA8:  MULWF  x38
03FAA:  MOVF   FF3,W
03FAC:  ADDWF  03,F
03FAE:  MOVF   FF4,W
03FB0:  ADDWFC 02,F
03FB2:  MOVLW  00
03FB4:  CLRF   01
03FB6:  ADDWFC 01,F
03FB8:  MOVF   x35,W
03FBA:  MULWF  x37
03FBC:  MOVF   FF3,W
03FBE:  ADDWF  x3B,F
03FC0:  MOVF   FF4,W
03FC2:  ADDWFC 03,F
03FC4:  MOVLW  00
03FC6:  ADDWFC 02,F
03FC8:  ADDWFC 01,F
03FCA:  MOVF   x34,W
03FCC:  MULWF  x37
03FCE:  MOVF   FF3,W
03FD0:  ADDWF  03,F
03FD2:  MOVF   FF4,W
03FD4:  ADDWFC 02,F
03FD6:  MOVLW  00
03FD8:  ADDWFC 01,F
03FDA:  MOVF   x33,W
03FDC:  MULWF  x37
03FDE:  MOVF   FF3,W
03FE0:  ADDWF  02,F
03FE2:  MOVF   FF4,W
03FE4:  ADDWFC 01,F
03FE6:  INCF   00,F
03FE8:  BTFSC  01.7
03FEA:  BRA    3FF6
03FEC:  RLCF   x3B,F
03FEE:  RLCF   03,F
03FF0:  RLCF   02,F
03FF2:  RLCF   01,F
03FF4:  DECF   00,F
03FF6:  MOVLW  00
03FF8:  BTFSS  x3B.7
03FFA:  BRA    4010
03FFC:  INCF   03,F
03FFE:  ADDWFC 02,F
04000:  ADDWFC 01,F
04002:  MOVF   01,W
04004:  BNZ   4010
04006:  MOVF   02,W
04008:  BNZ   4010
0400A:  MOVF   03,W
0400C:  BNZ   4010
0400E:  INCF   00,F
04010:  BTFSC  x3A.7
04012:  BSF    01.7
04014:  BTFSS  x3A.7
04016:  BCF    01.7
04018:  BRA    4022
0401A:  CLRF   00
0401C:  CLRF   01
0401E:  CLRF   02
04020:  CLRF   03
04022:  MOVLB  0
04024:  RETURN 0
04026:  MOVLB  8
04028:  MOVF   x1F,W
0402A:  SUBLW  B6
0402C:  MOVWF  x1F
0402E:  CLRF   03
04030:  MOVFF  820,823
04034:  BSF    x20.7
04036:  BCF    FD8.0
04038:  RRCF   x20,F
0403A:  RRCF   x21,F
0403C:  RRCF   x22,F
0403E:  RRCF   03,F
04040:  RRCF   02,F
04042:  RRCF   01,F
04044:  RRCF   00,F
04046:  DECFSZ x1F,F
04048:  BRA    4036
0404A:  BTFSS  x23.7
0404C:  BRA    4064
0404E:  COMF   00,F
04050:  COMF   01,F
04052:  COMF   02,F
04054:  COMF   03,F
04056:  INCF   00,F
04058:  BTFSC  FD8.2
0405A:  INCF   01,F
0405C:  BTFSC  FD8.2
0405E:  INCF   02,F
04060:  BTFSC  FD8.2
04062:  INCF   03,F
04064:  MOVLB  0
04066:  GOTO   4154 (RETURN)
0406A:  BTFSC  FD8.1
0406C:  BRA    4076
0406E:  MOVLW  08
04070:  MOVWF  FEA
04072:  MOVLW  27
04074:  MOVWF  FE9
04076:  CLRF   00
04078:  CLRF   01
0407A:  CLRF   02
0407C:  CLRF   03
0407E:  MOVLB  8
04080:  CLRF   x27
04082:  CLRF   x28
04084:  CLRF   x29
04086:  CLRF   x2A
04088:  MOVF   x26,W
0408A:  IORWF  x25,W
0408C:  IORWF  x24,W
0408E:  IORWF  x23,W
04090:  BZ    40EA
04092:  MOVLW  20
04094:  MOVWF  x2B
04096:  BCF    FD8.0
04098:  RLCF   x1F,F
0409A:  RLCF   x20,F
0409C:  RLCF   x21,F
0409E:  RLCF   x22,F
040A0:  RLCF   x27,F
040A2:  RLCF   x28,F
040A4:  RLCF   x29,F
040A6:  RLCF   x2A,F
040A8:  MOVF   x26,W
040AA:  SUBWF  x2A,W
040AC:  BNZ   40BE
040AE:  MOVF   x25,W
040B0:  SUBWF  x29,W
040B2:  BNZ   40BE
040B4:  MOVF   x24,W
040B6:  SUBWF  x28,W
040B8:  BNZ   40BE
040BA:  MOVF   x23,W
040BC:  SUBWF  x27,W
040BE:  BNC   40DE
040C0:  MOVF   x23,W
040C2:  SUBWF  x27,F
040C4:  MOVF   x24,W
040C6:  BTFSS  FD8.0
040C8:  INCFSZ x24,W
040CA:  SUBWF  x28,F
040CC:  MOVF   x25,W
040CE:  BTFSS  FD8.0
040D0:  INCFSZ x25,W
040D2:  SUBWF  x29,F
040D4:  MOVF   x26,W
040D6:  BTFSS  FD8.0
040D8:  INCFSZ x26,W
040DA:  SUBWF  x2A,F
040DC:  BSF    FD8.0
040DE:  RLCF   00,F
040E0:  RLCF   01,F
040E2:  RLCF   02,F
040E4:  RLCF   03,F
040E6:  DECFSZ x2B,F
040E8:  BRA    4096
040EA:  MOVFF  827,FEF
040EE:  MOVFF  828,FEC
040F2:  MOVFF  829,FEC
040F6:  MOVFF  82A,FEC
040FA:  MOVLB  0
040FC:  RETURN 0
040FE:  MOVF   FE9,W
04100:  MOVLB  8
04102:  MOVWF  x17
04104:  MOVF   x16,W
04106:  MOVWF  x19
04108:  BZ    4140
0410A:  MOVFF  815,835
0410E:  MOVFF  814,834
04112:  MOVFF  813,833
04116:  MOVFF  812,832
0411A:  CLRF   x39
0411C:  CLRF   x38
0411E:  MOVLW  20
04120:  MOVWF  x37
04122:  MOVLW  82
04124:  MOVWF  x36
04126:  MOVLB  0
04128:  RCALL  3F30
0412A:  MOVFF  03,815
0412E:  MOVFF  02,814
04132:  MOVFF  01,813
04136:  MOVFF  00,812
0413A:  MOVLB  8
0413C:  DECFSZ x19,F
0413E:  BRA    410A
04140:  MOVFF  815,822
04144:  MOVFF  814,821
04148:  MOVFF  813,820
0414C:  MOVFF  812,81F
04150:  MOVLB  0
04152:  BRA    4026
04154:  MOVFF  03,815
04158:  MOVFF  02,814
0415C:  MOVFF  01,813
04160:  MOVFF  00,812
04164:  MOVLB  8
04166:  BTFSS  x15.7
04168:  BRA    4184
0416A:  DECF   x17,F
0416C:  BSF    x17.5
0416E:  COMF   x12,F
04170:  COMF   x13,F
04172:  COMF   x14,F
04174:  COMF   x15,F
04176:  INCF   x12,F
04178:  BTFSC  FD8.2
0417A:  INCF   x13,F
0417C:  BTFSC  FD8.2
0417E:  INCF   x14,F
04180:  BTFSC  FD8.2
04182:  INCF   x15,F
04184:  MOVLW  3B
04186:  MOVWF  x1E
04188:  MOVLW  9A
0418A:  MOVWF  x1D
0418C:  MOVLW  CA
0418E:  MOVWF  x1C
04190:  CLRF   x1B
04192:  MOVLW  0A
04194:  MOVWF  x19
04196:  MOVF   x16,W
04198:  BTFSC  FD8.2
0419A:  INCF   x17,F
0419C:  BSF    FD8.1
0419E:  MOVLW  08
041A0:  MOVWF  FEA
041A2:  MOVLW  12
041A4:  MOVWF  FE9
041A6:  MOVFF  815,822
041AA:  MOVFF  814,821
041AE:  MOVFF  813,820
041B2:  MOVFF  812,81F
041B6:  MOVFF  81E,826
041BA:  MOVFF  81D,825
041BE:  MOVFF  81C,824
041C2:  MOVFF  81B,823
041C6:  MOVLB  0
041C8:  RCALL  406A
041CA:  MOVF   01,W
041CC:  MOVF   00,F
041CE:  BNZ   41F6
041D0:  MOVLB  8
041D2:  INCF   x16,W
041D4:  SUBWF  x19,W
041D6:  BTFSS  FD8.2
041D8:  BRA    41DE
041DA:  MOVLB  0
041DC:  BRA    41F6
041DE:  MOVF   x17,W
041E0:  BZ    41FC
041E2:  ANDLW  0F
041E4:  SUBWF  x19,W
041E6:  BZ    41EA
041E8:  BC    4262
041EA:  BTFSC  x17.7
041EC:  BRA    4262
041EE:  BTFSC  x17.6
041F0:  BRA    41FC
041F2:  MOVLW  20
041F4:  BRA    4258
041F6:  MOVLW  20
041F8:  MOVLB  8
041FA:  ANDWF  x17,F
041FC:  BTFSS  x17.5
041FE:  BRA    421A
04200:  BCF    x17.5
04202:  MOVF   x16,W
04204:  BTFSS  FD8.2
04206:  DECF   x17,F
04208:  MOVF   00,W
0420A:  MOVWF  x17
0420C:  MOVLW  2D
0420E:  BTFSS  FA4.4
04210:  BRA    420E
04212:  MOVWF  F73
04214:  MOVF   x17,W
04216:  MOVWF  00
04218:  CLRF   x17
0421A:  MOVF   x16,W
0421C:  SUBWF  x19,W
0421E:  BNZ   4236
04220:  MOVF   00,W
04222:  MOVWF  x17
04224:  MOVLW  2E
04226:  BTFSS  FA4.4
04228:  BRA    4226
0422A:  MOVWF  F73
0422C:  MOVF   x17,W
0422E:  MOVWF  00
04230:  MOVLW  20
04232:  ANDWF  x17,F
04234:  MOVLW  00
04236:  MOVLW  30
04238:  BTFSS  x17.5
0423A:  BRA    4258
0423C:  BCF    x17.5
0423E:  MOVF   x16,W
04240:  BTFSS  FD8.2
04242:  DECF   x17,F
04244:  MOVF   00,W
04246:  MOVWF  x17
04248:  MOVLW  2D
0424A:  BTFSS  FA4.4
0424C:  BRA    424A
0424E:  MOVWF  F73
04250:  MOVF   x17,W
04252:  MOVWF  00
04254:  CLRF   x17
04256:  MOVLW  30
04258:  ADDWF  00,F
0425A:  MOVF   00,W
0425C:  BTFSS  FA4.4
0425E:  BRA    425C
04260:  MOVWF  F73
04262:  BCF    FD8.1
04264:  MOVFF  81E,822
04268:  MOVFF  81D,821
0426C:  MOVFF  81C,820
04270:  MOVFF  81B,81F
04274:  CLRF   x26
04276:  CLRF   x25
04278:  CLRF   x24
0427A:  MOVLW  0A
0427C:  MOVWF  x23
0427E:  MOVLB  0
04280:  RCALL  406A
04282:  MOVFF  03,81E
04286:  MOVFF  02,81D
0428A:  MOVFF  01,81C
0428E:  MOVFF  00,81B
04292:  MOVLB  8
04294:  DECFSZ x19,F
04296:  BRA    419C
04298:  MOVLB  0
0429A:  RETURN 0
*
04352:  MOVLB  8
04354:  MOVF   x14,W
04356:  ANDLW  07
04358:  MOVWF  00
0435A:  RRCF   x14,W
0435C:  MOVWF  01
0435E:  RRCF   01,F
04360:  RRCF   01,F
04362:  MOVLW  1F
04364:  ANDWF  01,F
04366:  MOVF   01,W
04368:  ADDWF  x16,W
0436A:  MOVWF  FE9
0436C:  MOVLW  00
0436E:  ADDWFC x17,W
04370:  MOVWF  FEA
04372:  CLRF   01
04374:  INCF   01,F
04376:  INCF   00,F
04378:  BRA    437C
0437A:  RLCF   01,F
0437C:  DECFSZ 00,F
0437E:  BRA    437A
04380:  MOVF   x15,F
04382:  BZ    438A
04384:  MOVF   01,W
04386:  IORWF  FEF,F
04388:  BRA    4390
0438A:  COMF   01,F
0438C:  MOVF   01,W
0438E:  ANDWF  FEF,F
04390:  MOVLB  0
04392:  RETURN 0
*
04F1C:  CLRF   01
04F1E:  CLRF   02
04F20:  CLRF   00
04F22:  CLRF   03
04F24:  MOVLB  7
04F26:  MOVF   x53,W
04F28:  BNZ   4F2E
04F2A:  MOVF   x52,W
04F2C:  BZ    4F5E
04F2E:  MOVLW  10
04F30:  MOVWF  x54
04F32:  BCF    FD8.0
04F34:  RLCF   x50,F
04F36:  RLCF   x51,F
04F38:  RLCF   00,F
04F3A:  RLCF   03,F
04F3C:  MOVF   x53,W
04F3E:  SUBWF  03,W
04F40:  BNZ   4F46
04F42:  MOVF   x52,W
04F44:  SUBWF  00,W
04F46:  BNC   4F56
04F48:  MOVF   x52,W
04F4A:  SUBWF  00,F
04F4C:  BTFSS  FD8.0
04F4E:  DECF   03,F
04F50:  MOVF   x53,W
04F52:  SUBWF  03,F
04F54:  BSF    FD8.0
04F56:  RLCF   01,F
04F58:  RLCF   02,F
04F5A:  DECFSZ x54,F
04F5C:  BRA    4F32
04F5E:  MOVLB  0
04F60:  GOTO   4F78 (RETURN)
*
054F4:  MOVLB  7
054F6:  MOVF   x4C,W
054F8:  XORWF  x4E,W
054FA:  ANDLW  80
054FC:  MOVWF  x50
054FE:  BTFSS  x4C.7
05500:  BRA    550C
05502:  COMF   x4B,F
05504:  COMF   x4C,F
05506:  INCF   x4B,F
05508:  BTFSC  FD8.2
0550A:  INCF   x4C,F
0550C:  BTFSS  x4E.7
0550E:  BRA    551A
05510:  COMF   x4D,F
05512:  COMF   x4E,F
05514:  INCF   x4D,F
05516:  BTFSC  FD8.2
05518:  INCF   x4E,F
0551A:  CLRF   01
0551C:  CLRF   02
0551E:  CLRF   00
05520:  CLRF   03
05522:  MOVF   x4E,W
05524:  BNZ   552A
05526:  MOVF   x4D,W
05528:  BZ    555A
0552A:  MOVLW  10
0552C:  MOVWF  x4F
0552E:  BCF    FD8.0
05530:  RLCF   x4B,F
05532:  RLCF   x4C,F
05534:  RLCF   00,F
05536:  RLCF   03,F
05538:  MOVF   x4E,W
0553A:  SUBWF  03,W
0553C:  BNZ   5542
0553E:  MOVF   x4D,W
05540:  SUBWF  00,W
05542:  BNC   5552
05544:  MOVF   x4D,W
05546:  SUBWF  00,F
05548:  BTFSS  FD8.0
0554A:  DECF   03,F
0554C:  MOVF   x4E,W
0554E:  SUBWF  03,F
05550:  BSF    FD8.0
05552:  RLCF   01,F
05554:  RLCF   02,F
05556:  DECFSZ x4F,F
05558:  BRA    552E
0555A:  BTFSS  x50.7
0555C:  BRA    5568
0555E:  COMF   01,F
05560:  COMF   02,F
05562:  INCF   01,F
05564:  BTFSC  FD8.2
05566:  INCF   02,F
05568:  MOVLB  0
0556A:  RETURN 0
*
06272:  MOVLB  8
06274:  MOVF   x16,W
06276:  BTFSC  FD8.2
06278:  BRA    63C4
0627A:  MOVWF  x22
0627C:  MOVF   x1A,W
0627E:  BTFSC  FD8.2
06280:  BRA    63C4
06282:  SUBWF  x22,F
06284:  BNC   6290
06286:  MOVLW  7F
06288:  ADDWF  x22,F
0628A:  BTFSC  FD8.0
0628C:  BRA    63C4
0628E:  BRA    629C
06290:  MOVLW  81
06292:  SUBWF  x22,F
06294:  BTFSS  FD8.0
06296:  BRA    63C4
06298:  BTFSC  FD8.2
0629A:  BRA    63C4
0629C:  MOVFF  822,00
062A0:  CLRF   01
062A2:  CLRF   02
062A4:  CLRF   03
062A6:  CLRF   x21
062A8:  MOVFF  817,820
062AC:  BSF    x20.7
062AE:  MOVFF  818,81F
062B2:  MOVFF  819,81E
062B6:  MOVLW  19
062B8:  MOVWF  x22
062BA:  MOVF   x1D,W
062BC:  SUBWF  x1E,F
062BE:  BC    62DA
062C0:  MOVLW  01
062C2:  SUBWF  x1F,F
062C4:  BC    62DA
062C6:  SUBWF  x20,F
062C8:  BC    62DA
062CA:  SUBWF  x21,F
062CC:  BC    62DA
062CE:  INCF   x21,F
062D0:  INCF   x20,F
062D2:  INCF   x1F,F
062D4:  MOVF   x1D,W
062D6:  ADDWF  x1E,F
062D8:  BRA    632A
062DA:  MOVF   x1C,W
062DC:  SUBWF  x1F,F
062DE:  BC    6304
062E0:  MOVLW  01
062E2:  SUBWF  x20,F
062E4:  BC    6304
062E6:  SUBWF  x21,F
062E8:  BC    6304
062EA:  INCF   x21,F
062EC:  INCF   x20,F
062EE:  MOVF   x1C,W
062F0:  ADDWF  x1F,F
062F2:  MOVF   x1D,W
062F4:  ADDWF  x1E,F
062F6:  BNC   632A
062F8:  INCF   x1F,F
062FA:  BNZ   632A
062FC:  INCF   x20,F
062FE:  BNZ   632A
06300:  INCF   x21,F
06302:  BRA    632A
06304:  MOVF   x1B,W
06306:  IORLW  80
06308:  SUBWF  x20,F
0630A:  BC    6328
0630C:  MOVLW  01
0630E:  SUBWF  x21,F
06310:  BC    6328
06312:  INCF   x21,F
06314:  MOVF   x1B,W
06316:  IORLW  80
06318:  ADDWF  x20,F
0631A:  MOVF   x1C,W
0631C:  ADDWF  x1F,F
0631E:  BNC   62F2
06320:  INCF   x20,F
06322:  BNZ   62F2
06324:  INCF   x21,F
06326:  BRA    62F2
06328:  BSF    03.0
0632A:  DECFSZ x22,F
0632C:  BRA    6330
0632E:  BRA    6346
06330:  BCF    FD8.0
06332:  RLCF   x1E,F
06334:  RLCF   x1F,F
06336:  RLCF   x20,F
06338:  RLCF   x21,F
0633A:  BCF    FD8.0
0633C:  RLCF   03,F
0633E:  RLCF   02,F
06340:  RLCF   01,F
06342:  RLCF   x23,F
06344:  BRA    62BA
06346:  BTFSS  x23.0
06348:  BRA    6356
0634A:  BCF    FD8.0
0634C:  RRCF   01,F
0634E:  RRCF   02,F
06350:  RRCF   03,F
06352:  RRCF   x23,F
06354:  BRA    635A
06356:  DECF   00,F
06358:  BZ    63C4
0635A:  BTFSC  x23.7
0635C:  BRA    639A
0635E:  BCF    FD8.0
06360:  RLCF   x1E,F
06362:  RLCF   x1F,F
06364:  RLCF   x20,F
06366:  RLCF   x21,F
06368:  MOVF   x1D,W
0636A:  SUBWF  x1E,F
0636C:  BC    637C
0636E:  MOVLW  01
06370:  SUBWF  x1F,F
06372:  BC    637C
06374:  SUBWF  x20,F
06376:  BC    637C
06378:  SUBWF  x21,F
0637A:  BNC   63B0
0637C:  MOVF   x1C,W
0637E:  SUBWF  x1F,F
06380:  BC    638C
06382:  MOVLW  01
06384:  SUBWF  x20,F
06386:  BC    638C
06388:  SUBWF  x21,F
0638A:  BNC   63B0
0638C:  MOVF   x1B,W
0638E:  IORLW  80
06390:  SUBWF  x20,F
06392:  BC    639A
06394:  MOVLW  01
06396:  SUBWF  x21,F
06398:  BNC   63B0
0639A:  INCF   03,F
0639C:  BNZ   63B0
0639E:  INCF   02,F
063A0:  BNZ   63B0
063A2:  INCF   01,F
063A4:  BNZ   63B0
063A6:  INCF   00,F
063A8:  BZ    63C4
063AA:  RRCF   01,F
063AC:  RRCF   02,F
063AE:  RRCF   03,F
063B0:  MOVFF  817,822
063B4:  MOVF   x1B,W
063B6:  XORWF  x22,F
063B8:  BTFSS  x22.7
063BA:  BRA    63C0
063BC:  BSF    01.7
063BE:  BRA    63CC
063C0:  BCF    01.7
063C2:  BRA    63CC
063C4:  CLRF   00
063C6:  CLRF   01
063C8:  CLRF   02
063CA:  CLRF   03
063CC:  MOVLB  0
063CE:  RETURN 0
*
06832:  CLRF   00
06834:  CLRF   01
06836:  MOVLB  7
06838:  MOVF   x89,W
0683A:  BCF    FD8.0
0683C:  BTFSC  x8A.0
0683E:  ADDWF  00,F
06840:  RRCF   00,F
06842:  RRCF   01,F
06844:  BTFSC  x8A.1
06846:  ADDWF  00,F
06848:  RRCF   00,F
0684A:  RRCF   01,F
0684C:  BTFSC  x8A.2
0684E:  ADDWF  00,F
06850:  RRCF   00,F
06852:  RRCF   01,F
06854:  BTFSC  x8A.3
06856:  ADDWF  00,F
06858:  RRCF   00,F
0685A:  RRCF   01,F
0685C:  BTFSC  x8A.4
0685E:  ADDWF  00,F
06860:  RRCF   00,F
06862:  RRCF   01,F
06864:  BTFSC  x8A.5
06866:  ADDWF  00,F
06868:  RRCF   00,F
0686A:  RRCF   01,F
0686C:  BTFSC  x8A.6
0686E:  ADDWF  00,F
06870:  RRCF   00,F
06872:  RRCF   01,F
06874:  BTFSC  x8A.7
06876:  ADDWF  00,F
06878:  RRCF   00,F
0687A:  RRCF   01,F
0687C:  MOVLB  0
0687E:  RETURN 0
06880:  MOVLW  80
06882:  BTFSS  FD8.1
06884:  BRA    688A
06886:  MOVLB  8
06888:  XORWF  x37,F
0688A:  MOVLB  8
0688C:  CLRF   x3C
0688E:  CLRF   x3D
06890:  MOVFF  833,83B
06894:  MOVF   x37,W
06896:  XORWF  x3B,F
06898:  MOVF   x32,W
0689A:  BTFSC  FD8.2
0689C:  BRA    6A5C
0689E:  MOVWF  x3A
068A0:  MOVWF  00
068A2:  MOVF   x36,W
068A4:  BTFSC  FD8.2
068A6:  BRA    6A6E
068A8:  SUBWF  x3A,F
068AA:  BTFSC  FD8.2
068AC:  BRA    69B4
068AE:  BNC   692C
068B0:  MOVFF  837,840
068B4:  BSF    x40.7
068B6:  MOVFF  838,83F
068BA:  MOVFF  839,83E
068BE:  CLRF   x3D
068C0:  BCF    FD8.0
068C2:  RRCF   x40,F
068C4:  RRCF   x3F,F
068C6:  RRCF   x3E,F
068C8:  RRCF   x3D,F
068CA:  DECFSZ x3A,F
068CC:  BRA    68BE
068CE:  BTFSS  x3B.7
068D0:  BRA    68D8
068D2:  BSF    x3C.0
068D4:  BRA    6A96
068D6:  BCF    x3C.0
068D8:  BCF    x3A.0
068DA:  BSF    x3C.4
068DC:  MOVLW  08
068DE:  MOVWF  FEA
068E0:  MOVLW  35
068E2:  MOVWF  FE9
068E4:  BRA    6ABC
068E6:  BCF    x3C.4
068E8:  BTFSC  x3B.7
068EA:  BRA    6900
068EC:  BTFSS  x3A.0
068EE:  BRA    6916
068F0:  RRCF   x40,F
068F2:  RRCF   x3F,F
068F4:  RRCF   x3E,F
068F6:  RRCF   x3D,F
068F8:  INCF   00,F
068FA:  BTFSC  FD8.2
068FC:  BRA    6A8C
068FE:  BRA    6916
06900:  BTFSC  x40.7
06902:  BRA    691C
06904:  BCF    FD8.0
06906:  RLCF   x3D,F
06908:  RLCF   x3E,F
0690A:  RLCF   x3F,F
0690C:  RLCF   x40,F
0690E:  DECF   00,F
06910:  BTFSC  FD8.2
06912:  BRA    6A8C
06914:  BRA    6900
06916:  BSF    x3C.6
06918:  BRA    69F4
0691A:  BCF    x3C.6
0691C:  MOVFF  833,83B
06920:  BTFSS  x33.7
06922:  BRA    6928
06924:  BSF    x40.7
06926:  BRA    6A7E
06928:  BCF    x40.7
0692A:  BRA    6A7E
0692C:  MOVFF  836,83A
06930:  MOVFF  836,00
06934:  MOVF   x32,W
06936:  SUBWF  x3A,F
06938:  MOVFF  833,840
0693C:  BSF    x40.7
0693E:  MOVFF  834,83F
06942:  MOVFF  835,83E
06946:  CLRF   x3D
06948:  BCF    FD8.0
0694A:  RRCF   x40,F
0694C:  RRCF   x3F,F
0694E:  RRCF   x3E,F
06950:  RRCF   x3D,F
06952:  DECFSZ x3A,F
06954:  BRA    6946
06956:  BTFSS  x3B.7
06958:  BRA    6960
0695A:  BSF    x3C.1
0695C:  BRA    6A96
0695E:  BCF    x3C.1
06960:  BCF    x3A.0
06962:  BSF    x3C.5
06964:  MOVLW  08
06966:  MOVWF  FEA
06968:  MOVLW  39
0696A:  MOVWF  FE9
0696C:  BRA    6ABC
0696E:  BCF    x3C.5
06970:  BTFSC  x3B.7
06972:  BRA    6988
06974:  BTFSS  x3A.0
06976:  BRA    699E
06978:  RRCF   x40,F
0697A:  RRCF   x3F,F
0697C:  RRCF   x3E,F
0697E:  RRCF   x3D,F
06980:  INCF   00,F
06982:  BTFSC  FD8.2
06984:  BRA    6A8C
06986:  BRA    699E
06988:  BTFSC  x40.7
0698A:  BRA    69A4
0698C:  BCF    FD8.0
0698E:  RLCF   x3D,F
06990:  RLCF   x3E,F
06992:  RLCF   x3F,F
06994:  RLCF   x40,F
06996:  DECF   00,F
06998:  BTFSC  FD8.2
0699A:  BRA    6A8C
0699C:  BRA    6988
0699E:  BSF    x3C.7
069A0:  BRA    69F4
069A2:  BCF    x3C.7
069A4:  MOVFF  837,83B
069A8:  BTFSS  x37.7
069AA:  BRA    69B0
069AC:  BSF    x40.7
069AE:  BRA    6A7E
069B0:  BCF    x40.7
069B2:  BRA    6A7E
069B4:  MOVFF  837,840
069B8:  BSF    x40.7
069BA:  MOVFF  838,83F
069BE:  MOVFF  839,83E
069C2:  BTFSS  x3B.7
069C4:  BRA    69CE
069C6:  BCF    x40.7
069C8:  BSF    x3C.2
069CA:  BRA    6A96
069CC:  BCF    x3C.2
069CE:  CLRF   x3D
069D0:  BCF    x3A.0
069D2:  MOVLW  08
069D4:  MOVWF  FEA
069D6:  MOVLW  35
069D8:  MOVWF  FE9
069DA:  BRA    6ABC
069DC:  BTFSC  x3B.7
069DE:  BRA    6A18
069E0:  MOVFF  833,83B
069E4:  BTFSS  x3A.0
069E6:  BRA    69F4
069E8:  RRCF   x40,F
069EA:  RRCF   x3F,F
069EC:  RRCF   x3E,F
069EE:  RRCF   x3D,F
069F0:  INCF   00,F
069F2:  BZ    6A8C
069F4:  BTFSS  x3D.7
069F6:  BRA    6A0E
069F8:  INCF   x3E,F
069FA:  BNZ   6A0E
069FC:  INCF   x3F,F
069FE:  BNZ   6A0E
06A00:  INCF   x40,F
06A02:  BNZ   6A0E
06A04:  RRCF   x40,F
06A06:  RRCF   x3F,F
06A08:  RRCF   x3E,F
06A0A:  INCF   00,F
06A0C:  BZ    6A8C
06A0E:  BTFSC  x3C.6
06A10:  BRA    691A
06A12:  BTFSC  x3C.7
06A14:  BRA    69A2
06A16:  BRA    6A50
06A18:  MOVLW  80
06A1A:  XORWF  x40,F
06A1C:  BTFSS  x40.7
06A1E:  BRA    6A28
06A20:  BRA    6A96
06A22:  MOVFF  837,83B
06A26:  BRA    6A3C
06A28:  MOVFF  833,83B
06A2C:  MOVF   x40,F
06A2E:  BNZ   6A3C
06A30:  MOVF   x3F,F
06A32:  BNZ   6A3C
06A34:  MOVF   x3E,F
06A36:  BNZ   6A3C
06A38:  CLRF   00
06A3A:  BRA    6A7E
06A3C:  BTFSC  x40.7
06A3E:  BRA    6A50
06A40:  BCF    FD8.0
06A42:  RLCF   x3D,F
06A44:  RLCF   x3E,F
06A46:  RLCF   x3F,F
06A48:  RLCF   x40,F
06A4A:  DECFSZ 00,F
06A4C:  BRA    6A3C
06A4E:  BRA    6A8C
06A50:  BTFSS  x3B.7
06A52:  BRA    6A58
06A54:  BSF    x40.7
06A56:  BRA    6A7E
06A58:  BCF    x40.7
06A5A:  BRA    6A7E
06A5C:  MOVFF  836,00
06A60:  MOVFF  837,840
06A64:  MOVFF  838,83F
06A68:  MOVFF  839,83E
06A6C:  BRA    6A7E
06A6E:  MOVFF  832,00
06A72:  MOVFF  833,840
06A76:  MOVFF  834,83F
06A7A:  MOVFF  835,83E
06A7E:  MOVFF  840,01
06A82:  MOVFF  83F,02
06A86:  MOVFF  83E,03
06A8A:  BRA    6AF4
06A8C:  CLRF   00
06A8E:  CLRF   01
06A90:  CLRF   02
06A92:  CLRF   03
06A94:  BRA    6AF4
06A96:  CLRF   x3D
06A98:  COMF   x3E,F
06A9A:  COMF   x3F,F
06A9C:  COMF   x40,F
06A9E:  COMF   x3D,F
06AA0:  INCF   x3D,F
06AA2:  BNZ   6AAE
06AA4:  INCF   x3E,F
06AA6:  BNZ   6AAE
06AA8:  INCF   x3F,F
06AAA:  BNZ   6AAE
06AAC:  INCF   x40,F
06AAE:  BTFSC  x3C.0
06AB0:  BRA    68D6
06AB2:  BTFSC  x3C.1
06AB4:  BRA    695E
06AB6:  BTFSC  x3C.2
06AB8:  BRA    69CC
06ABA:  BRA    6A22
06ABC:  MOVF   FEF,W
06ABE:  ADDWF  x3E,F
06AC0:  BNC   6ACC
06AC2:  INCF   x3F,F
06AC4:  BNZ   6ACC
06AC6:  INCF   x40,F
06AC8:  BTFSC  FD8.2
06ACA:  BSF    x3A.0
06ACC:  MOVF   FED,F
06ACE:  MOVF   FEF,W
06AD0:  ADDWF  x3F,F
06AD2:  BNC   6ADA
06AD4:  INCF   x40,F
06AD6:  BTFSC  FD8.2
06AD8:  BSF    x3A.0
06ADA:  MOVF   FED,F
06ADC:  MOVF   FEF,W
06ADE:  BTFSC  FEF.7
06AE0:  BRA    6AE4
06AE2:  XORLW  80
06AE4:  ADDWF  x40,F
06AE6:  BTFSC  FD8.0
06AE8:  BSF    x3A.0
06AEA:  BTFSC  x3C.4
06AEC:  BRA    68E6
06AEE:  BTFSC  x3C.5
06AF0:  BRA    696E
06AF2:  BRA    69DC
06AF4:  MOVLB  0
06AF6:  RETURN 0
*
095AE:  MOVLB  8
095B0:  CLRF   x38
095B2:  CLRF   x39
095B4:  MOVLW  01
095B6:  MOVWF  x3A
095B8:  CLRF   FDA
095BA:  CLRF   FD9
095BC:  MOVLW  08
095BE:  MOVWF  x3D
095C0:  MOVLW  30
095C2:  MOVWF  x3C
095C4:  MOVLW  08
095C6:  MOVWF  FEA
095C8:  MOVLW  34
095CA:  MOVWF  FE9
095CC:  MOVFF  83D,FE2
095D0:  MOVFF  83C,FE1
095D4:  MOVFF  83A,83B
095D8:  BCF    FD8.0
095DA:  MOVF   FE5,W
095DC:  MULWF  FEE
095DE:  MOVF   FF3,W
095E0:  ADDWFC x38,F
095E2:  MOVF   FF4,W
095E4:  ADDWFC x39,F
095E6:  DECFSZ x3B,F
095E8:  BRA    95D8
095EA:  MOVFF  838,FDE
095EE:  MOVFF  839,838
095F2:  CLRF   x39
095F4:  BTFSC  FD8.0
095F6:  INCF   x39,F
095F8:  INCF   x3C,F
095FA:  BTFSC  FD8.2
095FC:  INCF   x3D,F
095FE:  INCF   x3A,F
09600:  MOVF   x3A,W
09602:  SUBLW  05
09604:  BNZ   95C4
09606:  MOVLB  0
09608:  RETURN 0
*
0994A:  MOVLW  B6
0994C:  MOVWF  00
0994E:  CLRF   03
09950:  CLRF   02
09952:  CLRF   01
09954:  MOVLB  8
09956:  MOVF   x22,W
09958:  IORWF  x23,W
0995A:  IORWF  x24,W
0995C:  IORWF  x25,W
0995E:  BNZ   9964
09960:  CLRF   00
09962:  BRA    997E
09964:  BCF    FD8.0
09966:  BTFSC  01.7
09968:  BRA    997C
0996A:  RLCF   x22,F
0996C:  RLCF   x23,F
0996E:  RLCF   x24,F
09970:  RLCF   x25,F
09972:  RLCF   03,F
09974:  RLCF   02,F
09976:  RLCF   01,F
09978:  DECFSZ 00,F
0997A:  BRA    9964
0997C:  BCF    01.7
0997E:  MOVLB  0
09980:  RETURN 0
09982:  MOVLW  B6
09984:  MOVWF  00
09986:  CLRF   03
09988:  CLRF   02
0998A:  CLRF   01
0998C:  MOVLB  8
0998E:  BCF    x32.0
09990:  BTFSS  x31.7
09992:  BRA    99AC
09994:  BSF    x32.0
09996:  COMF   x2E,F
09998:  COMF   x2F,F
0999A:  COMF   x30,F
0999C:  COMF   x31,F
0999E:  INCF   x2E,F
099A0:  BNZ   99AC
099A2:  INCF   x2F,F
099A4:  BNZ   99AC
099A6:  INCF   x30,F
099A8:  BTFSC  FD8.2
099AA:  INCF   x31,F
099AC:  MOVF   x2E,W
099AE:  IORWF  x2F,W
099B0:  IORWF  x30,W
099B2:  IORWF  x31,W
099B4:  BNZ   99BA
099B6:  CLRF   00
099B8:  BRA    99D8
099BA:  BCF    FD8.0
099BC:  BTFSC  01.7
099BE:  BRA    99D2
099C0:  RLCF   x2E,F
099C2:  RLCF   x2F,F
099C4:  RLCF   x30,F
099C6:  RLCF   x31,F
099C8:  RLCF   03,F
099CA:  RLCF   02,F
099CC:  RLCF   01,F
099CE:  DECFSZ 00,F
099D0:  BRA    99BA
099D2:  BCF    01.7
099D4:  BTFSC  x32.0
099D6:  BSF    01.7
099D8:  MOVLB  0
099DA:  RETURN 0
*
09C78:  MOVF   FE9,W
09C7A:  MOVLB  8
09C7C:  MOVWF  x16
09C7E:  MOVLW  3B
09C80:  MOVWF  x1D
09C82:  MOVLW  9A
09C84:  MOVWF  x1C
09C86:  MOVLW  CA
09C88:  MOVWF  x1B
09C8A:  CLRF   x1A
09C8C:  MOVLW  0A
09C8E:  MOVWF  x18
09C90:  BSF    FD8.1
09C92:  MOVLW  08
09C94:  MOVWF  FEA
09C96:  MOVLW  12
09C98:  MOVWF  FE9
09C9A:  MOVFF  815,822
09C9E:  MOVFF  814,821
09CA2:  MOVFF  813,820
09CA6:  MOVFF  812,81F
09CAA:  MOVFF  81D,826
09CAE:  MOVFF  81C,825
09CB2:  MOVFF  81B,824
09CB6:  MOVFF  81A,823
09CBA:  MOVLB  0
09CBC:  CALL   406A
09CC0:  MOVF   01,W
09CC2:  MOVF   00,F
09CC4:  BNZ   9CEC
09CC6:  MOVLB  8
09CC8:  MOVF   x18,W
09CCA:  XORLW  01
09CCC:  BTFSS  FD8.2
09CCE:  BRA    9CD4
09CD0:  MOVLB  0
09CD2:  BRA    9CEC
09CD4:  MOVF   x16,W
09CD6:  BZ    9CF0
09CD8:  ANDLW  0F
09CDA:  SUBWF  x18,W
09CDC:  BZ    9CE0
09CDE:  BC    9CFC
09CE0:  BTFSC  x16.7
09CE2:  BRA    9CFC
09CE4:  BTFSC  x16.6
09CE6:  BRA    9CF0
09CE8:  MOVLW  20
09CEA:  BRA    9CF2
09CEC:  MOVLB  8
09CEE:  CLRF   x16
09CF0:  MOVLW  30
09CF2:  ADDWF  00,F
09CF4:  MOVF   00,W
09CF6:  BTFSS  FA4.4
09CF8:  BRA    9CF6
09CFA:  MOVWF  F73
09CFC:  BCF    FD8.1
09CFE:  MOVFF  81D,822
09D02:  MOVFF  81C,821
09D06:  MOVFF  81B,820
09D0A:  MOVFF  81A,81F
09D0E:  CLRF   x26
09D10:  CLRF   x25
09D12:  CLRF   x24
09D14:  MOVLW  0A
09D16:  MOVWF  x23
09D18:  MOVLB  0
09D1A:  CALL   406A
09D1E:  MOVFF  03,81D
09D22:  MOVFF  02,81C
09D26:  MOVFF  01,81B
09D2A:  MOVFF  00,81A
09D2E:  MOVLB  8
09D30:  DECFSZ x18,F
09D32:  BRA    9C90
09D34:  MOVLB  0
09D36:  RETURN 0
*
0C4A4:  MOVLW  8E
0C4A6:  MOVWF  00
0C4A8:  MOVFF  731,01
0C4AC:  MOVFF  730,02
0C4B0:  CLRF   03
0C4B2:  BTFSS  01.7
0C4B4:  BRA    C4C0
0C4B6:  COMF   01,F
0C4B8:  COMF   02,F
0C4BA:  INCF   02,F
0C4BC:  BNZ   C4C0
0C4BE:  INCF   01,F
0C4C0:  MOVF   01,F
0C4C2:  BNZ   C4D6
0C4C4:  MOVFF  02,01
0C4C8:  CLRF   02
0C4CA:  MOVLW  08
0C4CC:  SUBWF  00,F
0C4CE:  MOVF   01,F
0C4D0:  BNZ   C4D6
0C4D2:  CLRF   00
0C4D4:  BRA    C4F2
0C4D6:  BCF    FD8.0
0C4D8:  BTFSC  01.7
0C4DA:  BRA    C4E4
0C4DC:  RLCF   02,F
0C4DE:  RLCF   01,F
0C4E0:  DECF   00,F
0C4E2:  BRA    C4D6
0C4E4:  MOVLB  7
0C4E6:  BTFSS  x31.7
0C4E8:  BRA    C4EE
0C4EA:  MOVLB  0
0C4EC:  BRA    C4F2
0C4EE:  BCF    01.7
0C4F0:  MOVLB  0
0C4F2:  RETURN 0
....................  
.................... //#nolist 
.................... //////// Program memory: 32768x16  Data RAM: 3896  Stack: 31 
.................... //////// I/O: 36   Analog Pins: 28 
.................... //////// Data EEPROM: 1024 
.................... //////// C Scratch area: 00   ID Location: 200000 
.................... //////// Fuses: LP,XT,HSH,HSM,ECH,ECH_IO,RC,RC_IO,INTRC_IO,INTRC,ECM,ECM_IO 
.................... //////// Fuses: ECL,ECL_IO,NOPLLEN,PLLEN,PRIMARY_SW,PRIMARY_ON,NOFCMEN,FCMEN 
.................... //////// Fuses: NOIESO,IESO,PUT,NOPUT,NOBROWNOUT,BROWNOUT_SW,BROWNOUT_NOSL 
.................... //////// Fuses: BROWNOUT,BORV29,BORV25,BORV22,BORV19,NOWDT,WDT_NOSLEEP 
.................... //////// Fuses: WDT_SW,WDT,WDT1,WDT2,WDT4,WDT8,WDT16,WDT32,WDT64,WDT128 
.................... //////// Fuses: WDT256,WDT512,WDT1024,WDT2048,WDT4096,WDT8192,WDT16384 
.................... //////// Fuses: WDT32768,CCP2B3,CCP2C1,NOPBADEN,PBADEN,CCP3E0,CCP3B5 
.................... //////// Fuses: NOHFOFST,HFOFST,TIMER3B5,TIMER3C0,CCP2C0,CCP2D2,NOMCLR,MCLR 
.................... //////// Fuses: NOSTVREN,STVREN,NOLVP,LVP,NOXINST,XINST,DEBUG,NODEBUG 
.................... //////// Fuses: PROTECT,NOPROTECT,CPB,NOCPB,CPD,NOCPD,WRT,NOWRT,WRTC,NOWRTC 
.................... //////// Fuses: WRTB,NOWRTB,WRTD,NOWRTD,EBTR,NOEBTR,EBTRB,NOEBTRB 
.................... ////////  
.................... #if (!defined(__PCH__)||defined(__ISNT_CCS__)) 
.................... #define _bif 
.................... #define int8 char 
.................... #define int16 long 
.................... #define int32 long long 
.................... #define float32 float 
.................... #define int1 char 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////////////////////// I/O 
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(), 
.................... //                         PORT_x_PULLUPS(), INPUT(), 
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(), 
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT(), 
.................... // Discrete I/O Prototypes: 
.................... _bif void set_tris_a(int8 value);   
.................... _bif void set_tris_b(int8 value);   
.................... _bif void set_tris_c(int8 value);   
.................... _bif void set_tris_d(int8 value);   
.................... _bif void set_tris_e(int8 value);   
.................... _bif int8 get_tris_a(void);   
.................... _bif int8 get_tris_b(void);   
.................... _bif int8 get_tris_c(void);   
.................... _bif int8 get_tris_d(void);   
.................... _bif int8 get_tris_e(void);   
.................... _bif void output_a(int8 value);   
.................... _bif void output_b(int8 value);   
.................... _bif void output_c(int8 value);   
.................... _bif void output_d(int8 value);   
.................... _bif void output_e(int8 value);   
.................... _bif int8 input_a(void);   
.................... _bif int8 input_b(void);   
.................... _bif int8 input_c(void);   
.................... _bif int8 input_d(void);   
.................... _bif int8 input_e(void);   
.................... _bif int8 input_change_a(void);   
.................... _bif int8 input_change_b(void);   
.................... _bif int8 input_change_c(void);   
.................... _bif int8 input_change_d(void);   
.................... _bif int8 input_change_e(void);   
.................... _bif void port_b_pullups(int8 upmask);    
.................... _bif void port_e_pullups(int1 value);    
.................... _bif int1 input(int16 pin); 
.................... _bif int1 input_state(int16 pin); 
.................... _bif void output_low(int16 pin); 
.................... _bif void output_high(int16 pin); 
.................... _bif void output_toggle(int16 pin); 
.................... _bif void output_bit(int16 pin, int1 level); 
.................... _bif void output_float(int16 pin); 
.................... _bif void output_drive(int16 pin); 
....................  
.................... // Constants used to identify pins in the above are: 
....................  
.................... #define PIN_A0  31744 
.................... #define PIN_A1  31745 
.................... #define PIN_A2  31746 
.................... #define PIN_A3  31747 
.................... #define PIN_A4  31748 
.................... #define PIN_A5  31749 
.................... #define PIN_A6  31750 
.................... #define PIN_A7  31751 
....................  
.................... #define PIN_B0  31752 
.................... #define PIN_B1  31753 
.................... #define PIN_B2  31754 
.................... #define PIN_B3  31755 
.................... #define PIN_B4  31756 
.................... #define PIN_B5  31757 
.................... #define PIN_B6  31758 
.................... #define PIN_B7  31759 
....................  
.................... #define PIN_C0  31760 
.................... #define PIN_C1  31761 
.................... #define PIN_C2  31762 
.................... #define PIN_C3  31763 
.................... #define PIN_C4  31764 
.................... #define PIN_C5  31765 
.................... #define PIN_C6  31766 
.................... #define PIN_C7  31767 
....................  
.................... #define PIN_D0  31768 
.................... #define PIN_D1  31769 
.................... #define PIN_D2  31770 
.................... #define PIN_D3  31771 
.................... #define PIN_D4  31772 
.................... #define PIN_D5  31773 
.................... #define PIN_D6  31774 
.................... #define PIN_D7  31775 
....................  
.................... #define PIN_E0  31776 
.................... #define PIN_E1  31777 
.................... #define PIN_E2  31778 
.................... #define PIN_E3  31779 
....................  
.................... ////////////////////////////////////////////////////////////////// Useful defines 
.................... #define FALSE 0 
.................... #define TRUE 1 
....................  
.................... #define BYTE int8 
.................... #define BOOLEAN int1 
....................  
.................... #define getc getch 
.................... #define fgetc getch 
.................... #define getchar getch 
.................... #define putc putchar 
.................... #define fputc putchar 
.................... #define fgets gets 
.................... #define fputs puts 
....................  
.................... ////////////////////////////////////////////////////////////////// Control 
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE() 
.................... // Prototypes: 
.................... _bif int8 restart_cause(void);   
.................... _bif void reset_cpu(void); 
.................... _bif void sleep(void); 
.................... _bif void sleep(int8 type);  
.................... // Constants returned from RESTART_CAUSE() are: 
.................... #define WDT_TIMEOUT       7      
.................... #define MCLR_FROM_SLEEP  11      
.................... #define MCLR_FROM_RUN    15      
.................... #define NORMAL_POWER_UP  12      
.................... #define BROWNOUT_RESTART 14      
.................... #define WDT_FROM_SLEEP    3      
.................... #define RESET_INSTRUCTION 0      
....................  
.................... // Constants for calls to sleep() are: 
.................... #define SLEEP_FULL       0  // Default 
.................... #define SLEEP_IDLE       1  // Clock and peripherals don't stop 
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 0 
.................... // Timer 0 (AKA RTCC)Functions: SETUP_COUNTERS() or SETUP_TIMER_0(), 
.................... //                              SET_TIMER0() or SET_RTCC(), 
.................... //                              GET_TIMER0() or GET_RTCC() 
.................... // Timer 0 Prototypes: 
.................... _bif void setup_timer_0(int8 mode); 
.................... _bif void set_timer0(int16 value);      
.................... _bif int16 get_timer0(void);            
.................... _bif void setup_counters(int8 mode, int8 prescaler); 
.................... _bif void set_rtcc(int16 value);        
.................... _bif int16 get_rtcc(void);              
.................... // Constants used for SETUP_TIMER_0() are: 
.................... #define T0_INTERNAL   0    
.................... #define T0_EXT_L_TO_H 32 
.................... #define T0_EXT_H_TO_L 48 
....................  
.................... #define T0_DIV_1      8 
.................... #define T0_DIV_2      0 
.................... #define T0_DIV_4      1 
.................... #define T0_DIV_8      2 
.................... #define T0_DIV_16     3 
.................... #define T0_DIV_32     4 
.................... #define T0_DIV_64     5 
.................... #define T0_DIV_128    6 
.................... #define T0_DIV_256    7 
....................  
.................... #define T0_OFF        0x80   
....................  
.................... #define T0_8_BIT      0x40   
....................  
.................... // The following are provided for compatibility 
.................... // with older compiler versions 
.................... #define RTCC_INTERNAL   0   
.................... #define RTCC_EXT_L_TO_H 32      
.................... #define RTCC_EXT_H_TO_L 48 
.................... #define RTCC_DIV_1      8 
.................... #define RTCC_DIV_2      0 
.................... #define RTCC_DIV_4      1 
.................... #define RTCC_DIV_8      2 
.................... #define RTCC_DIV_16     3 
.................... #define RTCC_DIV_32     4 
.................... #define RTCC_DIV_64     5 
.................... #define RTCC_DIV_128    6 
.................... #define RTCC_DIV_256    7 
.................... #define RTCC_OFF        0x80   
.................... #define RTCC_8_BIT      0x40   
....................  
.................... // Constants used for SETUP_COUNTERS() are the above 
.................... // constants for the 1st parameter and the following for 
.................... // the 2nd parameter: 
....................  
.................... ////////////////////////////////////////////////////////////////// WDT 
.................... // Watch Dog Timer Functions: SETUP_WDT() or SETUP_COUNTERS() (see above) 
.................... //                            RESTART_WDT() 
.................... // WDT base is 4ms 
.................... // WDT Prototypes: 
.................... _bif void setup_wdt(int16 mode); 
.................... _bif void restart_wdt(void); 
.................... // Constants used for SETUP_WDT() are: 
.................... #define WDT_ON        0x100 
.................... #define WDT_OFF       0 
....................  
.................... #define WDT_4MS    0x300   
.................... #define WDT_8MS    0x500   
.................... #define WDT_16MS   0x700   
.................... #define WDT_32MS   0x900   
.................... #define WDT_64MS   0xB00   
.................... #define WDT_128MS  0xD00   
.................... #define WDT_256MS  0xF00   
.................... #define WDT_512MS  0x1100   
.................... #define WDT_1S     0x1300   
.................... #define WDT_2S     0x1500   
.................... #define WDT_4S     0x1700   
.................... #define WDT_8S     0x1900   
.................... #define WDT_16     0x1B00   
.................... #define WDT_32S    0x1D00   
.................... #define WDT_64S    0x1F00   
.................... #define WDT_128S   0x2100 
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 1 
.................... // Timer 1 Functions: SETUP_TIMER_1, GET_TIMER1, SET_TIMER1 
.................... // Timer 1 Prototypes: 
.................... _bif void setup_timer_1(int16 mode);  
.................... _bif int16 get_timer1(void); 
.................... _bif void set_timer1(int16 value); 
.................... // Constants used for SETUP_TIMER_1() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define T1_DISABLED         0 
.................... #define T1_INTERNAL         0x07     
.................... #define T1_EXTERNAL         0x87     
.................... #define T1_EXTERNAL_SYNC    0x83     
.................... #define T1_FOSC             0x47     
....................  
.................... #define T1_ENABLE_SOSC      0x08     
....................  
.................... #define T1_DIV_BY_1         0 
.................... #define T1_DIV_BY_2         0x10 
.................... #define T1_DIV_BY_4         0x20 
.................... #define T1_DIV_BY_8         0x30 
....................  
.................... #define T1_GATE             0x8000 
.................... #define T1_GATE_INVERTED    0xC000 
.................... #define T1_GATE_TOGGLE      0xA000 
.................... #define T1_GATE_SINGLE      0x9000 
.................... #define T1_GATE_TIMER2      0x8100        
.................... #define T1_GATE_COMP1       0x8200     
.................... #define T1_GATE_COMP2       0x8300      
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 2 
.................... // Timer 2 Functions: SETUP_TIMER_2, GET_TIMER2, SET_TIMER2 
.................... // Timer 2 Prototypes: 
.................... _bif void setup_timer_2(int8 mode, int8 period, int8 postscale);  
.................... _bif int8 get_timer2(void); 
.................... _bif void set_timer2(int8 value); 
.................... // Constants used for SETUP_TIMER_2() are: 
.................... #define T2_DISABLED         0 
.................... #define T2_DIV_BY_1         4 
.................... #define T2_DIV_BY_4         5 
.................... #define T2_DIV_BY_16        6  
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 3 
.................... // Timer 3 Functions: SETUP_TIMER_3, GET_TIMER3, SET_TIMER3 
.................... // Timer 3 Prototypes: 
.................... _bif void setup_timer_3(int16 mode);  
.................... _bif int16 get_timer3(void); 
.................... _bif void set_timer3(int16 value); 
.................... // Constants used for SETUP_TIMER_3() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define T3_DISABLED         0 
.................... #define T3_INTERNAL         0x07  
.................... #define T3_EXTERNAL         0x87   
.................... #define T3_EXTERNAL_SYNC    0x83   
.................... #define T3_FOSC             0x47  
....................  
.................... #define T3_ENABLE_SOSC      0x08   
....................  
.................... #define T3_DIV_BY_1         0 
.................... #define T3_DIV_BY_2         0x10 
.................... #define T3_DIV_BY_4         0x20 
.................... #define T3_DIV_BY_8         0x30 
....................  
.................... #define T3_GATE             0x8000 
.................... #define T3_GATE_INVERTED    0xC000 
.................... #define T3_GATE_TOGGLE      0xA000 
.................... #define T3_GATE_SINGLE      0x9000 
.................... #define T3_GATE_TIMER4      0x8100    
.................... #define T3_GATE_COMP1       0x8200  
.................... #define T3_GATE_COMP2       0x8300  
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 4 
.................... // Timer 4 Functions: SETUP_TIMER_4, GET_TIMER4, SET_TIMER4 
.................... // Timer 4 Prototypes: 
.................... _bif void setup_timer_4(int16 mode,int8 period, int8 postscaler); 
.................... _bif int8 get_timer4(void); 
.................... _bif void set_timer4(int8 value); 
.................... // Constants used for SETUP_TIMER_4() are: 
.................... #define T4_DISABLED         0 
.................... #define T4_DIV_BY_1         4 
.................... #define T4_DIV_BY_4         5 
.................... #define T4_DIV_BY_16        6 
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 5 
.................... // Timer 5 Functions: SETUP_TIMER_5, GET_TIMER5, SET_TIMER5 
.................... // Timer 5 Prototypes: 
.................... _bif void setup_timer_5(int16 mode);  
.................... _bif int16 get_timer5(void); 
.................... _bif void set_timer5(int16 value); 
.................... // Constants used for SETUP_TIMER_5() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define T5_DISABLED         0 
.................... #define T5_INTERNAL         0x07  
.................... #define T5_EXTERNAL         0x87   
.................... #define T5_EXTERNAL_SYNC    0x83   
.................... #define T5_FOSC             0x47  
.................... #define T5_LFINTRC          0xC7  
....................  
.................... #define T5_ENABLE_SOSC      0x08   
....................  
.................... #define T5_DIV_BY_1         0 
.................... #define T5_DIV_BY_2         0x10 
.................... #define T5_DIV_BY_4         0x20 
.................... #define T5_DIV_BY_8         0x30 
....................  
.................... #define T5_GATE             0x8000 
.................... #define T5_GATE_INVERTED    0xC000 
.................... #define T5_GATE_TOGGLE      0xA000 
.................... #define T5_GATE_SINGLE      0x9000 
.................... #define T5_GATE_TIMER6      0x8100    
.................... #define T5_GATE_COMP1       0x8200  
.................... #define T5_GATE_COMP2       0x8300  
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 6 
.................... // Timer 6 Functions: SETUP_TIMER_6, GET_TIMER5, SET_TIMER5 
.................... // Timer 6 Prototypes: 
.................... _bif void setup_timer_6(int16 mode, int8 period, int8 postscaler); 
.................... _bif int8 get_timer6(void); 
.................... _bif void set_timer6(int8 value); 
.................... // Constants used for SETUP_TIMER_6() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define T6_DISABLED         0 
.................... #define T6_DIV_BY_1         4 
.................... #define T6_DIV_BY_4         5 
.................... #define T6_DIV_BY_16        6 
....................  
.................... ////////////////////////////////////////////////////////////////// CCP 
.................... // CCP Functions: SETUP_CCPx, SET_PWMx_DUTY  
.................... // CCP Variables: CCP_x, CCP_x_LOW, CCP_x_HIGH 
.................... // CCP1 Prototypes: 
.................... _bif void setup_ccp1(int32 mode); 
.................... _bif void setup_ccp1(int32 mode, int8 pwm);  
.................... _bif void set_pwm1_duty(int16 value);  
.................... // Constants used for SETUP_CCPx() are: 
.................... #define CCP_OFF                          0 
.................... #define CCP_CAPTURE_FE                   0x04 
.................... #define CCP_CAPTURE_RE                   0x05 
.................... #define CCP_CAPTURE_DIV_4                0x06 
.................... #define CCP_CAPTURE_DIV_16               0x07 
.................... #define CCP_COMPARE_SET_ON_MATCH         0x08 
.................... #define CCP_COMPARE_CLR_ON_MATCH         0x09 
.................... #define CCP_COMPARE_INT                  0x0A          
.................... #define CCP_COMPARE_INT_AND_TOGGLE       0x02   
.................... #define CCP_COMPARE_RESET_TIMER          0x0B         
.................... #define CCP_PWM                          0x0C     
.................... #define CCP_PWM_PLUS_1                   0x1c          
.................... #define CCP_PWM_PLUS_2                   0x2c          
.................... #define CCP_PWM_PLUS_3                   0x3c          
.................... //#define CCP_USE_TIMER3                 0x100  OBSOLETE, SEE TIMER-3       
....................  
.................... #word   CCP_1       =                    getenv("SFR:CCPR1L")  
.................... #byte   CCP_1_LOW   =                    getenv("SFR:CCPR1L")  
.................... #byte   CCP_1_HIGH  =                    getenv("SFR:CCPR1H")  
.................... // The following are used to select the Timer source for the CCP/ECCP 
.................... // The first timer is the timer used when in CAPTURE or COMPARE mode 
.................... // The second timer is the timer used when in PWM mode 
.................... #define CCP_USE_TIMER1_AND_TIMER2       0x0000 
.................... #define CCP_USE_TIMER3_AND_TIMER4       0x0100 
.................... #define CCP_USE_TIMER5_AND_TIMER6       0x0200 
....................  
.................... // The following should be used with the ECCP unit only (or these in) 
.................... #define CCP_PWM_H_H                     0x0c 
.................... #define CCP_PWM_H_L                     0x0d 
.................... #define CCP_PWM_L_H                     0x0e 
.................... #define CCP_PWM_L_L                     0x0f 
....................  
.................... #define CCP_PWM_FULL_BRIDGE             0x40 
.................... #define CCP_PWM_FULL_BRIDGE_REV         0xC0 
.................... #define CCP_PWM_HALF_BRIDGE             0x80 
....................  
.................... #define CCP_SHUTDOWN_ON_COMP1           0x100000 
.................... #define CCP_SHUTDOWN_ON_COMP2           0x200000 
.................... #define CCP_SHUTDOWN_ON_COMP            0x300000 
.................... #define CCP_SHUTDOWN_ON_INT0            0x400000 
.................... #define CCP_SHUTDOWN_ON_COMP1_INT0      0x500000 
.................... #define CCP_SHUTDOWN_ON_COMP2_INT0      0x600000 
.................... #define CCP_SHUTDOWN_ON_COMP_INT0       0x700000 
....................  
.................... #define CCP_SHUTDOWN_AC_L               0x000000 
.................... #define CCP_SHUTDOWN_AC_H               0x040000 
.................... #define CCP_SHUTDOWN_AC_F               0x080000 
....................  
.................... #define CCP_SHUTDOWN_BD_L               0x000000 
.................... #define CCP_SHUTDOWN_BD_H               0x010000 
.................... #define CCP_SHUTDOWN_BD_F               0x020000 
....................  
.................... #define CCP_SHUTDOWN_RESTART            0x80000000   
....................  
.................... #define CCP_PULSE_STEERING_A            0x01000000 
.................... #define CCP_PULSE_STEERING_B            0x02000000 
.................... #define CCP_PULSE_STEERING_C            0x04000000 
.................... #define CCP_PULSE_STEERING_D            0x08000000 
.................... #define CCP_PULSE_STEERING_SYNC         0x10000000 
....................  
....................  
.................... // CCP2 Prototypes: 
.................... _bif void setup_ccp2(int32 mode); 
.................... _bif void setup_ccp2(int32 mode, int8 pwm);  
.................... _bif void set_pwm2_duty(int16 value);  
.................... #word   CCP_2       =                    getenv("SFR:CCPR2L")  
.................... #byte   CCP_2_LOW   =                    getenv("SFR:CCPR2L")  
.................... #byte   CCP_2_HIGH  =                    getenv("SFR:CCPR2H")  
....................  
.................... // CCP3 Prototypes: 
.................... _bif void setup_ccp3(int32 mode); 
.................... _bif void setup_ccp3(int32 mode, int8 pwm); 
.................... _bif void set_pwm3_duty(int16 value); 
.................... #word   CCP_3       =                    getenv("SFR:CCPR3L") 
.................... #byte   CCP_3_LOW   =                    getenv("SFR:CCPR3L") 
.................... #byte   CCP_3_HIGH  =                    getenv("SFR:CCPR3H") 
....................  
.................... // CCP4 Prototypes: 
.................... _bif void setup_ccp4(int32 mode); 
.................... _bif void setup_ccp4(int32 mode, int8 pwm); 
.................... _bif void set_pwm4_duty(int16 value); 
.................... #word   CCP_4       =                    getenv("SFR:CCPR4L") 
.................... #byte   CCP_4_LOW   =                    getenv("SFR:CCPR4L") 
.................... #byte   CCP_4_HIGH  =                    getenv("SFR:CCPR4H") 
....................  
.................... // CCP5 Prototypes: 
.................... _bif void setup_ccp5(int32 mode); 
.................... _bif void setup_ccp5(int32 mode, int8 pwm); 
.................... _bif void set_pwm5_duty(int16 value); 
.................... #word   CCP_5       =                    getenv("SFR:CCPR5L") 
.................... #byte   CCP_5_LOW   =                    getenv("SFR:CCPR5L") 
.................... #byte   CCP_5_HIGH  =                    getenv("SFR:CCPR5H") 
.................... ////////////////////////////////////////////////////////////////// SPI 
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IS_IN 
.................... // SPI Prototypes: 
.................... _bif void setup_spi(int32 mode); 
.................... _bif void spi_write(int8 value); 
.................... _bif int8 spi_read(void); 
.................... _bif int8 spi_read(int8 value); 
.................... _bif int1 spi_data_is_in(void); 
.................... _bif void setup_spi2(int32 mode);   
.................... _bif void spi_write2(int8 value);   
.................... _bif int8 spi_read2(void);   
.................... _bif int8 spi_read2(int8 value);   
.................... _bif int1 spi_data_is_in2(void);   
.................... // Constants used in SETUP_SPI() are:  
.................... #define SPI_DISABLED             0x00  
.................... #define SPI_MASTER               0x20  
.................... #define SPI_SLAVE                0x24  
.................... #define SPI_SCK_IDLE_HIGH        0x10  
.................... #define SPI_SCK_IDLE_LOW         0x00  
.................... #define SPI_CLK_DIV_4            0x00  
.................... #define SPI_CLK_DIV_16           0x01  
.................... #define SPI_CLK_DIV_64           0x02  
.................... #define SPI_CLK_T2               0x03  
.................... #define SPI_SS_DISABLED          0x01  
....................  
.................... #define SPI_XMIT_L_TO_H          0x4000 
.................... #define SPI_XMIT_H_TO_L          0x0000 
....................  
.................... #define SPI_SAMPLE_AT_MIDDLE     0x0000 
.................... #define SPI_SAMPLE_AT_END        0x8000 
....................  
.................... //The following are provided for compatibility 
.................... #define SPI_L_TO_H       SPI_SCK_IDLE_LOW 
.................... #define SPI_H_TO_L       SPI_SCK_IDLE_HIGH 
....................  
.................... ////////////////////////////////////////////////////////////////// UART 
.................... // UART Prototypes: 
.................... _bif void setup_uart(int32 baud); 
.................... _bif void setup_uart(int32 baud, int8 stream); 
.................... _bif void setup_uart(int32 baud, int8 stream, int32 clock); 
.................... _bif void set_uart_speed(int32 baud); 
.................... _bif void set_uart_speed(int32 baud, int8 stream); 
.................... _bif void set_uart_speed(int32 baud, int8 stream, int32 clock); 
.................... // Constants used in setup_uart() are: 
.................... // FALSE - Turn UART off 
.................... // TRUE  - Turn UART on 
.................... #define UART_ADDRESS           2 
.................... #define UART_DATA              4 
.................... #define UART_AUTODETECT        8 
.................... #define UART_AUTODETECT_NOWAIT 9 
.................... #define UART_WAKEUP_ON_RDA     10 
.................... #define UART_SEND_BREAK        13 
.................... ////////////////////////////////////////////////////////////////// COMP 
.................... // Comparator Variables: C1OUT, C2OUT 
.................... // Comparator Prototypes: 
.................... _bif void setup_comparator(int32 mode); 
.................... // Constants used in setup_comparator() are: 
.................... // 
.................... #define NC_NC_NC_NC   0x404 
.................... #define NC_NC         0x404 
....................  
.................... //Pick one constant for COMP1 
.................... #define CP1_A0_A3       0x000080 
.................... #define CP1_A1_A3       0x000081 
.................... #define CP1_B3_A3       0x000082 
.................... #define CP1_B1_A3       0x000083 
.................... #define CP1_A0_DAC      0x000084 
.................... #define CP1_A1_DAC      0x000085 
.................... #define CP1_B3_DAC      0x000086 
.................... #define CP1_B1_DAC      0x000087 
.................... #define CP1_A0_FVR      0x200084 
.................... #define CP1_A1_FVR      0x200085 
.................... #define CP1_B3_FVR      0x200086 
.................... #define CP1_B1_FVR      0x200087 
.................... //Optionally OR with any of the following 
.................... #define CP1_OUT_ON_A4   0x000020 
.................... #define CP1_INVERT      0x000010 
.................... #define CP1_FAST        0x000008 
.................... #define CP1_HYST        0x080000   
.................... #define CP1_SYNC        0x020000 
....................  
.................... //OR with one constant for COMP2 
.................... #define CP2_A0_A2       0x008000 
.................... #define CP2_A1_A2       0x008100 
.................... #define CP2_B3_A2       0x008200 
.................... #define CP2_B1_A2       0x008300 
.................... #define CP2_A0_DAC      0x008400 
.................... #define CP2_A1_DAC      0x008500 
.................... #define CP2_B3_DAC      0x008600 
.................... #define CP2_B1_DAC      0x008700 
.................... #define CP2_A0_FVR      0x108400 
.................... #define CP2_A1_FVR      0x108500 
.................... #define CP2_B3_FVR      0x108600 
.................... #define CP2_B1_FVR      0x108700 
.................... //Optionally OR with any of the following 
.................... #define CP2_OUT_ON_A5   0x002000 
.................... #define CP2_INVERT      0x001000 
.................... #define CP2_FAST        0x000800 
.................... #define CP2_HYST        0x040000   
.................... #define CP2_SYNC        0x010000 
....................  
.................... #bit C1OUT = 0xF79.6 
.................... #bit C2OUT = 0xF78.6 
....................  
.................... ////////////////////////////////////////////////////////////////// VREF 
.................... // VREF Prototypes: 
.................... _bif void setup_vref(int8 mode); 
.................... // Constants used in setup_vref() are: 
.................... #define VREF_OFF     0 
.................... #define VREF_1v024   0x90 
.................... #define VREF_2v048   0xA0 
.................... #define VREF_4v096   0xB0 
....................  
.................... ////////////////////////////////////////////////////////////////// LVD 
.................... // LVD Prototypes: 
.................... _bif void setup_low_volt_detect(int8 mode); 
.................... // Constants used in setup_low_volt_detect() are: 
.................... #define LVD_LVDIN   0x1F 
.................... #define LVD_47      0x1E 
.................... #define LVD_43      0x1D 
.................... #define LVD_41      0x1C 
.................... #define LVD_38      0x1B 
.................... #define LVD_36      0x1A 
.................... #define LVD_34      0x19 
.................... #define LVD_32      0x18 
.................... #define LVD_29      0x17 
.................... #define LVD_28      0x16 
.................... #define LVD_27      0x15 
.................... #define LVD_25      0x14 
.................... #define LVD_24      0x13 
.................... #define LVD_22      0x12 
.................... #define LVD_20      0x11 
.................... #define LVD_18      0x10 
....................  
.................... #define LVD_TRIGGER_BELOW 0 
.................... #define LVD_TRIGGER_ABOVE 0x80 
....................  
.................... ////////////////////////////////////////////////////////////////// DAC 
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE() 
.................... // DAC Prototypes: 
.................... _bif void setup_dac(int8 mode); 
.................... _bif void dac_write(int8 value); 
.................... // Constants used in SETUP_DAC() are: 
.................... #define DAC_OFF  0 
.................... #define DAC_VSS_VDD   0x80 
.................... #define DAC_VREF_VDD  0x81   
.................... #define DAC_VSS_VREF  0x84 
.................... #define DAC_VREF_VREF 0x85   
.................... #define DAC_VSS_FVR   0x88 
.................... #define DAC_VREF_FVR  0x89   
.................... // The following may be OR'ed in with the above using | 
.................... #define DAC_OUTPUT    0x20 
.................... #define DAC_LVP_POS   0x40      
.................... #define DAC_LVP_NEG   0      
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC 
.................... // Oscillator Prototypes: 
.................... _bif int8 setup_oscillator(int16 mode); 
.................... _bif int8 setup_oscillator(int16 mode, signed int8 tune); 
.................... // Constants used in setup_oscillator() are: 
.................... #define OSC_PLL_ON  0x4000 
.................... #define OSC_PLL_OFF 0 
.................... #define OSC_31250   0x8000 
.................... #define OSC_31KHZ   0x00 
.................... #define OSC_250KHZ  0x10 
.................... #define OSC_500KHZ  0x20 
.................... #define OSC_1MHZ    0x30 
.................... #define OSC_2MHZ    0x40 
.................... #define OSC_4MHZ    0x50 
.................... #define OSC_8MHZ    0x60 
.................... #define OSC_16MHZ   0x70 
.................... #define OSC_32MHZ   0x4060 
.................... #define OSC_64MHZ   0x4070 
.................... // The following may be OR'ed in with the above using | 
.................... #define OSC_TIMER1  1 
.................... #define OSC_INTRC   2 
.................... #define OSC_NORMAL  0 
.................... // The following may be OR'ed in with the above using | 
.................... #define OSC_IDLE_MODE  0x80 
.................... // A second optional parameter may be used with this part to fine 
.................... // tune the speed (signed int,-32 to 31) 
.................... // Result may be (ignore all other bits) 
.................... #define OSC_STATE_STABLE 4 
.................... #define OSC_STATE_EXT_RUNNING 8 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// ADC 
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS() (aka SETUP_PORT_A), 
.................... //                SET_ADC_CHANNEL(), READ_ADC(), ADC_DONE() 
.................... // ADC Prototypes: 
.................... _bif void setup_adc(int16 mode); 
.................... _bif int8 read_adc(void); 
.................... _bif int8 read_adc(int8 mode); 
.................... _bif int16 read_adc(void); 
.................... _bif int16 read_adc(int8 mode); 
.................... _bif int1 adc_done(void); 
.................... // Constants used for SETUP_ADC() are: 
.................... #define ADC_OFF               0           // ADC Off 
.................... #define ADC_CLOCK_DIV_2   0x100 
.................... #define ADC_CLOCK_DIV_4    0x04 
.................... #define ADC_CLOCK_DIV_8    0x01 
.................... #define ADC_CLOCK_DIV_16   0x05 
.................... #define ADC_CLOCK_DIV_32   0x02 
.................... #define ADC_CLOCK_DIV_64   0x06 
.................... #define ADC_CLOCK_INTERNAL 0x07           // Internal 2-6us 
.................... // The following may be OR'ed in with the above using | 
.................... #define ADC_TAD_MUL_0      0x00 
.................... #define ADC_TAD_MUL_2      0x08 
.................... #define ADC_TAD_MUL_4      0x10 
.................... #define ADC_TAD_MUL_6      0x18 
.................... #define ADC_TAD_MUL_8      0x20 
.................... #define ADC_TAD_MUL_12     0x28 
.................... #define ADC_TAD_MUL_16     0x30 
.................... #define ADC_TAD_MUL_20     0x38 
....................  
.................... //ADC Prototypes: 
.................... _bif void setup_adc_ports(int32 pins); 
.................... _bif void setup_adc_ports(int32 pins, int32 reference); 
.................... _bif void set_analog_pins(int8 pin, ...); 
.................... _bif void setup_adc_reference(int32 reference); 
.................... _bif void set_adc_channel(int8 channel); 
.................... // Constants used in SETUP_ADC_PORTS() are: 
.................... // First argument: 
.................... // OR together desired pins 
.................... #define sAN0         0x00800000       //| A0 
.................... #define sAN1         0x01000000       //| A1 
.................... #define sAN2         0x02000000       //| A2 
.................... #define sAN3         0x04000000       //| A3 
.................... #define sAN4         0x08000000       //| A5 
.................... #define sAN5         0x00100000       //| E0   
.................... #define sAN6         0x00200000       //| E1   
.................... #define sAN7         0x00400000       //| E2   
.................... #define sAN8         0x00010000       //| B2 
.................... #define sAN9         0x00020000       //| B3 
.................... #define sAN10        0x00008000       //| B1 
.................... #define sAN11        0x00040000       //| B4 
.................... #define sAN12        0x00004000       //| B0 
.................... #define sAN13        0x00080000       //| B5 
.................... #define sAN14        0x00000100       //| C2 
.................... #define sAN15        0x00000200       //| C3   
.................... #define sAN16        0x00000400       //| C4   
.................... #define sAN17        0x00000800       //| C5   
.................... #define sAN18        0x00001000       //| C6 
.................... #define sAN19        0x00002000       //| C7 
.................... #define sAN20        0x00000001       //| D0   
.................... #define sAN21        0x00000002       //| D1   
.................... #define sAN22        0x00000004       //| D2   
.................... #define sAN23        0x00000008       //| D3   
.................... #define sAN24        0x00000010       //| D4   
.................... #define sAN25        0x00000020       //| D5   
.................... #define sAN26        0x00000040       //| D6   
.................... #define sAN27        0x00000080       //| D7   
.................... #define NO_ANALOGS            0       // None 
.................... #define ALL_ANALOG   0x0FFFFFFF       // A0 A1 A2 A3 A5 E0 E1 E2 B2 B3 B1 B4 B0 B5 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7   
....................  
.................... // Optional Second parameter for SETUP_ADC_PORTS, and parameter for SETUP_ADC_REFERENCE: 
.................... #define VSS_VDD      0x00000000       //| Range 0-Vdd 
.................... #define VSS_VREF     0x40000000       //| Range 0-VrefH 
.................... #define VSS_FVR      0x80000000       //| Range 0-Fvr BUF2 
.................... #define VREF_VDD     0x10000000       //| Range VrefL-Vdd 
.................... #define VREF_VREF    0x50000000       //| Range VrefL-VrefH 
.................... #define VREF_FVR     0x90000000       //| Range VrefL-Fvr BUF2 
....................  
.................... // Constants used in SET_ADC_CHANNEL() are: 
.................... // either use the channel number or one of the following 
.................... #define CTMU_CHANNEL        0x1D 
.................... #define DAC_CHANNEL         0x1E 
.................... #define FVR_CHANNEL         0x1F 
....................  
.................... // Constants used in READ_ADC() are: 
.................... #define ADC_START_AND_READ     7   // This is the default if nothing is specified 
.................... #define ADC_START_ONLY         1 
.................... #define ADC_READ_ONLY          6 
....................  
.................... ////////////////////////////////////////////////////////////////// BIF 
.................... // Built In Functions Prototypes 
.................... // 
.................... // Math Prototypes: 
.................... _bif signed int8 abs(signed int8 x); 
.................... _bif signed int16 abs(signed int16 x); 
.................... _bif signed int32 abs(signed int32 x); 
.................... _bif float32 abs(float32 x); 
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8); 
.................... _bif signed int16 _mul(signed int8, signed int8); 
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16); 
.................... _bif signed int32 _mul(signed int16, signed int16); 
....................  
.................... // Memory Manipulation Prototypes: 
.................... _bif int8 read_bank(int8 bank, int8 offset); 
.................... _bif void write_bank(int8 bank, int8 offset, int8 value); 
.................... _bif void strcpy(char* dest, char* src); 
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num); 
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num); 
....................  
.................... // String Prototypes: 
.................... _bif char toupper(char cvalue); 
.................... _bif char tolower(char cvalue); 
.................... _bif void sprintf(char* string, char* cstring, ...); 
....................  
.................... // Data Manipulators Prototypes: 
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value); 
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value); 
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes); 
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes); 
.................... _bif void swap(unsigned int8 value); 
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset); 
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset); 
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow); 
.................... _bif unsigned int32 make32(unsigned int16 var1); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3); 
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit); 
....................  
.................... // #use delay() Prototypes: 
.................... _bif void delay_cycles(unsigned int8 count); 
.................... _bif void delay_ms(unsigned int16 time); 
.................... _bif void delay_us(unsigned int16 time); 
....................  
.................... // #use rs232() Prototypes: 
.................... _bif void putchar(char cdata); 
.................... _bif void putchar(char cdata, unsigned int8 stream); 
.................... _bif void puts(char* string); 
.................... _bif void puts(char* string, unsigned int8 stream); 
.................... _bif char getch(void); 
.................... _bif char getch(unsigned int8 stream); 
.................... _bif void gets(char* string); 
.................... _bif void gets(char* string, unsigned int8 stream); 
.................... _bif int1 kbhit(void); 
.................... _bif int1 kbhit(unsigned int8 stream); 
.................... _bif void printf(char* string, ...); 
.................... _bif void fprintf(unsigned int8 stream, char* string, ...); 
.................... _bif void putc_send(void); 
.................... _bif void fputc_send(unsigned int8 stream); 
.................... _bif int1 rcv_buffer_full(void); 
.................... _bif int1 rcv_buffer_full(unsigned int8 stream); 
.................... _bif unsigned int16 rcv_buffer_bytes(void); 
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream); 
.................... _bif int1 tx_buffer_full(void); 
.................... _bif int1 tx_buffer_full(unsigned int8 stream); 
.................... _bif unsigned int16 tx_buffer_bytes(void); 
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream); 
....................  
.................... // #use i2c() Prototypes: 
.................... _bif unsigned int8 i2c_read(void); 
.................... _bif unsigned int8 i2c_read(unsigned int8 ack); 
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, unsigned int8 ack); 
.................... _bif int1 i2c_write(unsigned int8 data); 
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data); 
.................... _bif void i2c_start(void); 
.................... _bif void i2c_start(unsigned int8 stream); 
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart); 
.................... _bif void i2c_stop(void); 
.................... _bif void i2c_stop(unsigned int8 stream); 
.................... _bif int8 i2c_isr_state(void); 
.................... _bif void i2c_slaveaddr(unsigned int8 addr); 
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr); 
.................... _bif int1 i2c_poll(void); 
.................... _bif int1 i2c_poll(unsigned int8 stream); 
.................... _bif void i2c_init(unsigned int32 baud); 
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud); 
....................  
.................... // #use spi() Prototypes: 
.................... _bif unsigned int8 spi_xfer(void); 
.................... _bif unsigned int16 spi_xfer(void); 
.................... _bif unsigned int32 spi_xfer(void); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 data); 
.................... _bif unsigned int16 spi_xfer(unsigned int16 data); 
.................... _bif unsigned int32 spi_xfer(unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data); 
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data); 
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits); 
.................... _bif void spi_init(unsigned int32 baud); 
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock); 
.................... _bif void spi_prewrite(unsigned int8 data); 
.................... _bif void spi_prewrite(unsigned int16 data); 
.................... _bif void spi_prewrite(unsigned int32 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer_in(void); 
.................... _bif unsigned int16 spi_xfer_in(void); 
.................... _bif unsigned int32 spi_xfer_in(void); 
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
....................  
.................... // #use rtos() Prototypes: 
.................... _bif void rtos_run(void); 
.................... _bif void rtos_yield(void); 
.................... _bif void rtos_enable(unsigned int8 task); 
.................... _bif void rtos_disable(unsigned int8 task); 
.................... _bif void rtos_terminate(void); 
.................... _bif void rtos_await(int1 flag); 
.................... _bif void rtos_wait(unsigned int8 sem); 
.................... _bif void rtos_signal(unsigned int8 sem); 
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg); 
.................... _bif unsigned int8 rtos_msg_read(void); 
.................... _bif unsigned int8 rtos_msg_poll(void); 
.................... _bif int1 rtos_overrun(unsigned int8 task); 
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat); 
....................  
.................... // #use timer() Prototypes: 
.................... _bif unsigned int8 get_ticks(void); 
.................... _bif unsigned int16 get_ticks(void); 
.................... _bif unsigned int32 get_ticks(void); 
.................... _bif unsigned int8 get_ticks(unsigned int8 stream); 
.................... _bif unsigned int16 get_ticks(unsigned int8 stream); 
.................... _bif unsigned int32 get_ticks(unsigned int8 stream); 
.................... _bif void set_ticks(unsigned int8 value); 
.................... _bif void set_ticks(unsigned int16 value); 
.................... _bif void set_ticks(unsigned int32 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value); 
....................  
.................... // #use pwm() Prototypes: 
.................... _bif void pwm_on(void); 
.................... _bif void pwm_on(unsigned int8 stream); 
.................... _bif void pwm_off(void); 
.................... _bif void pwm_off(unsigned int8 stream); 
.................... _bif void pwm_set_duty(unsigned int16 duty); 
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty); 
.................... _bif void pwm_set_duty_percent(unsigned int16 percent); 
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent); 
.................... _bif void pwm_set_frequency(unsigned int32 frequency); 
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency); 
....................  
.................... // #use capture() Prototypes: 
.................... _bif unsigned int16 get_capture_time(void); 
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream); 
.................... _bif int1 get_capture_event(void); 
.................... _bif int1 get_capture_event(unsigned int8 stream); 
....................  
.................... // Enviroment Prototypes: 
.................... //_bif unsigned int8 getenv(char* cstring); 
....................  
.................... // Address Prototypes: 
.................... #ifndef __ADDRESS__ 
....................  #if defined(__PCM__) || defined(__PCB__) 
....................   #define __ADDRESS__ unsigned int16 
....................  #else 
....................   #define __ADDRESS__ unsigned int32 
....................  #endif 
.................... #endif 
.................... _bif void goto_address(__ADDRESS__ address); 
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label); 
....................  
.................... // Program Memory Read Prototypes: 
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count); 
.................... _bif unsigned int16 read_program_eeprom(__ADDRESS__ address); 
....................  
.................... // Program Memory Write Prototypes: 
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count); 
.................... _bif void write_program_eeprom(__ADDRESS__ address, unsigned int16 data); 
....................  
.................... // EEPROM Prototypes: 
.................... #ifndef __EEADDRESS__ 
....................  #if getenv("DATA_EEPROM")>256 
....................   #define __EEADDRESS__ unsigned int16 
....................  #else 
....................   #define __EEADDRESS__ unsigned int8 
....................  #endif 
.................... #endif 
.................... _bif unsigned int8 read_eeprom(__EEADDRESS__ address); 
.................... _bif void write_eeprom(__EEADDRESS__ address, unsigned int8 value); 
....................  
.................... // #use touchpad() Prototypes: 
.................... _bif void touchpad_state(unsigned int8 state); 
.................... _bif char touchpad_getc(void); 
.................... _bif int1 touchpad_hit(void); 
.................... ////////////////////////////////////////////////////////////////// INT 
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(), 
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),   
.................... //                      EXT_INT_EDGE()   
.................... // INT Prototypes: 
.................... _bif void enable_interrupts(int32 interrupt); 
.................... _bif void disable_interrupts(int32 interrupt); 
.................... _bif void clear_interrupt(int32 interrupt); 
.................... _bif int1 interrupt_active(int32 interrupt); 
.................... _bif int1 interrupt_enabled(int32 interrupt); 
.................... _bif void ext_int_edge(int8 source, int8 edge);   
.................... _bif void jump_to_isr(int16 address); 
.................... // Constants used in EXT_INT_EDGE() are:   
.................... #define L_TO_H              0x40   
.................... #define H_TO_L                 0   
.................... // Constants used in ENABLE/DISABLE_INTERRUPTS() are: 
.................... #define GLOBAL                    0xF2C0 
.................... #define PERIPH                    0xF240 
.................... #define INT_RTCC                  0x00F220 
.................... #define INT_TIMER0                0x00F220 
.................... #define INT_TIMER1                0x009D01 
.................... #define INT_TIMER2                0x009D02 
.................... #define INT_TIMER3                0x00A002 
.................... #define INT_EXT_L2H               0x5000F210 
.................... #define INT_EXT_H2L               0x6000F210 
.................... #define INT_EXT                   0x00F210 
.................... #define INT_EXT1_L2H              0x5001F008 
.................... #define INT_EXT1_H2L              0x6001F008 
.................... #define INT_EXT1                  0x00F008 
.................... #define INT_EXT2_L2H              0x5002F010 
.................... #define INT_EXT2_H2L              0x6002F010 
.................... #define INT_EXT2                  0x00F010 
.................... #define INT_RB                    0x01FFF208 
.................... #define INT_AD                    0x009D40 
.................... #define INT_RDA                   0x009D20 
.................... #define INT_TBE                   0x009D10 
.................... #define INT_SSP                   0x009D08 
.................... #define INT_CCP1                  0x009D04 
.................... #define INT_CCP2                  0x00A001 
.................... #define INT_BUSCOL                0x00A008 
.................... #define INT_COMP                  0x00A040 
.................... #define INT_EEPROM                0x00A010 
.................... #define INT_TBE2                  0x00A310 
.................... #define INT_RDA2                  0x00A320 
.................... #define INT_OSCF                  0x00A080 
.................... #define INT_HLVD                  0x00A004 
.................... #define INT_BUSCOL2               0x00A340 
.................... #define INT_COMP2                 0x00A020 
.................... #define INT_SSP2                  0x00A380 
.................... #define INT_TIMER4                0x007D01 
.................... #define INT_TIMER5                0x007D02 
.................... #define INT_TIMER6                0x007D04 
.................... #define INT_CCP3                  0x007A01 
.................... #define INT_CCP4                  0x007A02 
.................... #define INT_CCP5                  0x007A04 
.................... #define INT_TMR1G                 0x00A301 
.................... #define INT_TMR3G                 0x00A302 
.................... #define INT_TMR5G                 0x00A304 
.................... #define INT_CTMU                  0x00A308 
.................... #define INT_RB4                   0x110F208 
.................... #define INT_RB5                   0x120F208 
.................... #define INT_RB6                   0x140F208 
.................... #define INT_RB7                   0x180F208 
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #device ANSI 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
....................  
.................... #use delay(internal=8000000) 
*
02D2E:  MOVLW  08
02D30:  MOVWF  FEA
02D32:  MOVLW  18
02D34:  MOVWF  FE9
02D36:  MOVF   FEF,W
02D38:  BZ    2D54
02D3A:  MOVLW  02
02D3C:  MOVWF  01
02D3E:  CLRF   00
02D40:  DECFSZ 00,F
02D42:  BRA    2D40
02D44:  DECFSZ 01,F
02D46:  BRA    2D3E
02D48:  MOVLW  97
02D4A:  MOVWF  00
02D4C:  DECFSZ 00,F
02D4E:  BRA    2D4C
02D50:  DECFSZ FEF,F
02D52:  BRA    2D3A
02D54:  RETURN 0
....................  
.................... // NOTE: The last RS232 will be used by printf as STDOUT 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,ERRORS,stream=BLE) 
*
0073E:  BTFSS  F9E.5
00740:  BRA    073E
00742:  MOVFF  FAB,1A
00746:  MOVFF  FAE,01
0074A:  BTFSS  1A.1
0074C:  BRA    0752
0074E:  BCF    FAB.4
00750:  BSF    FAB.4
00752:  GOTO   17E4 (RETURN)
*
007D6:  BTFSS  F9E.4
007D8:  BRA    07D6
007DA:  MOVWF  FAD
007DC:  RETURN 0
.................... #use rs232(baud=115200,parity=N,xmit=PIN_D6,rcv=PIN_D7,bits=8,ERRORS,RECEIVE_BUFFER=50,stream=STDOUT) 
*
094F0:  MOVLW  01
094F2:  MOVWF  00
094F4:  MOVF   1C,W
094F6:  SUBWF  1B,W
094F8:  BTFSC  FD8.2
094FA:  CLRF   00
094FC:  GOTO   D850 (RETURN)
09500:  MOVF   1C,W
09502:  SUBWF  1B,W
09504:  BZ    9500
09506:  CLRF   FEA
09508:  MOVLW  24
0950A:  MOVWF  FE9
0950C:  MOVF   1C,W
0950E:  ADDWF  FE9,F
09510:  MOVLW  00
09512:  ADDWFC FEA,F
09514:  MOVFF  FEF,01
09518:  INCF   1C,F
0951A:  MOVLW  31
0951C:  BSF    FD8.0
0951E:  SUBFWB 1C,W
09520:  BC    9524
09522:  CLRF   1C
09524:  RETURN 0
09526:  BTFSS  FA4.4
09528:  BRA    9526
0952A:  MOVWF  F73
0952C:  RETURN 0
....................  
.................... #use i2c(Master,Slow,sda=PIN_C4,scl=PIN_C3)          //Use this set-up - BLE works, BME does not  
*
009D0:  BCF    FC6.7
009D2:  BCF    F9E.3
009D4:  MOVFF  97A,FC9
009D8:  MOVLW  02
009DA:  BTFSC  FC6.7
009DC:  BRA    09E8
009DE:  BTFSS  F9E.3
009E0:  BRA    09DE
009E2:  MOVLW  00
009E4:  BTFSC  FC5.6
009E6:  MOVLW  01
009E8:  MOVWF  01
009EA:  RETURN 0
*
02BFE:  BCF    FC6.6
02C00:  BSF    FC5.3
02C02:  BTFSC  FC5.3
02C04:  BRA    2C02
02C06:  BTFSC  00.0
02C08:  BCF    FC5.5
02C0A:  BTFSS  00.0
02C0C:  BSF    FC5.5
02C0E:  BSF    FC5.4
02C10:  BTFSC  FC5.4
02C12:  BRA    2C10
02C14:  MOVFF  FC9,01
02C18:  RETURN 0
.................... //#use i2c(Master,Slow,sda=PIN_D5,scl=PIN_A7)        //Use this set-up - BME works, BLE does not 
....................  
.................... #use spi(MASTER, DO=PIN_D4, CLK=PIN_D0, ENABLE=PIN_D3, MODE=0, BITS=24, STREAM=SPI_1) 
*
042AC:  MOVLB  8
042AE:  MOVF   x1B,W
042B0:  SUBLW  20
042B2:  BZ    42C2
042B4:  MOVWF  x1C
042B6:  RLCF   x17,F
042B8:  RLCF   x18,F
042BA:  RLCF   x19,F
042BC:  RLCF   x1A,F
042BE:  DECFSZ x1C,F
042C0:  BRA    42B6
042C2:  CLRF   00
042C4:  BCF    F95.4
042C6:  BCF    F95.0
042C8:  BCF    F8C.0
042CA:  BCF    F95.3
042CC:  BCF    F8C.3
042CE:  MOVFF  81B,81C
042D2:  BTFSS  x1A.7
042D4:  BCF    F8C.4
042D6:  BTFSC  x1A.7
042D8:  BSF    F8C.4
042DA:  RLCF   x17,F
042DC:  RLCF   x18,F
042DE:  RLCF   x19,F
042E0:  RLCF   x1A,F
042E2:  BSF    F8C.0
042E4:  BCF    F8C.0
042E6:  DECFSZ x1C,F
042E8:  BRA    42D2
042EA:  BSF    F8C.3
042EC:  MOVLB  0
042EE:  GOTO   4342 (RETURN)
.................... //#use spi(MASTER, DO=PIN_C4, DI=PIN_D4, CLK=PIN_C3, ENABLE=PIN_E2, MODE=0, BITS=16, STREAM=SPI_BME) 
....................  
.................... #define PWM_BUZZER PIN_D1 
.................... #use pwm(OUTPUT=PWM_BUZZER, FREQUENCY=260Hz, DUTY=50, PWM_OFF, STREAM=BUZZER) 
*
0448C:  BCF    FD8.1
0448E:  MOVFF  81D,822
04492:  MOVFF  81C,821
04496:  MOVFF  81B,820
0449A:  MOVFF  81A,81F
0449E:  MOVFF  819,826
044A2:  MOVFF  818,825
044A6:  MOVFF  817,824
044AA:  MOVFF  816,823
044AE:  RCALL  406A
044B0:  MOVF   02,W
044B2:  BNZ   44BC
044B4:  MOVF   01,W
044B6:  BNZ   44BC
044B8:  MOVF   00,W
044BA:  BNZ   44F8
044BC:  RRCF   02,F
044BE:  RRCF   01,F
044C0:  RRCF   00,F
044C2:  RRCF   02,F
044C4:  RRCF   01,F
044C6:  RRCF   00,F
044C8:  MOVLW  3F
044CA:  ANDWF  02,F
044CC:  MOVF   02,W
044CE:  BNZ   44D8
044D0:  MOVF   01,W
044D2:  BNZ   44D8
044D4:  MOVF   00,W
044D6:  BNZ   44FE
044D8:  RRCF   02,F
044DA:  RRCF   01,F
044DC:  RRCF   00,F
044DE:  RRCF   02,F
044E0:  RRCF   01,F
044E2:  RRCF   00,F
044E4:  MOVLW  3F
044E6:  ANDWF  02,F
044E8:  MOVF   02,W
044EA:  BNZ   44F4
044EC:  MOVF   01,W
044EE:  BNZ   44F4
044F0:  MOVF   00,W
044F2:  BNZ   4504
044F4:  CLRF   00
044F6:  BRA    4504
044F8:  MOVLW  04
044FA:  MOVWF  FBA
044FC:  BRA    4508
044FE:  MOVLW  05
04500:  MOVWF  FBA
04502:  BRA    4508
04504:  MOVLW  06
04506:  MOVWF  FBA
04508:  DECF   00,F
0450A:  MOVFF  00,FBB
0450E:  GOTO   4536 (RETURN)
....................  
.................... #use timer(TIMER=1, TICK=1ms, BITS=32, ISR) 
*
043C2:  MOVFF  56,01
043C6:  MOVF   FCE,W
043C8:  MOVFF  FCF,03
043CC:  BCF    F9D.0
043CE:  MOVWF  02
043D0:  MOVF   56,W
043D2:  SUBWF  01,W
043D4:  BZ    43DE
043D6:  MOVF   FCE,W
043D8:  MOVFF  FCF,03
043DC:  BRA    43E0
043DE:  MOVF   02,W
043E0:  MOVFF  03,00
043E4:  MOVFF  56,01
043E8:  MOVFF  57,02
043EC:  MOVFF  58,03
043F0:  MOVF   59,W
043F2:  BSF    F9D.0
043F4:  RETURN 0
*
045A2:  MOVFF  731,00
045A6:  MOVFF  732,01
045AA:  MOVFF  733,02
045AE:  MOVFF  734,03
045B2:  MOVLW  00
045B4:  BCF    FD8.0
045B6:  MOVWF  59
045B8:  MOVFF  03,58
045BC:  MOVFF  02,57
045C0:  MOVFF  01,56
045C4:  MOVFF  00,FCF
045C8:  CLRF   FCE
045CA:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////// 
....................  
....................  
.................... #include <.\Drivers\stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <.\Drivers\stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <.\Drivers\stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <.\Drivers\stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0952E:  MOVFF  706,03
09532:  MOVLB  7
09534:  MOVFF  705,FE9
09538:  MOVFF  03,FEA
0953C:  MOVFF  FEF,709
09540:  MOVFF  708,03
09544:  MOVFF  707,FE9
09548:  MOVFF  03,FEA
0954C:  MOVF   FEF,W
0954E:  SUBWF  x09,W
09550:  BNZ   9580
....................       if (*s1 == '\0') 
09552:  MOVFF  706,03
09556:  MOVFF  705,FE9
0955A:  MOVFF  03,FEA
0955E:  MOVF   FEF,F
09560:  BNZ   9568
....................          return(0); 
09562:  MOVLW  00
09564:  MOVWF  01
09566:  BRA    95AA
09568:  MOVFF  706,03
0956C:  MOVF   x05,W
0956E:  INCF   x05,F
09570:  BTFSC  FD8.2
09572:  INCF   x06,F
09574:  INCF   x07,F
09576:  BTFSC  FD8.2
09578:  INCF   x08,F
0957A:  MOVLB  0
0957C:  BRA    952E
0957E:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1); 
09580:  MOVFF  706,03
09584:  MOVFF  705,FE9
09588:  MOVFF  03,FEA
0958C:  MOVFF  FEF,709
09590:  MOVFF  708,03
09594:  MOVFF  707,FE9
09598:  MOVFF  03,FEA
0959C:  MOVF   FEF,W
0959E:  SUBWF  x09,W
095A0:  BC    95A6
095A2:  MOVLW  FF
095A4:  BRA    95A8
095A6:  MOVLW  01
095A8:  MOVWF  01
095AA:  MOVLB  0
095AC:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0C25C:  MOVLB  7
0C25E:  CLRF   x0E
....................    sign = 0; 
0C260:  CLRF   x0C
....................    base = 10; 
0C262:  MOVLW  0A
0C264:  MOVWF  x0D
....................    result = 0; 
0C266:  CLRF   x0B
....................  
....................    if (!s) 
0C268:  MOVF   x09,W
0C26A:  IORWF  x0A,W
0C26C:  BNZ   C274
....................       return 0; 
0C26E:  MOVLW  00
0C270:  MOVWF  01
0C272:  BRA    C424
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0C274:  MOVF   x0E,W
0C276:  INCF   x0E,F
0C278:  ADDWF  x09,W
0C27A:  MOVWF  FE9
0C27C:  MOVLW  00
0C27E:  ADDWFC x0A,W
0C280:  MOVWF  FEA
0C282:  MOVFF  FEF,70F
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0C286:  MOVF   x0F,W
0C288:  SUBLW  2D
0C28A:  BNZ   C2A4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0C28C:  MOVLW  01
0C28E:  MOVWF  x0C
....................       c = s[index++]; 
0C290:  MOVF   x0E,W
0C292:  INCF   x0E,F
0C294:  ADDWF  x09,W
0C296:  MOVWF  FE9
0C298:  MOVLW  00
0C29A:  ADDWFC x0A,W
0C29C:  MOVWF  FEA
0C29E:  MOVFF  FEF,70F
....................    } 
0C2A2:  BRA    C2BC
....................    else if (c == '+') 
0C2A4:  MOVF   x0F,W
0C2A6:  SUBLW  2B
0C2A8:  BNZ   C2BC
....................    { 
....................       c = s[index++]; 
0C2AA:  MOVF   x0E,W
0C2AC:  INCF   x0E,F
0C2AE:  ADDWF  x09,W
0C2B0:  MOVWF  FE9
0C2B2:  MOVLW  00
0C2B4:  ADDWFC x0A,W
0C2B6:  MOVWF  FEA
0C2B8:  MOVFF  FEF,70F
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0C2BC:  BTFSC  x0F.7
0C2BE:  BRA    C414
0C2C0:  MOVF   x0F,W
0C2C2:  SUBLW  2F
0C2C4:  BTFSC  FD8.0
0C2C6:  BRA    C414
0C2C8:  BTFSC  x0F.7
0C2CA:  BRA    C2D4
0C2CC:  MOVF   x0F,W
0C2CE:  SUBLW  39
0C2D0:  BTFSS  FD8.0
0C2D2:  BRA    C414
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0C2D4:  MOVF   x0F,W
0C2D6:  SUBLW  30
0C2D8:  BNZ   C316
0C2DA:  MOVF   x0E,W
0C2DC:  ADDWF  x09,W
0C2DE:  MOVWF  FE9
0C2E0:  MOVLW  00
0C2E2:  ADDWFC x0A,W
0C2E4:  MOVWF  FEA
0C2E6:  MOVF   FEF,W
0C2E8:  SUBLW  78
0C2EA:  BZ    C2FE
0C2EC:  MOVF   x0E,W
0C2EE:  ADDWF  x09,W
0C2F0:  MOVWF  FE9
0C2F2:  MOVLW  00
0C2F4:  ADDWFC x0A,W
0C2F6:  MOVWF  FEA
0C2F8:  MOVF   FEF,W
0C2FA:  SUBLW  58
0C2FC:  BNZ   C316
....................       { 
....................          base = 16; 
0C2FE:  MOVLW  10
0C300:  MOVWF  x0D
....................          index++; 
0C302:  INCF   x0E,F
....................          c = s[index++]; 
0C304:  MOVF   x0E,W
0C306:  INCF   x0E,F
0C308:  ADDWF  x09,W
0C30A:  MOVWF  FE9
0C30C:  MOVLW  00
0C30E:  ADDWFC x0A,W
0C310:  MOVWF  FEA
0C312:  MOVFF  FEF,70F
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C316:  MOVF   x0D,W
0C318:  SUBLW  0A
0C31A:  BNZ   C35E
....................       { 
....................          while (c >= '0' && c <= '9') 
0C31C:  BTFSC  x0F.7
0C31E:  BRA    C35C
0C320:  MOVF   x0F,W
0C322:  SUBLW  2F
0C324:  BC    C35C
0C326:  BTFSC  x0F.7
0C328:  BRA    C330
0C32A:  MOVF   x0F,W
0C32C:  SUBLW  39
0C32E:  BNC   C35C
....................          { 
....................             result = 10*result + (c - '0'); 
0C330:  MOVLW  0A
0C332:  MOVWF  x89
0C334:  MOVFF  70B,78A
0C338:  MOVLB  0
0C33A:  CALL   6832
0C33E:  MOVLW  30
0C340:  MOVLB  7
0C342:  SUBWF  x0F,W
0C344:  ADDWF  01,W
0C346:  MOVWF  x0B
....................             c = s[index++]; 
0C348:  MOVF   x0E,W
0C34A:  INCF   x0E,F
0C34C:  ADDWF  x09,W
0C34E:  MOVWF  FE9
0C350:  MOVLW  00
0C352:  ADDWFC x0A,W
0C354:  MOVWF  FEA
0C356:  MOVFF  FEF,70F
0C35A:  BRA    C31C
....................          } 
....................       } 
0C35C:  BRA    C414
....................       else if (base == 16)    // The number is a hexa number 
0C35E:  MOVF   x0D,W
0C360:  SUBLW  10
0C362:  BNZ   C414
....................       { 
....................          c = toupper(c); 
0C364:  BTFSC  x0F.7
0C366:  BRA    C37E
0C368:  MOVF   x0F,W
0C36A:  SUBLW  60
0C36C:  BC    C37E
0C36E:  BTFSC  x0F.7
0C370:  BRA    C378
0C372:  MOVF   x0F,W
0C374:  SUBLW  7A
0C376:  BNC   C37E
0C378:  MOVF   x0F,W
0C37A:  ANDLW  DF
0C37C:  BRA    C380
0C37E:  MOVF   x0F,W
0C380:  MOVWF  x0F
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0C382:  BTFSC  x0F.7
0C384:  BRA    C396
0C386:  MOVF   x0F,W
0C388:  SUBLW  2F
0C38A:  BC    C396
0C38C:  BTFSC  x0F.7
0C38E:  BRA    C3AA
0C390:  MOVF   x0F,W
0C392:  SUBLW  39
0C394:  BC    C3AA
0C396:  BTFSC  x0F.7
0C398:  BRA    C414
0C39A:  MOVF   x0F,W
0C39C:  SUBLW  40
0C39E:  BC    C414
0C3A0:  BTFSC  x0F.7
0C3A2:  BRA    C3AA
0C3A4:  MOVF   x0F,W
0C3A6:  SUBLW  46
0C3A8:  BNC   C414
....................          { 
....................             if (c >= '0' && c <= '9') 
0C3AA:  BTFSC  x0F.7
0C3AC:  BRA    C3D0
0C3AE:  MOVF   x0F,W
0C3B0:  SUBLW  2F
0C3B2:  BC    C3D0
0C3B4:  BTFSC  x0F.7
0C3B6:  BRA    C3BE
0C3B8:  MOVF   x0F,W
0C3BA:  SUBLW  39
0C3BC:  BNC   C3D0
....................                result = (result << 4) + (c - '0'); 
0C3BE:  SWAPF  x0B,W
0C3C0:  MOVWF  x10
0C3C2:  MOVLW  F0
0C3C4:  ANDWF  x10,F
0C3C6:  MOVLW  30
0C3C8:  SUBWF  x0F,W
0C3CA:  ADDWF  x10,W
0C3CC:  MOVWF  x0B
0C3CE:  BRA    C3E2
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0C3D0:  SWAPF  x0B,W
0C3D2:  MOVWF  x10
0C3D4:  MOVLW  F0
0C3D6:  ANDWF  x10,F
0C3D8:  MOVLW  41
0C3DA:  SUBWF  x0F,W
0C3DC:  ADDLW  0A
0C3DE:  ADDWF  x10,W
0C3E0:  MOVWF  x0B
....................  
....................             c = s[index++]; 
0C3E2:  MOVF   x0E,W
0C3E4:  INCF   x0E,F
0C3E6:  ADDWF  x09,W
0C3E8:  MOVWF  FE9
0C3EA:  MOVLW  00
0C3EC:  ADDWFC x0A,W
0C3EE:  MOVWF  FEA
0C3F0:  MOVFF  FEF,70F
....................             c = toupper(c); 
0C3F4:  BTFSC  x0F.7
0C3F6:  BRA    C40E
0C3F8:  MOVF   x0F,W
0C3FA:  SUBLW  60
0C3FC:  BC    C40E
0C3FE:  BTFSC  x0F.7
0C400:  BRA    C408
0C402:  MOVF   x0F,W
0C404:  SUBLW  7A
0C406:  BNC   C40E
0C408:  MOVF   x0F,W
0C40A:  ANDLW  DF
0C40C:  BRA    C410
0C40E:  MOVF   x0F,W
0C410:  MOVWF  x0F
0C412:  BRA    C382
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0C414:  DECFSZ x0C,W
0C416:  BRA    C420
0C418:  MOVF   x0D,W
0C41A:  SUBLW  0A
0C41C:  BNZ   C420
....................        result = -result; 
0C41E:  NEGF   x0B
....................  
....................    return(result); 
0C420:  MOVFF  70B,01
0C424:  MOVLB  0
0C426:  GOTO   C44A (RETURN)
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0BFEC:  MOVLB  7
0BFEE:  CLRF   x10
....................    sign = 0; 
0BFF0:  CLRF   x0E
....................    base = 10; 
0BFF2:  MOVLW  0A
0BFF4:  MOVWF  x0F
....................    result = 0; 
0BFF6:  CLRF   x0D
0BFF8:  CLRF   x0C
....................  
....................    if (!s) 
0BFFA:  MOVF   x0A,W
0BFFC:  IORWF  x0B,W
0BFFE:  BNZ   C008
....................       return 0; 
0C000:  MOVLW  00
0C002:  MOVWF  01
0C004:  MOVWF  02
0C006:  BRA    C220
....................    c = s[index++]; 
0C008:  MOVF   x10,W
0C00A:  INCF   x10,F
0C00C:  ADDWF  x0A,W
0C00E:  MOVWF  FE9
0C010:  MOVLW  00
0C012:  ADDWFC x0B,W
0C014:  MOVWF  FEA
0C016:  MOVFF  FEF,711
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0C01A:  MOVF   x11,W
0C01C:  SUBLW  2D
0C01E:  BNZ   C038
....................    { 
....................       sign = 1;         // Set the sign to negative 
0C020:  MOVLW  01
0C022:  MOVWF  x0E
....................       c = s[index++]; 
0C024:  MOVF   x10,W
0C026:  INCF   x10,F
0C028:  ADDWF  x0A,W
0C02A:  MOVWF  FE9
0C02C:  MOVLW  00
0C02E:  ADDWFC x0B,W
0C030:  MOVWF  FEA
0C032:  MOVFF  FEF,711
....................    } 
0C036:  BRA    C050
....................    else if (c == '+') 
0C038:  MOVF   x11,W
0C03A:  SUBLW  2B
0C03C:  BNZ   C050
....................    { 
....................       c = s[index++]; 
0C03E:  MOVF   x10,W
0C040:  INCF   x10,F
0C042:  ADDWF  x0A,W
0C044:  MOVWF  FE9
0C046:  MOVLW  00
0C048:  ADDWFC x0B,W
0C04A:  MOVWF  FEA
0C04C:  MOVFF  FEF,711
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0C050:  BTFSC  x11.7
0C052:  BRA    C204
0C054:  MOVF   x11,W
0C056:  SUBLW  2F
0C058:  BTFSC  FD8.0
0C05A:  BRA    C204
0C05C:  BTFSC  x11.7
0C05E:  BRA    C068
0C060:  MOVF   x11,W
0C062:  SUBLW  39
0C064:  BTFSS  FD8.0
0C066:  BRA    C204
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0C068:  MOVF   x11,W
0C06A:  SUBLW  30
0C06C:  BNZ   C0AA
0C06E:  MOVF   x10,W
0C070:  ADDWF  x0A,W
0C072:  MOVWF  FE9
0C074:  MOVLW  00
0C076:  ADDWFC x0B,W
0C078:  MOVWF  FEA
0C07A:  MOVF   FEF,W
0C07C:  SUBLW  78
0C07E:  BZ    C092
0C080:  MOVF   x10,W
0C082:  ADDWF  x0A,W
0C084:  MOVWF  FE9
0C086:  MOVLW  00
0C088:  ADDWFC x0B,W
0C08A:  MOVWF  FEA
0C08C:  MOVF   FEF,W
0C08E:  SUBLW  58
0C090:  BNZ   C0AA
....................       { 
....................          base = 16; 
0C092:  MOVLW  10
0C094:  MOVWF  x0F
....................          index++; 
0C096:  INCF   x10,F
....................          c = s[index++]; 
0C098:  MOVF   x10,W
0C09A:  INCF   x10,F
0C09C:  ADDWF  x0A,W
0C09E:  MOVWF  FE9
0C0A0:  MOVLW  00
0C0A2:  ADDWFC x0B,W
0C0A4:  MOVWF  FEA
0C0A6:  MOVFF  FEF,711
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C0AA:  MOVF   x0F,W
0C0AC:  SUBLW  0A
0C0AE:  BNZ   C112
....................       { 
....................          while (c >= '0' && c <= '9') 
0C0B0:  BTFSC  x11.7
0C0B2:  BRA    C110
0C0B4:  MOVF   x11,W
0C0B6:  SUBLW  2F
0C0B8:  BC    C110
0C0BA:  BTFSC  x11.7
0C0BC:  BRA    C0C4
0C0BE:  MOVF   x11,W
0C0C0:  SUBLW  39
0C0C2:  BNC   C110
0C0C4:  CLRF   19
0C0C6:  BTFSC  FF2.7
0C0C8:  BSF    19.7
0C0CA:  BCF    FF2.7
....................          { 
....................             result = 10*result + (c - '0'); 
0C0CC:  MOVLB  9
0C0CE:  CLRF   x6B
0C0D0:  MOVLW  0A
0C0D2:  MOVWF  x6A
0C0D4:  MOVFF  70D,96D
0C0D8:  MOVFF  70C,96C
0C0DC:  MOVLB  0
0C0DE:  CALL   0C48
0C0E2:  BTFSC  19.7
0C0E4:  BSF    FF2.7
0C0E6:  MOVLW  30
0C0E8:  MOVLB  7
0C0EA:  SUBWF  x11,W
0C0EC:  CLRF   03
0C0EE:  BTFSC  FE8.7
0C0F0:  DECF   03,F
0C0F2:  ADDWF  01,W
0C0F4:  MOVWF  x0C
0C0F6:  MOVF   03,W
0C0F8:  ADDWFC 02,W
0C0FA:  MOVWF  x0D
....................             c = s[index++]; 
0C0FC:  MOVF   x10,W
0C0FE:  INCF   x10,F
0C100:  ADDWF  x0A,W
0C102:  MOVWF  FE9
0C104:  MOVLW  00
0C106:  ADDWFC x0B,W
0C108:  MOVWF  FEA
0C10A:  MOVFF  FEF,711
0C10E:  BRA    C0B0
....................          } 
....................       } 
0C110:  BRA    C204
....................       else if (base == 16)    // The number is a hexa number 
0C112:  MOVF   x0F,W
0C114:  SUBLW  10
0C116:  BTFSS  FD8.2
0C118:  BRA    C204
....................       { 
....................          c = toupper(c); 
0C11A:  BTFSC  x11.7
0C11C:  BRA    C134
0C11E:  MOVF   x11,W
0C120:  SUBLW  60
0C122:  BC    C134
0C124:  BTFSC  x11.7
0C126:  BRA    C12E
0C128:  MOVF   x11,W
0C12A:  SUBLW  7A
0C12C:  BNC   C134
0C12E:  MOVF   x11,W
0C130:  ANDLW  DF
0C132:  BRA    C136
0C134:  MOVF   x11,W
0C136:  MOVWF  x11
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0C138:  BTFSC  x11.7
0C13A:  BRA    C14C
0C13C:  MOVF   x11,W
0C13E:  SUBLW  2F
0C140:  BC    C14C
0C142:  BTFSC  x11.7
0C144:  BRA    C160
0C146:  MOVF   x11,W
0C148:  SUBLW  39
0C14A:  BC    C160
0C14C:  BTFSC  x11.7
0C14E:  BRA    C204
0C150:  MOVF   x11,W
0C152:  SUBLW  40
0C154:  BC    C204
0C156:  BTFSC  x11.7
0C158:  BRA    C160
0C15A:  MOVF   x11,W
0C15C:  SUBLW  46
0C15E:  BNC   C204
....................          { 
....................             if (c >= '0' && c <= '9') 
0C160:  BTFSC  x11.7
0C162:  BRA    C1A4
0C164:  MOVF   x11,W
0C166:  SUBLW  2F
0C168:  BC    C1A4
0C16A:  BTFSC  x11.7
0C16C:  BRA    C174
0C16E:  MOVF   x11,W
0C170:  SUBLW  39
0C172:  BNC   C1A4
....................                result = (result << 4) + (c - '0'); 
0C174:  RLCF   x0C,W
0C176:  MOVWF  x12
0C178:  RLCF   x0D,W
0C17A:  MOVWF  x13
0C17C:  RLCF   x12,F
0C17E:  RLCF   x13,F
0C180:  RLCF   x12,F
0C182:  RLCF   x13,F
0C184:  RLCF   x12,F
0C186:  RLCF   x13,F
0C188:  MOVLW  F0
0C18A:  ANDWF  x12,F
0C18C:  MOVLW  30
0C18E:  SUBWF  x11,W
0C190:  CLRF   03
0C192:  MOVWF  00
0C194:  BTFSC  FE8.7
0C196:  DECF   03,F
0C198:  ADDWF  x12,W
0C19A:  MOVWF  x0C
0C19C:  MOVF   03,W
0C19E:  ADDWFC x13,W
0C1A0:  MOVWF  x0D
0C1A2:  BRA    C1D2
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0C1A4:  RLCF   x0C,W
0C1A6:  MOVWF  x12
0C1A8:  RLCF   x0D,W
0C1AA:  MOVWF  x13
0C1AC:  RLCF   x12,F
0C1AE:  RLCF   x13,F
0C1B0:  RLCF   x12,F
0C1B2:  RLCF   x13,F
0C1B4:  RLCF   x12,F
0C1B6:  RLCF   x13,F
0C1B8:  MOVLW  F0
0C1BA:  ANDWF  x12,F
0C1BC:  MOVLW  41
0C1BE:  SUBWF  x11,W
0C1C0:  ADDLW  0A
0C1C2:  CLRF   03
0C1C4:  BTFSC  FE8.7
0C1C6:  DECF   03,F
0C1C8:  ADDWF  x12,W
0C1CA:  MOVWF  x0C
0C1CC:  MOVF   03,W
0C1CE:  ADDWFC x13,W
0C1D0:  MOVWF  x0D
....................  
....................             c = s[index++];c = toupper(c); 
0C1D2:  MOVF   x10,W
0C1D4:  INCF   x10,F
0C1D6:  ADDWF  x0A,W
0C1D8:  MOVWF  FE9
0C1DA:  MOVLW  00
0C1DC:  ADDWFC x0B,W
0C1DE:  MOVWF  FEA
0C1E0:  MOVFF  FEF,711
0C1E4:  BTFSC  x11.7
0C1E6:  BRA    C1FE
0C1E8:  MOVF   x11,W
0C1EA:  SUBLW  60
0C1EC:  BC    C1FE
0C1EE:  BTFSC  x11.7
0C1F0:  BRA    C1F8
0C1F2:  MOVF   x11,W
0C1F4:  SUBLW  7A
0C1F6:  BNC   C1FE
0C1F8:  MOVF   x11,W
0C1FA:  ANDLW  DF
0C1FC:  BRA    C200
0C1FE:  MOVF   x11,W
0C200:  MOVWF  x11
0C202:  BRA    C138
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0C204:  MOVF   x0F,W
0C206:  SUBLW  0A
0C208:  BNZ   C218
0C20A:  DECFSZ x0E,W
0C20C:  BRA    C218
....................       result = -result; 
0C20E:  COMF   x0C,F
0C210:  COMF   x0D,F
0C212:  INCF   x0C,F
0C214:  BTFSC  FD8.2
0C216:  INCF   x0D,F
....................  
....................    return(result); 
0C218:  MOVFF  70C,01
0C21C:  MOVFF  70D,02
0C220:  MOVLB  0
0C222:  GOTO   C246 (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C4F4:  MOVLB  7
0C4F6:  CLRF   x24
0C4F8:  CLRF   x23
0C4FA:  CLRF   x22
0C4FC:  MOVLW  7F
0C4FE:  MOVWF  x21
0C500:  CLRF   x28
0C502:  CLRF   x27
0C504:  CLRF   x26
0C506:  CLRF   x25
0C508:  BSF    x29.0
0C50A:  BCF    x29.1
0C50C:  BCF    x29.2
0C50E:  CLRF   x2B
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C510:  MOVF   x1D,W
0C512:  IORWF  x1E,W
0C514:  BNZ   C520
....................       return 0; 
0C516:  CLRF   00
0C518:  CLRF   01
0C51A:  CLRF   02
0C51C:  CLRF   03
0C51E:  BRA    C764
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C520:  MOVF   x2B,W
0C522:  INCF   x2B,F
0C524:  ADDWF  x1D,W
0C526:  MOVWF  FE9
0C528:  MOVLW  00
0C52A:  ADDWFC x1E,W
0C52C:  MOVWF  FEA
0C52E:  MOVFF  FEF,72A
0C532:  MOVF   x2A,F
0C534:  BTFSC  FD8.2
0C536:  BRA    C6DE
....................    { 
....................       if (skip && !isspace(c)) 
0C538:  BTFSS  x29.0
0C53A:  BRA    C55A
0C53C:  MOVF   x2A,W
0C53E:  SUBLW  20
0C540:  BZ    C55A
....................       { 
....................          skip = 0; 
0C542:  BCF    x29.0
....................          if (c == '+') 
0C544:  MOVF   x2A,W
0C546:  SUBLW  2B
0C548:  BNZ   C550
....................          { 
....................             sign = 0; 
0C54A:  BCF    x29.1
....................             continue; 
0C54C:  BRA    C6C6
....................          }             
0C54E:  BRA    C55A
....................          else if (c == '-') 
0C550:  MOVF   x2A,W
0C552:  SUBLW  2D
0C554:  BNZ   C55A
....................          { 
....................             sign = 1; 
0C556:  BSF    x29.1
....................             continue; 
0C558:  BRA    C6C6
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C55A:  BTFSC  x29.0
0C55C:  BRA    C56C
0C55E:  MOVF   x2A,W
0C560:  SUBLW  2E
0C562:  BNZ   C56C
0C564:  BTFSC  x29.2
0C566:  BRA    C56C
....................          point = 1; 
0C568:  BSF    x29.2
0C56A:  BRA    C6C6
....................       else if (!skip && isdigit(c)) 
0C56C:  BTFSC  x29.0
0C56E:  BRA    C6C0
0C570:  BTFSC  x2A.7
0C572:  BRA    C6C0
0C574:  MOVF   x2A,W
0C576:  SUBLW  2F
0C578:  BTFSC  FD8.0
0C57A:  BRA    C6C0
0C57C:  BTFSC  x2A.7
0C57E:  BRA    C588
0C580:  MOVF   x2A,W
0C582:  SUBLW  39
0C584:  BTFSS  FD8.0
0C586:  BRA    C6C0
....................       { 
....................          c -= '0'; 
0C588:  MOVLW  30
0C58A:  SUBWF  x2A,F
....................          if (point) 
0C58C:  BTFSS  x29.2
0C58E:  BRA    C642
....................          { 
....................             pow10 = pow10 * 10.0; 
0C590:  MOVFF  724,835
0C594:  MOVFF  723,834
0C598:  MOVFF  722,833
0C59C:  MOVFF  721,832
0C5A0:  MOVLB  8
0C5A2:  CLRF   x39
0C5A4:  CLRF   x38
0C5A6:  MOVLW  20
0C5A8:  MOVWF  x37
0C5AA:  MOVLW  82
0C5AC:  MOVWF  x36
0C5AE:  MOVLB  0
0C5B0:  CALL   3F30
0C5B4:  MOVFF  03,724
0C5B8:  MOVFF  02,723
0C5BC:  MOVFF  01,722
0C5C0:  MOVFF  00,721
....................             result += (float)c / pow10;    
0C5C4:  MOVLB  7
0C5C6:  CLRF   x31
0C5C8:  MOVFF  72A,730
0C5CC:  BTFSC  x30.7
0C5CE:  DECF   x31,F
0C5D0:  MOVLB  0
0C5D2:  RCALL  C4A4
0C5D4:  MOVFF  03,72F
0C5D8:  MOVFF  02,72E
0C5DC:  MOVFF  01,72D
0C5E0:  MOVFF  00,72C
0C5E4:  MOVFF  03,819
0C5E8:  MOVFF  02,818
0C5EC:  MOVFF  01,817
0C5F0:  MOVFF  00,816
0C5F4:  MOVFF  724,81D
0C5F8:  MOVFF  723,81C
0C5FC:  MOVFF  722,81B
0C600:  MOVFF  721,81A
0C604:  CALL   6272
0C608:  BCF    FD8.1
0C60A:  MOVFF  728,835
0C60E:  MOVFF  727,834
0C612:  MOVFF  726,833
0C616:  MOVFF  725,832
0C61A:  MOVFF  03,839
0C61E:  MOVFF  02,838
0C622:  MOVFF  01,837
0C626:  MOVFF  00,836
0C62A:  CALL   6880
0C62E:  MOVFF  03,728
0C632:  MOVFF  02,727
0C636:  MOVFF  01,726
0C63A:  MOVFF  00,725
....................          } 
0C63E:  BRA    C6BC
0C640:  MOVLB  7
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C642:  MOVLB  8
0C644:  CLRF   x35
0C646:  CLRF   x34
0C648:  MOVLW  20
0C64A:  MOVWF  x33
0C64C:  MOVLW  82
0C64E:  MOVWF  x32
0C650:  MOVFF  728,839
0C654:  MOVFF  727,838
0C658:  MOVFF  726,837
0C65C:  MOVFF  725,836
0C660:  MOVLB  0
0C662:  CALL   3F30
0C666:  MOVFF  03,72F
0C66A:  MOVFF  02,72E
0C66E:  MOVFF  01,72D
0C672:  MOVFF  00,72C
0C676:  MOVLB  7
0C678:  CLRF   x31
0C67A:  MOVFF  72A,730
0C67E:  BTFSC  x30.7
0C680:  DECF   x31,F
0C682:  MOVLB  0
0C684:  RCALL  C4A4
0C686:  BCF    FD8.1
0C688:  MOVFF  72F,835
0C68C:  MOVFF  72E,834
0C690:  MOVFF  72D,833
0C694:  MOVFF  72C,832
0C698:  MOVFF  03,839
0C69C:  MOVFF  02,838
0C6A0:  MOVFF  01,837
0C6A4:  MOVFF  00,836
0C6A8:  CALL   6880
0C6AC:  MOVFF  03,728
0C6B0:  MOVFF  02,727
0C6B4:  MOVFF  01,726
0C6B8:  MOVFF  00,725
....................          } 
....................       } 
0C6BC:  BRA    C6C8
0C6BE:  MOVLB  7
....................       else if (!skip) 
0C6C0:  BTFSC  x29.0
0C6C2:  BRA    C6C6
....................          break; 
0C6C4:  BRA    C6DE
0C6C6:  MOVLB  0
0C6C8:  MOVLB  7
0C6CA:  MOVF   x2B,W
0C6CC:  INCF   x2B,F
0C6CE:  ADDWF  x1D,W
0C6D0:  MOVWF  FE9
0C6D2:  MOVLW  00
0C6D4:  ADDWFC x1E,W
0C6D6:  MOVWF  FEA
0C6D8:  MOVFF  FEF,72A
0C6DC:  BRA    C532
....................    } 
....................  
....................    if (sign) 
0C6DE:  BTFSS  x29.1
0C6E0:  BRA    C718
....................       result = -1*result; 
0C6E2:  MOVLB  8
0C6E4:  CLRF   x35
0C6E6:  CLRF   x34
0C6E8:  MOVLW  80
0C6EA:  MOVWF  x33
0C6EC:  MOVLW  7F
0C6EE:  MOVWF  x32
0C6F0:  MOVFF  728,839
0C6F4:  MOVFF  727,838
0C6F8:  MOVFF  726,837
0C6FC:  MOVFF  725,836
0C700:  MOVLB  0
0C702:  CALL   3F30
0C706:  MOVFF  03,728
0C70A:  MOVFF  02,727
0C70E:  MOVFF  01,726
0C712:  MOVFF  00,725
0C716:  MOVLB  7
....................        
....................    if(endptr) 
0C718:  MOVF   x1F,W
0C71A:  IORWF  x20,W
0C71C:  BZ    C754
....................    { 
....................       if (ptr) { 
0C71E:  MOVF   x2B,F
0C720:  BZ    C73E
....................          ptr--; 
0C722:  DECF   x2B,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0C724:  MOVFF  720,03
0C728:  MOVFF  71F,FE9
0C72C:  MOVFF  03,FEA
0C730:  MOVF   x2B,W
0C732:  ADDWF  x1D,W
0C734:  MOVWF  FEF
0C736:  MOVLW  00
0C738:  ADDWFC x1E,W
0C73A:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0C73C:  BRA    C754
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0C73E:  MOVFF  720,03
0C742:  MOVFF  71F,FE9
0C746:  MOVFF  03,FEA
0C74A:  MOVFF  71E,FEC
0C74E:  MOVF   FED,F
0C750:  MOVFF  71D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0C754:  MOVFF  725,00
0C758:  MOVFF  726,01
0C75C:  MOVFF  727,02
0C760:  MOVFF  728,03
0C764:  MOVLB  0
0C766:  GOTO   C790 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <.\Drivers\string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <.\Drivers\stddef.h> 
.................... #include <.\Drivers\ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <.\Drivers\string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <.\Drivers\stddef.h> 
.................... #include <.\Drivers\ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\ieeefloat.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                        ieeefloat.c                                //// 
.................... ////                                                                   //// 
.................... ////    This library converts IEEE float format to and from            //// 
.................... ////    the Microchip format used by PCB,PCM and PCH.                  //// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... float32 f_PICtoIEEE(unsigned int32) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format 
.................... PARAMS: 32 bit number 
.................... RETURNS: 32 bit Floating point number 
.................... */ 
.................... float32 f_PICtoIEEE(unsigned int32 pic) 
.................... { 
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.d = pic; 
....................     
....................    result.b[0] = data.b[3]; 
....................    result.b[1] = data.b[2]; 
....................    result.b[2] = data.b[1]; 
....................     
....................    if(bit_test(data.d,0)) 
....................       bit_set(result.b[2],7); 
....................    else 
....................       bit_clear(result.b[2],7); 
....................     
....................    shift_right(&data.b[0],1,bit_test(data.b[1],7)); 
....................    result.b[3] = data.b[0]; 
....................     
....................    return(result.f); 
.................... } 
.................... #else 
.................... /* 
.................... int32 f_PICtoIEEE(float f) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format in little endian mode 
.................... PARAMS: Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... int32 f_PICtoIEEE(float f) 
.................... { 
....................  
....................    int32 * ret; 
....................    #locate f=0x20 
....................  
....................    ret = &f;    
*
066E0:  MOVLB  8
066E2:  CLRF   x13
066E4:  MOVLW  20
066E6:  MOVWF  x12
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlf   0x21 
....................       rrf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
066E8:  RLCF   21,F
....................       rrcf   0x20 
066EA:  RRCF   20,F
....................       rrcf   0x21    
066EC:  RRCF   21,F
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
066EE:  MOVF   20,W
....................       xorwf  0x23,W 
066F0:  XORWF  23,W
....................       xorwf  0x23,F 
066F2:  XORWF  23,F
....................       xorwf  0x23,W 
066F4:  XORWF  23,W
....................       movwf  0x20 
066F6:  MOVWF  20
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
066F8:  MOVF   21,W
....................       xorwf  0x22,W 
066FA:  XORWF  22,W
....................       xorwf  0x22,F 
066FC:  XORWF  22,F
....................       xorwf  0x22,W 
066FE:  XORWF  22,W
....................       movwf  0x21 
06700:  MOVWF  21
....................     
....................    #endasm 
....................     
....................    return *ret; 
06702:  MOVFF  813,03
06706:  MOVFF  812,FE9
0670A:  MOVFF  03,FEA
0670E:  MOVFF  FEF,00
06712:  MOVFF  FEC,01
06716:  MOVFF  FEC,02
0671A:  MOVFF  FEC,03
0671E:  MOVLB  0
06720:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... unsigned int32 f_IEEEtoPIC(float32 f) 
.................... PURPOSE: This function converts IEEE format to float CCS -PIC format 
.................... PARAMS: 32 bit Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... unsigned int32 f_IEEEtoPIC(float32 ieee) 
.................... { 
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.f = ieee; 
....................     
....................    result.b[3] = data.b[0]; 
....................    result.b[2] = data.b[1]; 
....................    result.b[1] = data.b[2]; 
....................     
....................    if(bit_test(data.b[3],7)) 
....................       bit_set(result.b[1],7); 
....................    else 
....................       bit_clear(result.b[1],7); 
....................     
....................    result.b[0] = data.b[3]; 
....................     
....................    shift_left(&result.b[0],1,bit_test(data.b[2],7)); 
....................     
....................    return(result.d);    
.................... } 
.................... #else 
.................... /* 
.................... float f_IEEEtoPIC(int32 f) 
.................... PURPOSE: This function converts IEEE format to a float 
.................... PARAMS: 32 bit number 
.................... RETURNS: Floating point number 
.................... */ 
.................... float f_IEEEtoPIC(int32 f) 
.................... { 
....................  
....................    float * ret; 
....................    #locate f=0x20 
....................     
....................    ret = &f; 
*
0CAAA:  MOVLB  7
0CAAC:  CLRF   x19
0CAAE:  MOVLW  20
0CAB0:  MOVWF  x18
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
0CAB2:  MOVF   20,W
....................       xorwf  0x23,W 
0CAB4:  XORWF  23,W
....................       xorwf  0x23,F 
0CAB6:  XORWF  23,F
....................       xorwf  0x23,W 
0CAB8:  XORWF  23,W
....................       movwf  0x20 
0CABA:  MOVWF  20
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
0CABC:  MOVF   21,W
....................       xorwf  0x22,W 
0CABE:  XORWF  22,W
....................       xorwf  0x22,F 
0CAC0:  XORWF  22,F
....................       xorwf  0x22,W 
0CAC2:  XORWF  22,W
....................       movwf  0x21 
0CAC4:  MOVWF  21
....................  
....................    #endasm 
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................  
....................       // switch the bits 
....................       rlf   0x21 
....................       rlf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
0CAC6:  RLCF   21,F
....................       rlcf   0x20 
0CAC8:  RLCF   20,F
....................       rrcf   0x21    
0CACA:  RRCF   21,F
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    return *ret; 
0CACC:  MOVFF  719,03
0CAD0:  MOVFF  718,FE9
0CAD4:  MOVFF  03,FEA
0CAD8:  MOVFF  FEF,00
0CADC:  MOVFF  FEC,01
0CAE0:  MOVFF  FEC,02
0CAE4:  MOVFF  FEC,03
0CAE8:  MOVLB  0
0CAEA:  GOTO   CC12 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////// 
....................  
.................... #define STREAM_SERIAL_INPUT STDOUT 
.................... #include <.\Drivers\input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <.\Drivers\ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifndef InputKbhit 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputKbhit()    kbhit() 
....................    #endif 
.................... #endif 
....................  
.................... #if !definedinc(InputPutc) 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       void InputPutc(char c)    {fputc(c, STREAM_SERIAL_INPUT);} 
*
0BF56:  MOVLB  7
0BF58:  MOVF   x22,W
0BF5A:  MOVLB  0
0BF5C:  CALL   9526
0BF60:  RETURN 0
....................    #else 
....................       void InputPutc(char c)    {putc(c);} 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef InputGetc 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputGetc()    getc() 
....................    #endif 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
0BF62:  MOVLW  02
0BF64:  MOVLB  7
0BF66:  SUBWF  x1F,F
....................    len=0; 
0BF68:  CLRF   x20
....................    do { 
....................      c=InputGetc(); 
0BF6A:  MOVLB  0
0BF6C:  CALL   9500
0BF70:  MOVFF  01,721
....................      if(c==8) {  // Backspace 
0BF74:  MOVLB  7
0BF76:  MOVF   x21,W
0BF78:  SUBLW  08
0BF7A:  BNZ   BF9E
....................         if(len>0) { 
0BF7C:  MOVF   x20,F
0BF7E:  BZ    BF9C
....................           len--; 
0BF80:  DECF   x20,F
....................           InputPutc(c); 
0BF82:  MOVFF  721,722
0BF86:  MOVLB  0
0BF88:  RCALL  BF56
....................           InputPutc(' '); 
0BF8A:  MOVLW  20
0BF8C:  MOVLB  7
0BF8E:  MOVWF  x22
0BF90:  MOVLB  0
0BF92:  RCALL  BF56
....................           InputPutc(c); 
0BF94:  MOVFF  721,722
0BF98:  RCALL  BF56
0BF9A:  MOVLB  7
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0BF9C:  BRA    BFD4
0BF9E:  BTFSC  x21.7
0BFA0:  BRA    BFD4
0BFA2:  MOVF   x21,W
0BFA4:  SUBLW  1F
0BFA6:  BC    BFD4
0BFA8:  BTFSC  x21.7
0BFAA:  BRA    BFB2
0BFAC:  MOVF   x21,W
0BFAE:  SUBLW  7E
0BFB0:  BNC   BFD4
....................        if(len<=max) { 
0BFB2:  MOVF   x20,W
0BFB4:  SUBWF  x1F,W
0BFB6:  BNC   BFD4
....................          s[len++]=c; 
0BFB8:  MOVF   x20,W
0BFBA:  INCF   x20,F
0BFBC:  ADDWF  x1D,W
0BFBE:  MOVWF  FE9
0BFC0:  MOVLW  00
0BFC2:  ADDWFC x1E,W
0BFC4:  MOVWF  FEA
0BFC6:  MOVFF  721,FEF
....................          InputPutc(c); 
0BFCA:  MOVFF  721,722
0BFCE:  MOVLB  0
0BFD0:  RCALL  BF56
0BFD2:  MOVLB  7
....................        } 
....................    } while(c!=13); 
0BFD4:  MOVF   x21,W
0BFD6:  SUBLW  0D
0BFD8:  BNZ   BF6A
....................    s[len]=0; 
0BFDA:  MOVF   x20,W
0BFDC:  ADDWF  x1D,W
0BFDE:  MOVWF  FE9
0BFE0:  MOVLW  00
0BFE2:  ADDWFC x1E,W
0BFE4:  MOVWF  FEA
0BFE6:  CLRF   FEF
0BFE8:  MOVLB  0
0BFEA:  RETURN 0
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf(InputPutc, "%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
*
0C42A:  MOVLW  07
0C42C:  MOVLB  7
0C42E:  MOVWF  x1E
0C430:  MOVLW  03
0C432:  MOVWF  x1D
0C434:  MOVLW  05
0C436:  MOVWF  x1F
0C438:  MOVLB  0
0C43A:  RCALL  BF62
....................  
....................   i=atoi(s); 
0C43C:  MOVLW  07
0C43E:  MOVLB  7
0C440:  MOVWF  x0A
0C442:  MOVLW  03
0C444:  MOVWF  x09
0C446:  MOVLB  0
0C448:  BRA    C25C
0C44A:  MOVFF  01,708
....................   return(i); 
0C44E:  MOVLB  7
0C450:  MOVFF  708,01
0C454:  MOVLB  0
0C456:  RETURN 0
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
*
0C226:  MOVLW  07
0C228:  MOVLB  7
0C22A:  MOVWF  x1E
0C22C:  MOVLW  01
0C22E:  MOVWF  x1D
0C230:  MOVLW  07
0C232:  MOVWF  x1F
0C234:  MOVLB  0
0C236:  RCALL  BF62
....................   l=atol(s); 
0C238:  MOVLW  07
0C23A:  MOVLB  7
0C23C:  MOVWF  x0B
0C23E:  MOVLW  01
0C240:  MOVWF  x0A
0C242:  MOVLB  0
0C244:  BRA    BFEC
0C246:  MOVFF  02,709
0C24A:  MOVFF  01,708
....................   return(l); 
0C24E:  MOVLB  7
0C250:  MOVFF  708,01
0C254:  MOVFF  709,02
0C258:  MOVLB  0
0C25A:  RETURN 0
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float32 get_float() { 
....................   char s[20]; 
....................   float32 f; 
....................  
....................   get_string(s, 20); 
*
0C76A:  MOVLW  07
0C76C:  MOVLB  7
0C76E:  MOVWF  x1E
0C770:  MOVLW  05
0C772:  MOVWF  x1D
0C774:  MOVLW  14
0C776:  MOVWF  x1F
0C778:  MOVLB  0
0C77A:  CALL   BF62
....................   f = atof(s); 
0C77E:  MOVLW  07
0C780:  MOVLB  7
0C782:  MOVWF  x1E
0C784:  MOVLW  05
0C786:  MOVWF  x1D
0C788:  CLRF   x20
0C78A:  CLRF   x1F
0C78C:  MOVLB  0
0C78E:  BRA    C4F4
0C790:  MOVFF  03,71C
0C794:  MOVFF  02,71B
0C798:  MOVFF  01,71A
0C79C:  MOVFF  00,719
....................   return(f); 
0C7A0:  MOVFF  719,00
0C7A4:  MOVFF  71A,01
0C7A8:  MOVFF  71B,02
0C7AC:  MOVFF  71C,03
0C7B0:  GOTO   C7C2 (RETURN)
.................... } 
....................  
.................... #ifdef _STRING 
.................... float32 get_floatEdit(float old) { 
....................   char s[20]; 
....................   float32 f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
....................  
.................... //////////////////////////////////////// 
....................  
.................... typedef unsigned int8 uint8; 
.................... typedef unsigned int16 uint16; 
.................... typedef unsigned int32 uint32; 
....................  
.................... //////////////////////////////////////// 
....................  
.................... #define TURNOFF_AUTO_POWERDOWN 
.................... //#define SOFTWARE_DEBUG 
.................... #define BYPASS_BREATH_COLLECTION 
.................... //#define SKIP_WETCARTRIDGE_CHECK       
.................... //#define HIGH_SCORE_TEST 
.................... //#define SHORT_TIME 
.................... //#define TURN_OFF_BRIGHTNESS_CHECK   
....................  
....................  
.................... #define EEPROM_SDA PIN_C4 
.................... #define EEPROM_SCL PIN_C3 
....................  
.................... extern uint8 iosApp; 
.................... int8 TestMode = 0; 
....................  
.................... //#include <rtc.h> 
....................  
.................... //////////////////////////////////////// 
.................... void ShowPrompt() { 
....................    fprintf(STDOUT, "[I50 V%lu.%lu.%lu", 
....................      FIRMWARE_VERSION_MAJOR, 
....................      FIRMWARE_VERSION_MINOR, 
....................      FIRMWARE_VERSION_REVISION); 
*
04E82:  MOVLW  6C
04E84:  MOVWF  FF6
04E86:  MOVLW  04
04E88:  MOVWF  FF7
04E8A:  CLRF   19
04E8C:  BTFSC  FF2.7
04E8E:  BSF    19.7
04E90:  BCF    FF2.7
04E92:  MOVLW  06
04E94:  MOVLB  9
04E96:  MOVWF  x66
04E98:  MOVLB  0
04E9A:  CALL   0AAC
04E9E:  BTFSC  19.7
04EA0:  BSF    FF2.7
04EA2:  MOVLW  10
04EA4:  MOVWF  FE9
04EA6:  CLRF   19
04EA8:  BTFSC  FF2.7
04EAA:  BSF    19.7
04EAC:  BCF    FF2.7
04EAE:  MOVLB  9
04EB0:  CLRF   x67
04EB2:  CLRF   x66
04EB4:  MOVLB  0
04EB6:  CALL   0AD6
04EBA:  BTFSC  19.7
04EBC:  BSF    FF2.7
04EBE:  MOVLW  2E
04EC0:  BTFSS  FA4.4
04EC2:  BRA    4EC0
04EC4:  MOVWF  F73
04EC6:  MOVLW  10
04EC8:  MOVWF  FE9
04ECA:  CLRF   19
04ECC:  BTFSC  FF2.7
04ECE:  BSF    19.7
04ED0:  BCF    FF2.7
04ED2:  MOVLB  9
04ED4:  CLRF   x67
04ED6:  MOVLW  41
04ED8:  MOVWF  x66
04EDA:  MOVLB  0
04EDC:  CALL   0AD6
04EE0:  BTFSC  19.7
04EE2:  BSF    FF2.7
04EE4:  MOVLW  2E
04EE6:  BTFSS  FA4.4
04EE8:  BRA    4EE6
04EEA:  MOVWF  F73
04EEC:  MOVLW  10
04EEE:  MOVWF  FE9
04EF0:  CLRF   19
04EF2:  BTFSC  FF2.7
04EF4:  BSF    19.7
04EF6:  BCF    FF2.7
04EF8:  MOVLB  9
04EFA:  CLRF   x67
04EFC:  MOVLW  02
04EFE:  MOVWF  x66
04F00:  MOVLB  0
04F02:  CALL   0AD6
04F06:  BTFSC  19.7
04F08:  BSF    FF2.7
.................... //   PrintRtcTime(); 
....................    fprintf(STDOUT, "] "); 
04F0A:  MOVLW  5D
04F0C:  BTFSS  FA4.4
04F0E:  BRA    4F0C
04F10:  MOVWF  F73
04F12:  MOVLW  20
04F14:  BTFSS  FA4.4
04F16:  BRA    4F14
04F18:  MOVWF  F73
04F1A:  RETURN 0
.................... } 
....................  
.................... #include <24256-custom.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B1 
.................... #define EEPROM_SCL  PIN_B0 
....................  
.................... #endif 
....................  
.................... // Use the declaration in main.h instead. I need the "Slow" parameter apparently 
.................... // #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... typedef long int EepromAddress; 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
02AE4:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
02AE6:  BSF    F94.4
02AE8:  GOTO   D25E (RETURN)
.................... } 
....................  
.................... //#define CONFIG_SERIAL 20 
....................  
.................... void write_ext_eeprom(EepromAddress address, BYTE data) 
.................... { 
....................    short int status; 
....................     
....................    i2c_start(); 
*
009EC:  BSF    FC5.0
009EE:  BTFSC  FC5.0
009F0:  BRA    09EE
....................    i2c_write(0xa0); 
009F2:  MOVLW  A0
009F4:  MOVLB  9
009F6:  MOVWF  x7A
009F8:  MOVLB  0
009FA:  RCALL  09D0
....................    i2c_write(address>>8); 
009FC:  MOVFF  975,978
00A00:  MOVLB  9
00A02:  CLRF   x79
00A04:  MOVFF  975,97A
00A08:  MOVLB  0
00A0A:  RCALL  09D0
....................    i2c_write(address); 
00A0C:  MOVFF  974,97A
00A10:  RCALL  09D0
....................    i2c_write(data); 
00A12:  MOVFF  976,97A
00A16:  RCALL  09D0
....................    i2c_stop(); 
00A18:  BSF    FC5.2
00A1A:  BTFSC  FC5.2
00A1C:  BRA    0A1A
....................    i2c_start(); 
00A1E:  BSF    FC5.0
00A20:  BTFSC  FC5.0
00A22:  BRA    0A20
....................    status=i2c_write(0xa0); 
00A24:  MOVLW  A0
00A26:  MOVLB  9
00A28:  MOVWF  x7A
00A2A:  MOVLB  0
00A2C:  RCALL  09D0
00A2E:  MOVF   01,W
00A30:  MOVLB  9
00A32:  BCF    x77.0
00A34:  BTFSC  01.0
00A36:  BSF    x77.0
....................     
....................    while(status==1)  
00A38:  BTFSS  x77.0
00A3A:  BRA    0A56
....................    { 
....................       i2c_start(); 
00A3C:  BSF    FC5.1
00A3E:  BTFSC  FC5.1
00A40:  BRA    0A3E
....................       status=i2c_write(0xa0); 
00A42:  MOVLW  A0
00A44:  MOVWF  x7A
00A46:  MOVLB  0
00A48:  RCALL  09D0
00A4A:  MOVF   01,W
00A4C:  MOVLB  9
00A4E:  BCF    x77.0
00A50:  BTFSC  01.0
00A52:  BSF    x77.0
00A54:  BRA    0A38
....................    } 
....................     
....................    i2c_stop(); 
00A56:  BSF    FC5.2
00A58:  BTFSC  FC5.2
00A5A:  BRA    0A58
00A5C:  MOVLB  0
00A5E:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(EepromAddress address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
02C1A:  BSF    FC5.0
02C1C:  BTFSC  FC5.0
02C1E:  BRA    2C1C
02C20:  CLRF   19
02C22:  BTFSC  FF2.7
02C24:  BSF    19.7
02C26:  BCF    FF2.7
....................    i2c_write(0xa0); 
02C28:  MOVLW  A0
02C2A:  MOVLB  9
02C2C:  MOVWF  x7A
02C2E:  MOVLB  0
02C30:  CALL   09D0
02C34:  BTFSC  19.7
02C36:  BSF    FF2.7
....................    i2c_write(address>>8); 
02C38:  MOVFF  75F,761
02C3C:  MOVLB  7
02C3E:  CLRF   x62
02C40:  CLRF   19
02C42:  BTFSC  FF2.7
02C44:  BSF    19.7
02C46:  BCF    FF2.7
02C48:  MOVFF  75F,97A
02C4C:  MOVLB  0
02C4E:  CALL   09D0
02C52:  BTFSC  19.7
02C54:  BSF    FF2.7
02C56:  CLRF   19
02C58:  BTFSC  FF2.7
02C5A:  BSF    19.7
02C5C:  BCF    FF2.7
....................    i2c_write(address); 
02C5E:  MOVFF  75E,97A
02C62:  CALL   09D0
02C66:  BTFSC  19.7
02C68:  BSF    FF2.7
....................    i2c_start(); 
02C6A:  BSF    FC5.1
02C6C:  BTFSC  FC5.1
02C6E:  BRA    2C6C
02C70:  CLRF   19
02C72:  BTFSC  FF2.7
02C74:  BSF    19.7
02C76:  BCF    FF2.7
....................    i2c_write(0xa1); 
02C78:  MOVLW  A1
02C7A:  MOVLB  9
02C7C:  MOVWF  x7A
02C7E:  MOVLB  0
02C80:  CALL   09D0
02C84:  BTFSC  19.7
02C86:  BSF    FF2.7
....................    data=i2c_read(0); 
02C88:  CLRF   00
02C8A:  RCALL  2BFE
02C8C:  MOVFF  01,760
02C90:  MOVLB  7
....................    i2c_stop(); 
02C92:  BSF    FC5.2
02C94:  BTFSC  FC5.2
02C96:  BRA    2C94
....................    return(data); 
02C98:  MOVFF  760,01
02C9C:  MOVLB  0
02C9E:  RETURN 0
.................... } 
....................  
.................... uint16 EepromReadInt16(EepromAddress address) { 
....................    uint16 x; 
....................    uint8 *p = &x; 
....................    p[0]= read_ext_eeprom(address++); 
....................    p[1]= read_ext_eeprom(address); 
....................     
....................    return x; 
.................... } 
....................  
....................  
.................... void EepromWriteInt16(EepromAddress address, uint16 x) { 
....................    uint8 *p = &x; 
....................    write_ext_eeprom(address++,p[0]); 
....................    write_ext_eeprom(address,p[1]); 
.................... } 
....................  
.................... #include <DS3231.c> 
.................... #include "DS3231.h" 
....................  
.................... // https://www.ccsinfo.com/forum/viewtopic.php?t=50256 
....................  
.................... #ifndef DS3231_H 
.................... #define DS3231_H 
....................  
.................... #define DS3231_Address              0x68 
....................  
.................... #define DS3231_Read_addr            ((DS3231_Address << 1) | 0x01) 
.................... #define DS3231_Write_addr           ((DS3231_Address << 1) & 0xFE) 
....................  
.................... #define secondREG                   0x00 
.................... #define minuteREG                   0x01 
.................... #define hourREG                     0x02 
.................... #define dayREG                      0x03 
.................... #define dateREG                     0x04 
.................... #define monthREG                    0x05 
.................... #define yearREG                     0x06 
.................... #define alarm1secREG                0x07 
.................... #define alarm1minREG                0x08 
.................... #define alarm1hrREG                 0x09 
.................... #define alarm1dateREG               0x0A 
.................... #define alarm2minREG                0x0B 
.................... #define alarm2hrREG                 0x0C 
.................... #define alarm2dateREG               0x0D 
.................... #define controlREG                  0x0E 
.................... #define statusREG                   0x0F 
.................... #define ageoffsetREG                0x10 
.................... #define tempMSBREG                  0x11 
.................... #define tempLSBREG                  0x12 
....................  
.................... #define _24_hour_format             0 
.................... #define _12_hour_format             1 
.................... #define am                          0 
.................... #define pm                          1 
....................  
....................  
.................... unsigned char bcd_to_decimal(unsigned char d); 
.................... unsigned char decimal_to_bcd(unsigned char d); 
.................... unsigned char DS3231_Read(unsigned char address); 
.................... void DS3231_Write(unsigned char address, unsigned char value); 
.................... void DS3231_init(); 
.................... void getTime(unsigned char &p3, unsigned char &p2, unsigned char &p1, short &p0, short hour_format); 
.................... void getDate(unsigned char &p4, unsigned char &p3, unsigned char &p2, unsigned char &p1); 
.................... void setTime(unsigned char hSet, unsigned char mSet, unsigned char sSet, short am_pm_state, short hour_format); 
.................... void setDate(unsigned char daySet, unsigned char dateSet, unsigned char monthSet, unsigned char yearSet); 
.................... float getTemp(); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... unsigned char bcd_to_decimal(unsigned char d) 
.................... { 
....................    return ((d & 0x0F) + (((d & 0xF0) >> 4) * 10)); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... unsigned char decimal_to_bcd(unsigned char d) 
.................... { 
....................    return (((d / 10) << 4) & 0xF0) | ((d % 10) & 0x0F); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... unsigned char DS3231_Read(unsigned char address) 
.................... { 
....................    unsigned char value = 0; 
....................    i2c_start(); 
....................    i2c_write(DS3231_Write_addr); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(DS3231_Read_addr); 
....................    value = i2c_read(0); 
....................    i2c_stop(); 
....................    return value; 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void DS3231_Write(unsigned char address, unsigned char value) 
.................... { 
....................    i2c_start(); 
....................    i2c_write(DS3231_Write_addr); 
....................    i2c_write(address); 
....................    i2c_write(value); 
....................    i2c_stop(); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void DS3231_init() 
.................... { 
....................    DS3231_Write(controlREG, 0x00); 
....................    DS3231_Write(statusREG, 0x08); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void getTime(unsigned char &p3, unsigned char &p2, unsigned char &p1, short &p0, short hour_format) 
.................... { 
....................    unsigned char tmp = 0; 
....................    p1 = DS3231_Read(secondREG); 
....................    p1 = bcd_to_decimal(p1); 
....................    p2 = DS3231_Read(minuteREG); 
....................    p2 = bcd_to_decimal(p2); 
....................     
....................    switch(hour_format) 
....................    { 
....................       case 1: 
....................       { 
....................          tmp = DS3231_Read(hourREG); 
....................          tmp &= 0x20; 
....................          p0 = (short)(tmp >> 5); 
....................          p3 = (0x1F & DS3231_Read(hourREG)); 
....................          p3 = bcd_to_decimal(p3); 
....................          break; 
....................       } 
....................        
....................       default: 
....................       { 
....................          p3 = (0x3F & DS3231_Read(hourREG)); 
....................          p3 = bcd_to_decimal(p3); 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void getDate(unsigned char &p4, unsigned char &p3, unsigned char &p2, unsigned char &p1) 
.................... { 
....................    p1 = DS3231_Read(yearREG); 
....................    p1 = bcd_to_decimal(p1); 
....................    p2 = (0x1F & DS3231_Read(monthREG)); 
....................    p2 = bcd_to_decimal(p2); 
....................    p3 = (0x3F & DS3231_Read(dateREG)); 
....................    p3 = bcd_to_decimal(p3); 
....................    p4 = (0x07 & DS3231_Read(dayREG)); 
....................    p4 = bcd_to_decimal(p4); 
.................... } 
....................  
....................  
.................... void setTime(unsigned char hSet, unsigned char mSet, unsigned char sSet, short am_pm_state, short hour_format) 
.................... { 
....................    unsigned char tmp = 0; 
....................    DS3231_Write(secondREG, (decimal_to_bcd(sSet))); 
....................    DS3231_Write(minuteREG, (decimal_to_bcd(mSet))); 
....................    switch(hour_format) 
....................    { 
....................       case 1: 
....................       { 
....................          switch(am_pm_state) 
....................          { 
....................             case 1: 
....................             { 
....................                tmp = 0x60; 
....................                break; 
....................             } 
....................              
....................             default: 
....................             { 
....................                tmp = 0x40; 
....................                break; 
....................             } 
....................          } 
....................           
....................          DS3231_Write(hourREG, ((tmp | (0x1F & (decimal_to_bcd(hSet)))))); 
....................          break; 
....................       } 
....................  
....................       default: 
....................       { 
....................          DS3231_Write(hourREG, (0x3F & (decimal_to_bcd(hSet)))); 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void setDate(unsigned char daySet, unsigned char dateSet, unsigned char monthSet, unsigned char yearSet) 
.................... { 
....................    DS3231_Write(dayREG, (decimal_to_bcd(daySet))); 
....................    DS3231_Write(dateREG, (decimal_to_bcd(dateSet))); 
....................    DS3231_Write(monthREG, (decimal_to_bcd(monthSet))); 
....................    DS3231_Write(yearREG, (decimal_to_bcd(yearSet))); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... float getTemp() 
.................... { 
....................    register float t = 0.0; 
....................    unsigned char lowByte = 0; 
....................    signed char highByte = 0; 
....................    lowByte = DS3231_Read(tempLSBREG); 
....................    highByte = DS3231_Read(tempMSBREG); 
....................    lowByte >>= 6; 
....................    lowByte &= 0x03; 
....................    t = ((float)lowByte); 
....................    t *= 0.25; 
....................    t += highByte; 
....................    return t; 
.................... } 
....................  
.................... #include <config.c> 
.................... #include <ble.h> 
.................... #ifndef __BLE__ 
.................... #define __BLE__ 
....................  
....................  
.................... typedef struct bd_addr_t 
.................... { 
....................   uint8 addr[6]; 
.................... } bd_addr; 
....................  
.................... typedef bd_addr hwaddr; 
....................  
.................... typedef struct 
.................... { 
....................   uint8 len; 
....................   uint8 data[]; 
.................... } uint8array; 
....................  
.................... struct ble_header 
.................... { 
....................     uint8  type_hilen; 
....................     uint8  lolen; 
....................     uint8  cls; 
....................     uint8  command; 
.................... }; 
....................  
.................... struct ble_msg_system_boot_evt_t 
.................... { 
....................    uint16   major; 
....................    uint16   minor; 
....................    uint16   patch; 
....................    uint16   build; 
....................    uint16   ll_version; 
....................    uint8    protocol_version; 
....................    uint8    hw; 
.................... }; 
....................  
.................... struct ble_msg_attributes_value_evt_t 
.................... { 
....................    uint8       connection; 
....................    uint8       reason; 
....................    uint16      handle; 
....................    uint16      offset; 
....................    uint8array  value; 
.................... }; 
....................  
.................... #define BLE_RESET_PIN PIN_B2 
....................  
.................... #define BLE_HANDLE_SERIAL_NUMBER 17 
.................... #define BLE_HANDLE_DEVICE_STAT 21 
.................... #define BLE_HANDLE_TEST_STAGE 25 
.................... #define BLE_HANDLE_TEST_STAT 29 
.................... #define BLE_HANDLE_TEST_REPORT 33 
.................... #define BLE_HANDLE_INDEX_START 37 
.................... #define BLE_HANDLE_INDEX_STOP 41 
.................... #define BLE_HANDLE_INDEX_CURRENT 45 
.................... #define BLE_HANDLE_READING 48 
.................... #define BLE_HANDLE_READING_IN_PROGRESS 52 
.................... #define BLE_HANDLE_OPCODE 56 
.................... #define BLE_HANDLE_STATE_CODE 59 
.................... #define BLE_HANDLE_ERROR_CODE 63 
....................  
.................... #define BLE_HANDLE_RX 68 
.................... #define BLE_HANDLE_TX 71 
....................  
.................... enum BleOpcodes  
.................... { 
....................    OPCODE_BLE_START_KETONE_TEST = 0, 
....................    OPCODE_BLE_START_AMMONIA_TEST, 
....................    OPCODE_RESET_USE_COUNTER, 
....................    OPCODE_RESET_READINGS, 
....................    OPCODE_RESET_STATE_MACHINE = 0XFA, 
....................    OPCODE_BLE_START_FIRMWARE_UPDATE = 0xFF, 
....................  
.................... }; 
....................  
.................... void ble_cmd_system_hello(); 
.................... void ble_cmd_system_AddressGet(); 
.................... void ble_cmd_gap_set_mode(uint8 discover, uint8 connect); 
.................... void ble_cmd_attributes_write(uint16 handle, uint8 offset, uint8 length, uint8 *value); 
.................... void ble_wait(int32 timeout); 
.................... void ble_wait_for_message(uint8 start); 
.................... void ble_process(); 
.................... void ConstructBleModule(); 
.................... void DisableBleModule(); 
.................... void bleNotifyErrorSet(int8 errorBit); 
.................... void bleNotifyErrorReset(int8 errorBit); 
.................... uint8 ble_log_process(); 
.................... void ble_configure(); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define CONFIG_LED730_BRIGHTNESS_ADDRESS 0 
.................... #define CONFIG_LED588_BRIGHTNESS_ADDRESS 1 
.................... #define CONFIG_LED475_BRIGHTNESS_ADDRESS 2 
....................  
.................... //32 bits float 
.................... #define CONFIG_SLOPE 10 
.................... #define CONFIG_INTERCEPT 14 
.................... #define CONFIG_LED_BRIGHTNESS_CALIBRATED 19     // 1 bytes 
....................  
.................... // The serial number is 6 sequential bytes. For example {1, 2, 3, 4, 5, 6} for a serial number of "123456" 
.................... #define CONFIG_SERIAL 20  
....................  
.................... //16 bit unsigned int 
.................... #define CONFIG_BREATH_VOLUME 26 
.................... #define CONFIG_MOUTHPIECE_USES 28 
....................  
.................... // Index are 16 bit 
.................... #define CONFIG_READING_INDEX_START 30 
.................... #define CONFIG_READING_INDEX_STOP 32 
....................  
.................... // 8 Bit 
.................... #define CONFIG_DYNAMIC_WHITEBALANCE_ENABLED 34 
....................  
.................... #define CONFIG_READING_BASE   CONFIG_DYNAMIC_WHITEBALANCE_ENABLED + 6 
.................... #define CONFIG_READING_COUNT  10 
.................... #define CONFIG_READING_END    CONFIG_READING_BASE + ( sizeof(struct reading ) * CONFIG_READING_COUNT ) // Where 18 is size of reading struct 
....................  
....................  
.................... #ifdef BASE_40 
.................... #define CONFIG_READING_END 280 // 40 + (12 * 20) 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////// 
....................  
.................... void config_serial_set(uint8 * serial)  
.................... { 
....................   for(uint8 i = 0; i < 6; i++) { 
*
0C458:  MOVLB  7
0C45A:  CLRF   x03
0C45C:  MOVF   x03,W
0C45E:  SUBLW  05
0C460:  BNC   C49E
....................     write_ext_eeprom(CONFIG_SERIAL + i, *(serial + i)); 
0C462:  MOVLW  14
0C464:  ADDWF  x03,W
0C466:  MOVWF  x04
0C468:  MOVF   x03,W
0C46A:  ADDWF  x01,W
0C46C:  MOVWF  01
0C46E:  MOVLW  00
0C470:  ADDWFC x02,W
0C472:  MOVWF  03
0C474:  MOVFF  01,FE9
0C478:  MOVWF  FEA
0C47A:  MOVFF  FEF,976
0C47E:  CLRF   19
0C480:  BTFSC  FF2.7
0C482:  BSF    19.7
0C484:  BCF    FF2.7
0C486:  MOVLB  9
0C488:  CLRF   x75
0C48A:  MOVFF  704,974
0C48E:  MOVLB  0
0C490:  CALL   09EC
0C494:  BTFSC  19.7
0C496:  BSF    FF2.7
0C498:  MOVLB  7
0C49A:  INCF   x03,F
0C49C:  BRA    C45C
....................   } 
0C49E:  MOVLB  0
0C4A0:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... void config_serial_get(uint8 * serial)  
.................... { 
....................   for(uint8 i = 0; i < 6; i++)  
*
02F32:  MOVLB  7
02F34:  CLRF   x27
02F36:  MOVF   x27,W
02F38:  SUBLW  05
02F3A:  BNC   2F6E
....................   { 
....................     serial[i] = read_ext_eeprom(CONFIG_SERIAL + i); 
02F3C:  MOVF   x27,W
02F3E:  ADDWF  x25,W
02F40:  MOVWF  01
02F42:  MOVLW  00
02F44:  ADDWFC x26,W
02F46:  MOVWF  03
02F48:  MOVFF  01,728
02F4C:  MOVWF  x29
02F4E:  MOVLW  14
02F50:  ADDWF  x27,W
02F52:  MOVWF  x2A
02F54:  CLRF   x5F
02F56:  MOVWF  x5E
02F58:  MOVLB  0
02F5A:  RCALL  2C1A
02F5C:  MOVFF  729,FEA
02F60:  MOVFF  728,FE9
02F64:  MOVFF  01,FEF
02F68:  MOVLB  7
02F6A:  INCF   x27,F
02F6C:  BRA    2F36
....................   } 
02F6E:  MOVLB  0
02F70:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
....................  
.................... void ConfigWriteFloat(long int address, float32 data) 
*
00A60:  MOVLW  09
00A62:  MOVLB  9
00A64:  MOVWF  x71
00A66:  MOVLW  6C
00A68:  MOVWF  x70
.................... { 
....................    int *p = &data; 
....................    for (int i=0; i<4; i++, address++) 
00A6A:  CLRF   x72
00A6C:  BTFSC  x72.7
00A6E:  BRA    0A76
00A70:  MOVF   x72,W
00A72:  SUBLW  03
00A74:  BNC   0AA8
....................       write_ext_eeprom(address, p[i]); 
00A76:  CLRF   03
00A78:  MOVF   x72,W
00A7A:  MOVWF  00
00A7C:  BTFSC  FE8.7
00A7E:  DECF   03,F
00A80:  ADDWF  x70,W
00A82:  MOVWF  FE9
00A84:  MOVF   x71,W
00A86:  ADDWFC 03,W
00A88:  MOVWF  FEA
00A8A:  MOVFF  FEF,976
00A8E:  MOVFF  96B,975
00A92:  MOVFF  96A,974
00A96:  MOVLB  0
00A98:  RCALL  09EC
00A9A:  MOVLB  9
00A9C:  MOVF   x72,W
00A9E:  INCF   x72,F
00AA0:  INCF   x6A,F
00AA2:  BTFSC  FD8.2
00AA4:  INCF   x6B,F
00AA6:  BRA    0A6C
00AA8:  MOVLB  0
00AAA:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... float32 ConfigReadFloat(long int address) 
*
03B00:  MOVLW  07
03B02:  MOVLB  7
03B04:  MOVWF  x5A
03B06:  MOVLW  55
03B08:  MOVWF  x59
.................... { 
....................    float32 data; 
....................    int *p = &data; 
....................  
....................    for (int i=0; i<4; i++, address++) 
03B0A:  CLRF   x5B
03B0C:  BTFSC  x5B.7
03B0E:  BRA    3B16
03B10:  MOVF   x5B,W
03B12:  SUBLW  03
03B14:  BNC   3B58
....................       p[i] = read_ext_eeprom(address); 
03B16:  CLRF   03
03B18:  MOVF   x5B,W
03B1A:  MOVWF  00
03B1C:  BTFSC  FE8.7
03B1E:  DECF   03,F
03B20:  ADDWF  x59,W
03B22:  MOVWF  01
03B24:  MOVF   x5A,W
03B26:  ADDWFC 03,F
03B28:  MOVFF  01,75C
03B2C:  MOVFF  03,75D
03B30:  MOVFF  754,75F
03B34:  MOVFF  753,75E
03B38:  MOVLB  0
03B3A:  CALL   2C1A
03B3E:  MOVFF  75D,FEA
03B42:  MOVFF  75C,FE9
03B46:  MOVFF  01,FEF
03B4A:  MOVLB  7
03B4C:  MOVF   x5B,W
03B4E:  INCF   x5B,F
03B50:  INCF   x53,F
03B52:  BTFSC  FD8.2
03B54:  INCF   x54,F
03B56:  BRA    3B0C
....................  
....................    return data; 
03B58:  MOVFF  755,00
03B5C:  MOVFF  756,01
03B60:  MOVFF  757,02
03B64:  MOVFF  758,03
03B68:  MOVLB  0
03B6A:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... int ConfigReadByte(long int address)  
.................... { 
....................    return read_ext_eeprom(address); 
*
0429C:  MOVFF  753,75F
042A0:  MOVFF  752,75E
042A4:  CALL   2C1A
042A8:  MOVF   01,W
042AA:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... void ConfigWriteByte(long int address, int data)  
*
0556C:  CLRF   19
0556E:  BTFSC  FF2.7
05570:  BSF    19.7
05572:  BCF    FF2.7
.................... { 
....................    write_ext_eeprom(address, data); 
05574:  MOVFF  74C,975
05578:  MOVFF  74B,974
0557C:  MOVFF  74D,976
05580:  CALL   09EC
05584:  BTFSC  19.7
05586:  BSF    FF2.7
05588:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... uint16 ConfigReadInt16(long int address)  
.................... { 
....................    uint16 data; 
....................    int *p = &data; 
....................     
....................    p[0] = read_ext_eeprom(address++); 
....................    p[1] = read_ext_eeprom(address); 
....................    return data; 
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... void ConfigWriteIn16(long int address, uint16 data)  
.................... { 
....................    int *p = &data; 
....................    write_ext_eeprom(address, p[0]); 
....................    write_ext_eeprom(address, p[1]); 
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... #ifdef BASE_40 
....................  
.................... #define CONFIG_SERVO_UP_TIME 280 // 2 bytes 
.................... #define CONFIG_SERVO_PARK_TIME 282 // 2 bytes 
.................... #define CONFIG_SERVO_DOWN_TIME 284 // 2 bytes 
....................  
.................... uint16 ServoUpTime; 
.................... uint16 ServoParkTime; 
.................... uint16 ServoDownTime; 
.................... uint8 g_bottle_uses = 0; 
.................... uint8 lastbottleUses = 0xFF; 
....................  
.................... uint8 config_bottle_uses_get() { 
....................    g_bottle_uses = read_ext_eeprom(CONFIG_BOTTLE_USES); 
....................    fprintf(STDOUT, "Tank-uses counter=%u\r\n", g_bottle_uses); 
....................    if (lastbottleUses != g_bottle_uses) { 
....................       lastbottleUses = g_bottle_uses; 
....................       ble_cmd_attributes_write(BLE_HANDLE_TANK_COUNTER, 0, 1, &lastbottleUses); 
....................       while(!ble_log_process()); 
....................    } 
....................    return g_bottle_uses; 
.................... } 
....................  
.................... void config_bottle_uses_set(uint8 value) { 
....................    g_bottle_uses = value; 
....................    write_ext_eeprom(CONFIG_BOTTLE_USES, value); 
....................    config_bottle_uses_get(); 
.................... } 
....................  
.................... void config_bottle_uses_increment() { 
....................   uint8 i = config_bottle_uses_get(); 
....................  
....................   i = i + 1; 
....................   config_bottle_uses_set(i); 
.................... } 
....................  
.................... void config_bottle_uses_decrement() { 
....................   uint8 i = config_bottle_uses_get(); 
....................  
....................   i = i - 1; 
....................   if (i>127) 
....................     i = 0; 
....................      
....................   config_bottle_uses_set(i); 
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
....................  
.................... uint8 g_mouthpiece_uses = 0; 
.................... uint8 lastMouthpieceUses = 0xFE; 
....................  
.................... uint8 config_mouthpiece_get() 
.................... { 
....................   g_mouthpiece_uses = read_ext_eeprom(CONFIG_MOUTHPIECE_USES); 
....................   fprintf(STDOUT, "Mouthpiece-uses counter=%u\r\n", g_mouthpiece_uses); 
....................    if (lastMouthpieceUses != g_mouthpiece_uses)  
....................    { 
....................       lastMouthpieceUses = g_mouthpiece_uses; 
....................       ble_cmd_attributes_write(BLE_HANDLE_MOUTHPIECE_COUNTER, 0, 1, &lastMouthpieceUses); 
....................      while(!ble_log_process()); 
....................    } 
....................   return g_mouthpiece_uses; 
.................... } 
....................  
.................... void config_mouthpiece_set(uint8 value) { 
....................    g_mouthpiece_uses = value; 
....................    write_ext_eeprom(CONFIG_MOUTHPIECE_USES, value); 
....................    config_mouthpiece_get(); 
.................... } 
....................  
.................... void config_mouthpiece_increment() { 
....................   uint8 i = config_mouthpiece_get(); 
....................  
....................   i = i + 1; 
....................   config_mouthpiece_set(i); 
.................... } 
....................  
.................... ////////////////////////////////////////////////// 
.................... void InitializeServo() { 
....................    ServoUpTime = EepromReadInt16(CONFIG_SERVO_UP_TIME); 
....................    fprintf(STDOUT, "ServoUpTime= %lu us\r\n", ServoUpTime); 
....................    if (ServoUpTime == 0) { 
....................       ServoUpTime = 1200; 
....................       EepromWriteInt16(CONFIG_SERVO_UP_TIME, ServoUpTime); 
....................       fprintf(STDOUT, "ServoUpTime initialized to %lu us\r\n", ServoUpTime); 
....................    } 
....................     
....................    ServoParkTime = EepromReadInt16(CONFIG_SERVO_PARK_TIME); 
....................    fprintf(STDOUT, "ServoParkTime= %lu us\r", ServoParkTime); 
....................    if (ServoParkTime < 100) { 
....................       ServoParkTime = 900; 
....................       EepromWriteInt16(CONFIG_SERVO_PARK_TIME, ServoParkTime); 
....................       fprintf(STDOUT, "ServoParkTime initialized to %lu us\r\n", ServoParkTime); 
....................    } 
....................     
....................    ServoDownTime = EepromReadInt16(CONFIG_SERVO_DOWN_TIME); 
....................    fprintf(STDOUT, "ServoDownTime= %lu us\r", ServoDownTime); 
....................    if (ServoDownTime < 100) { 
....................       ServoDownTime = 800; 
....................       EepromWriteInt16(CONFIG_SERVO_DOWN_TIME, ServoDownTime); 
....................       fprintf(STDOUT, "ServoDownTime initialized to %lu us\r\n", ServoDownTime); 
....................    }    
.................... } 
....................  
.................... uint16 ConfigGetServoUpTime() { 
....................    uint16 x = EepromReadInt16(CONFIG_SERVO_UP_TIME); 
....................    fprintf(STDOUT, "ServoUpTime= %lu us\r\n", x); 
....................    return x; 
.................... } 
....................  
.................... uint16 ConfigGetServoParkTime() { 
....................    uint16 x = EepromReadInt16(CONFIG_SERVO_PARK_TIME); 
....................    fprintf(STDOUT, "ServoParkTime= %lu us\r\n", x); 
....................    return x; 
.................... } 
....................  
.................... uint16 ConfigGetServoDownTime() { 
....................    uint16 x = EepromReadInt16(CONFIG_SERVO_DOWN_TIME); 
....................    fprintf(STDOUT, "ServoDownTime= %lu us\r\n", x); 
....................    return x; 
.................... } 
....................  
.................... void ConfigSetServoUpTime(uint16 x) { 
....................    EepromWriteInt16(CONFIG_SERVO_UP_TIME, x); 
....................    ServoUpTime = x; 
....................    fprintf(STDOUT, "ServoUpTime changed to %lu us\r\n", x); 
.................... } 
....................  
.................... void ConfigSetServoParkTime(uint16 x) { 
....................    EepromWriteInt16(CONFIG_SERVO_PARK_TIME, x); 
....................    ServoParkTime = x; 
....................    fprintf(STDOUT, "ServoParkTime changed to %lu us\r\n", x); 
.................... } 
.................... void ConfigSetServoDownTime(uint16 x) { 
....................    EepromWriteInt16(CONFIG_SERVO_DOWN_TIME, x); 
....................    ServoDownTime = x; 
....................    fprintf(STDOUT, "ServoDownTime changed to %lu us\r\n", x); 
.................... } 
.................... #endif 
....................  
.................... #include <ble.c> 
.................... #include <reading.h> 
.................... #ifndef __READING__ 
.................... #define __READING__ 
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define READING_ERROR_NONE                   0 
.................... #define READING_ERROR_TRAY_OPENED            1 
.................... #define READING_ERROR_CARTRIDGE_REMOVED      2 
.................... #define READING_ERROR_BOTTLE_DOOR_OPENED     3 
.................... #define READING_ERROR_CARTRIDGE_FORGOTTEN    4 
.................... #define READING_ERROR_MODULE_NOT_STRAIGHT    5 
.................... #define READING_ERROR_BAD_TEMPERATURE        6 
.................... #define READING_ERROR_BAD_ORIENTATION        7 
.................... #define READING_ERROR_BAD_READING            8 
....................  
.................... #ifdef BASE_40 
.................... // Total Size: 12 
.................... struct reading  
.................... { 
....................   uint32 timestamp; 
....................  
....................   // NOTE: WARNING. This is actually a float. 
....................   // However the PIC processor does not use IEEE-754 floats 
....................   // so we have to convert manually. 
....................   int32 value; 
....................   uint16 status; 
....................   uint16 FullTestStepID; 
.................... }; 
....................  
.................... void reading_save(uint32 timestamp, float32 value, uint16 status, uint16 fullTestStepID); 
.................... #endif 
....................  
.................... // Total Size: 18 
.................... struct reading  
.................... { 
....................    struct testResultPara   testResult; 
....................    struct timePara         time; 
....................    // NOTE: WARNING. This is actually a float. 
....................    // However the PIC processor does not use IEEE-754 floats 
....................    // so we have to convert manually. 
....................  
.................... }; 
....................  
.................... void readings_reset(); 
.................... uint16 reading_index_start(); 
.................... uint16 reading_index_stop(); 
.................... struct reading reading_fetch(uint16 index); 
.................... void reading_save(struct testResultPara *testResult, struct timePara *timestamp); 
.................... void reading_simulate(); 
....................  
.................... uint16 SetFullTestStepID(uint16 stepID); 
....................  
.................... #endif 
....................  
....................  
.................... #include <ble.h> 
.................... #ifndef __BLE__ 
.................... #define __BLE__ 
....................  
....................  
.................... typedef struct bd_addr_t 
.................... { 
....................   uint8 addr[6]; 
.................... } bd_addr; 
....................  
.................... typedef bd_addr hwaddr; 
....................  
.................... typedef struct 
.................... { 
....................   uint8 len; 
....................   uint8 data[]; 
.................... } uint8array; 
....................  
.................... struct ble_header 
.................... { 
....................     uint8  type_hilen; 
....................     uint8  lolen; 
....................     uint8  cls; 
....................     uint8  command; 
.................... }; 
....................  
.................... struct ble_msg_system_boot_evt_t 
.................... { 
....................    uint16   major; 
....................    uint16   minor; 
....................    uint16   patch; 
....................    uint16   build; 
....................    uint16   ll_version; 
....................    uint8    protocol_version; 
....................    uint8    hw; 
.................... }; 
....................  
.................... struct ble_msg_attributes_value_evt_t 
.................... { 
....................    uint8       connection; 
....................    uint8       reason; 
....................    uint16      handle; 
....................    uint16      offset; 
....................    uint8array  value; 
.................... }; 
....................  
.................... #define BLE_RESET_PIN PIN_B2 
....................  
.................... #define BLE_HANDLE_SERIAL_NUMBER 17 
.................... #define BLE_HANDLE_DEVICE_STAT 21 
.................... #define BLE_HANDLE_TEST_STAGE 25 
.................... #define BLE_HANDLE_TEST_STAT 29 
.................... #define BLE_HANDLE_TEST_REPORT 33 
.................... #define BLE_HANDLE_INDEX_START 37 
.................... #define BLE_HANDLE_INDEX_STOP 41 
.................... #define BLE_HANDLE_INDEX_CURRENT 45 
.................... #define BLE_HANDLE_READING 48 
.................... #define BLE_HANDLE_READING_IN_PROGRESS 52 
.................... #define BLE_HANDLE_OPCODE 56 
.................... #define BLE_HANDLE_STATE_CODE 59 
.................... #define BLE_HANDLE_ERROR_CODE 63 
....................  
.................... #define BLE_HANDLE_RX 68 
.................... #define BLE_HANDLE_TX 71 
....................  
.................... enum BleOpcodes  
.................... { 
....................    OPCODE_BLE_START_KETONE_TEST = 0, 
....................    OPCODE_BLE_START_AMMONIA_TEST, 
....................    OPCODE_RESET_USE_COUNTER, 
....................    OPCODE_RESET_READINGS, 
....................    OPCODE_RESET_STATE_MACHINE = 0XFA, 
....................    OPCODE_BLE_START_FIRMWARE_UPDATE = 0xFF, 
....................  
.................... }; 
....................  
.................... void ble_cmd_system_hello(); 
.................... void ble_cmd_system_AddressGet(); 
.................... void ble_cmd_gap_set_mode(uint8 discover, uint8 connect); 
.................... void ble_cmd_attributes_write(uint16 handle, uint8 offset, uint8 length, uint8 *value); 
.................... void ble_wait(int32 timeout); 
.................... void ble_wait_for_message(uint8 start); 
.................... void ble_process(); 
.................... void ConstructBleModule(); 
.................... void DisableBleModule(); 
.................... void bleNotifyErrorSet(int8 errorBit); 
.................... void bleNotifyErrorReset(int8 errorBit); 
.................... uint8 ble_log_process(); 
.................... void ble_configure(); 
....................  
....................  
.................... #endif 
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... extern uint8   bluetoothState; 
.................... extern uint16  breathVolume; 
.................... extern struct  commandPara   cmdReceived; 
....................  
.................... extern struct testResultPara  testResult; 
.................... extern struct statusPara      testTime; 
.................... extern struct deviceInfoPara  deviceStat; 
.................... extern struct testInfoPara    testStat; 
....................  
....................  
....................  
.................... uint8 ble_log_buffer[256]; 
.................... uint8 ble_log_buffer_head = 0; 
.................... uint8 ble_log_buffer_tail = 0; 
.................... uint8 BleModuleId[BLE_MODULE_ID_SIZE] = {0x01, 0x02, 0x0E, 0x0C, 0x0A, 0x0F} ; 
....................  
.................... int8 ErrorBits = 0; 
.................... int8 LastErrorBits = 0; 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_log(char * message, uint8 length)  
.................... { 
....................  
.................... #ifdef BASE_40 
....................    //Note- Sum of this data type will never be greater than 256 
....................    if (ble_log_buffer_tail + length > 256)  
....................       return; 
.................... #endif 
....................  
....................    for(uint8 i = 0; i < length; i++) 
*
00CE2:  MOVLB  9
00CE4:  CLRF   x69
00CE6:  MOVF   x68,W
00CE8:  SUBWF  x69,W
00CEA:  BC    0D22
....................    { 
....................       ble_log_buffer[ble_log_buffer_tail] = message[i]; 
00CEC:  CLRF   03
00CEE:  MOVLB  3
00CF0:  MOVF   x49,W
00CF2:  ADDLW  48
00CF4:  MOVWF  01
00CF6:  MOVLW  02
00CF8:  ADDWFC 03,F
00CFA:  MOVLB  9
00CFC:  MOVF   x69,W
00CFE:  ADDWF  x66,W
00D00:  MOVWF  FE9
00D02:  MOVLW  00
00D04:  ADDWFC x67,W
00D06:  MOVWF  FEA
00D08:  MOVFF  FEF,96C
00D0C:  MOVFF  03,FEA
00D10:  MOVFF  01,FE9
00D14:  MOVFF  96C,FEF
....................       ble_log_buffer_tail++; 
00D18:  MOVLB  3
00D1A:  INCF   x49,F
00D1C:  MOVLB  9
00D1E:  INCF   x69,F
00D20:  BRA    0CE6
....................    } 
00D22:  MOVLB  0
00D24:  GOTO   17DC (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 ble_log_process()  
*
02D56:  MOVLB  8
02D58:  CLRF   x13
.................... { 
....................   uint8 did_work = 0; 
....................  
....................   while(ble_log_buffer_head < ble_log_buffer_tail)  
02D5A:  MOVLB  3
02D5C:  MOVF   x49,W
02D5E:  SUBWF  x48,W
02D60:  BC    2D78
....................   { 
....................     did_work = 1; 
02D62:  MOVLW  01
02D64:  MOVLB  8
02D66:  MOVWF  x13
....................  
....................     //fputc(ble_log_buffer[ble_log_buffer_head], STDOUT); 
....................     ble_log_buffer_head++; 
02D68:  MOVLB  3
02D6A:  INCF   x48,F
....................     if (ble_log_buffer_head == ble_log_buffer_tail) 
02D6C:  MOVF   x49,W
02D6E:  SUBWF  x48,W
02D70:  BNZ   2D76
....................     { 
....................        ble_log_buffer_head = 0; 
02D72:  CLRF   x48
....................        ble_log_buffer_tail = 0; 
02D74:  CLRF   x49
....................     } 
02D76:  BRA    2D5C
....................   } 
....................  
....................   return did_work; 
02D78:  MOVLB  8
02D7A:  MOVFF  813,01
02D7E:  MOVLB  0
02D80:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 ble_header_equals(struct ble_header * hdr, uint8 type_hilen, uint8 lolen, uint8 cls, uint8 command) 
.................... { 
....................    return (hdr->type_hilen == type_hilen && hdr->cls == cls && hdr->command == command); 
*
00756:  MOVLB  9
00758:  MOVFF  966,FE9
0075C:  MOVFF  967,FEA
00760:  MOVF   x68,W
00762:  SUBWF  FEF,W
00764:  BNZ   078A
00766:  MOVLW  02
00768:  ADDWF  x66,W
0076A:  MOVWF  FE9
0076C:  MOVLW  00
0076E:  ADDWFC x67,W
00770:  MOVWF  FEA
00772:  MOVF   x6A,W
00774:  SUBWF  FEF,W
00776:  BNZ   078A
00778:  MOVLW  03
0077A:  ADDWF  x66,W
0077C:  MOVWF  FE9
0077E:  MOVLW  00
00780:  ADDWFC x67,W
00782:  MOVWF  FEA
00784:  MOVF   x6B,W
00786:  SUBWF  FEF,W
00788:  BZ    078E
0078A:  MOVLW  00
0078C:  BRA    0790
0078E:  MOVLW  01
00790:  MOVWF  01
00792:  MOVLB  0
00794:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_cmd_system_hello() 
.................... { 
....................    fputc(0x04, BLE); 
*
02D82:  MOVLW  04
02D84:  CALL   07D6
....................  
....................    fputc(0x00, BLE); 
02D88:  MOVLW  00
02D8A:  CALL   07D6
....................    fputc(0x00, BLE); 
02D8E:  MOVLW  00
02D90:  CALL   07D6
....................    fputc(0x00, BLE); 
02D94:  MOVLW  00
02D96:  CALL   07D6
....................    fputc(0x01, BLE); 
02D9A:  MOVLW  01
02D9C:  CALL   07D6
02DA0:  GOTO   3040 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_cmd_system_AddressGet() 
.................... { 
....................    fputc(0x04, BLE); 
02DA4:  MOVLW  04
02DA6:  CALL   07D6
....................  
....................    fputc(0x00, BLE); 
02DAA:  MOVLW  00
02DAC:  CALL   07D6
....................    fputc(0x00, BLE); 
02DB0:  MOVLW  00
02DB2:  CALL   07D6
....................    fputc(0x00, BLE); 
02DB6:  MOVLW  00
02DB8:  CALL   07D6
....................    fputc(0x02, BLE); 
02DBC:  MOVLW  02
02DBE:  CALL   07D6
02DC2:  GOTO   3072 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_cmd_gap_set_mode(uint8 discover, uint8 connect) 
.................... { 
....................    fputc(0x06, BLE); 
*
007DE:  MOVLW  06
007E0:  RCALL  07D6
....................  
....................    fputc(0x00, BLE); 
007E2:  MOVLW  00
007E4:  RCALL  07D6
....................    fputc(0x02, BLE); 
007E6:  MOVLW  02
007E8:  RCALL  07D6
....................    fputc(0x06, BLE); 
007EA:  MOVLW  06
007EC:  RCALL  07D6
....................    fputc(0x01, BLE); 
007EE:  MOVLW  01
007F0:  RCALL  07D6
....................  
....................    fputc(discover, BLE); 
007F2:  MOVLB  9
007F4:  MOVF   x66,W
007F6:  MOVLB  0
007F8:  RCALL  07D6
....................    fputc(connect, BLE); 
007FA:  MOVLB  9
007FC:  MOVF   x67,W
007FE:  MOVLB  0
00800:  RCALL  07D6
00802:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_cmd_attributes_write(uint16 handle, uint8 offset, uint8 length, uint8 *value) 
.................... { 
....................    fputc(0x04 + 0x4 + length, BLE); 
*
02E2E:  MOVLW  08
02E30:  MOVLB  8
02E32:  ADDWF  x16,W
02E34:  MOVWF  x19
02E36:  MOVF   x19,W
02E38:  MOVLB  0
02E3A:  CALL   07D6
....................  
....................    fputc(0x00, BLE); 
02E3E:  MOVLW  00
02E40:  CALL   07D6
....................    fputc(0x04 + length, BLE); 
02E44:  MOVLW  04
02E46:  MOVLB  8
02E48:  ADDWF  x16,W
02E4A:  MOVWF  x19
02E4C:  MOVF   x19,W
02E4E:  MOVLB  0
02E50:  CALL   07D6
....................    fputc(0x02, BLE); 
02E54:  MOVLW  02
02E56:  CALL   07D6
....................    fputc(0x00, BLE); 
02E5A:  MOVLW  00
02E5C:  CALL   07D6
....................  
....................    fputc(handle & 0xff, BLE); 
02E60:  MOVLB  8
02E62:  MOVF   x13,W
02E64:  MOVWF  x19
02E66:  CLRF   x1A
02E68:  MOVF   x19,W
02E6A:  MOVLB  0
02E6C:  CALL   07D6
....................    handle >>= 8; 
02E70:  MOVFF  814,813
02E74:  MOVLB  8
02E76:  CLRF   x14
....................    fputc(handle & 0xff, BLE); 
02E78:  MOVF   x13,W
02E7A:  MOVWF  x19
02E7C:  CLRF   x1A
02E7E:  MOVF   x19,W
02E80:  MOVLB  0
02E82:  CALL   07D6
....................  
....................    fputc(offset, BLE); 
02E86:  MOVLB  8
02E88:  MOVF   x15,W
02E8A:  MOVLB  0
02E8C:  CALL   07D6
....................    fputc(length, BLE); 
02E90:  MOVLB  8
02E92:  MOVF   x16,W
02E94:  MOVLB  0
02E96:  CALL   07D6
....................  
....................    while(length--)  
02E9A:  MOVLB  8
02E9C:  MOVF   x16,W
02E9E:  DECF   x16,F
02EA0:  XORLW  00
02EA2:  BZ    2EC6
....................    { 
....................       fputc(*value, BLE); 
02EA4:  MOVFF  818,03
02EA8:  MOVF   x17,W
02EAA:  MOVWF  FE9
02EAC:  MOVFF  03,FEA
02EB0:  MOVFF  FEF,819
02EB4:  MOVF   x19,W
02EB6:  MOVLB  0
02EB8:  CALL   07D6
....................       value++; 
02EBC:  MOVLB  8
02EBE:  INCF   x17,F
02EC0:  BTFSC  FD8.2
02EC2:  INCF   x18,F
02EC4:  BRA    2E9C
....................    } 
02EC6:  MOVLB  0
02EC8:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_wait(int32 timeout) 
*
043F6:  MOVLB  7
043F8:  CLRF   x5C
043FA:  CLRF   x5B
043FC:  CLRF   x5A
043FE:  CLRF   x59
04400:  CLRF   x60
04402:  CLRF   x5F
04404:  CLRF   x5E
04406:  CLRF   x5D
04408:  CLRF   x64
0440A:  CLRF   x63
0440C:  CLRF   x62
0440E:  CLRF   x61
.................... { 
....................    int32 timer_current = 0; 
....................    int32 timer_previous = 0; 
....................    int32 timer_difference = 0; 
....................  
....................    timer_previous = get_ticks(); 
04410:  MOVLB  0
04412:  RCALL  43C2
04414:  MOVFF  03,760
04418:  MOVFF  02,75F
0441C:  MOVFF  01,75E
04420:  MOVFF  00,75D
....................     
....................    while(TRUE)  
....................    { 
....................       timer_current = get_ticks(); 
04424:  RCALL  43C2
04426:  MOVFF  03,75C
0442A:  MOVFF  02,75B
0442E:  MOVFF  01,75A
04432:  MOVFF  00,759
....................       timer_difference = timer_current - timer_previous; 
04436:  MOVLB  7
04438:  MOVF   x5D,W
0443A:  SUBWF  x59,W
0443C:  MOVWF  x61
0443E:  MOVF   x5E,W
04440:  SUBWFB x5A,W
04442:  MOVWF  x62
04444:  MOVF   x5F,W
04446:  SUBWFB x5B,W
04448:  MOVWF  x63
0444A:  MOVF   x60,W
0444C:  SUBWFB x5C,W
0444E:  MOVWF  x64
....................        
....................       if(timer_difference > timeout) 
04450:  BTFSS  x58.7
04452:  BRA    445A
04454:  BTFSS  x64.7
04456:  BRA    447C
04458:  BRA    445E
0445A:  BTFSC  x64.7
0445C:  BRA    447E
0445E:  MOVF   x58,W
04460:  SUBWF  x64,W
04462:  BNC   447E
04464:  BNZ   447C
04466:  MOVF   x57,W
04468:  SUBWF  x63,W
0446A:  BNC   447E
0446C:  BNZ   447C
0446E:  MOVF   x56,W
04470:  SUBWF  x62,W
04472:  BNC   447E
04474:  BNZ   447C
04476:  MOVF   x61,W
04478:  SUBWF  x55,W
0447A:  BC    447E
....................          break; 
0447C:  BRA    4488
....................  
....................       ble_log_process(); 
0447E:  MOVLB  0
04480:  CALL   2D56
04484:  BRA    4424
04486:  MOVLB  7
....................    } 
04488:  MOVLB  0
0448A:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 ble_data_buffer[256]; 
.................... uint8 ble_data_index = 0; 
.................... uint8 ble_data_message_count = 0; 
.................... uint8 iosApp = 0; 
.................... uint8 FullTestRunning = 0; 
....................  
.................... int16 transmit_reading_at_index = -1; 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void ble_wait_for_message(uint8 start) 
.................... { 
....................   while(start == ble_data_message_count); 
*
092C0:  MOVLB  4
092C2:  MOVF   x53,W
092C4:  MOVLB  7
092C6:  SUBWF  x1B,W
092C8:  BTFSS  FD8.2
092CA:  BRA    92D0
092CC:  MOVLB  0
092CE:  BRA    92C0
092D0:  MOVLB  0
092D2:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void ble_process()  
*
00D28:  MOVLW  03
00D2A:  MOVLB  8
00D2C:  MOVWF  x47
00D2E:  MOVLW  52
00D30:  MOVWF  x46
00D32:  MOVLW  03
00D34:  MOVWF  x49
00D36:  MOVLW  56
00D38:  MOVWF  x48
00D3A:  MOVLB  9
00D3C:  CLRF   x52
.................... { 
....................    struct   ble_header * hdr = &ble_data_buffer; 
....................    uint8 *  data = &ble_data_buffer + 4; 
....................    uint8 *  srcPtr, *destPtr, cmd, tmpCtr; 
....................    uint16   tmpVolume; 
....................    char message[256]; 
....................    uint8 length = 0; 
....................     
....................    //incoming data 
....................    //srcPtr = data; 
....................    //Skip the header 
....................    //srcPtr += 6; 
....................     
....................    destPtr = &cmdReceived; 
00D3E:  MOVLW  02
00D40:  MOVLB  8
00D42:  MOVWF  x4D
00D44:  MOVLW  05
00D46:  MOVWF  x4C
....................  
....................    if(ble_header_equals(hdr, 0x80, 0x00, 0x00, 0x00))  
00D48:  MOVFF  847,967
00D4C:  MOVFF  846,966
00D50:  MOVLW  80
00D52:  MOVLB  9
00D54:  MOVWF  x68
00D56:  CLRF   x69
00D58:  CLRF   x6A
00D5A:  CLRF   x6B
00D5C:  MOVLB  0
00D5E:  RCALL  0756
00D60:  MOVF   01,F
00D62:  BZ    0D82
....................    { 
....................       // struct ble_msg_system_boot_evt_t *evt = data; 
....................       length = sprintf(message, "\rBLE Boot Event\r\n"); 
00D64:  MOVLW  08
00D66:  MOVWF  xCF
00D68:  MOVLW  52
00D6A:  MOVWF  xCE
00D6C:  MOVLW  7E
00D6E:  MOVWF  FF6
00D70:  MOVLW  04
00D72:  MOVWF  FF7
00D74:  RCALL  07B6
00D76:  MOVLW  52
00D78:  SUBWF  xCE,W
00D7A:  MOVLB  9
00D7C:  MOVWF  x52
....................    } 
00D7E:  GOTO   17C6
....................    
....................    else if(ble_header_equals(hdr, 0x00, 0x00, 0x00, 0x01))  
00D82:  MOVFF  847,967
00D86:  MOVFF  846,966
00D8A:  MOVLB  9
00D8C:  CLRF   x68
00D8E:  CLRF   x69
00D90:  CLRF   x6A
00D92:  MOVLW  01
00D94:  MOVWF  x6B
00D96:  MOVLB  0
00D98:  RCALL  0756
00D9A:  MOVF   01,F
00D9C:  BZ    0DBC
....................    { 
....................       length = sprintf(message, "\rBLE Hello\r\n"); 
00D9E:  MOVLW  08
00DA0:  MOVWF  xCF
00DA2:  MOVLW  52
00DA4:  MOVWF  xCE
00DA6:  MOVLW  90
00DA8:  MOVWF  FF6
00DAA:  MOVLW  04
00DAC:  MOVWF  FF7
00DAE:  RCALL  07B6
00DB0:  MOVLW  52
00DB2:  SUBWF  xCE,W
00DB4:  MOVLB  9
00DB6:  MOVWF  x52
....................    }  
00DB8:  GOTO   17C6
....................    
....................    else if(ble_header_equals(hdr, 0x80, 0x10, 0x03, 0x00))  
00DBC:  MOVFF  847,967
00DC0:  MOVFF  846,966
00DC4:  MOVLW  80
00DC6:  MOVLB  9
00DC8:  MOVWF  x68
00DCA:  MOVLW  10
00DCC:  MOVWF  x69
00DCE:  MOVLW  03
00DD0:  MOVWF  x6A
00DD2:  CLRF   x6B
00DD4:  MOVLB  0
00DD6:  RCALL  0756
00DD8:  MOVF   01,F
00DDA:  BZ    0DFA
....................    { 
....................       length = sprintf(message, "\rBLE Connection\r\n"); 
00DDC:  MOVLW  08
00DDE:  MOVWF  xCF
00DE0:  MOVLW  52
00DE2:  MOVWF  xCE
00DE4:  MOVLW  9E
00DE6:  MOVWF  FF6
00DE8:  MOVLW  04
00DEA:  MOVWF  FF7
00DEC:  RCALL  07B6
00DEE:  MOVLW  52
00DF0:  SUBWF  xCE,W
00DF2:  MOVLB  9
00DF4:  MOVWF  x52
....................    }  
00DF6:  GOTO   17C6
....................    
....................    else if(ble_header_equals(hdr, 0x80, 0x03, 0x03, 0x04))  
00DFA:  MOVFF  847,967
00DFE:  MOVFF  846,966
00E02:  MOVLW  80
00E04:  MOVLB  9
00E06:  MOVWF  x68
00E08:  MOVLW  03
00E0A:  MOVWF  x69
00E0C:  MOVWF  x6A
00E0E:  MOVLW  04
00E10:  MOVWF  x6B
00E12:  MOVLB  0
00E14:  RCALL  0756
00E16:  MOVF   01,F
00E18:  BZ    0E42
....................    { 
....................       length = sprintf(message, "\rBLE Disconnection\r\n"); 
00E1A:  MOVLW  08
00E1C:  MOVWF  xCF
00E1E:  MOVLW  52
00E20:  MOVWF  xCE
00E22:  MOVLW  B0
00E24:  MOVWF  FF6
00E26:  MOVLW  04
00E28:  MOVWF  FF7
00E2A:  RCALL  07B6
00E2C:  MOVLW  52
00E2E:  SUBWF  xCE,W
00E30:  MOVLB  9
00E32:  MOVWF  x52
....................       ble_cmd_gap_set_mode(2, 2); 
00E34:  MOVLW  02
00E36:  MOVWF  x66
00E38:  MOVWF  x67
00E3A:  MOVLB  0
00E3C:  RCALL  07DE
....................    }  
00E3E:  GOTO   17C8
....................    
....................    else if(ble_header_equals(hdr, 0x00, 0x02, 0x06, 0x01))  
00E42:  MOVFF  847,967
00E46:  MOVFF  846,966
00E4A:  MOVLB  9
00E4C:  CLRF   x68
00E4E:  MOVLW  02
00E50:  MOVWF  x69
00E52:  MOVLW  06
00E54:  MOVWF  x6A
00E56:  MOVLW  01
00E58:  MOVWF  x6B
00E5A:  MOVLB  0
00E5C:  RCALL  0756
00E5E:  MOVF   01,F
00E60:  BZ    0ECC
....................    { 
....................       uint16 *ptr = data; 
00E62:  MOVFF  849,954
00E66:  MOVFF  848,953
....................       length = sprintf(message, "\rBLE Mode Changed. Error = %lu\r\n", *ptr); 
00E6A:  MOVFF  954,03
00E6E:  MOVLB  9
00E70:  MOVFF  953,FE9
00E74:  MOVFF  03,FEA
00E78:  MOVFF  FEC,967
00E7C:  MOVF   FED,F
00E7E:  MOVFF  FEF,966
00E82:  MOVLW  08
00E84:  MOVLB  0
00E86:  MOVWF  xCF
00E88:  MOVLW  52
00E8A:  MOVWF  xCE
00E8C:  MOVLW  C6
00E8E:  MOVWF  FF6
00E90:  MOVLW  04
00E92:  MOVWF  FF7
00E94:  MOVLW  1B
00E96:  MOVLB  9
00E98:  MOVWF  x6A
00E9A:  MOVLB  0
00E9C:  RCALL  0804
00E9E:  MOVLW  10
00EA0:  MOVWF  FE9
00EA2:  MOVFF  967,96A
00EA6:  MOVFF  966,969
00EAA:  RCALL  082C
00EAC:  MOVLW  0D
00EAE:  MOVLB  9
00EB0:  MOVWF  x72
00EB2:  MOVLB  0
00EB4:  RCALL  0796
00EB6:  MOVLW  0A
00EB8:  MOVLB  9
00EBA:  MOVWF  x72
00EBC:  MOVLB  0
00EBE:  RCALL  0796
00EC0:  MOVLW  52
00EC2:  SUBWF  xCE,W
00EC4:  MOVLB  9
00EC6:  MOVWF  x52
....................    }  
00EC8:  GOTO   17C6
....................    
....................    else if(ble_header_equals(hdr, 0x80, 0x03, 0x02, 0x02))  
00ECC:  MOVFF  847,967
00ED0:  MOVFF  846,966
00ED4:  MOVLW  80
00ED6:  MOVLB  9
00ED8:  MOVWF  x68
00EDA:  MOVLW  03
00EDC:  MOVWF  x69
00EDE:  MOVLW  02
00EE0:  MOVWF  x6A
00EE2:  MOVWF  x6B
00EE4:  MOVLB  0
00EE6:  RCALL  0756
00EE8:  MOVF   01,F
00EEA:  BZ    0FA6
....................    { 
....................       length = sprintf(message, "\rBLE Connection Status Changed: {%u, %u, %u}\r\n", data[0], data[1], data[2]); 
00EEC:  MOVLB  8
00EEE:  MOVFF  848,FE9
00EF2:  MOVFF  849,FEA
00EF6:  MOVFF  FEF,966
00EFA:  MOVLW  01
00EFC:  ADDWF  x48,W
00EFE:  MOVWF  FE9
00F00:  MOVLW  00
00F02:  ADDWFC x49,W
00F04:  MOVWF  FEA
00F06:  MOVFF  FEF,967
00F0A:  MOVLW  02
00F0C:  ADDWF  x48,W
00F0E:  MOVWF  FE9
00F10:  MOVLW  00
00F12:  ADDWFC x49,W
00F14:  MOVWF  FEA
00F16:  MOVFF  FEF,968
00F1A:  MOVLW  08
00F1C:  MOVLB  0
00F1E:  MOVWF  xCF
00F20:  MOVLW  52
00F22:  MOVWF  xCE
00F24:  MOVLW  E8
00F26:  MOVWF  FF6
00F28:  MOVLW  04
00F2A:  MOVWF  FF7
00F2C:  MOVLW  21
00F2E:  MOVLB  9
00F30:  MOVWF  x6A
00F32:  MOVLB  0
00F34:  RCALL  0804
00F36:  MOVFF  966,969
00F3A:  MOVLW  1B
00F3C:  MOVLB  9
00F3E:  MOVWF  x6A
00F40:  MOVLB  0
00F42:  RCALL  091E
00F44:  MOVLW  2C
00F46:  MOVLB  9
00F48:  MOVWF  x72
00F4A:  MOVLB  0
00F4C:  RCALL  0796
00F4E:  MOVLW  20
00F50:  MOVLB  9
00F52:  MOVWF  x72
00F54:  MOVLB  0
00F56:  RCALL  0796
00F58:  MOVFF  967,969
00F5C:  MOVLW  1B
00F5E:  MOVLB  9
00F60:  MOVWF  x6A
00F62:  MOVLB  0
00F64:  RCALL  091E
00F66:  MOVLW  2C
00F68:  MOVLB  9
00F6A:  MOVWF  x72
00F6C:  MOVLB  0
00F6E:  RCALL  0796
00F70:  MOVLW  20
00F72:  MOVLB  9
00F74:  MOVWF  x72
00F76:  MOVLB  0
00F78:  RCALL  0796
00F7A:  MOVFF  968,969
00F7E:  MOVLW  1B
00F80:  MOVLB  9
00F82:  MOVWF  x6A
00F84:  MOVLB  0
00F86:  RCALL  091E
00F88:  MOVLW  13
00F8A:  MOVWF  FF6
00F8C:  MOVLW  05
00F8E:  MOVWF  FF7
00F90:  MOVLW  03
00F92:  MOVLB  9
00F94:  MOVWF  x6A
00F96:  MOVLB  0
00F98:  RCALL  0804
00F9A:  MOVLW  52
00F9C:  SUBWF  xCE,W
00F9E:  MOVLB  9
00FA0:  MOVWF  x52
....................    }  
00FA2:  GOTO   17C6
....................    
....................    else if(ble_header_equals(hdr, 0x00, 0x02, 0x02, 0x00))  
00FA6:  MOVFF  847,967
00FAA:  MOVFF  846,966
00FAE:  MOVLB  9
00FB0:  CLRF   x68
00FB2:  MOVLW  02
00FB4:  MOVWF  x69
00FB6:  MOVWF  x6A
00FB8:  CLRF   x6B
00FBA:  MOVLB  0
00FBC:  CALL   0756
00FC0:  MOVF   01,F
00FC2:  BZ    106C
....................    { 
....................       uint16 *ptr = data; 
00FC4:  MOVFF  849,956
00FC8:  MOVFF  848,955
....................       length = sprintf(message, "\rBLE Write Response. Length = %u. Result = %lu\r\n", hdr->lolen, *ptr); 
00FCC:  MOVLW  01
00FCE:  MOVLB  8
00FD0:  ADDWF  x46,W
00FD2:  MOVWF  FE9
00FD4:  MOVLW  00
00FD6:  ADDWFC x47,W
00FD8:  MOVWF  FEA
00FDA:  MOVFF  FEF,966
00FDE:  MOVFF  956,03
00FE2:  MOVLB  9
00FE4:  MOVFF  955,FE9
00FE8:  MOVFF  03,FEA
00FEC:  MOVFF  FEC,968
00FF0:  MOVF   FED,F
00FF2:  MOVFF  FEF,967
00FF6:  MOVLW  08
00FF8:  MOVLB  0
00FFA:  MOVWF  xCF
00FFC:  MOVLW  52
00FFE:  MOVWF  xCE
01000:  MOVLW  18
01002:  MOVWF  FF6
01004:  MOVLW  05
01006:  MOVWF  FF7
01008:  MOVLW  1E
0100A:  MOVLB  9
0100C:  MOVWF  x6A
0100E:  MOVLB  0
01010:  CALL   0804
01014:  MOVFF  966,969
01018:  MOVLW  1B
0101A:  MOVLB  9
0101C:  MOVWF  x6A
0101E:  MOVLB  0
01020:  RCALL  091E
01022:  MOVLW  38
01024:  MOVWF  FF6
01026:  MOVLW  05
01028:  MOVWF  FF7
0102A:  MOVLW  0B
0102C:  MOVLB  9
0102E:  MOVWF  x6A
01030:  MOVLB  0
01032:  CALL   0804
01036:  MOVLW  10
01038:  MOVWF  FE9
0103A:  MOVFF  968,96A
0103E:  MOVFF  967,969
01042:  CALL   082C
01046:  MOVLW  0D
01048:  MOVLB  9
0104A:  MOVWF  x72
0104C:  MOVLB  0
0104E:  CALL   0796
01052:  MOVLW  0A
01054:  MOVLB  9
01056:  MOVWF  x72
01058:  MOVLB  0
0105A:  CALL   0796
0105E:  MOVLW  52
01060:  SUBWF  xCE,W
01062:  MOVLB  9
01064:  MOVWF  x52
....................       ble_data_message_count++; 
01066:  MOVLB  4
01068:  INCF   x53,F
....................    }  
0106A:  BRA    17C6
....................    
....................    else if(ble_header_equals(hdr, 0x80, 0x07, 0x02, 0x00))  
0106C:  MOVFF  847,967
01070:  MOVFF  846,966
01074:  MOVLW  80
01076:  MOVLB  9
01078:  MOVWF  x68
0107A:  MOVLW  07
0107C:  MOVWF  x69
0107E:  MOVLW  02
01080:  MOVWF  x6A
01082:  CLRF   x6B
01084:  MOVLB  0
01086:  CALL   0756
0108A:  MOVF   01,F
0108C:  BTFSC  FD8.2
0108E:  BRA    1590
....................    { 
....................       length = sprintf(message, "\rBLE Value Written. Length = %u.\r\n", hdr->lolen); 
01090:  MOVLW  01
01092:  MOVLB  8
01094:  ADDWF  x46,W
01096:  MOVWF  FE9
01098:  MOVLW  00
0109A:  ADDWFC x47,W
0109C:  MOVWF  FEA
0109E:  MOVFF  FEF,966
010A2:  MOVLW  08
010A4:  MOVLB  0
010A6:  MOVWF  xCF
010A8:  MOVLW  52
010AA:  MOVWF  xCE
010AC:  MOVLW  4A
010AE:  MOVWF  FF6
010B0:  MOVLW  05
010B2:  MOVWF  FF7
010B4:  MOVLW  1D
010B6:  MOVLB  9
010B8:  MOVWF  x6A
010BA:  MOVLB  0
010BC:  CALL   0804
010C0:  MOVFF  966,969
010C4:  MOVLW  1B
010C6:  MOVLB  9
010C8:  MOVWF  x6A
010CA:  MOVLB  0
010CC:  RCALL  091E
010CE:  MOVLW  69
010D0:  MOVWF  FF6
010D2:  MOVLW  05
010D4:  MOVWF  FF7
010D6:  MOVLW  03
010D8:  MOVLB  9
010DA:  MOVWF  x6A
010DC:  MOVLB  0
010DE:  CALL   0804
010E2:  MOVLW  52
010E4:  SUBWF  xCE,W
010E6:  MOVLB  9
010E8:  MOVWF  x52
.................... //    ble_log(message, length); 
....................  
....................       struct ble_msg_attributes_value_evt_t *evt = data; 
....................       uint16 handle = evt->handle; 
....................       uint16 * value_ptr = NULL; 
....................       uint16 value = 0; 
010EA:  MOVFF  849,958
010EE:  MOVFF  848,957
010F2:  MOVLW  02
010F4:  ADDWF  x57,W
010F6:  MOVWF  FE9
010F8:  MOVLW  00
010FA:  ADDWFC x58,W
010FC:  MOVWF  FEA
010FE:  MOVFF  FEC,95A
01102:  MOVF   FED,F
01104:  MOVFF  FEF,959
01108:  CLRF   x5C
0110A:  CLRF   x5B
0110C:  CLRF   x5E
0110E:  CLRF   x5D
....................  
....................       switch(handle)  
01110:  MOVF   x59,W
01112:  MOVWF  00
01114:  MOVF   x5A,W
01116:  MOVWF  03
01118:  MOVF   03,W
0111A:  BNZ   1126
0111C:  MOVLW  2D
0111E:  SUBWF  00,W
01120:  MOVLB  0
01122:  BZ    1146
01124:  MOVLB  9
01126:  MOVF   03,W
01128:  BNZ   1134
0112A:  MOVLW  44
0112C:  SUBWF  00,W
0112E:  MOVLB  0
01130:  BZ    11B2
01132:  MOVLB  9
01134:  MOVF   03,W
01136:  BNZ   1144
01138:  MOVLW  38
0113A:  SUBWF  00,W
0113C:  MOVLB  0
0113E:  BTFSC  FD8.2
01140:  BRA    131A
01142:  MOVLB  9
01144:  BRA    158E
....................       { 
....................          case BLE_HANDLE_INDEX_CURRENT: 
....................             //value_ptr = &evt->value.data[0]; 
....................             //value = *value_ptr; 
....................             value = evt->value.data[0]; 
01146:  MOVLW  07
01148:  MOVLB  9
0114A:  ADDWF  x57,W
0114C:  MOVWF  FE9
0114E:  MOVLW  00
01150:  ADDWFC x58,W
01152:  MOVWF  FEA
01154:  CLRF   x5E
01156:  MOVFF  FEF,95D
....................             length = sprintf(message, "\rFetching index: %lu\r\n", value); 
0115A:  MOVLW  08
0115C:  MOVLB  0
0115E:  MOVWF  xCF
01160:  MOVLW  52
01162:  MOVWF  xCE
01164:  MOVLW  6E
01166:  MOVWF  FF6
01168:  MOVLW  05
0116A:  MOVWF  FF7
0116C:  MOVLW  11
0116E:  MOVLB  9
01170:  MOVWF  x6A
01172:  MOVLB  0
01174:  CALL   0804
01178:  MOVLW  10
0117A:  MOVWF  FE9
0117C:  MOVFF  95E,96A
01180:  MOVFF  95D,969
01184:  CALL   082C
01188:  MOVLW  0D
0118A:  MOVLB  9
0118C:  MOVWF  x72
0118E:  MOVLB  0
01190:  CALL   0796
01194:  MOVLW  0A
01196:  MOVLB  9
01198:  MOVWF  x72
0119A:  MOVLB  0
0119C:  CALL   0796
011A0:  MOVLW  52
011A2:  SUBWF  xCE,W
011A4:  MOVLB  9
011A6:  MOVWF  x52
.................... //        ble_log(message, length); 
....................  
....................             transmit_reading_at_index = value; 
011A8:  MOVFF  95E,456
011AC:  MOVFF  95D,455
....................             break; 
011B0:  BRA    158E
....................           
....................          case BLE_HANDLE_RX: 
....................             value_ptr = &evt->value.data[0]; 
011B2:  MOVLW  07
011B4:  MOVLB  9
011B6:  ADDWF  x57,W
011B8:  MOVWF  01
011BA:  MOVLW  00
011BC:  ADDWFC x58,W
011BE:  MOVFF  01,95B
011C2:  MOVWF  x5C
....................             value = *value_ptr; 
011C4:  MOVFF  95C,03
011C8:  MOVFF  95B,FE9
011CC:  MOVFF  03,FEA
011D0:  MOVFF  FEC,95E
011D4:  MOVF   FED,F
011D6:  MOVFF  FEF,95D
....................  
....................             length = sprintf(message, "\rValue has changed: %lu!\r\n", value); 
011DA:  MOVLW  08
011DC:  MOVLB  0
011DE:  MOVWF  xCF
011E0:  MOVLW  52
011E2:  MOVWF  xCE
011E4:  MOVLW  86
011E6:  MOVWF  FF6
011E8:  MOVLW  05
011EA:  MOVWF  FF7
011EC:  MOVLW  14
011EE:  MOVLB  9
011F0:  MOVWF  x6A
011F2:  MOVLB  0
011F4:  CALL   0804
011F8:  MOVLW  10
011FA:  MOVWF  FE9
011FC:  MOVFF  95E,96A
01200:  MOVFF  95D,969
01204:  CALL   082C
01208:  MOVLW  9D
0120A:  MOVWF  FF6
0120C:  MOVLW  05
0120E:  MOVWF  FF7
01210:  MOVLW  03
01212:  MOVLB  9
01214:  MOVWF  x6A
01216:  MOVLB  0
01218:  CALL   0804
0121C:  MOVLW  52
0121E:  SUBWF  xCE,W
01220:  MOVLB  9
01222:  MOVWF  x52
.................... //        ble_log(message, length); 
....................  
....................             value += 1; 
01224:  MOVLW  01
01226:  ADDWF  x5D,F
01228:  MOVLW  00
0122A:  ADDWFC x5E,F
....................             length = sprintf(message, "\rValue incremented. Should be: %lu!\r\n", value); 
0122C:  MOVLW  08
0122E:  MOVLB  0
01230:  MOVWF  xCF
01232:  MOVLW  52
01234:  MOVWF  xCE
01236:  MOVLW  A2
01238:  MOVWF  FF6
0123A:  MOVLW  05
0123C:  MOVWF  FF7
0123E:  MOVLW  1F
01240:  MOVLB  9
01242:  MOVWF  x6A
01244:  MOVLB  0
01246:  CALL   0804
0124A:  MOVLW  10
0124C:  MOVWF  FE9
0124E:  MOVFF  95E,96A
01252:  MOVFF  95D,969
01256:  CALL   082C
0125A:  MOVLW  C4
0125C:  MOVWF  FF6
0125E:  MOVLW  05
01260:  MOVWF  FF7
01262:  MOVLW  03
01264:  MOVLB  9
01266:  MOVWF  x6A
01268:  MOVLB  0
0126A:  CALL   0804
0126E:  MOVLW  52
01270:  SUBWF  xCE,W
01272:  MOVLB  9
01274:  MOVWF  x52
.................... //        ble_log(message, length); 
....................             uint8 offset = 0; 
....................             uint8 value_length = sizeof(value); 
....................             uint16 tx_handle = BLE_HANDLE_TX; 
01276:  CLRF   x5F
01278:  MOVLW  02
0127A:  MOVWF  x60
0127C:  CLRF   x62
0127E:  MOVLW  47
01280:  MOVWF  x61
....................             fputc(0x04 + 0x4 + value_length, BLE); 
01282:  MOVLW  08
01284:  ADDWF  x60,W
01286:  MOVWF  x66
01288:  MOVF   x66,W
0128A:  MOVLB  0
0128C:  CALL   07D6
....................            
....................             fputc(0x00, BLE); 
01290:  MOVLW  00
01292:  CALL   07D6
....................             fputc(0x04 + value_length, BLE); 
01296:  MOVLW  04
01298:  MOVLB  9
0129A:  ADDWF  x60,W
0129C:  MOVWF  x66
0129E:  MOVF   x66,W
012A0:  MOVLB  0
012A2:  CALL   07D6
....................             fputc(0x02, BLE); 
012A6:  MOVLW  02
012A8:  CALL   07D6
....................             fputc(0x00, BLE); 
012AC:  MOVLW  00
012AE:  CALL   07D6
....................            
....................             fputc(tx_handle & 0xff, BLE); 
012B2:  MOVLB  9
012B4:  MOVF   x61,W
012B6:  MOVWF  x66
012B8:  CLRF   x67
012BA:  MOVF   x66,W
012BC:  MOVLB  0
012BE:  CALL   07D6
....................             tx_handle >>= 8; 
012C2:  MOVFF  962,961
012C6:  MOVLB  9
012C8:  CLRF   x62
....................             fputc(tx_handle & 0xff, BLE); 
012CA:  MOVF   x61,W
012CC:  MOVWF  x66
012CE:  CLRF   x67
012D0:  MOVF   x66,W
012D2:  MOVLB  0
012D4:  CALL   07D6
....................            
....................             fputc(offset, BLE); 
012D8:  MOVLB  9
012DA:  MOVF   x5F,W
012DC:  MOVLB  0
012DE:  CALL   07D6
....................             fputc(value_length, BLE); 
012E2:  MOVLB  9
012E4:  MOVF   x60,W
012E6:  MOVLB  0
012E8:  CALL   07D6
....................            
....................             while(value_length--)  
012EC:  MOVLB  9
012EE:  MOVF   x60,W
012F0:  DECF   x60,F
012F2:  XORLW  00
012F4:  BZ    1318
....................             { 
....................                fputc(*value, BLE); 
012F6:  MOVFF  95E,03
012FA:  MOVF   x5D,W
012FC:  MOVWF  FE9
012FE:  MOVFF  03,FEA
01302:  MOVFF  FEF,966
01306:  MOVF   x66,W
01308:  MOVLB  0
0130A:  CALL   07D6
....................                value++; 
0130E:  MOVLB  9
01310:  INCF   x5D,F
01312:  BTFSC  FD8.2
01314:  INCF   x5E,F
01316:  BRA    12EE
....................             } 
....................  
....................             break; 
01318:  BRA    158E
....................          
....................          case BLE_HANDLE_OPCODE: 
....................             srcPtr = &evt->value.data[0]; 
0131A:  MOVLW  07
0131C:  MOVLB  9
0131E:  ADDWF  x57,W
01320:  MOVWF  01
01322:  MOVLW  00
01324:  ADDWFC x58,W
01326:  MOVFF  01,84A
0132A:  MOVLB  8
0132C:  MOVWF  x4B
....................              
....................             for( tmpCtr = 0; tmpCtr < sizeof( cmdReceived ); tmpCtr++ ) 
0132E:  CLRF   x4F
01330:  MOVF   x4F,W
01332:  SUBLW  08
01334:  BNC   1368
....................                destPtr[tmpCtr] = srcPtr[tmpCtr]; 
01336:  MOVF   x4F,W
01338:  ADDWF  x4C,W
0133A:  MOVWF  01
0133C:  MOVLW  00
0133E:  ADDWFC x4D,W
01340:  MOVWF  03
01342:  MOVLB  8
01344:  MOVF   x4F,W
01346:  ADDWF  x4A,W
01348:  MOVWF  FE9
0134A:  MOVLW  00
0134C:  ADDWFC x4B,W
0134E:  MOVWF  FEA
01350:  MOVFF  FEF,968
01354:  MOVLB  9
01356:  MOVFF  03,FEA
0135A:  MOVFF  01,FE9
0135E:  MOVFF  968,FEF
01362:  MOVLB  8
01364:  INCF   x4F,F
01366:  BRA    1330
....................                 
.................... #ifdef DEBUG            
....................             fprintf(STDOUT, "Opcode Number received: %d \r\n", cmdReceived.opCode); 
....................             fprintf(STDOUT, "Volume Settings received : %lu \r\n", cmdReceived.volume); 
....................             fprintf(STDOUT, "Hour received   : %lu \r\n", cmdReceived.time.hour); 
....................             fprintf(STDOUT, "Minute received   : %lu \r\n", cmdReceived.time.minute); 
....................             fprintf(STDOUT, "Second received : %lu \r\n", cmdReceived.time.second); 
....................             fprintf(STDOUT, "Day received   : %lu \r\n", cmdReceived.time.day); 
....................             fprintf(STDOUT, "Month received   : %lu \r\n", cmdReceived.time.month); 
....................             fprintf(STDOUT, "Year received : %lu \r\n", cmdReceived.time.year); 
....................             fprintf(STDOUT, "\r\n\r\n"); 
....................  #endif            
....................  
....................             cmd = cmdReceived.opCode; 
01368:  MOVFF  205,84E
....................             tmpVolume = cmdReceived.volume; 
0136C:  MOVFF  207,851
01370:  MOVFF  206,850
....................              
....................             if( tmpVolume < MININUM_BREATH_VOLUME || tmpVolume > MAXINUM_BREATH_VOLUME ) 
01374:  MOVF   x51,W
01376:  SUBLW  01
01378:  BNC   1382
0137A:  BNZ   1392
0137C:  MOVF   x50,W
0137E:  SUBLW  2B
01380:  BC    1392
01382:  MOVF   x51,W
01384:  SUBLW  06
01386:  BC    1396
01388:  XORLW  FF
0138A:  BNZ   1392
0138C:  MOVF   x50,W
0138E:  SUBLW  D0
01390:  BC    1396
....................                tmpVolume = 0; 
01392:  CLRF   x51
01394:  CLRF   x50
....................              
....................             //check for breath volume setting 
....................             if( tmpVolume > MININUM_BREATH_VOLUME || tmpVolume < MAXINUM_BREATH_VOLUME ) 
01396:  MOVF   x51,W
01398:  SUBLW  00
0139A:  BC    13A6
0139C:  XORLW  FF
0139E:  BNZ   13B4
013A0:  MOVF   x50,W
013A2:  SUBLW  2C
013A4:  BNC   13B4
013A6:  MOVF   x51,W
013A8:  SUBLW  07
013AA:  BNC   142A
013AC:  BNZ   13B4
013AE:  MOVF   x50,W
013B0:  SUBLW  CF
013B2:  BNC   142A
....................             {  //Update with new breath volume setting 
....................                ConfigWriteFloat( CONFIG_BREATH_VOLUME, tmpVolume ); 
013B4:  MOVFF  851,967
013B8:  MOVFF  850,966
013BC:  MOVLB  0
013BE:  CALL   099A
013C2:  MOVFF  03,969
013C6:  MOVFF  02,968
013CA:  MOVFF  01,967
013CE:  MOVFF  00,966
013D2:  MOVLB  9
013D4:  CLRF   x6B
013D6:  MOVLW  1A
013D8:  MOVWF  x6A
013DA:  MOVFF  03,96F
013DE:  MOVFF  02,96E
013E2:  MOVFF  01,96D
013E6:  MOVFF  00,96C
013EA:  MOVLB  0
013EC:  CALL   0A60
....................                fprintf(STDOUT, "New volume settings: %lu \r\n", tmpVolume); 
013F0:  MOVLW  C8
013F2:  MOVWF  FF6
013F4:  MOVLW  05
013F6:  MOVWF  FF7
013F8:  MOVLW  15
013FA:  MOVLB  9
013FC:  MOVWF  x66
013FE:  MOVLB  0
01400:  CALL   0AAC
01404:  MOVLW  10
01406:  MOVWF  FE9
01408:  MOVFF  851,967
0140C:  MOVFF  850,966
01410:  CALL   0AD6
01414:  MOVLW  E0
01416:  MOVWF  FF6
01418:  MOVLW  05
0141A:  MOVWF  FF7
0141C:  MOVLW  03
0141E:  MOVLB  9
01420:  MOVWF  x66
01422:  MOVLB  0
01424:  CALL   0AAC
01428:  MOVLB  8
....................             } 
....................                 
....................             length = sprintf(message, "\riOS App opcode%d\r\n", cmd); 
0142A:  MOVLW  08
0142C:  MOVLB  0
0142E:  MOVWF  xCF
01430:  MOVLW  52
01432:  MOVWF  xCE
01434:  MOVLW  E4
01436:  MOVWF  FF6
01438:  MOVLW  05
0143A:  MOVWF  FF7
0143C:  MOVLW  0F
0143E:  MOVLB  9
01440:  MOVWF  x6A
01442:  MOVLB  0
01444:  CALL   0804
01448:  MOVFF  84E,966
0144C:  MOVLW  18
0144E:  MOVLB  9
01450:  MOVWF  x67
01452:  MOVLB  0
01454:  GOTO   0B8A
01458:  MOVLW  0D
0145A:  MOVLB  9
0145C:  MOVWF  x72
0145E:  MOVLB  0
01460:  CALL   0796
01464:  MOVLW  0A
01466:  MOVLB  9
01468:  MOVWF  x72
0146A:  MOVLB  0
0146C:  CALL   0796
01470:  MOVLW  52
01472:  SUBWF  xCE,W
01474:  MOVLB  9
01476:  MOVWF  x52
.................... //        ble_log(message, length); 
....................  
....................             if (!FullTestRunning)  
01478:  MOVLB  4
0147A:  MOVF   x54,F
0147C:  BTFSS  FD8.2
0147E:  BRA    158C
....................             { 
....................                switch(cmd)  
01480:  MOVLB  8
01482:  MOVF   x4E,W
01484:  XORLW  00
01486:  MOVLB  0
01488:  BZ    14A0
0148A:  XORLW  01
0148C:  BZ    14C2
0148E:  XORLW  03
01490:  BZ    14E4
01492:  XORLW  01
01494:  BZ    1506
01496:  XORLW  FC
01498:  BZ    1528
0149A:  XORLW  05
0149C:  BZ    1548
0149E:  BRA    156C
....................                { 
....................                   case OPCODE_BLE_START_KETONE_TEST: 
....................                      iosApp = IOS_REQUEST_START_KETONE_TEST; 
014A0:  MOVLW  01
014A2:  MOVWF  xD0
....................                      length = sprintf(message, "\rKetone test cmd received.\r\n"); 
014A4:  MOVLW  08
014A6:  MOVWF  xCF
014A8:  MOVLW  52
014AA:  MOVWF  xCE
014AC:  MOVLW  F8
014AE:  MOVWF  FF6
014B0:  MOVLW  05
014B2:  MOVWF  FF7
014B4:  CALL   07B6
014B8:  MOVLW  52
014BA:  SUBWF  xCE,W
014BC:  MOVLB  9
014BE:  MOVWF  x52
....................  
....................                      break; 
014C0:  BRA    1588
....................            
....................                   case OPCODE_BLE_START_AMMONIA_TEST: 
....................                      iosApp = IOS_REQUEST_START_AMMONIA_TEST; 
014C2:  MOVLW  02
014C4:  MOVWF  xD0
....................                      length = sprintf(message, "\rAmmonia test cmd received.\r\n"); 
014C6:  MOVLW  08
014C8:  MOVWF  xCF
014CA:  MOVLW  52
014CC:  MOVWF  xCE
014CE:  MOVLW  16
014D0:  MOVWF  FF6
014D2:  MOVLW  06
014D4:  MOVWF  FF7
014D6:  CALL   07B6
014DA:  MOVLW  52
014DC:  SUBWF  xCE,W
014DE:  MOVLB  9
014E0:  MOVWF  x52
....................                    
....................                      break; 
014E2:  BRA    1588
....................            
....................                   case OPCODE_RESET_USE_COUNTER: 
....................                      iosApp = IOS_REQUEST_START_AMMONIA_TEST; 
014E4:  MOVLW  02
014E6:  MOVWF  xD0
....................                      length = sprintf(message, "\rReset use counter cmd received\r\n"); 
014E8:  MOVLW  08
014EA:  MOVWF  xCF
014EC:  MOVLW  52
014EE:  MOVWF  xCE
014F0:  MOVLW  34
014F2:  MOVWF  FF6
014F4:  MOVLW  06
014F6:  MOVWF  FF7
014F8:  CALL   07B6
014FC:  MOVLW  52
014FE:  SUBWF  xCE,W
01500:  MOVLB  9
01502:  MOVWF  x52
....................  
....................                      break; 
01504:  BRA    1588
....................  
....................                   case OPCODE_RESET_READINGS: 
....................                      iosApp = IOS_REQUEST_RESET_READINGS; 
01506:  MOVLW  04
01508:  MOVWF  xD0
....................                      length = sprintf(message, "\rClear memory cmd received.\r\n"); 
0150A:  MOVLW  08
0150C:  MOVWF  xCF
0150E:  MOVLW  52
01510:  MOVWF  xCE
01512:  MOVLW  56
01514:  MOVWF  FF6
01516:  MOVLW  06
01518:  MOVWF  FF7
0151A:  CALL   07B6
0151E:  MOVLW  52
01520:  SUBWF  xCE,W
01522:  MOVLB  9
01524:  MOVWF  x52
....................                    
....................                      break; 
01526:  BRA    1588
....................  
....................                   case OPCODE_BLE_START_FIRMWARE_UPDATE: 
....................                      iosApp = IOS_REQUEST_START_FIRMWARE_UPDATE; 
01528:  SETF   xD0
....................                      length = sprintf(message, "\rFirmware update cmd detected.\r\n"); 
0152A:  MOVLW  08
0152C:  MOVWF  xCF
0152E:  MOVLW  52
01530:  MOVWF  xCE
01532:  MOVLW  74
01534:  MOVWF  FF6
01536:  MOVLW  06
01538:  MOVWF  FF7
0153A:  CALL   07B6
0153E:  MOVLW  52
01540:  SUBWF  xCE,W
01542:  MOVLB  9
01544:  MOVWF  x52
....................                    
....................                      break; 
01546:  BRA    1588
....................                       
....................                   case OPCODE_RESET_STATE_MACHINE: 
....................                      iosApp = IOS_REQUEST_RESET_STATE_MACHINE; 
01548:  MOVLW  FA
0154A:  MOVWF  xD0
....................                      length = sprintf(message, "\rReset State Machine cmd detected.\r\n"); 
0154C:  MOVLW  08
0154E:  MOVWF  xCF
01550:  MOVLW  52
01552:  MOVWF  xCE
01554:  MOVLW  96
01556:  MOVWF  FF6
01558:  MOVLW  06
0155A:  MOVWF  FF7
0155C:  CALL   07B6
01560:  MOVLW  52
01562:  SUBWF  xCE,W
01564:  MOVLB  9
01566:  MOVWF  x52
....................                    
....................                      break; 
01568:  BRA    1588
0156A:  MOVLB  0
....................  
....................                   default: 
....................                      length = sprintf(message, "\r[NOTE] Unsupported cmd detected\r\n"); 
0156C:  MOVLW  08
0156E:  MOVWF  xCF
01570:  MOVLW  52
01572:  MOVWF  xCE
01574:  MOVLW  BC
01576:  MOVWF  FF6
01578:  MOVLW  06
0157A:  MOVWF  FF7
0157C:  CALL   07B6
01580:  MOVLW  52
01582:  SUBWF  xCE,W
01584:  MOVLB  9
01586:  MOVWF  x52
.................... //                     ble_log(message, length);    
....................                } 
....................  
....................                // Prevent the ble_log at the end of the function below. 
....................                length = 0; 
01588:  CLRF   x52
0158A:  MOVLB  4
....................             }  
....................              
....................             break; 
0158C:  MOVLB  9
....................       } 
....................    } 
0158E:  BRA    17C6
....................    
....................    else if(ble_header_equals(hdr, 0x00, 0x06, 0x00, 0x02))  
01590:  MOVFF  847,967
01594:  MOVFF  846,966
01598:  MOVLB  9
0159A:  CLRF   x68
0159C:  MOVLW  06
0159E:  MOVWF  x69
015A0:  CLRF   x6A
015A2:  MOVLW  02
015A4:  MOVWF  x6B
015A6:  MOVLB  0
015A8:  CALL   0756
015AC:  MOVF   01,F
015AE:  BTFSC  FD8.2
015B0:  BRA    16C6
....................    { // Response to ADDRESS_GET command 
....................       uint16 *ptr = data; 
015B2:  MOVFF  849,964
015B6:  MOVFF  848,963
....................        
....................       for(int i = 0; i < 6; i++ ) 
015BA:  MOVLB  9
015BC:  CLRF   x65
015BE:  BTFSC  x65.7
015C0:  BRA    15C8
015C2:  MOVF   x65,W
015C4:  SUBLW  05
015C6:  BNC   1624
....................          BleModuleId[i] = ptr[i]; 
015C8:  CLRF   03
015CA:  MOVF   x65,W
015CC:  ADDLW  4A
015CE:  MOVWF  01
015D0:  MOVLW  03
015D2:  ADDWFC 03,F
015D4:  MOVFF  01,966
015D8:  MOVFF  03,967
015DC:  CLRF   03
015DE:  MOVF   x65,W
015E0:  MOVWF  00
015E2:  BTFSC  FE8.7
015E4:  DECF   03,F
015E6:  MOVWF  x68
015E8:  MOVFF  03,969
015EC:  MOVFF  03,96B
015F0:  MOVWF  x6A
015F2:  CLRF   x6D
015F4:  MOVLW  02
015F6:  MOVWF  x6C
015F8:  MOVLB  0
015FA:  CALL   0C48
015FE:  MOVFF  02,03
01602:  MOVF   01,W
01604:  MOVLB  9
01606:  ADDWF  x63,W
01608:  MOVWF  FE9
0160A:  MOVF   x64,W
0160C:  ADDWFC 02,W
0160E:  MOVWF  FEA
01610:  MOVFF  FEF,968
01614:  MOVFF  967,FEA
01618:  MOVFF  966,FE9
0161C:  MOVFF  968,FEF
01620:  INCF   x65,F
01622:  BRA    15BE
....................  
....................       length = sprintf(message, "\r\nBLE Module ID captured %2X%2X%2X%2X%2X%2X\r\n", BleModuleId[0], BleModuleId[1], BleModuleId[2], BleModuleId[3], BleModuleId[4], BleModuleId[5]); 
01624:  MOVLW  08
01626:  MOVLB  0
01628:  MOVWF  xCF
0162A:  MOVLW  52
0162C:  MOVWF  xCE
0162E:  MOVLW  E0
01630:  MOVWF  FF6
01632:  MOVLW  06
01634:  MOVWF  FF7
01636:  MOVLW  19
01638:  MOVLB  9
0163A:  MOVWF  x6A
0163C:  MOVLB  0
0163E:  CALL   0804
01642:  MOVFF  34A,96A
01646:  MOVLW  37
01648:  MOVLB  9
0164A:  MOVWF  x6B
0164C:  MOVLB  0
0164E:  CALL   0C9C
01652:  MOVFF  34B,96A
01656:  MOVLW  37
01658:  MOVLB  9
0165A:  MOVWF  x6B
0165C:  MOVLB  0
0165E:  CALL   0C9C
01662:  MOVFF  34C,96A
01666:  MOVLW  37
01668:  MOVLB  9
0166A:  MOVWF  x6B
0166C:  MOVLB  0
0166E:  CALL   0C9C
01672:  MOVFF  34D,96A
01676:  MOVLW  37
01678:  MOVLB  9
0167A:  MOVWF  x6B
0167C:  MOVLB  0
0167E:  CALL   0C9C
01682:  MOVFF  34E,96A
01686:  MOVLW  37
01688:  MOVLB  9
0168A:  MOVWF  x6B
0168C:  MOVLB  0
0168E:  CALL   0C9C
01692:  MOVFF  34F,96A
01696:  MOVLW  37
01698:  MOVLB  9
0169A:  MOVWF  x6B
0169C:  MOVLB  0
0169E:  CALL   0C9C
016A2:  MOVLW  0D
016A4:  MOVLB  9
016A6:  MOVWF  x72
016A8:  MOVLB  0
016AA:  CALL   0796
016AE:  MOVLW  0A
016B0:  MOVLB  9
016B2:  MOVWF  x72
016B4:  MOVLB  0
016B6:  CALL   0796
016BA:  MOVLW  52
016BC:  SUBWF  xCE,W
016BE:  MOVLB  9
016C0:  MOVWF  x52
....................    } 
016C2:  BRA    17C6
016C4:  MOVLB  0
....................    
....................    else  
....................       length = sprintf(message, "\r[NOTE] Ignored BLE Message {%x, %x, %x, %x}\r\n", hdr->type_hilen, hdr->lolen, hdr->cls, hdr->command); 
016C6:  MOVLB  8
016C8:  MOVFF  846,FE9
016CC:  MOVFF  847,FEA
016D0:  MOVFF  FEF,966
016D4:  MOVLW  01
016D6:  ADDWF  x46,W
016D8:  MOVWF  FE9
016DA:  MOVLW  00
016DC:  ADDWFC x47,W
016DE:  MOVWF  FEA
016E0:  MOVFF  FEF,967
016E4:  MOVLW  02
016E6:  ADDWF  x46,W
016E8:  MOVWF  FE9
016EA:  MOVLW  00
016EC:  ADDWFC x47,W
016EE:  MOVWF  FEA
016F0:  MOVFF  FEF,968
016F4:  MOVLW  03
016F6:  ADDWF  x46,W
016F8:  MOVWF  FE9
016FA:  MOVLW  00
016FC:  ADDWFC x47,W
016FE:  MOVWF  FEA
01700:  MOVFF  FEF,969
01704:  MOVLW  08
01706:  MOVLB  0
01708:  MOVWF  xCF
0170A:  MOVLW  52
0170C:  MOVWF  xCE
0170E:  MOVLW  0E
01710:  MOVWF  FF6
01712:  MOVLW  07
01714:  MOVWF  FF7
01716:  MOVLW  1D
01718:  MOVLB  9
0171A:  MOVWF  x6A
0171C:  MOVLB  0
0171E:  CALL   0804
01722:  MOVFF  966,96A
01726:  MOVLW  57
01728:  MOVLB  9
0172A:  MOVWF  x6B
0172C:  MOVLB  0
0172E:  CALL   0C9C
01732:  MOVLW  2C
01734:  MOVLB  9
01736:  MOVWF  x72
01738:  MOVLB  0
0173A:  CALL   0796
0173E:  MOVLW  20
01740:  MOVLB  9
01742:  MOVWF  x72
01744:  MOVLB  0
01746:  CALL   0796
0174A:  MOVFF  967,96A
0174E:  MOVLW  57
01750:  MOVLB  9
01752:  MOVWF  x6B
01754:  MOVLB  0
01756:  CALL   0C9C
0175A:  MOVLW  2C
0175C:  MOVLB  9
0175E:  MOVWF  x72
01760:  MOVLB  0
01762:  CALL   0796
01766:  MOVLW  20
01768:  MOVLB  9
0176A:  MOVWF  x72
0176C:  MOVLB  0
0176E:  CALL   0796
01772:  MOVFF  968,96A
01776:  MOVLW  57
01778:  MOVLB  9
0177A:  MOVWF  x6B
0177C:  MOVLB  0
0177E:  CALL   0C9C
01782:  MOVLW  2C
01784:  MOVLB  9
01786:  MOVWF  x72
01788:  MOVLB  0
0178A:  CALL   0796
0178E:  MOVLW  20
01790:  MOVLB  9
01792:  MOVWF  x72
01794:  MOVLB  0
01796:  CALL   0796
0179A:  MOVFF  969,96A
0179E:  MOVLW  57
017A0:  MOVLB  9
017A2:  MOVWF  x6B
017A4:  MOVLB  0
017A6:  CALL   0C9C
017AA:  MOVLW  39
017AC:  MOVWF  FF6
017AE:  MOVLW  07
017B0:  MOVWF  FF7
017B2:  MOVLW  03
017B4:  MOVLB  9
017B6:  MOVWF  x6A
017B8:  MOVLB  0
017BA:  CALL   0804
017BE:  MOVLW  52
017C0:  SUBWF  xCE,W
017C2:  MOVLB  9
017C4:  MOVWF  x52
017C6:  MOVLB  0
....................  
....................    ble_log(message, length); 
017C8:  MOVLW  08
017CA:  MOVLB  9
017CC:  MOVWF  x67
017CE:  MOVLW  52
017D0:  MOVWF  x66
017D2:  MOVFF  952,968
017D6:  MOVLB  0
017D8:  GOTO   0CE2
017DC:  GOTO   1832 (RETURN)
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #INT_RDA 
.................... void ble_receive() 
017E0:  GOTO   073E
017E4:  MOVFF  01,842
.................... { 
....................    uint8 rx = fgetc(BLE); 
....................    ble_data_buffer[ble_data_index] = rx; 
017E8:  CLRF   03
017EA:  MOVLB  4
017EC:  MOVF   x52,W
017EE:  ADDLW  52
017F0:  MOVWF  FE9
017F2:  MOVLW  03
017F4:  ADDWFC 03,W
017F6:  MOVWF  FEA
017F8:  MOVFF  842,FEF
....................    ble_data_index++; 
017FC:  INCF   x52,F
....................  
....................    if(ble_data_index == 256)  
017FE:  MOVF   x52,W
01800:  SUBLW  00
01802:  BNZ   1806
....................    { 
....................       ble_data_index = 0; 
01804:  CLRF   x52
....................    } 
....................  
....................    struct ble_header * hdr = &ble_data_buffer; 
....................    uint8 length = hdr->lolen + 4; 
01806:  MOVLW  03
01808:  MOVLB  8
0180A:  MOVWF  x44
0180C:  MOVLW  52
0180E:  MOVWF  x43
01810:  MOVLW  01
01812:  ADDWF  x43,W
01814:  MOVWF  FE9
01816:  MOVLW  00
01818:  ADDWFC x44,W
0181A:  MOVWF  FEA
0181C:  MOVLW  04
0181E:  ADDWF  FEF,W
01820:  MOVWF  x45
....................  
....................    if(ble_data_index >= length)  
01822:  MOVF   x45,W
01824:  MOVLB  4
01826:  SUBWF  x52,W
01828:  BNC   1834
....................    { 
....................       ble_data_index = 0; 
0182A:  CLRF   x52
....................       ble_process(); 
0182C:  MOVLB  0
0182E:  GOTO   0D28
01832:  MOVLB  4
....................    } 
01834:  BCF    F9E.5
01836:  MOVLB  0
01838:  GOTO   0078
.................... } 
.................... //////////////////////////////////////// 
.................... void ConstructBleModule() 
.................... { 
....................    // Reset the BLE chip. Reset is active low. So hold "nReset" low. 
....................    // Wait for the boot message 
....................    for(uint16 i=1; ; i++)  
....................    { 
.................... #ifdef DEBUG 
....................      fprintf(STDOUT, "Initialize bluetooth \r\n"); 
.................... #endif 
....................  
....................      output_low(BLE_RESET_PIN); 
....................      delay_ms(500); 
....................      output_high(BLE_RESET_PIN); 
....................  
....................      delay_ms(1100); 
....................      int j=0; 
....................      for (; j<100; j++)  
....................      { 
....................         if (ble_log_process()) 
....................            break; 
....................      } 
....................       
....................      if (j<100) 
....................         break; 
....................    } 
....................  
....................    // Make sure that the "hello" ping works 
....................    ble_cmd_system_hello(); 
....................    while(!ble_log_process()); 
....................     
....................    // gap_general_discoverable, gap_undirected_connectable 
....................    ble_cmd_gap_set_mode(2, 2); 
....................    while(!ble_log_process()); 
....................     
....................    uint8 buff[7]; 
....................    ble_cmd_system_AddressGet(); 
....................    while(!ble_log_process()); 
....................     
....................    config_serial_get( (uint8 *)&buff[0] ); 
....................    ble_cmd_attributes_write(BLE_HANDLE_SERIAL_NUMBER, 0, 7, &buff); 
....................    while(!ble_log_process()); 
....................  
....................    ble_cmd_attributes_write(BLE_HANDLE_DEVICE_STAT, 0, sizeof(deviceStat), (uint8 *)&deviceStat); 
....................    while(!ble_log_process()); 
....................  
....................    fprintf(STDOUT, "Bluetooth Initialized \r\n"); 
....................    bluetoothState = PASS;                          //Got this far, blu is working 
.................... //   bleNotifyState(MP_STARTUP); 
....................  
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void DisableBleModule() 
.................... { 
....................    // Reset the BLE chip. Reset is active low. So hold "nReset" low. 
....................    // Wait for the boot message 
....................      fprintf(STDOUT, "Shutdown bluetooth \r\n"); 
*
045CC:  MOVLW  56
045CE:  MOVWF  FF6
045D0:  MOVLW  18
045D2:  MOVWF  FF7
045D4:  CALL   2CA0
....................  
....................      output_low(BLE_RESET_PIN); 
045D8:  BCF    F93.2
045DA:  BCF    F8A.2
....................      delay_ms(300); 
045DC:  MOVLW  02
045DE:  MOVLB  7
045E0:  MOVWF  x31
045E2:  MOVLW  96
045E4:  MOVLB  8
045E6:  MOVWF  x18
045E8:  MOVLB  0
045EA:  CALL   2D2E
045EE:  MOVLB  7
045F0:  DECFSZ x31,F
045F2:  BRA    45E2
....................      output_high(BLE_RESET_PIN); 
045F4:  BCF    F93.2
045F6:  BSF    F8A.2
....................      delay_ms(300); 
045F8:  MOVLW  02
045FA:  MOVWF  x31
045FC:  MOVLW  96
045FE:  MOVLB  8
04600:  MOVWF  x18
04602:  MOVLB  0
04604:  CALL   2D2E
04608:  MOVLB  7
0460A:  DECFSZ x31,F
0460C:  BRA    45FC
....................      output_low(BLE_RESET_PIN); 
0460E:  BCF    F93.2
04610:  BCF    F8A.2
....................      delay_ms(300); 
04612:  MOVLW  02
04614:  MOVWF  x31
04616:  MOVLW  96
04618:  MOVLB  8
0461A:  MOVWF  x18
0461C:  MOVLB  0
0461E:  CALL   2D2E
04622:  MOVLB  7
04624:  DECFSZ x31,F
04626:  BRA    4616
04628:  MOVLB  0
0462A:  GOTO   4630 (RETURN)
.................... } 
.................... //////////////////////////////////////// 
.................... void ble_configure() 
.................... { 
....................    // Reset the BLE chip. Reset is active low. So hold "nReset" low. 
....................    // Wait for the boot message 
....................    for(uint16 i=1; ; i++)  
*
02F72:  MOVLB  7
02F74:  CLRF   x1B
02F76:  MOVLW  01
02F78:  MOVWF  x1A
....................    { 
....................      fprintf(STDOUT, "Resetting BLE %lu times...\r\n\r\n", i); 
02F7A:  MOVLW  6C
02F7C:  MOVWF  FF6
02F7E:  MOVLW  18
02F80:  MOVWF  FF7
02F82:  CLRF   19
02F84:  BTFSC  FF2.7
02F86:  BSF    19.7
02F88:  BCF    FF2.7
02F8A:  MOVLW  0E
02F8C:  MOVLB  9
02F8E:  MOVWF  x66
02F90:  MOVLB  0
02F92:  CALL   0AAC
02F96:  BTFSC  19.7
02F98:  BSF    FF2.7
02F9A:  MOVLW  10
02F9C:  MOVWF  FE9
02F9E:  CLRF   19
02FA0:  BTFSC  FF2.7
02FA2:  BSF    19.7
02FA4:  BCF    FF2.7
02FA6:  MOVFF  71B,967
02FAA:  MOVFF  71A,966
02FAE:  CALL   0AD6
02FB2:  BTFSC  19.7
02FB4:  BSF    FF2.7
02FB6:  MOVLW  7D
02FB8:  MOVWF  FF6
02FBA:  MOVLW  18
02FBC:  MOVWF  FF7
02FBE:  CLRF   19
02FC0:  BTFSC  FF2.7
02FC2:  BSF    19.7
02FC4:  BCF    FF2.7
02FC6:  MOVLW  0D
02FC8:  MOVLB  9
02FCA:  MOVWF  x66
02FCC:  MOVLB  0
02FCE:  CALL   0AAC
02FD2:  BTFSC  19.7
02FD4:  BSF    FF2.7
....................      output_low(BLE_RESET_PIN); 
02FD6:  BCF    F93.2
02FD8:  BCF    F8A.2
....................      delay_ms(500); 
02FDA:  MOVLW  02
02FDC:  MOVLB  7
02FDE:  MOVWF  x25
02FE0:  MOVLW  FA
02FE2:  MOVLB  8
02FE4:  MOVWF  x18
02FE6:  MOVLB  0
02FE8:  RCALL  2D2E
02FEA:  MOVLB  7
02FEC:  DECFSZ x25,F
02FEE:  BRA    2FE0
....................  
....................      output_high(BLE_RESET_PIN); 
02FF0:  BCF    F93.2
02FF2:  BSF    F8A.2
....................      delay_ms(1100); 
02FF4:  MOVLW  05
02FF6:  MOVWF  x25
02FF8:  MOVLW  DC
02FFA:  MOVLB  8
02FFC:  MOVWF  x18
02FFE:  MOVLB  0
03000:  RCALL  2D2E
03002:  MOVLB  7
03004:  DECFSZ x25,F
03006:  BRA    2FF8
....................       
....................      int j=0; 
03008:  CLRF   x1C
....................      for (; j<100; j++)  
0300A:  BTFSC  x1C.7
0300C:  BRA    3014
0300E:  MOVF   x1C,W
03010:  SUBLW  63
03012:  BNC   3028
....................      { 
....................         if (ble_log_process()) 
03014:  MOVLB  0
03016:  RCALL  2D56
03018:  MOVF   01,F
0301A:  BZ    3022
....................            break; 
0301C:  MOVLB  7
0301E:  BRA    3028
03020:  MOVLB  0
03022:  MOVLB  7
03024:  INCF   x1C,F
03026:  BRA    300A
....................      } 
....................       
....................      if (j<100) 
03028:  BTFSC  x1C.7
0302A:  BRA    3032
0302C:  MOVF   x1C,W
0302E:  SUBLW  63
03030:  BNC   3034
....................         break; 
03032:  BRA    303C
03034:  INCF   x1A,F
03036:  BTFSC  FD8.2
03038:  INCF   x1B,F
0303A:  BRA    2F7A
....................    } 
....................  
....................    // Make sure that the "hello" ping works 
....................    ble_cmd_system_hello(); 
0303C:  MOVLB  0
0303E:  BRA    2D82
....................    while(!ble_log_process()); 
03040:  RCALL  2D56
03042:  MOVF   01,F
03044:  BZ    3040
03046:  CLRF   19
03048:  BTFSC  FF2.7
0304A:  BSF    19.7
0304C:  BCF    FF2.7
....................  
....................    // gap_general_discoverable, gap_undirected_connectable 
....................    ble_cmd_gap_set_mode(2, 2); 
0304E:  MOVLW  02
03050:  MOVLB  9
03052:  MOVWF  x66
03054:  MOVWF  x67
03056:  MOVLB  0
03058:  CALL   07DE
0305C:  BTFSC  19.7
0305E:  BSF    FF2.7
....................    while(!ble_log_process());   
03060:  RCALL  2D56
03062:  MOVF   01,F
03064:  BZ    3060
....................  
....................    uint8  value = 0; 
....................    uint8  progress = SEND_RESULTS; 
....................    uint8  buff[6]; 
03066:  MOVLB  7
03068:  CLRF   x1D
0306A:  MOVLW  3C
0306C:  MOVWF  x1E
....................    
....................    ble_cmd_system_AddressGet(); 
0306E:  MOVLB  0
03070:  BRA    2DA4
....................    while(!ble_log_process()); 
03072:  RCALL  2D56
03074:  MOVF   01,F
03076:  BZ    3072
....................  
....................    value = reading_index_start(); 
03078:  RCALL  2DC6
0307A:  MOVFF  01,71D
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_START, 0, sizeof(uint16), &value); 
0307E:  MOVLB  8
03080:  CLRF   x14
03082:  MOVLW  25
03084:  MOVWF  x13
03086:  CLRF   x15
03088:  MOVLW  02
0308A:  MOVWF  x16
0308C:  MOVLW  07
0308E:  MOVWF  x18
03090:  MOVLW  1D
03092:  MOVWF  x17
03094:  MOVLB  0
03096:  RCALL  2E2E
....................    while(!ble_log_process()); 
03098:  RCALL  2D56
0309A:  MOVF   01,F
0309C:  BZ    3098
....................  
....................    value = reading_index_stop(); 
0309E:  RCALL  2ECA
030A0:  MOVFF  01,71D
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_STOP, 0, sizeof(uint16), &value); 
030A4:  MOVLB  8
030A6:  CLRF   x14
030A8:  MOVLW  29
030AA:  MOVWF  x13
030AC:  CLRF   x15
030AE:  MOVLW  02
030B0:  MOVWF  x16
030B2:  MOVLW  07
030B4:  MOVWF  x18
030B6:  MOVLW  1D
030B8:  MOVWF  x17
030BA:  MOVLB  0
030BC:  RCALL  2E2E
....................    while(!ble_log_process()); 
030BE:  RCALL  2D56
030C0:  MOVF   01,F
030C2:  BZ    30BE
....................  
....................    config_serial_get(buff); 
030C4:  MOVLW  07
030C6:  MOVLB  7
030C8:  MOVWF  x26
030CA:  MOVLW  1F
030CC:  MOVWF  x25
030CE:  MOVLB  0
030D0:  RCALL  2F32
....................    ble_cmd_attributes_write(BLE_HANDLE_SERIAL_NUMBER, 0, 6, &buff); 
030D2:  MOVLB  8
030D4:  CLRF   x14
030D6:  MOVLW  11
030D8:  MOVWF  x13
030DA:  CLRF   x15
030DC:  MOVLW  06
030DE:  MOVWF  x16
030E0:  MOVLW  07
030E2:  MOVWF  x18
030E4:  MOVLW  1F
030E6:  MOVWF  x17
030E8:  MOVLB  0
030EA:  RCALL  2E2E
....................    while(!ble_log_process()); 
030EC:  RCALL  2D56
030EE:  MOVF   01,F
030F0:  BZ    30EC
....................     
....................    ble_cmd_attributes_write(BLE_HANDLE_READING_IN_PROGRESS, 0, 2, &progress); 
030F2:  MOVLB  8
030F4:  CLRF   x14
030F6:  MOVLW  34
030F8:  MOVWF  x13
030FA:  CLRF   x15
030FC:  MOVLW  02
030FE:  MOVWF  x16
03100:  MOVLW  07
03102:  MOVWF  x18
03104:  MOVLW  1E
03106:  MOVWF  x17
03108:  MOVLB  0
0310A:  RCALL  2E2E
....................    while(!ble_log_process()); 
0310C:  RCALL  2D56
0310E:  MOVF   01,F
03110:  BZ    310C
....................     
.................... //   ble_cmd_attributes_write(BLE_HANDLE_SERIAL_NUMBER, 0, 6, &BleModuleId); 
.................... //   while(!ble_log_process()); 
....................  
....................    ble_cmd_attributes_write(BLE_HANDLE_DEVICE_STAT, 0, sizeof(deviceStat), (uint8 *)&deviceStat); 
03112:  MOVLW  02
03114:  MOVLB  7
03116:  MOVWF  x26
03118:  MOVLW  2A
0311A:  MOVWF  x25
0311C:  MOVLB  8
0311E:  CLRF   x14
03120:  MOVLW  15
03122:  MOVWF  x13
03124:  CLRF   x15
03126:  MOVLW  10
03128:  MOVWF  x16
0312A:  MOVFF  726,818
0312E:  MOVFF  725,817
03132:  MOVLB  0
03134:  RCALL  2E2E
....................    while(!ble_log_process()); 
03136:  RCALL  2D56
03138:  MOVF   01,F
0313A:  BZ    3136
0313C:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void bleNotifyErrorSet(int8 errorBit) 
.................... {    
....................    //ErrorBits |= (1 << errorBit); 
....................    ErrorBits = errorBit; 
*
03A78:  MOVFF  812,350
....................    if (ErrorBits != LastErrorBits) { 
03A7C:  MOVLB  3
03A7E:  MOVF   x51,W
03A80:  SUBWF  x50,W
03A82:  BZ    3AFC
....................       fprintf(STDOUT, "Error bit %u set\r\n", errorBit); 
03A84:  MOVLW  8C
03A86:  MOVWF  FF6
03A88:  MOVLW  18
03A8A:  MOVWF  FF7
03A8C:  CLRF   19
03A8E:  BTFSC  FF2.7
03A90:  BSF    19.7
03A92:  BCF    FF2.7
03A94:  MOVLW  0A
03A96:  MOVLB  9
03A98:  MOVWF  x66
03A9A:  MOVLB  0
03A9C:  CALL   0AAC
03AA0:  BTFSC  19.7
03AA2:  BSF    FF2.7
03AA4:  MOVFF  812,813
03AA8:  MOVLW  1B
03AAA:  MOVLB  8
03AAC:  MOVWF  x14
03AAE:  MOVLB  0
03AB0:  RCALL  39DC
03AB2:  MOVLW  98
03AB4:  MOVWF  FF6
03AB6:  MOVLW  18
03AB8:  MOVWF  FF7
03ABA:  CLRF   19
03ABC:  BTFSC  FF2.7
03ABE:  BSF    19.7
03AC0:  BCF    FF2.7
03AC2:  MOVLW  06
03AC4:  MOVLB  9
03AC6:  MOVWF  x66
03AC8:  MOVLB  0
03ACA:  CALL   0AAC
03ACE:  BTFSC  19.7
03AD0:  BSF    FF2.7
....................       LastErrorBits = ErrorBits; 
03AD2:  MOVFF  350,351
....................       ble_cmd_attributes_write(BLE_HANDLE_ERROR_CODE, 0, 2, &ErrorBits); 
03AD6:  MOVLB  8
03AD8:  CLRF   x14
03ADA:  MOVLW  3F
03ADC:  MOVWF  x13
03ADE:  CLRF   x15
03AE0:  MOVLW  02
03AE2:  MOVWF  x16
03AE4:  MOVLW  03
03AE6:  MOVWF  x18
03AE8:  MOVLW  50
03AEA:  MOVWF  x17
03AEC:  MOVLB  0
03AEE:  CALL   2E2E
....................       while(!ble_log_process()); 
03AF2:  CALL   2D56
03AF6:  MOVF   01,F
03AF8:  BZ    3AF2
03AFA:  MOVLB  3
....................    } 
03AFC:  MOVLB  0
03AFE:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void bleNotifyErrorResetErrorBits() 
.................... { 
....................    ErrorBits = 0; 
*
04768:  MOVLB  3
0476A:  CLRF   x50
....................    if (ErrorBits != LastErrorBits) { 
0476C:  MOVF   x51,W
0476E:  SUBWF  x50,W
04770:  BZ    47AA
....................       fprintf(STDOUT, "Error bits cleared\r\n"); 
04772:  MOVLW  A0
04774:  MOVWF  FF6
04776:  MOVLW  18
04778:  MOVWF  FF7
0477A:  MOVLB  0
0477C:  CALL   2CA0
....................       LastErrorBits = ErrorBits; 
04780:  MOVFF  350,351
....................       ble_cmd_attributes_write(BLE_HANDLE_ERROR_CODE, 0, 2, &ErrorBits); 
04784:  MOVLB  8
04786:  CLRF   x14
04788:  MOVLW  3F
0478A:  MOVWF  x13
0478C:  CLRF   x15
0478E:  MOVLW  02
04790:  MOVWF  x16
04792:  MOVLW  03
04794:  MOVWF  x18
04796:  MOVLW  50
04798:  MOVWF  x17
0479A:  MOVLB  0
0479C:  CALL   2E2E
....................       while(!ble_log_process()); 
047A0:  CALL   2D56
047A4:  MOVF   01,F
047A6:  BZ    47A0
047A8:  MOVLB  3
....................    } 
047AA:  MOVLB  0
047AC:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void bleNotifyErrorReset(int8 errorBit) 
.................... { 
....................    ErrorBits &= ~(1 << errorBit); 
....................    if (ErrorBits != LastErrorBits) { 
....................       fprintf(STDOUT, "Error bit%u cleared\r\n", errorBit); 
....................       LastErrorBits = ErrorBits; 
....................       ble_cmd_attributes_write(BLE_HANDLE_ERROR_CODE, 0, 2, &ErrorBits); 
....................       while(!ble_log_process()); 
....................    } 
.................... } 
....................  
....................  
.................... #include <reading.c> 
.................... #include <reading.h> 
.................... #ifndef __READING__ 
.................... #define __READING__ 
....................  
.................... #include "datatype.h" 
....................  
.................... #define READING_ERROR_NONE                   0 
.................... #define READING_ERROR_TRAY_OPENED            1 
.................... #define READING_ERROR_CARTRIDGE_REMOVED      2 
.................... #define READING_ERROR_BOTTLE_DOOR_OPENED     3 
.................... #define READING_ERROR_CARTRIDGE_FORGOTTEN    4 
.................... #define READING_ERROR_MODULE_NOT_STRAIGHT    5 
.................... #define READING_ERROR_BAD_TEMPERATURE        6 
.................... #define READING_ERROR_BAD_ORIENTATION        7 
.................... #define READING_ERROR_BAD_READING            8 
....................  
.................... #ifdef BASE_40 
.................... // Total Size: 12 
.................... struct reading  
.................... { 
....................   uint32 timestamp; 
....................  
....................   // NOTE: WARNING. This is actually a float. 
....................   // However the PIC processor does not use IEEE-754 floats 
....................   // so we have to convert manually. 
....................   int32 value; 
....................   uint16 status; 
....................   uint16 FullTestStepID; 
.................... }; 
....................  
.................... void reading_save(uint32 timestamp, float32 value, uint16 status, uint16 fullTestStepID); 
.................... #endif 
....................  
.................... // Total Size: 18 
.................... struct reading  
.................... { 
....................    struct testResultPara   testResult; 
....................    struct timePara         time; 
....................    // NOTE: WARNING. This is actually a float. 
....................    // However the PIC processor does not use IEEE-754 floats 
....................    // so we have to convert manually. 
....................  
.................... }; 
....................  
.................... void readings_reset(); 
.................... uint16 reading_index_start(); 
.................... uint16 reading_index_stop(); 
.................... struct reading reading_fetch(uint16 index); 
.................... void reading_save(struct testResultPara *testResult, struct timePara *timestamp); 
.................... void reading_simulate(); 
....................  
.................... uint16 SetFullTestStepID(uint16 stepID); 
....................  
.................... #endif 
....................  
....................  
.................... //#include <rtc.h> 
.................... #include <ble.h> 
.................... #ifndef __BLE__ 
.................... #define __BLE__ 
....................  
....................  
.................... typedef struct bd_addr_t 
.................... { 
....................   uint8 addr[6]; 
.................... } bd_addr; 
....................  
.................... typedef bd_addr hwaddr; 
....................  
.................... typedef struct 
.................... { 
....................   uint8 len; 
....................   uint8 data[]; 
.................... } uint8array; 
....................  
.................... struct ble_header 
.................... { 
....................     uint8  type_hilen; 
....................     uint8  lolen; 
....................     uint8  cls; 
....................     uint8  command; 
.................... }; 
....................  
.................... struct ble_msg_system_boot_evt_t 
.................... { 
....................    uint16   major; 
....................    uint16   minor; 
....................    uint16   patch; 
....................    uint16   build; 
....................    uint16   ll_version; 
....................    uint8    protocol_version; 
....................    uint8    hw; 
.................... }; 
....................  
.................... struct ble_msg_attributes_value_evt_t 
.................... { 
....................    uint8       connection; 
....................    uint8       reason; 
....................    uint16      handle; 
....................    uint16      offset; 
....................    uint8array  value; 
.................... }; 
....................  
.................... #define BLE_RESET_PIN PIN_B2 
....................  
.................... #define BLE_HANDLE_SERIAL_NUMBER 17 
.................... #define BLE_HANDLE_DEVICE_STAT 21 
.................... #define BLE_HANDLE_TEST_STAGE 25 
.................... #define BLE_HANDLE_TEST_STAT 29 
.................... #define BLE_HANDLE_TEST_REPORT 33 
.................... #define BLE_HANDLE_INDEX_START 37 
.................... #define BLE_HANDLE_INDEX_STOP 41 
.................... #define BLE_HANDLE_INDEX_CURRENT 45 
.................... #define BLE_HANDLE_READING 48 
.................... #define BLE_HANDLE_READING_IN_PROGRESS 52 
.................... #define BLE_HANDLE_OPCODE 56 
.................... #define BLE_HANDLE_STATE_CODE 59 
.................... #define BLE_HANDLE_ERROR_CODE 63 
....................  
.................... #define BLE_HANDLE_RX 68 
.................... #define BLE_HANDLE_TX 71 
....................  
.................... enum BleOpcodes  
.................... { 
....................    OPCODE_BLE_START_KETONE_TEST = 0, 
....................    OPCODE_BLE_START_AMMONIA_TEST, 
....................    OPCODE_RESET_USE_COUNTER, 
....................    OPCODE_RESET_READINGS, 
....................    OPCODE_RESET_STATE_MACHINE = 0XFA, 
....................    OPCODE_BLE_START_FIRMWARE_UPDATE = 0xFF, 
....................  
.................... }; 
....................  
.................... void ble_cmd_system_hello(); 
.................... void ble_cmd_system_AddressGet(); 
.................... void ble_cmd_gap_set_mode(uint8 discover, uint8 connect); 
.................... void ble_cmd_attributes_write(uint16 handle, uint8 offset, uint8 length, uint8 *value); 
.................... void ble_wait(int32 timeout); 
.................... void ble_wait_for_message(uint8 start); 
.................... void ble_process(); 
.................... void ConstructBleModule(); 
.................... void DisableBleModule(); 
.................... void bleNotifyErrorSet(int8 errorBit); 
.................... void bleNotifyErrorReset(int8 errorBit); 
.................... uint8 ble_log_process(); 
.................... void ble_configure(); 
....................  
....................  
.................... #endif 
....................  
.................... //#include <Temperature.h> 
.................... //#include <Orientation.h> 
.................... #include <Peripherals.h> 
.................... #ifndef __PERIPHERALS__ 
.................... #define __PERIPHERALS__ 
....................  
.................... #define BUTTON_PRIMARY 0 
.................... #define BUTTON_RESET 1 
.................... #define DETECT_CARTRIDGE 2 
.................... #define DETECT_BOTTLE_DOOR_ALT 3 
.................... #define DETECT_TRAY 4 
.................... #define DETECT_BOTTLE_DOOR 7 
.................... #define DETECT_OVER_TEMPERATURE 6 
.................... #define DETECT_BOTTLE 5 
....................  
.................... #define CHECK_BIT(var,pos) ((var) & (1<<(pos))) 
.................... #define CHECK_SWITCH(var, pos) !CHECK_BIT(var, pos) 
....................  
.................... #define SOLENOID_PIN PIN_D5 
.................... #define SOLENOID_POLARITY_SWAP 0 
....................  
.................... #define NOTE_C 261 
.................... #define NOTE_D 293 
.................... #define NOTE_E 329 
.................... #define NOTE_F 349 
.................... #define NOTE_G 391 
.................... #define NOTE_A 440 
.................... #define NOTE_B 493 
....................  
.................... struct colorRGB { 
....................    uint16 Red, Green, Blue; 
.................... }; 
....................  
....................  
....................  
.................... int read_switches(); 
.................... int read_switch(int pin); 
.................... int16 photodiode(); 
....................  
.................... #ifdef BASE_40 
.................... void tray_init(); 
.................... void tray_open(); 
.................... void tray_open_loop(); 
.................... #endif 
....................  
.................... void tone(int32 frequency_hz); 
.................... void play(); 
.................... void play_error(); 
.................... void play_error_hw_failure() ; 
....................  
.................... #ifdef BASE_40 
.................... void SetButtonColor(uint16 Red, uint16 Green, uint16 Blue); 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include <ErrorCodes.h> 
.................... #ifndef __ERROR_CODES__ 
.................... #define __ERROR_CODES__ 
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... enum ErrorBitsDefinition 
.................... { 
.................... //   LIS3DH_MALFUNCTION = 0, 
....................    BME680_MALFUNCTION = 0, 
....................    EEPROM_MALFUNCTON, 
....................    LED_MALFUNCTION, 
....................     
....................    ERROR_UNKNOWN = 0XFF 
.................... }; 
....................  
.................... //Result Errors Code 
.................... #define MYSTATUS_OK              0x0 
.................... #define LOW_PRESSURE_BREATH      0X3 
....................  
.................... /* Device Errors Code*/ 
.................... //#define LIS3DH_FAIL                       2 
.................... #define BLE_FAIL                          4 
.................... #define EEPROM_FAIL                       8 
.................... #define BME680_SENSOR_FAIL                16 
.................... #define LED_FAIL                          32 
.................... #define XXXXX_FAIL                        64 
.................... #define NULL_POINTER_DETECTED             128 
....................  
.................... extern int8 ErrorBits; 
.................... extern int8 LastErrorBits; 
....................  
.................... #endif 
....................  
....................  
....................  
.................... uint16 LastFullStepID = SEND_RESULTS; 
....................  
.................... //////////////////////////////////////// 
.................... void readings_reset()  
*
092D4:  CLRF   19
092D6:  BTFSC  FF2.7
092D8:  BSF    19.7
092DA:  BCF    FF2.7
.................... { 
....................    //Zerorize current index 
....................    write_ext_eeprom(CONFIG_READING_INDEX_START + 0, 0); 
092DC:  MOVLB  9
092DE:  CLRF   x75
092E0:  MOVLW  1E
092E2:  MOVWF  x74
092E4:  CLRF   x76
092E6:  MOVLB  0
092E8:  CALL   09EC
092EC:  BTFSC  19.7
092EE:  BSF    FF2.7
092F0:  CLRF   19
092F2:  BTFSC  FF2.7
092F4:  BSF    19.7
092F6:  BCF    FF2.7
....................    write_ext_eeprom(CONFIG_READING_INDEX_START + 1, 0); 
092F8:  MOVLB  9
092FA:  CLRF   x75
092FC:  MOVLW  1F
092FE:  MOVWF  x74
09300:  CLRF   x76
09302:  MOVLB  0
09304:  CALL   09EC
09308:  BTFSC  19.7
0930A:  BSF    FF2.7
0930C:  CLRF   19
0930E:  BTFSC  FF2.7
09310:  BSF    19.7
09312:  BCF    FF2.7
....................  
....................    write_ext_eeprom(CONFIG_READING_INDEX_STOP + 0, 0); 
09314:  MOVLB  9
09316:  CLRF   x75
09318:  MOVLW  20
0931A:  MOVWF  x74
0931C:  CLRF   x76
0931E:  MOVLB  0
09320:  CALL   09EC
09324:  BTFSC  19.7
09326:  BSF    FF2.7
09328:  CLRF   19
0932A:  BTFSC  FF2.7
0932C:  BSF    19.7
0932E:  BCF    FF2.7
....................    write_ext_eeprom(CONFIG_READING_INDEX_STOP + 1, 0); 
09330:  MOVLB  9
09332:  CLRF   x75
09334:  MOVLW  21
09336:  MOVWF  x74
09338:  CLRF   x76
0933A:  MOVLB  0
0933C:  CALL   09EC
09340:  BTFSC  19.7
09342:  BSF    FF2.7
....................  
....................    struct reading r; 
....................    uint8  ctr; 
....................    uint8  *ptr = (uint8 *)&r; 
09344:  MOVLW  07
09346:  MOVLB  7
09348:  MOVWF  x1C
0934A:  MOVLW  01
0934C:  MOVFF  71C,715
09350:  MOVWF  x14
....................    
....................    //Clear the r structure 
....................    for( ctr = 0; ctr < sizeof( r ); ctr++ ) 
09352:  CLRF   x13
09354:  MOVF   x13,W
09356:  SUBLW  11
09358:  BNC   936C
....................       ptr[ctr] = 0; 
0935A:  MOVF   x13,W
0935C:  ADDWF  x14,W
0935E:  MOVWF  FE9
09360:  MOVLW  00
09362:  ADDWFC x15,W
09364:  MOVWF  FEA
09366:  CLRF   FEF
09368:  INCF   x13,F
0936A:  BRA    9354
....................  
....................    uint16 a = CONFIG_READING_BASE; 
0936C:  CLRF   x17
0936E:  MOVLW  28
09370:  MOVWF  x16
....................    
....................    for(uint8 i = 0; i < CONFIG_READING_COUNT; i++)  
09372:  CLRF   x18
09374:  MOVF   x18,W
09376:  SUBLW  09
09378:  BNC   93D0
....................    { 
....................       for(int j = 0; j < sizeof(struct reading); j++)  
0937A:  CLRF   x19
0937C:  BTFSC  x19.7
0937E:  BRA    9386
09380:  MOVF   x19,W
09382:  SUBLW  11
09384:  BNC   93CC
....................          write_ext_eeprom(a++, ptr[j]); 
09386:  MOVFF  717,03
0938A:  MOVF   x16,W
0938C:  INCF   x16,F
0938E:  BTFSC  FD8.2
09390:  INCF   x17,F
09392:  MOVWF  x1B
09394:  MOVFF  03,975
09398:  CLRF   03
0939A:  MOVF   x19,W
0939C:  MOVWF  00
0939E:  BTFSC  FE8.7
093A0:  DECF   03,F
093A2:  ADDWF  x14,W
093A4:  MOVWF  FE9
093A6:  MOVF   x15,W
093A8:  ADDWFC 03,W
093AA:  MOVWF  FEA
093AC:  MOVFF  FEF,976
093B0:  CLRF   19
093B2:  BTFSC  FF2.7
093B4:  BSF    19.7
093B6:  BCF    FF2.7
093B8:  MOVFF  71B,974
093BC:  MOVLB  0
093BE:  CALL   09EC
093C2:  BTFSC  19.7
093C4:  BSF    FF2.7
093C6:  MOVLB  7
093C8:  INCF   x19,F
093CA:  BRA    937C
093CC:  INCF   x18,F
093CE:  BRA    9374
....................    } 
....................  
....................    uint8 message = ble_data_message_count; 
093D0:  MOVFF  453,71A
....................    a = 0; 
093D4:  CLRF   x17
093D6:  CLRF   x16
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_START, 0, 2, (uint8 *)&a); 
093D8:  MOVLW  07
093DA:  MOVWF  x1C
093DC:  MOVLW  16
093DE:  MOVWF  x1B
093E0:  MOVLB  8
093E2:  CLRF   x14
093E4:  MOVLW  25
093E6:  MOVWF  x13
093E8:  CLRF   x15
093EA:  MOVLW  02
093EC:  MOVWF  x16
093EE:  MOVFF  71C,818
093F2:  MOVFF  71B,817
093F6:  MOVLB  0
093F8:  CALL   2E2E
....................    ble_wait_for_message(message); 
093FC:  MOVFF  71A,71B
09400:  RCALL  92C0
....................  
....................    message = ble_data_message_count; 
09402:  MOVFF  453,71A
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_STOP, 0, 2, (uint8 *)&a); 
09406:  MOVLW  07
09408:  MOVLB  7
0940A:  MOVWF  x1C
0940C:  MOVLW  16
0940E:  MOVWF  x1B
09410:  MOVLB  8
09412:  CLRF   x14
09414:  MOVLW  29
09416:  MOVWF  x13
09418:  CLRF   x15
0941A:  MOVLW  02
0941C:  MOVWF  x16
0941E:  MOVFF  71C,818
09422:  MOVFF  71B,817
09426:  MOVLB  0
09428:  CALL   2E2E
....................    ble_wait_for_message(message); 
0942C:  MOVFF  71A,71B
09430:  RCALL  92C0
....................     
....................    fprintf(STDOUT, "Start Index: %lu. Stop Index: 0x%lu.\r\n", reading_index_start(), reading_index_stop()); 
09432:  CALL   2DC6
09436:  MOVFF  02,71C
0943A:  MOVFF  01,71B
0943E:  CALL   2ECA
09442:  MOVFF  02,71E
09446:  MOVFF  01,71D
0944A:  MOVLW  CC
0944C:  MOVWF  FF6
0944E:  MOVLW  18
09450:  MOVWF  FF7
09452:  CLRF   19
09454:  BTFSC  FF2.7
09456:  BSF    19.7
09458:  BCF    FF2.7
0945A:  MOVLW  0D
0945C:  MOVLB  9
0945E:  MOVWF  x66
09460:  MOVLB  0
09462:  CALL   0AAC
09466:  BTFSC  19.7
09468:  BSF    FF2.7
0946A:  MOVLW  10
0946C:  MOVWF  FE9
0946E:  CLRF   19
09470:  BTFSC  FF2.7
09472:  BSF    19.7
09474:  BCF    FF2.7
09476:  MOVFF  71C,967
0947A:  MOVFF  71B,966
0947E:  CALL   0AD6
09482:  BTFSC  19.7
09484:  BSF    FF2.7
09486:  MOVLW  DC
09488:  MOVWF  FF6
0948A:  MOVLW  18
0948C:  MOVWF  FF7
0948E:  CLRF   19
09490:  BTFSC  FF2.7
09492:  BSF    19.7
09494:  BCF    FF2.7
09496:  MOVLW  10
09498:  MOVLB  9
0949A:  MOVWF  x66
0949C:  MOVLB  0
0949E:  CALL   0AAC
094A2:  BTFSC  19.7
094A4:  BSF    FF2.7
094A6:  MOVLW  10
094A8:  MOVWF  FE9
094AA:  CLRF   19
094AC:  BTFSC  FF2.7
094AE:  BSF    19.7
094B0:  BCF    FF2.7
094B2:  MOVFF  71E,967
094B6:  MOVFF  71D,966
094BA:  CALL   0AD6
094BE:  BTFSC  19.7
094C0:  BSF    FF2.7
094C2:  MOVLW  EF
094C4:  MOVWF  FF6
094C6:  MOVLW  18
094C8:  MOVWF  FF7
094CA:  CLRF   19
094CC:  BTFSC  FF2.7
094CE:  BSF    19.7
094D0:  BCF    FF2.7
094D2:  MOVLW  03
094D4:  MOVLB  9
094D6:  MOVWF  x66
094D8:  MOVLB  0
094DA:  CALL   0AAC
094DE:  BTFSC  19.7
094E0:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
094E2:  MOVLW  01
094E4:  MOVWF  FEA
094E6:  MOVLW  A7
094E8:  MOVWF  FE9
094EA:  CALL   2D08
094EE:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 reading_index_start()  
*
02DC6:  MOVLB  7
02DC8:  CLRF   x52
02DCA:  CLRF   x51
02DCC:  MOVLW  07
02DCE:  MOVWF  x54
02DD0:  MOVLW  51
02DD2:  MOVWF  x53
.................... { 
....................    uint16 records_start = 0; 
....................    uint8 * pointer = &records_start; 
....................    pointer[0] = read_ext_eeprom(CONFIG_READING_INDEX_START + 0); 
02DD4:  MOVFF  753,01
02DD8:  MOVFF  754,756
02DDC:  MOVFF  01,755
02DE0:  CLRF   x5F
02DE2:  MOVLW  1E
02DE4:  MOVWF  x5E
02DE6:  MOVLB  0
02DE8:  RCALL  2C1A
02DEA:  MOVFF  756,FEA
02DEE:  MOVFF  755,FE9
02DF2:  MOVFF  01,FEF
....................    pointer[1] = read_ext_eeprom(CONFIG_READING_INDEX_START + 1); 
02DF6:  MOVLW  01
02DF8:  MOVLB  7
02DFA:  ADDWF  x53,W
02DFC:  MOVWF  01
02DFE:  MOVLW  00
02E00:  ADDWFC x54,W
02E02:  MOVWF  03
02E04:  MOVFF  01,755
02E08:  MOVWF  x56
02E0A:  CLRF   x5F
02E0C:  MOVLW  1F
02E0E:  MOVWF  x5E
02E10:  MOVLB  0
02E12:  RCALL  2C1A
02E14:  MOVFF  756,FEA
02E18:  MOVFF  755,FE9
02E1C:  MOVFF  01,FEF
....................  
....................    return records_start; 
02E20:  MOVLB  7
02E22:  MOVFF  751,01
02E26:  MOVFF  752,02
02E2A:  MOVLB  0
02E2C:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 reading_index_stop()  
*
02ECA:  MOVLB  7
02ECC:  CLRF   x54
02ECE:  CLRF   x53
02ED0:  MOVLW  07
02ED2:  MOVWF  x56
02ED4:  MOVLW  53
02ED6:  MOVWF  x55
.................... { 
....................    uint16 records_stop = 0; 
....................    uint8 * pointer = &records_stop; 
....................    pointer[0] = read_ext_eeprom(CONFIG_READING_INDEX_STOP + 0); 
02ED8:  MOVFF  755,01
02EDC:  MOVFF  756,758
02EE0:  MOVFF  01,757
02EE4:  CLRF   x5F
02EE6:  MOVLW  20
02EE8:  MOVWF  x5E
02EEA:  MOVLB  0
02EEC:  RCALL  2C1A
02EEE:  MOVFF  758,FEA
02EF2:  MOVFF  757,FE9
02EF6:  MOVFF  01,FEF
....................    pointer[1] = read_ext_eeprom(CONFIG_READING_INDEX_STOP + 1); 
02EFA:  MOVLW  01
02EFC:  MOVLB  7
02EFE:  ADDWF  x55,W
02F00:  MOVWF  01
02F02:  MOVLW  00
02F04:  ADDWFC x56,W
02F06:  MOVWF  03
02F08:  MOVFF  01,757
02F0C:  MOVWF  x58
02F0E:  CLRF   x5F
02F10:  MOVLW  21
02F12:  MOVWF  x5E
02F14:  MOVLB  0
02F16:  RCALL  2C1A
02F18:  MOVFF  758,FEA
02F1C:  MOVFF  757,FE9
02F20:  MOVFF  01,FEF
....................  
....................    return records_stop; 
02F24:  MOVLB  7
02F26:  MOVFF  753,01
02F2A:  MOVFF  754,02
02F2E:  MOVLB  0
02F30:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void reading_save(struct testResultPara *testResult, struct timePara *timestamp) 
.................... { 
....................    struct reading r; 
....................    
....................    r.time.second = timestamp->second; 
*
0836E:  MOVLW  02
08370:  MOVLB  7
08372:  ADDWF  x33,W
08374:  MOVWF  FE9
08376:  MOVLW  00
08378:  ADDWFC x34,W
0837A:  MOVWF  FEA
0837C:  MOVFF  FEF,743
....................    r.time.minute = timestamp->minute; 
08380:  MOVLW  01
08382:  ADDWF  x33,W
08384:  MOVWF  FE9
08386:  MOVLW  00
08388:  ADDWFC x34,W
0838A:  MOVWF  FEA
0838C:  MOVFF  FEF,742
....................    r.time.hour = timestamp->hour; 
08390:  MOVFF  733,FE9
08394:  MOVFF  734,FEA
08398:  MOVFF  FEF,741
....................    r.time.day = timestamp->day; 
0839C:  MOVLW  03
0839E:  ADDWF  x33,W
083A0:  MOVWF  FE9
083A2:  MOVLW  00
083A4:  ADDWFC x34,W
083A6:  MOVWF  FEA
083A8:  MOVFF  FEF,744
....................    r.time.month = timestamp->month; 
083AC:  MOVLW  04
083AE:  ADDWF  x33,W
083B0:  MOVWF  FE9
083B2:  MOVLW  00
083B4:  ADDWFC x34,W
083B6:  MOVWF  FEA
083B8:  MOVFF  FEF,745
....................    r.time.year = timestamp->year; 
083BC:  MOVLW  05
083BE:  ADDWF  x33,W
083C0:  MOVWF  FE9
083C2:  MOVLW  00
083C4:  ADDWFC x34,W
083C6:  MOVWF  FEA
083C8:  MOVFF  FEF,746
....................     
....................    r.testResult.testMode = testResult->testMode; 
083CC:  MOVFF  731,FE9
083D0:  MOVFF  732,FEA
083D4:  MOVFF  FEC,736
083D8:  MOVF   FED,F
083DA:  MOVFF  FEF,735
....................    r.testResult.totalTestTime = testResult->totalTestTime; 
083DE:  MOVLW  02
083E0:  ADDWF  x31,W
083E2:  MOVWF  FE9
083E4:  MOVLW  00
083E6:  ADDWFC x32,W
083E8:  MOVWF  FEA
083EA:  MOVFF  FEF,737
083EE:  MOVFF  FEC,738
083F2:  MOVFF  FEC,739
083F6:  MOVFF  FEC,73A
....................    r.testResult.score = testResult->score; 
083FA:  MOVLW  06
083FC:  ADDWF  x31,W
083FE:  MOVWF  FE9
08400:  MOVLW  00
08402:  ADDWFC x32,W
08404:  MOVWF  FEA
08406:  MOVFF  FEF,73B
0840A:  MOVFF  FEC,73C
0840E:  MOVFF  FEC,73D
08412:  MOVFF  FEC,73E
....................     
....................    r.testResult.status = testResult->status; 
08416:  MOVLW  0A
08418:  ADDWF  x31,W
0841A:  MOVWF  FE9
0841C:  MOVLW  00
0841E:  ADDWFC x32,W
08420:  MOVWF  FEA
08422:  MOVFF  FEF,73F
....................    r.testResult.stepID = testResult->stepID; 
08426:  MOVLW  0B
08428:  ADDWF  x31,W
0842A:  MOVWF  FE9
0842C:  MOVLW  00
0842E:  ADDWFC x32,W
08430:  MOVWF  FEA
08432:  MOVFF  FEF,740
....................     
.................... //   uint8 message = 0; 
....................    uint8 * pointer; 
....................  
....................    uint16 records_start = reading_index_start(); 
....................    uint16 records_stop = reading_index_stop(); 
....................    uint16 reading_base = CONFIG_READING_BASE + ( records_stop * sizeof(r) ); 
08436:  MOVLB  0
08438:  CALL   2DC6
0843C:  MOVFF  02,74A
08440:  MOVFF  01,749
08444:  CALL   2ECA
08448:  MOVFF  02,74C
0844C:  MOVFF  01,74B
08450:  MOVFF  74C,752
08454:  MOVFF  74B,751
08458:  MOVLB  7
0845A:  CLRF   x54
0845C:  MOVLW  12
0845E:  MOVWF  x53
08460:  MOVLB  0
08462:  CALL   3DEA
08466:  MOVF   01,W
08468:  ADDLW  28
0846A:  MOVLB  7
0846C:  MOVWF  x4D
0846E:  MOVLW  00
08470:  ADDWFC 02,W
08472:  MOVWF  x4E
....................  
....................    pointer = (uint8 *) &r; 
08474:  MOVLW  07
08476:  MOVWF  x52
08478:  MOVLW  35
0847A:  MOVFF  752,748
0847E:  MOVWF  x47
....................    for(uint16 i = 0; i < sizeof(struct reading); i++)  
08480:  CLRF   x50
08482:  CLRF   x4F
08484:  MOVF   x50,F
08486:  BNZ   84CE
08488:  MOVF   x4F,W
0848A:  SUBLW  11
0848C:  BNC   84CE
....................       write_ext_eeprom(reading_base + i, pointer[i]); 
0848E:  MOVF   x4F,W
08490:  ADDWF  x4D,W
08492:  MOVWF  x51
08494:  MOVF   x50,W
08496:  ADDWFC x4E,W
08498:  MOVWF  x52
0849A:  MOVF   x47,W
0849C:  ADDWF  x4F,W
0849E:  MOVWF  FE9
084A0:  MOVF   x48,W
084A2:  ADDWFC x50,W
084A4:  MOVWF  FEA
084A6:  MOVFF  FEF,976
084AA:  CLRF   19
084AC:  BTFSC  FF2.7
084AE:  BSF    19.7
084B0:  BCF    FF2.7
084B2:  MOVFF  752,975
084B6:  MOVFF  751,974
084BA:  MOVLB  0
084BC:  CALL   09EC
084C0:  BTFSC  19.7
084C2:  BSF    FF2.7
084C4:  MOVLB  7
084C6:  INCF   x4F,F
084C8:  BTFSC  FD8.2
084CA:  INCF   x50,F
084CC:  BRA    8484
....................  
....................    records_stop++; 
084CE:  INCF   x4B,F
084D0:  BTFSC  FD8.2
084D2:  INCF   x4C,F
....................    if(records_stop == CONFIG_READING_COUNT)  
084D4:  MOVF   x4B,W
084D6:  SUBLW  0A
084D8:  BNZ   84E2
084DA:  MOVF   x4C,F
084DC:  BNZ   84E2
....................       records_stop = 0; 
084DE:  CLRF   x4C
084E0:  CLRF   x4B
....................  
....................    if(records_start >= records_stop)  
084E2:  MOVF   x4C,W
084E4:  SUBWF  x4A,W
084E6:  BNC   8504
084E8:  BNZ   84F0
084EA:  MOVF   x4B,W
084EC:  SUBWF  x49,W
084EE:  BNC   8504
....................    { 
....................       records_start++; 
084F0:  INCF   x49,F
084F2:  BTFSC  FD8.2
084F4:  INCF   x4A,F
....................        
....................       if(records_start == CONFIG_READING_COUNT)  
084F6:  MOVF   x49,W
084F8:  SUBLW  0A
084FA:  BNZ   8504
084FC:  MOVF   x4A,F
084FE:  BNZ   8504
....................          records_start = 0; 
08500:  CLRF   x4A
08502:  CLRF   x49
....................      
....................    } 
....................  
....................    pointer = (uint8 *) &records_start; 
08504:  MOVLW  07
08506:  MOVWF  x52
08508:  MOVLW  49
0850A:  MOVFF  752,748
0850E:  MOVWF  x47
....................    write_ext_eeprom(CONFIG_READING_INDEX_START + 0, pointer[0]); 
08510:  MOVFF  747,FE9
08514:  MOVFF  748,FEA
08518:  MOVFF  FEF,976
0851C:  CLRF   19
0851E:  BTFSC  FF2.7
08520:  BSF    19.7
08522:  BCF    FF2.7
08524:  MOVLB  9
08526:  CLRF   x75
08528:  MOVLW  1E
0852A:  MOVWF  x74
0852C:  MOVLB  0
0852E:  CALL   09EC
08532:  BTFSC  19.7
08534:  BSF    FF2.7
....................    write_ext_eeprom(CONFIG_READING_INDEX_START + 1, pointer[1]); 
08536:  MOVLW  01
08538:  MOVLB  7
0853A:  ADDWF  x47,W
0853C:  MOVWF  FE9
0853E:  MOVLW  00
08540:  ADDWFC x48,W
08542:  MOVWF  FEA
08544:  MOVFF  FEF,976
08548:  CLRF   19
0854A:  BTFSC  FF2.7
0854C:  BSF    19.7
0854E:  BCF    FF2.7
08550:  MOVLB  9
08552:  CLRF   x75
08554:  MOVLW  1F
08556:  MOVWF  x74
08558:  MOVLB  0
0855A:  CALL   09EC
0855E:  BTFSC  19.7
08560:  BSF    FF2.7
....................  
....................    pointer = (uint8 *) &records_stop; 
08562:  MOVLW  07
08564:  MOVLB  7
08566:  MOVWF  x52
08568:  MOVLW  4B
0856A:  MOVFF  752,748
0856E:  MOVWF  x47
....................    write_ext_eeprom(CONFIG_READING_INDEX_STOP + 0, pointer[0]); 
08570:  MOVFF  747,FE9
08574:  MOVFF  748,FEA
08578:  MOVFF  FEF,976
0857C:  CLRF   19
0857E:  BTFSC  FF2.7
08580:  BSF    19.7
08582:  BCF    FF2.7
08584:  MOVLB  9
08586:  CLRF   x75
08588:  MOVLW  20
0858A:  MOVWF  x74
0858C:  MOVLB  0
0858E:  CALL   09EC
08592:  BTFSC  19.7
08594:  BSF    FF2.7
....................    write_ext_eeprom(CONFIG_READING_INDEX_STOP + 1, pointer[1]); 
08596:  MOVLW  01
08598:  MOVLB  7
0859A:  ADDWF  x47,W
0859C:  MOVWF  FE9
0859E:  MOVLW  00
085A0:  ADDWFC x48,W
085A2:  MOVWF  FEA
085A4:  MOVFF  FEF,976
085A8:  CLRF   19
085AA:  BTFSC  FF2.7
085AC:  BSF    19.7
085AE:  BCF    FF2.7
085B0:  MOVLB  9
085B2:  CLRF   x75
085B4:  MOVLW  21
085B6:  MOVWF  x74
085B8:  MOVLB  0
085BA:  CALL   09EC
085BE:  BTFSC  19.7
085C0:  BSF    FF2.7
....................  
.................... //   message = ble_data_message_count; 
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_START, 0, 2, (uint8 *)&records_start); 
085C2:  MOVLW  07
085C4:  MOVLB  7
085C6:  MOVWF  x52
085C8:  MOVLW  49
085CA:  MOVWF  x51
085CC:  MOVLB  8
085CE:  CLRF   x14
085D0:  MOVLW  25
085D2:  MOVWF  x13
085D4:  CLRF   x15
085D6:  MOVLW  02
085D8:  MOVWF  x16
085DA:  MOVFF  752,818
085DE:  MOVFF  751,817
085E2:  MOVLB  0
085E4:  CALL   2E2E
.................... //   ble_wait_for_message(message); 
....................  
.................... //   message = ble_data_message_count; 
....................    ble_cmd_attributes_write(BLE_HANDLE_INDEX_STOP, 0, 2, (uint8 *)&records_stop); 
085E8:  MOVLW  07
085EA:  MOVLB  7
085EC:  MOVWF  x52
085EE:  MOVLW  4B
085F0:  MOVWF  x51
085F2:  MOVLB  8
085F4:  CLRF   x14
085F6:  MOVLW  29
085F8:  MOVWF  x13
085FA:  CLRF   x15
085FC:  MOVLW  02
085FE:  MOVWF  x16
08600:  MOVFF  752,818
08604:  MOVFF  751,817
08608:  MOVLB  0
0860A:  CALL   2E2E
.................... //   ble_wait_for_message(message); 
....................  
....................    fprintf(STDOUT, "Start Index: %lu. Stop Index: 0x%lu.\r\n", reading_index_start(), reading_index_stop()); 
0860E:  CALL   2DC6
08612:  MOVFF  02,752
08616:  MOVFF  01,751
0861A:  CALL   2ECA
0861E:  MOVFF  02,754
08622:  MOVFF  01,753
08626:  MOVLW  F4
08628:  MOVWF  FF6
0862A:  MOVLW  18
0862C:  MOVWF  FF7
0862E:  CLRF   19
08630:  BTFSC  FF2.7
08632:  BSF    19.7
08634:  BCF    FF2.7
08636:  MOVLW  0D
08638:  MOVLB  9
0863A:  MOVWF  x66
0863C:  MOVLB  0
0863E:  CALL   0AAC
08642:  BTFSC  19.7
08644:  BSF    FF2.7
08646:  MOVLW  10
08648:  MOVWF  FE9
0864A:  CLRF   19
0864C:  BTFSC  FF2.7
0864E:  BSF    19.7
08650:  BCF    FF2.7
08652:  MOVFF  752,967
08656:  MOVFF  751,966
0865A:  CALL   0AD6
0865E:  BTFSC  19.7
08660:  BSF    FF2.7
08662:  MOVLW  04
08664:  MOVWF  FF6
08666:  MOVLW  19
08668:  MOVWF  FF7
0866A:  CLRF   19
0866C:  BTFSC  FF2.7
0866E:  BSF    19.7
08670:  BCF    FF2.7
08672:  MOVLW  10
08674:  MOVLB  9
08676:  MOVWF  x66
08678:  MOVLB  0
0867A:  CALL   0AAC
0867E:  BTFSC  19.7
08680:  BSF    FF2.7
08682:  MOVLW  10
08684:  MOVWF  FE9
08686:  CLRF   19
08688:  BTFSC  FF2.7
0868A:  BSF    19.7
0868C:  BCF    FF2.7
0868E:  MOVFF  754,967
08692:  MOVFF  753,966
08696:  CALL   0AD6
0869A:  BTFSC  19.7
0869C:  BSF    FF2.7
0869E:  MOVLW  17
086A0:  MOVWF  FF6
086A2:  MOVLW  19
086A4:  MOVWF  FF7
086A6:  CLRF   19
086A8:  BTFSC  FF2.7
086AA:  BSF    19.7
086AC:  BCF    FF2.7
086AE:  MOVLW  03
086B0:  MOVLB  9
086B2:  MOVWF  x66
086B4:  MOVLB  0
086B6:  CALL   0AAC
086BA:  BTFSC  19.7
086BC:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
086BE:  MOVLW  01
086C0:  MOVWF  FEA
086C2:  MOVLW  A7
086C4:  MOVWF  FE9
086C6:  CALL   2D08
086CA:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... struct reading reading_fetch(uint16 index)  
.................... { 
....................    index = index % CONFIG_READING_COUNT; 
*
04F64:  MOVFF  738,751
04F68:  MOVFF  737,750
04F6C:  MOVLB  7
04F6E:  CLRF   x53
04F70:  MOVLW  0A
04F72:  MOVWF  x52
04F74:  MOVLB  0
04F76:  BRA    4F1C
04F78:  MOVFF  00,737
04F7C:  MOVLB  7
04F7E:  MOVFF  03,738
....................    uint16 reading_base = CONFIG_READING_BASE + (index * sizeof(struct reading)); 
....................  
....................    struct reading r; 
....................    uint8 * pointer = &r; 
04F82:  MOVFF  738,752
04F86:  MOVFF  737,751
04F8A:  CLRF   x54
04F8C:  MOVLW  12
04F8E:  MOVWF  x53
04F90:  MOVLB  0
04F92:  CALL   3DEA
04F96:  MOVF   01,W
04F98:  ADDLW  28
04F9A:  MOVLB  7
04F9C:  MOVWF  x39
04F9E:  MOVLW  00
04FA0:  ADDWFC 02,W
04FA2:  MOVWF  x3A
04FA4:  MOVLW  07
04FA6:  MOVWF  x4E
04FA8:  MOVLW  3B
04FAA:  MOVWF  x4D
....................  
....................    for(uint8 i = 0; i < sizeof(struct reading); i++)  
04FAC:  CLRF   x4F
04FAE:  MOVF   x4F,W
04FB0:  SUBLW  11
04FB2:  BNC   4FF0
....................       pointer[i] = read_ext_eeprom(reading_base + i); 
04FB4:  MOVF   x4F,W
04FB6:  ADDWF  x4D,W
04FB8:  MOVWF  01
04FBA:  MOVLW  00
04FBC:  ADDWFC x4E,W
04FBE:  MOVWF  03
04FC0:  MOVFF  01,750
04FC4:  MOVWF  x51
04FC6:  MOVF   x4F,W
04FC8:  ADDWF  x39,W
04FCA:  MOVWF  x52
04FCC:  MOVLW  00
04FCE:  ADDWFC x3A,W
04FD0:  MOVWF  x53
04FD2:  MOVWF  x5F
04FD4:  MOVFF  752,75E
04FD8:  MOVLB  0
04FDA:  CALL   2C1A
04FDE:  MOVFF  751,FEA
04FE2:  MOVFF  750,FE9
04FE6:  MOVFF  01,FEF
04FEA:  MOVLB  7
04FEC:  INCF   x4F,F
04FEE:  BRA    4FAE
....................    
....................    return r; 
04FF0:  MOVLW  3B
04FF2:  MOVWF  01
04FF4:  MOVLW  07
04FF6:  MOVWF  02
04FF8:  MOVLB  0
04FFA:  RETURN 0
.................... } 
....................  
....................  //////////////////////////////////////// 
.................... void reading_simulate() 
*
0C834:  MOVLB  7
0C836:  CLRF   x15
0C838:  MOVLW  01
0C83A:  MOVWF  x14
0C83C:  CLRF   x19
0C83E:  CLRF   x18
0C840:  MOVLW  61
0C842:  MOVWF  x17
0C844:  MOVLW  A8
0C846:  MOVWF  x16
0C848:  MOVLW  AE
0C84A:  MOVWF  x1D
0C84C:  MOVLW  D8
0C84E:  MOVWF  x1C
0C850:  MOVLW  51
0C852:  MOVWF  x1B
0C854:  MOVLW  82
0C856:  MOVWF  x1A
0C858:  CLRF   x1E
0C85A:  MOVLW  32
0C85C:  MOVWF  x1F
0C85E:  MOVLW  01
0C860:  MOVWF  x20
0C862:  MOVLW  0A
0C864:  MOVWF  x21
0C866:  MOVWF  x22
0C868:  MOVLW  0C
0C86A:  MOVWF  x23
0C86C:  MOVLW  01
0C86E:  MOVWF  x24
0C870:  MOVLW  14
0C872:  MOVWF  x25
.................... { 
....................    struct testResultPara simulateTestResult; 
....................    struct timePara simulateTimestamp; 
....................    int8     ctr; 
....................     
....................    int16    testMode = 1; 
....................    uint32   totalTestTime = 25000; 
....................    float    score = 13.1154; 
....................    uint8    status = NO_ERROR; 
....................    uint8    stepID = TEST_COMPLETED; 
....................     
....................    uint8   hour = 1; 
....................    uint8   minute = 10; 
....................    uint8   second = 10; 
....................    uint8   day = 12; 
....................    uint8   month = 1; 
....................    uint8   year = 20; 
....................     
....................    simulateTestResult.testMode = testMode; 
0C874:  MOVFF  715,702
0C878:  MOVFF  714,701
....................     
....................    simulateTestResult.totalTestTime = totalTestTime; 
0C87C:  MOVFF  719,706
0C880:  MOVFF  718,705
0C884:  MOVFF  717,704
0C888:  MOVFF  716,703
....................    simulateTestResult.status = status; 
0C88C:  MOVFF  71E,70B
....................    simulateTestResult.stepID = stepID; 
0C890:  MOVFF  71F,70C
....................     
....................    simulateTimestamp.hour = hour; 
0C894:  MOVFF  720,70D
....................    simulateTimestamp.minute = minute; 
0C898:  MOVFF  721,70E
....................    simulateTimestamp.second = second; 
0C89C:  MOVFF  722,70F
....................    simulateTimestamp.day = day; 
0C8A0:  MOVFF  723,710
....................    simulateTimestamp.month = month; 
0C8A4:  MOVFF  724,711
....................    simulateTimestamp.year = year; 
0C8A8:  MOVFF  725,712
....................     
....................    fprintf(STDOUT, "Simulate and save 10 test results\r\n"); 
0C8AC:  MOVLW  1C
0C8AE:  MOVWF  FF6
0C8B0:  MOVLW  19
0C8B2:  MOVWF  FF7
0C8B4:  MOVLB  0
0C8B6:  CALL   2CA0
....................     
....................    for( ctr = 0; ctr < 10; ctr++ ) 
0C8BA:  MOVLB  7
0C8BC:  CLRF   x13
0C8BE:  BTFSC  x13.7
0C8C0:  BRA    C8CA
0C8C2:  MOVF   x13,W
0C8C4:  SUBLW  09
0C8C6:  BTFSS  FD8.0
0C8C8:  BRA    C9E8
....................    { 
....................       simulateTestResult.totalTestTime += 1500; 
0C8CA:  MOVLW  DC
0C8CC:  ADDWF  x03,F
0C8CE:  MOVLW  05
0C8D0:  ADDWFC x04,F
0C8D2:  MOVLW  00
0C8D4:  ADDWFC x05,F
0C8D6:  ADDWFC x06,F
....................       simulateTimestamp.hour += 1; 
0C8D8:  MOVLW  01
0C8DA:  ADDWF  x0D,F
....................       simulateTimestamp.minute += 3; 
0C8DC:  MOVLW  03
0C8DE:  ADDWF  x0E,F
....................       simulateTimestamp.second += 4; 
0C8E0:  MOVLW  04
0C8E2:  ADDWF  x0F,F
....................       simulateTimestamp.day += 1; 
0C8E4:  MOVLW  01
0C8E6:  ADDWF  x10,F
....................       simulateTimestamp.month += 1; 
0C8E8:  ADDWF  x11,F
....................       score += .232; 
0C8EA:  BCF    FD8.1
0C8EC:  MOVFF  71D,835
0C8F0:  MOVFF  71C,834
0C8F4:  MOVFF  71B,833
0C8F8:  MOVFF  71A,832
0C8FC:  MOVLW  68
0C8FE:  MOVLB  8
0C900:  MOVWF  x39
0C902:  MOVLW  91
0C904:  MOVWF  x38
0C906:  MOVLW  6D
0C908:  MOVWF  x37
0C90A:  MOVLW  7C
0C90C:  MOVWF  x36
0C90E:  MOVLB  0
0C910:  CALL   6880
0C914:  MOVFF  03,71D
0C918:  MOVFF  02,71C
0C91C:  MOVFF  01,71B
0C920:  MOVFF  00,71A
....................       simulateTestResult.score = f_PICtoIEEE(score + ctr); 
0C924:  MOVLB  7
0C926:  CLRF   x31
0C928:  MOVFF  713,730
0C92C:  BTFSC  x30.7
0C92E:  DECF   x31,F
0C930:  MOVLB  0
0C932:  RCALL  C4A4
0C934:  BCF    FD8.1
0C936:  MOVFF  71D,835
0C93A:  MOVFF  71C,834
0C93E:  MOVFF  71B,833
0C942:  MOVFF  71A,832
0C946:  MOVFF  03,839
0C94A:  MOVFF  02,838
0C94E:  MOVFF  01,837
0C952:  MOVFF  00,836
0C956:  CALL   6880
0C95A:  MOVFF  03,729
0C95E:  MOVFF  02,728
0C962:  MOVFF  01,727
0C966:  MOVFF  00,726
0C96A:  MOVFF  03,23
0C96E:  MOVFF  02,22
0C972:  MOVFF  01,21
0C976:  MOVFF  00,20
0C97A:  CALL   66E0
0C97E:  MOVFF  03,70A
0C982:  MOVFF  02,709
0C986:  MOVFF  01,708
0C98A:  MOVFF  00,707
....................       reading_save( &simulateTestResult, &simulateTimestamp ); 
0C98E:  MOVLW  07
0C990:  MOVLB  7
0C992:  MOVWF  x32
0C994:  MOVLW  01
0C996:  MOVWF  x31
0C998:  MOVLW  07
0C99A:  MOVWF  x34
0C99C:  MOVLW  0D
0C99E:  MOVWF  x33
0C9A0:  MOVLB  0
0C9A2:  CALL   836E
....................       delay_ms(50); 
0C9A6:  MOVLW  32
0C9A8:  MOVLB  8
0C9AA:  MOVWF  x18
0C9AC:  MOVLB  0
0C9AE:  CALL   2D2E
....................       fprintf(STDOUT, "%d record\r\n", ctr); 
0C9B2:  MOVFF  713,812
0C9B6:  MOVLW  18
0C9B8:  MOVLB  8
0C9BA:  MOVWF  x13
0C9BC:  MOVLB  0
0C9BE:  CALL   2AEC
0C9C2:  MOVLW  42
0C9C4:  MOVWF  FF6
0C9C6:  MOVLW  19
0C9C8:  MOVWF  FF7
0C9CA:  CLRF   19
0C9CC:  BTFSC  FF2.7
0C9CE:  BSF    19.7
0C9D0:  BCF    FF2.7
0C9D2:  MOVLW  09
0C9D4:  MOVLB  9
0C9D6:  MOVWF  x66
0C9D8:  MOVLB  0
0C9DA:  CALL   0AAC
0C9DE:  BTFSC  19.7
0C9E0:  BSF    FF2.7
0C9E2:  MOVLB  7
0C9E4:  INCF   x13,F
0C9E6:  BRA    C8BE
....................    } 
....................      
....................    fprintf(STDOUT, "Start Index: %lu. Stop Index: %lu.\r\n", reading_index_start(), reading_index_stop()); 
0C9E8:  MOVLB  0
0C9EA:  CALL   2DC6
0C9EE:  MOVFF  02,727
0C9F2:  MOVFF  01,726
0C9F6:  CALL   2ECA
0C9FA:  MOVFF  02,729
0C9FE:  MOVFF  01,728
0CA02:  MOVLW  4C
0CA04:  MOVWF  FF6
0CA06:  MOVLW  19
0CA08:  MOVWF  FF7
0CA0A:  CLRF   19
0CA0C:  BTFSC  FF2.7
0CA0E:  BSF    19.7
0CA10:  BCF    FF2.7
0CA12:  MOVLW  0D
0CA14:  MOVLB  9
0CA16:  MOVWF  x66
0CA18:  MOVLB  0
0CA1A:  CALL   0AAC
0CA1E:  BTFSC  19.7
0CA20:  BSF    FF2.7
0CA22:  MOVLW  10
0CA24:  MOVWF  FE9
0CA26:  CLRF   19
0CA28:  BTFSC  FF2.7
0CA2A:  BSF    19.7
0CA2C:  BCF    FF2.7
0CA2E:  MOVFF  727,967
0CA32:  MOVFF  726,966
0CA36:  CALL   0AD6
0CA3A:  BTFSC  19.7
0CA3C:  BSF    FF2.7
0CA3E:  MOVLW  5C
0CA40:  MOVWF  FF6
0CA42:  MOVLW  19
0CA44:  MOVWF  FF7
0CA46:  CLRF   19
0CA48:  BTFSC  FF2.7
0CA4A:  BSF    19.7
0CA4C:  BCF    FF2.7
0CA4E:  MOVLW  0E
0CA50:  MOVLB  9
0CA52:  MOVWF  x66
0CA54:  MOVLB  0
0CA56:  CALL   0AAC
0CA5A:  BTFSC  19.7
0CA5C:  BSF    FF2.7
0CA5E:  MOVLW  10
0CA60:  MOVWF  FE9
0CA62:  CLRF   19
0CA64:  BTFSC  FF2.7
0CA66:  BSF    19.7
0CA68:  BCF    FF2.7
0CA6A:  MOVFF  729,967
0CA6E:  MOVFF  728,966
0CA72:  CALL   0AD6
0CA76:  BTFSC  19.7
0CA78:  BSF    FF2.7
0CA7A:  MOVLW  6D
0CA7C:  MOVWF  FF6
0CA7E:  MOVLW  19
0CA80:  MOVWF  FF7
0CA82:  CLRF   19
0CA84:  BTFSC  FF2.7
0CA86:  BSF    19.7
0CA88:  BCF    FF2.7
0CA8A:  MOVLW  03
0CA8C:  MOVLB  9
0CA8E:  MOVWF  x66
0CA90:  MOVLB  0
0CA92:  CALL   0AAC
0CA96:  BTFSC  19.7
0CA98:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
0CA9A:  MOVLW  01
0CA9C:  MOVWF  FEA
0CA9E:  MOVLW  A7
0CAA0:  MOVWF  FE9
0CAA2:  CALL   2D08
0CAA6:  GOTO   E32C (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void readings_print() 
*
0CAEE:  MOVLB  7
0CAF0:  CLRF   x17
.................... { 
....................    struct reading r; 
....................    float  score; 
....................    uint8 i = 0; 
....................  
....................    fprintf(STDOUT, "Start Index: %lu. Stop Index: %lu.\r\n", reading_index_start(), reading_index_stop()); 
0CAF2:  MOVLB  0
0CAF4:  CALL   2DC6
0CAF8:  MOVFF  02,719
0CAFC:  MOVFF  01,718
0CB00:  CALL   2ECA
0CB04:  MOVFF  02,71B
0CB08:  MOVFF  01,71A
0CB0C:  MOVLW  72
0CB0E:  MOVWF  FF6
0CB10:  MOVLW  19
0CB12:  MOVWF  FF7
0CB14:  CLRF   19
0CB16:  BTFSC  FF2.7
0CB18:  BSF    19.7
0CB1A:  BCF    FF2.7
0CB1C:  MOVLW  0D
0CB1E:  MOVLB  9
0CB20:  MOVWF  x66
0CB22:  MOVLB  0
0CB24:  CALL   0AAC
0CB28:  BTFSC  19.7
0CB2A:  BSF    FF2.7
0CB2C:  MOVLW  10
0CB2E:  MOVWF  FE9
0CB30:  CLRF   19
0CB32:  BTFSC  FF2.7
0CB34:  BSF    19.7
0CB36:  BCF    FF2.7
0CB38:  MOVFF  719,967
0CB3C:  MOVFF  718,966
0CB40:  CALL   0AD6
0CB44:  BTFSC  19.7
0CB46:  BSF    FF2.7
0CB48:  MOVLW  82
0CB4A:  MOVWF  FF6
0CB4C:  MOVLW  19
0CB4E:  MOVWF  FF7
0CB50:  CLRF   19
0CB52:  BTFSC  FF2.7
0CB54:  BSF    19.7
0CB56:  BCF    FF2.7
0CB58:  MOVLW  0E
0CB5A:  MOVLB  9
0CB5C:  MOVWF  x66
0CB5E:  MOVLB  0
0CB60:  CALL   0AAC
0CB64:  BTFSC  19.7
0CB66:  BSF    FF2.7
0CB68:  MOVLW  10
0CB6A:  MOVWF  FE9
0CB6C:  CLRF   19
0CB6E:  BTFSC  FF2.7
0CB70:  BSF    19.7
0CB72:  BCF    FF2.7
0CB74:  MOVFF  71B,967
0CB78:  MOVFF  71A,966
0CB7C:  CALL   0AD6
0CB80:  BTFSC  19.7
0CB82:  BSF    FF2.7
0CB84:  MOVLW  93
0CB86:  MOVWF  FF6
0CB88:  MOVLW  19
0CB8A:  MOVWF  FF7
0CB8C:  CLRF   19
0CB8E:  BTFSC  FF2.7
0CB90:  BSF    19.7
0CB92:  BCF    FF2.7
0CB94:  MOVLW  03
0CB96:  MOVLB  9
0CB98:  MOVWF  x66
0CB9A:  MOVLB  0
0CB9C:  CALL   0AAC
0CBA0:  BTFSC  19.7
0CBA2:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
0CBA4:  MOVLW  01
0CBA6:  MOVWF  FEA
0CBA8:  MOVLW  A7
0CBAA:  MOVWF  FE9
0CBAC:  CALL   2D08
....................  
....................  
....................    fprintf(STDOUT, "Record# Test Mode Test Time Test Score Test Status Test State Time Stamp"); 
0CBB0:  MOVLW  98
0CBB2:  MOVWF  FF6
0CBB4:  MOVLW  19
0CBB6:  MOVWF  FF7
0CBB8:  CALL   2CA0
....................    fprintf(STDOUT, two_new_lines_resp); 
0CBBC:  MOVLW  01
0CBBE:  MOVWF  FEA
0CBC0:  MOVLW  F2
0CBC2:  MOVWF  FE9
0CBC4:  CALL   2D08
....................     
....................    for(i = 0; i < CONFIG_READING_COUNT; i++)  
0CBC8:  MOVLB  7
0CBCA:  CLRF   x17
0CBCC:  MOVF   x17,W
0CBCE:  SUBLW  09
0CBD0:  BTFSS  FD8.0
0CBD2:  BRA    CE7A
....................    { 
....................       r = reading_fetch(i); 
0CBD4:  CLRF   x38
0CBD6:  MOVFF  717,737
0CBDA:  MOVLB  0
0CBDC:  CALL   4F64
0CBE0:  MOVFF  02,03
0CBE4:  MOVFF  01,FE1
0CBE8:  MOVFF  02,FE2
0CBEC:  MOVLW  07
0CBEE:  MOVWF  FEA
0CBF0:  MOVLW  01
0CBF2:  MOVWF  FE9
0CBF4:  MOVLW  12
0CBF6:  MOVWF  01
0CBF8:  MOVFF  FE6,FEE
0CBFC:  DECFSZ 01,F
0CBFE:  BRA    CBF8
....................       score = f_IEEEtoPIC(r.testResult.score); 
0CC00:  MOVFF  70A,23
0CC04:  MOVFF  709,22
0CC08:  MOVFF  708,21
0CC0C:  MOVFF  707,20
0CC10:  BRA    CAAA
0CC12:  MOVFF  03,716
0CC16:  MOVFF  02,715
0CC1A:  MOVFF  01,714
0CC1E:  MOVFF  00,713
....................        
....................       fprintf(STDOUT, "  %d         %ld       %lu         %.4f\t %d\t      %d", i, r.testResult.testMode, r.testResult.totalTestTime / 1000, score, r.testResult.status, r.testResult.stepID ); 
0CC22:  BCF    FD8.1
0CC24:  MOVFF  706,822
0CC28:  MOVFF  705,821
0CC2C:  MOVFF  704,820
0CC30:  MOVFF  703,81F
0CC34:  MOVLB  8
0CC36:  CLRF   x26
0CC38:  CLRF   x25
0CC3A:  MOVLW  03
0CC3C:  MOVWF  x24
0CC3E:  MOVLW  E8
0CC40:  MOVWF  x23
0CC42:  MOVLB  0
0CC44:  CALL   406A
0CC48:  MOVFF  03,71B
0CC4C:  MOVFF  02,71A
0CC50:  MOVFF  01,719
0CC54:  MOVFF  00,718
0CC58:  MOVLW  20
0CC5A:  BTFSS  FA4.4
0CC5C:  BRA    CC5A
0CC5E:  MOVWF  F73
0CC60:  MOVLW  20
0CC62:  BTFSS  FA4.4
0CC64:  BRA    CC62
0CC66:  MOVWF  F73
0CC68:  MOVFF  717,812
0CC6C:  MOVLW  18
0CC6E:  MOVLB  8
0CC70:  MOVWF  x13
0CC72:  MOVLB  0
0CC74:  CALL   2AEC
0CC78:  MOVLW  E6
0CC7A:  MOVWF  FF6
0CC7C:  MOVLW  19
0CC7E:  MOVWF  FF7
0CC80:  CLRF   19
0CC82:  BTFSC  FF2.7
0CC84:  BSF    19.7
0CC86:  BCF    FF2.7
0CC88:  MOVLW  09
0CC8A:  MOVLB  9
0CC8C:  MOVWF  x66
0CC8E:  MOVLB  0
0CC90:  CALL   0AAC
0CC94:  BTFSC  19.7
0CC96:  BSF    FF2.7
0CC98:  MOVLW  10
0CC9A:  MOVWF  FE9
0CC9C:  MOVFF  702,74C
0CCA0:  MOVFF  701,74B
0CCA4:  CALL   3C60
0CCA8:  MOVLW  F2
0CCAA:  MOVWF  FF6
0CCAC:  MOVLW  19
0CCAE:  MOVWF  FF7
0CCB0:  CLRF   19
0CCB2:  BTFSC  FF2.7
0CCB4:  BSF    19.7
0CCB6:  BCF    FF2.7
0CCB8:  MOVLW  07
0CCBA:  MOVLB  9
0CCBC:  MOVWF  x66
0CCBE:  MOVLB  0
0CCC0:  CALL   0AAC
0CCC4:  BTFSC  19.7
0CCC6:  BSF    FF2.7
0CCC8:  MOVLW  41
0CCCA:  MOVWF  FE9
0CCCC:  MOVFF  71B,815
0CCD0:  MOVFF  71A,814
0CCD4:  MOVFF  719,813
0CCD8:  MOVFF  718,812
0CCDC:  CALL   9C78
0CCE0:  MOVLW  FC
0CCE2:  MOVWF  FF6
0CCE4:  MOVLW  19
0CCE6:  MOVWF  FF7
0CCE8:  CLRF   19
0CCEA:  BTFSC  FF2.7
0CCEC:  BSF    19.7
0CCEE:  BCF    FF2.7
0CCF0:  MOVLW  09
0CCF2:  MOVLB  9
0CCF4:  MOVWF  x66
0CCF6:  MOVLB  0
0CCF8:  CALL   0AAC
0CCFC:  BTFSC  19.7
0CCFE:  BSF    FF2.7
0CD00:  MOVLW  89
0CD02:  MOVWF  FE9
0CD04:  MOVFF  716,815
0CD08:  MOVFF  715,814
0CD0C:  MOVFF  714,813
0CD10:  MOVFF  713,812
0CD14:  MOVLW  04
0CD16:  MOVLB  8
0CD18:  MOVWF  x16
0CD1A:  MOVLB  0
0CD1C:  CALL   40FE
0CD20:  MOVLW  09
0CD22:  BTFSS  FA4.4
0CD24:  BRA    CD22
0CD26:  MOVWF  F73
0CD28:  MOVLW  20
0CD2A:  BTFSS  FA4.4
0CD2C:  BRA    CD2A
0CD2E:  MOVWF  F73
0CD30:  MOVFF  70B,812
0CD34:  MOVLW  18
0CD36:  MOVLB  8
0CD38:  MOVWF  x13
0CD3A:  MOVLB  0
0CD3C:  CALL   2AEC
0CD40:  MOVLW  0D
0CD42:  MOVWF  FF6
0CD44:  MOVLW  1A
0CD46:  MOVWF  FF7
0CD48:  CLRF   19
0CD4A:  BTFSC  FF2.7
0CD4C:  BSF    19.7
0CD4E:  BCF    FF2.7
0CD50:  MOVLW  07
0CD52:  MOVLB  9
0CD54:  MOVWF  x66
0CD56:  MOVLB  0
0CD58:  CALL   0AAC
0CD5C:  BTFSC  19.7
0CD5E:  BSF    FF2.7
0CD60:  MOVFF  70C,812
0CD64:  MOVLW  18
0CD66:  MOVLB  8
0CD68:  MOVWF  x13
0CD6A:  MOVLB  0
0CD6C:  CALL   2AEC
....................       fprintf(STDOUT, "       %2d:%2d:%2d, D %2d M %2d Y %2d ", r.time.hour, r.time.minute, r.time.second, r.time.day, r.time.month, r.time.year ); 
0CD70:  MOVLW  18
0CD72:  MOVWF  FF6
0CD74:  MOVLW  1A
0CD76:  MOVWF  FF7
0CD78:  CLRF   19
0CD7A:  BTFSC  FF2.7
0CD7C:  BSF    19.7
0CD7E:  BCF    FF2.7
0CD80:  MOVLW  07
0CD82:  MOVLB  9
0CD84:  MOVWF  x66
0CD86:  MOVLB  0
0CD88:  CALL   0AAC
0CD8C:  BTFSC  19.7
0CD8E:  BSF    FF2.7
0CD90:  MOVFF  70D,812
0CD94:  MOVLW  11
0CD96:  MOVLB  8
0CD98:  MOVWF  x13
0CD9A:  MOVLB  0
0CD9C:  CALL   2AEC
0CDA0:  MOVLW  3A
0CDA2:  BTFSS  FA4.4
0CDA4:  BRA    CDA2
0CDA6:  MOVWF  F73
0CDA8:  MOVFF  70E,812
0CDAC:  MOVLW  11
0CDAE:  MOVLB  8
0CDB0:  MOVWF  x13
0CDB2:  MOVLB  0
0CDB4:  CALL   2AEC
0CDB8:  MOVLW  3A
0CDBA:  BTFSS  FA4.4
0CDBC:  BRA    CDBA
0CDBE:  MOVWF  F73
0CDC0:  MOVFF  70F,812
0CDC4:  MOVLW  11
0CDC6:  MOVLB  8
0CDC8:  MOVWF  x13
0CDCA:  MOVLB  0
0CDCC:  CALL   2AEC
0CDD0:  MOVLW  2A
0CDD2:  MOVWF  FF6
0CDD4:  MOVLW  1A
0CDD6:  MOVWF  FF7
0CDD8:  CLRF   19
0CDDA:  BTFSC  FF2.7
0CDDC:  BSF    19.7
0CDDE:  BCF    FF2.7
0CDE0:  MOVLW  04
0CDE2:  MOVLB  9
0CDE4:  MOVWF  x66
0CDE6:  MOVLB  0
0CDE8:  CALL   0AAC
0CDEC:  BTFSC  19.7
0CDEE:  BSF    FF2.7
0CDF0:  MOVFF  710,812
0CDF4:  MOVLW  11
0CDF6:  MOVLB  8
0CDF8:  MOVWF  x13
0CDFA:  MOVLB  0
0CDFC:  CALL   2AEC
0CE00:  MOVLW  31
0CE02:  MOVWF  FF6
0CE04:  MOVLW  1A
0CE06:  MOVWF  FF7
0CE08:  CLRF   19
0CE0A:  BTFSC  FF2.7
0CE0C:  BSF    19.7
0CE0E:  BCF    FF2.7
0CE10:  MOVLW  03
0CE12:  MOVLB  9
0CE14:  MOVWF  x66
0CE16:  MOVLB  0
0CE18:  CALL   0AAC
0CE1C:  BTFSC  19.7
0CE1E:  BSF    FF2.7
0CE20:  MOVFF  711,812
0CE24:  MOVLW  11
0CE26:  MOVLB  8
0CE28:  MOVWF  x13
0CE2A:  MOVLB  0
0CE2C:  CALL   2AEC
0CE30:  MOVLW  37
0CE32:  MOVWF  FF6
0CE34:  MOVLW  1A
0CE36:  MOVWF  FF7
0CE38:  CLRF   19
0CE3A:  BTFSC  FF2.7
0CE3C:  BSF    19.7
0CE3E:  BCF    FF2.7
0CE40:  MOVLW  03
0CE42:  MOVLB  9
0CE44:  MOVWF  x66
0CE46:  MOVLB  0
0CE48:  CALL   0AAC
0CE4C:  BTFSC  19.7
0CE4E:  BSF    FF2.7
0CE50:  MOVFF  712,812
0CE54:  MOVLW  11
0CE56:  MOVLB  8
0CE58:  MOVWF  x13
0CE5A:  MOVLB  0
0CE5C:  CALL   2AEC
0CE60:  MOVLW  20
0CE62:  BTFSS  FA4.4
0CE64:  BRA    CE62
0CE66:  MOVWF  F73
....................       fprintf(STDOUT, new_line_resp); 
0CE68:  MOVLW  01
0CE6A:  MOVWF  FEA
0CE6C:  MOVLW  A7
0CE6E:  MOVWF  FE9
0CE70:  CALL   2D08
....................  
.................... #ifdef TEST      
0CE74:  MOVLB  7
0CE76:  INCF   x17,F
0CE78:  BRA    CBCC
....................        
....................       uint8 c, *ptr; 
....................       ptr = &r; 
....................       fprintf(STDOUT, "0x"); 
....................        
....................       for( c = 0; c < sizeof(r); c++ ) 
....................          fprintf(STDOUT, "%x", ptr[c]); 
....................        
....................       fprintf(STDOUT, new_line_resp); 
.................... #endif 
....................  
....................    } 
....................    
....................    fprintf(STDOUT, new_line_resp); 
0CE7A:  MOVLW  01
0CE7C:  MOVWF  FEA
0CE7E:  MOVLW  A7
0CE80:  MOVWF  FE9
0CE82:  MOVLB  0
0CE84:  CALL   2D08
0CE88:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void reading_in_progress(uint16 progress)  
.................... { 
....................    uint8 message = ble_data_message_count; 
....................    ble_cmd_attributes_write(BLE_HANDLE_READING_IN_PROGRESS, 0, 2, (uint8 *)&progress); 
....................    ble_wait_for_message(message); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 SetFullTestStepID(uint16 stepID)  
.................... { 
....................    LastFullStepID = stepID; 
....................    reading_in_progress(stepID); 
....................    return stepID; 
.................... } 
....................  
.................... #include <peripherals.c> 
.................... #include <Peripherals.h> 
.................... #ifndef __PERIPHERALS__ 
.................... #define __PERIPHERALS__ 
....................  
.................... #define BUTTON_PRIMARY 0 
.................... #define BUTTON_RESET 1 
.................... #define DETECT_CARTRIDGE 2 
.................... #define DETECT_BOTTLE_DOOR_ALT 3 
.................... #define DETECT_TRAY 4 
.................... #define DETECT_BOTTLE_DOOR 7 
.................... #define DETECT_OVER_TEMPERATURE 6 
.................... #define DETECT_BOTTLE 5 
....................  
.................... #define CHECK_BIT(var,pos) ((var) & (1<<(pos))) 
.................... #define CHECK_SWITCH(var, pos) !CHECK_BIT(var, pos) 
....................  
.................... #define SOLENOID_PIN PIN_D5 
.................... #define SOLENOID_POLARITY_SWAP 0 
....................  
.................... #define NOTE_C 261 
.................... #define NOTE_D 293 
.................... #define NOTE_E 329 
.................... #define NOTE_F 349 
.................... #define NOTE_G 391 
.................... #define NOTE_A 440 
.................... #define NOTE_B 493 
....................  
.................... struct colorRGB { 
....................    uint16 Red, Green, Blue; 
.................... }; 
....................  
....................  
....................  
.................... int read_switches(); 
.................... int read_switch(int pin); 
.................... int16 photodiode(); 
....................  
.................... #ifdef BASE_40 
.................... void tray_init(); 
.................... void tray_open(); 
.................... void tray_open_loop(); 
.................... #endif 
....................  
.................... void tone(int32 frequency_hz); 
.................... void play(); 
.................... void play_error(); 
.................... void play_error_hw_failure() ; 
....................  
.................... #ifdef BASE_40 
.................... void SetButtonColor(uint16 Red, uint16 Green, uint16 Blue); 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef BASE_40 
.................... struct colorRGB CurrentColor; 
.................... #endif 
....................  
.................... //////////////////////////////////////// 
.................... void tone(int32 frequency_hz) 
.................... { 
....................    pwm_set_frequency(BUZZER, frequency_hz); 
*
04512:  MOVFF  815,819
04516:  MOVFF  814,818
0451A:  MOVFF  813,817
0451E:  MOVFF  812,816
04522:  MOVLB  8
04524:  CLRF   x1D
04526:  MOVLW  1E
04528:  MOVWF  x1C
0452A:  MOVLW  84
0452C:  MOVWF  x1B
0452E:  MOVLW  80
04530:  MOVWF  x1A
04532:  MOVLB  0
04534:  BRA    448C
04536:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void play()  
.................... { 
....................    pwm_on(BUZZER); 
*
0CE8C:  MOVLW  0C
0CE8E:  MOVLB  F
0CE90:  IORWF  x57,F
....................    tone(260); 
0CE92:  MOVLB  8
0CE94:  CLRF   x15
0CE96:  CLRF   x14
0CE98:  MOVLW  01
0CE9A:  MOVWF  x13
0CE9C:  MOVLW  04
0CE9E:  MOVWF  x12
0CEA0:  MOVLB  0
0CEA2:  CALL   4512
....................    delay_ms(200); 
0CEA6:  MOVLW  C8
0CEA8:  MOVLB  8
0CEAA:  MOVWF  x18
0CEAC:  MOVLB  0
0CEAE:  CALL   2D2E
....................    pwm_off(BUZZER); 
0CEB2:  MOVLW  F0
0CEB4:  MOVLB  F
0CEB6:  ANDWF  x57,F
0CEB8:  MOVLB  0
0CEBA:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void play_error()  
.................... { 
....................    pwm_on(BUZZER); 
*
04538:  MOVLW  0C
0453A:  MOVLB  F
0453C:  IORWF  x57,F
....................    tone(500); 
0453E:  MOVLB  8
04540:  CLRF   x15
04542:  CLRF   x14
04544:  MOVLW  01
04546:  MOVWF  x13
04548:  MOVLW  F4
0454A:  MOVWF  x12
0454C:  MOVLB  0
0454E:  RCALL  4512
....................    delay_ms(250); 
04550:  MOVLW  FA
04552:  MOVLB  8
04554:  MOVWF  x18
04556:  MOVLB  0
04558:  CALL   2D2E
....................    tone(600); 
0455C:  MOVLB  8
0455E:  CLRF   x15
04560:  CLRF   x14
04562:  MOVLW  02
04564:  MOVWF  x13
04566:  MOVLW  58
04568:  MOVWF  x12
0456A:  MOVLB  0
0456C:  RCALL  4512
....................    delay_ms(250); 
0456E:  MOVLW  FA
04570:  MOVLB  8
04572:  MOVWF  x18
04574:  MOVLB  0
04576:  CALL   2D2E
....................    tone(500); 
0457A:  MOVLB  8
0457C:  CLRF   x15
0457E:  CLRF   x14
04580:  MOVLW  01
04582:  MOVWF  x13
04584:  MOVLW  F4
04586:  MOVWF  x12
04588:  MOVLB  0
0458A:  RCALL  4512
....................    delay_ms(250); 
0458C:  MOVLW  FA
0458E:  MOVLB  8
04590:  MOVWF  x18
04592:  MOVLB  0
04594:  CALL   2D2E
....................    pwm_off(BUZZER); 
04598:  MOVLW  F0
0459A:  MOVLB  F
0459C:  ANDWF  x57,F
0459E:  MOVLB  0
045A0:  RETURN 0
.................... } 
....................  
.................... void play_error_hw_failure()  
.................... { 
....................    pwm_on(BUZZER); 
....................    tone(500); 
....................    delay_ms(100); 
....................    tone(500); 
....................    delay_ms(100); 
....................    pwm_off(BUZZER); 
.................... } 
.................... //////////////////////////////////////// 
.................... // void play() 
.................... // { 
.................... //    pwm_on(BUZZER); 
.................... //    int16 melody[] = { NOTE_C, NOTE_D, NOTE_E }; 
.................... // 
.................... //    int16 i = 0; 
.................... // 
.................... //    for(i = 0; i < sizeof(melody) / sizeof(melody[0]); i++) { 
.................... //       pwm_on(BUZZER); 
.................... //       tone(melody[i]); 
.................... //       delay_ms(200); 
.................... //       pwm_off(BUZZER); 
.................... // 
.................... //       pwm_on(BUZZER); 
.................... //       tone(2000); 
.................... //       delay_ms(200); 
.................... //       pwm_off(BUZZER); 
.................... // 
.................... //       delay_ms(200); 
.................... //    } 
.................... //    pwm_off(BUZZER); 
.................... // } 
.................... //////////////////////////////////////// 
....................  
.................... #DEFINE ILLUMINATION_588 PIN_C0 
.................... #DEFINE ILLUMINATION_730 PIN_A5 
.................... #DEFINE ILLUMINATION_475 PIN_A4 
....................  
.................... //////////////////////////////////////// 
.................... void illumination_brightness(BYTE brightness) 
*
042F2:  MOVLB  8
042F4:  CLRF   x1B
042F6:  CLRF   x1A
042F8:  CLRF   x19
042FA:  MOVFF  812,818
042FE:  BTFSS  x12.7
04300:  BRA    4308
04302:  DECF   x19,F
04304:  DECF   x1A,F
04306:  DECF   x1B,F
04308:  MOVFF  81A,03
0430C:  MOVFF  819,02
04310:  MOVFF  818,814
04314:  CLRF   00
04316:  MOVLW  30
04318:  ADDWF  02,F
0431A:  MOVLW  00
0431C:  ADDWFC 03,F
0431E:  MOVFF  03,816
04322:  MOVFF  02,815
04326:  MOVFF  00,813
.................... { 
....................    int32 command = ((int32)0b0011 << 20) + ((int32)brightness << 8); 
....................    spi_xfer(SPI_1, command, 24); 
0432A:  MOVFF  816,81A
0432E:  MOVFF  815,819
04332:  MOVFF  814,818
04336:  MOVFF  813,817
0433A:  MOVLW  18
0433C:  MOVWF  x1B
0433E:  MOVLB  0
04340:  BRA    42AC
04342:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void illumination_all_off() 
.................... { 
....................    output_low(ILLUMINATION_475); 
04344:  BCF    F92.4
04346:  BCF    F89.4
....................    output_low(ILLUMINATION_588); 
04348:  BCF    F94.0
0434A:  BCF    F8B.0
....................    output_low(ILLUMINATION_730); 
0434C:  BCF    F92.5
0434E:  BCF    F89.5
04350:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void illumination_use(int16 pin) 
.................... { 
....................    illumination_all_off(); 
*
04394:  RCALL  4344
....................    output_high(pin); 
04396:  MOVFF  812,814
0439A:  MOVLW  01
0439C:  MOVLB  8
0439E:  MOVWF  x15
043A0:  MOVLW  0F
043A2:  MOVWF  x17
043A4:  MOVLW  89
043A6:  MOVWF  x16
043A8:  MOVLB  0
043AA:  RCALL  4352
043AC:  MOVFF  812,814
043B0:  MOVLB  8
043B2:  CLRF   x15
043B4:  MOVLW  0F
043B6:  MOVWF  x17
043B8:  MOVLW  92
043BA:  MOVWF  x16
043BC:  MOVLB  0
043BE:  RCALL  4352
043C0:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... int read_switches() 
.................... { 
....................    int data = 0; 
....................    i2c_start(); 
....................    i2c_write(0b10000110); 
....................    i2c_write(0x0F); 
....................  
....................    i2c_start(); 
....................    i2c_write(0b10000111); 
....................    data = i2c_read(FALSE); 
....................    i2c_stop(); 
....................  
....................    return data; 
.................... } 
.................... //////////////////////////////////////// 
.................... int16 photodiode() 
.................... { 
....................    set_adc_channel(0); 
*
04FFC:  MOVLW  00
04FFE:  MOVWF  01
05000:  MOVF   FC2,W
05002:  ANDLW  83
05004:  IORWF  01,W
05006:  MOVWF  FC2
....................    return read_adc(); 
05008:  BSF    FC2.1
0500A:  BTFSC  FC2.1
0500C:  BRA    500A
0500E:  MOVFF  FC4,03
05012:  MOVFF  FC3,01
05016:  MOVFF  FC4,02
0501A:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... #ifdef BASE_40 
.................... int LastTrayState = 0; 
.................... int read_switch(int pin) 
.................... { 
....................    int state = CHECK_SWITCH(read_switches(), pin); 
....................     
....................    if (pin == DETECT_TRAY) 
....................    { 
....................       if (LastTrayState != state)  
....................       { 
....................          LastTrayState = state; 
....................          
....................          if (state) 
....................          { 
....................             int v=0; 
....................             ble_cmd_attributes_write(BLE_HANDLE_TRAY_IS_OPEN, 0, 1, &v); 
....................              
....................             while(!ble_log_process()); 
....................                fprintf(STDOUT, "Tray closed\r\n"); 
....................          } 
....................       } 
....................    } 
....................     
....................    return state; 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void tray_init() 
.................... { 
....................    if(SOLENOID_POLARITY_SWAP)  
....................       output_high(SOLENOID_PIN); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void tray_open() 
.................... { 
....................  
....................    if(SOLENOID_POLARITY_SWAP)  
....................       output_low(SOLENOID_PIN); 
....................  
....................    else  
....................       output_high(SOLENOID_PIN); 
....................  
....................    delay_ms(1000); 
....................  
....................    if(SOLENOID_POLARITY_SWAP)  
....................       output_high(SOLENOID_PIN); 
....................  
....................    else 
....................       output_low(SOLENOID_PIN); 
.................... } 
....................  
.................... //////////////////////////////////////// 
....................  
.................... void tray_open_loop() 
.................... { 
....................    while(TRUE)  
....................    { 
....................       tray_open(); 
....................       if(read_switch(DETECT_TRAY) == 0) 
....................       { 
....................          int v=1; 
....................          ble_cmd_attributes_write(BLE_HANDLE_TRAY_IS_OPEN, 0, 1, &v); 
....................           
....................          while(!ble_log_process()); 
....................             break; 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void indicator_led_set(uint16 red, uint16 green, uint16 blue) 
.................... { 
....................    // All the values are between 0 and 1000 
....................    pwm_set_duty_percent(LED_RED, red); 
....................    pwm_set_duty_percent(LED_GREEN, green); 
....................    pwm_set_duty_percent(LED_BLUE, blue); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////// 
.................... #define SERVO PIN_E2 
.................... void set_servo(int16 time_us, int16 count) 
.................... { 
....................    int16 i = 0; 
....................    int16 rest_us = 20000 - time_us; 
....................  
....................    for(i = 0; i < count; i++) 
....................    { 
....................       output_high(SERVO); 
....................       delay_us(time_us); 
....................       output_low(SERVO); 
....................       delay_us(rest_us); 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void servo_up()  
.................... { 
....................    set_servo(ServoUpTime, 50); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void servo_down_with_adjustment(int16 adjustment)  
.................... { 
....................    uint16 i; 
....................    if (g_bottle_uses > 0)  
....................       i = ServoDownTime + adjustment; 
....................  
....................    else  
....................       i = ServoDownTime + 20 + adjustment; 
....................     
....................    set_servo(i, 30); 
....................    fprintf(STDOUT, "Servodown: %lu us\r\n", i); 
....................    
....................    config_bottle_uses_increment(); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void servo_down()  
.................... { 
....................    servo_down_with_adjustment(0); 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void servo_park()  
.................... { 
....................    set_servo(ServoParkTime,50); 
.................... } 
.................... #endif 
....................  
....................  
.................... #include <util.c> 
....................  
.................... float32 prompt_float() 
.................... { 
....................   fprintf(STDOUT, "Value: "); 
*
0C7B4:  MOVLW  40
0C7B6:  MOVWF  FF6
0C7B8:  MOVLW  1A
0C7BA:  MOVWF  FF7
0C7BC:  CALL   2CA0
....................   float32 value = get_float(); 
0C7C0:  BRA    C76A
0C7C2:  MOVFF  03,704
0C7C6:  MOVFF  02,703
0C7CA:  MOVFF  01,702
0C7CE:  MOVFF  00,701
....................   fprintf(STDOUT, "\r\nGot it: %.3f\r\n", value); 
0C7D2:  MOVLW  48
0C7D4:  MOVWF  FF6
0C7D6:  MOVLW  1A
0C7D8:  MOVWF  FF7
0C7DA:  CLRF   19
0C7DC:  BTFSC  FF2.7
0C7DE:  BSF    19.7
0C7E0:  BCF    FF2.7
0C7E2:  MOVLW  0A
0C7E4:  MOVLB  9
0C7E6:  MOVWF  x66
0C7E8:  MOVLB  0
0C7EA:  CALL   0AAC
0C7EE:  BTFSC  19.7
0C7F0:  BSF    FF2.7
0C7F2:  MOVLW  89
0C7F4:  MOVWF  FE9
0C7F6:  MOVFF  704,815
0C7FA:  MOVFF  703,814
0C7FE:  MOVFF  702,813
0C802:  MOVFF  701,812
0C806:  MOVLW  03
0C808:  MOVLB  8
0C80A:  MOVWF  x16
0C80C:  MOVLB  0
0C80E:  CALL   40FE
0C812:  MOVLW  0D
0C814:  BTFSS  FA4.4
0C816:  BRA    C814
0C818:  MOVWF  F73
0C81A:  MOVLW  0A
0C81C:  BTFSS  FA4.4
0C81E:  BRA    C81C
0C820:  MOVWF  F73
....................  
....................   return value; 
0C822:  MOVFF  701,00
0C826:  MOVFF  702,01
0C82A:  MOVFF  703,02
0C82E:  MOVFF  704,03
0C832:  RETURN 0
.................... } 
....................  
.................... #include <bme680.c> 
.................... /** 
....................  * @brief       BME680.cpp 
....................  * @details     Low power gas, pressure, temperature & humidity sensor. 
....................  *              Function file. 
....................  * 
....................  * 
....................  * @return      N/A 
....................  * 
....................  * @author      Manuel Caballero 
....................  * @date        21/July/2018 
....................  * @version     21/July/2018    The ORIGIN 
....................  * @pre         This is just a port from Bosh driver to mBed ( c++ ) 
....................  * @warning     N/A 
....................  * @pre         This code belongs to Nimbus Centre ( http://www.nimbus.cit.ie ). 
....................  */ 
.................... /**\mainpage 
....................  * Copyright (C) 2017 - 2018 Bosch Sensortec GmbH 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  * Redistributions of source code must retain the above copyright 
....................  * notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * Redistributions in binary form must reproduce the above copyright 
....................  * notice, this list of conditions and the following disclaimer in the 
....................  * documentation and/or other materials provided with the distribution. 
....................  * 
....................  * Neither the name of the copyright holder nor the names of the 
....................  * contributors may be used to endorse or promote products derived from 
....................  * this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
....................  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
....................  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER 
....................  * OR CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
....................  * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
....................  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
....................  * ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE 
....................  * 
....................  * The information provided is believed to be accurate and reliable. 
....................  * The copyright holder assumes no responsibility 
....................  * for the consequences of use 
....................  * of such information nor for any infringement of patents or 
....................  * other rights of third parties which may result from its use. 
....................  * No license is granted by implication or otherwise under any patent or 
....................  * patent rights of the copyright holder. 
....................  * 
....................  * File     bme680.c 
....................  * @date    19 Jun 2018 
....................  * @version 3.5.9 
....................  * 
....................  */ 
....................   
.................... /*! @file bme680.c 
....................  @brief Sensor driver for BME680 sensor */ 
.................... #include "BME680.h" 
.................... /** 
....................  * Copyright (C) 2017 - 2018 Bosch Sensortec GmbH 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  * Redistributions of source code must retain the above copyright 
....................  * notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * Redistributions in binary form must reproduce the above copyright 
....................  * notice, this list of conditions and the following disclaimer in the 
....................  * documentation and/or other materials provided with the distribution. 
....................  * 
....................  * Neither the name of the copyright holder nor the names of the 
....................  * contributors may be used to endorse or promote products derived from 
....................  * this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
....................  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
....................  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER 
....................  * OR CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
....................  * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
....................  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
....................  * ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE 
....................  * 
....................  * The information provided is believed to be accurate and reliable. 
....................  * The copyright holder assumes no responsibility 
....................  * for the consequences of use 
....................  * of such information nor for any infringement of patents or 
....................  * other rights of third parties which may result from its use. 
....................  * No license is granted by implication or otherwise under any patent or 
....................  * patent rights of the copyright holder. 
....................  * 
....................  * @file   bme680.h 
....................  * @date   19 Jun 2018 
....................  * @version   3.5.9 
....................  * @brief 
....................  * 
....................  */ 
.................... /*! @file bme680.h 
....................  @brief Sensor driver for BME680 sensor */ 
.................... /*! 
....................  * @defgroup BME680 SENSOR API 
....................  * @{*/ 
.................... #ifndef BME680_H_ 
.................... #define BME680_H_ 
....................  
.................... /*! CPP guard */ 
.................... #ifdef __cplusplus 
.................... extern "C" 
.................... { 
.................... #endif 
....................  
.................... /* Header includes */ 
.................... #include "bme680_defs.h" 
.................... /** 
....................  * @brief       bme680_defs.h 
....................  * @details     Low power gas, pressure, temperature & humidity sensor. 
....................  *              Header file. 
....................  * 
....................  * 
....................  * @return      N/A 
....................  * 
....................  * @author      Manuel Caballero 
....................  * @date        21/July/2018 
....................  * @version     21/July/2018    The ORIGIN 
....................  * @pre         This is just a port from Bosh driver to mBed ( c++ ) 
....................  * @warning     N/A 
....................  * @pre         This code belongs to Nimbus Centre ( http://www.nimbus.cit.ie ). 
....................  */ 
....................  /** 
....................  * Copyright (C) 2017 - 2018 Bosch Sensortec GmbH 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  * Redistributions of source code must retain the above copyright 
....................  * notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * Redistributions in binary form must reproduce the above copyright 
....................  * notice, this list of conditions and the following disclaimer in the 
....................  * documentation and/or other materials provided with the distribution. 
....................  * 
....................  * Neither the name of the copyright holder nor the names of the 
....................  * contributors may be used to endorse or promote products derived from 
....................  * this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
....................  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
....................  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER 
....................  * OR CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
....................  * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
....................  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
....................  * ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE 
....................  * 
....................  * The information provided is believed to be accurate and reliable. 
....................  * The copyright holder assumes no responsibility 
....................  * for the consequences of use 
....................  * of such information nor for any infringement of patents or 
....................  * other rights of third parties which may result from its use. 
....................  * No license is granted by implication or otherwise under any patent or 
....................  * patent rights of the copyright holder. 
....................  * 
....................  * @file    bme680_defs.h 
....................  * @date    19 Jun 2018 
....................  * @version 3.5.9 
....................  * @brief 
....................  * 
....................  */ 
....................   
.................... /*! @file bme680_defs.h 
....................  @brief Sensor driver for BME680 sensor */ 
.................... /*! 
....................  * @defgroup BME680 SENSOR API 
....................  * @brief 
....................  * @{*/ 
.................... #ifndef BME680_DEFS_H_ 
.................... #define BME680_DEFS_H_ 
....................   
.................... /********************************************************/ 
.................... /* header includes */ 
.................... //#ifdef __KERNEL__ 
.................... //#include <linux/types.h> 
.................... //#include <linux/kernel.h> 
.................... //#else 
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... //#endif 
....................   
.................... /******************************************************************************/ 
.................... /*! @name       Common macros                         */ 
.................... /******************************************************************************/ 
....................   
....................   
.................... #include <.\Drivers\stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <.\Drivers\stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <.\Drivers\stddef.h> 
.................... #include <.\Drivers\string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <.\Drivers\string.h> 
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <.\Drivers\string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <.\Drivers\stddef.h> 
.................... #include <.\Drivers\ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <.\Drivers\ieeefloat.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                        ieeefloat.c                                //// 
.................... ////                                                                   //// 
.................... ////    This library converts IEEE float format to and from            //// 
.................... ////    the Microchip format used by PCB,PCM and PCH.                  //// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... float32 f_PICtoIEEE(unsigned int32) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format 
.................... PARAMS: 32 bit number 
.................... RETURNS: 32 bit Floating point number 
.................... */ 
.................... float32 f_PICtoIEEE(unsigned int32 pic) 
.................... { 
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.d = pic; 
....................     
....................    result.b[0] = data.b[3]; 
....................    result.b[1] = data.b[2]; 
....................    result.b[2] = data.b[1]; 
....................     
....................    if(bit_test(data.d,0)) 
....................       bit_set(result.b[2],7); 
....................    else 
....................       bit_clear(result.b[2],7); 
....................     
....................    shift_right(&data.b[0],1,bit_test(data.b[1],7)); 
....................    result.b[3] = data.b[0]; 
....................     
....................    return(result.f); 
.................... } 
.................... #else 
.................... /* 
.................... int32 f_PICtoIEEE(float f) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format in little endian mode 
.................... PARAMS: Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... int32 f_PICtoIEEE(float f) 
.................... { 
....................  
....................    int32 * ret; 
....................    #locate f=0x20 
....................  
....................    ret = &f;    
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlf   0x21 
....................       rrf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
....................       rrcf   0x20 
....................       rrcf   0x21    
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
....................       xorwf  0x23,W 
....................       xorwf  0x23,F 
....................       xorwf  0x23,W 
....................       movwf  0x20 
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
....................       xorwf  0x22,W 
....................       xorwf  0x22,F 
....................       xorwf  0x22,W 
....................       movwf  0x21 
....................     
....................    #endasm 
....................     
....................    return *ret; 
.................... } 
.................... #endif 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... unsigned int32 f_IEEEtoPIC(float32 f) 
.................... PURPOSE: This function converts IEEE format to float CCS -PIC format 
.................... PARAMS: 32 bit Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... unsigned int32 f_IEEEtoPIC(float32 ieee) 
.................... { 
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.f = ieee; 
....................     
....................    result.b[3] = data.b[0]; 
....................    result.b[2] = data.b[1]; 
....................    result.b[1] = data.b[2]; 
....................     
....................    if(bit_test(data.b[3],7)) 
....................       bit_set(result.b[1],7); 
....................    else 
....................       bit_clear(result.b[1],7); 
....................     
....................    result.b[0] = data.b[3]; 
....................     
....................    shift_left(&result.b[0],1,bit_test(data.b[2],7)); 
....................     
....................    return(result.d);    
.................... } 
.................... #else 
.................... /* 
.................... float f_IEEEtoPIC(int32 f) 
.................... PURPOSE: This function converts IEEE format to a float 
.................... PARAMS: 32 bit number 
.................... RETURNS: Floating point number 
.................... */ 
.................... float f_IEEEtoPIC(int32 f) 
.................... { 
....................  
....................    float * ret; 
....................    #locate f=0x20 
....................     
....................    ret = &f; 
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
....................       xorwf  0x23,W 
....................       xorwf  0x23,F 
....................       xorwf  0x23,W 
....................       movwf  0x20 
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
....................       xorwf  0x22,W 
....................       xorwf  0x22,F 
....................       xorwf  0x22,W 
....................       movwf  0x21 
....................  
....................    #endasm 
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................  
....................       // switch the bits 
....................       rlf   0x21 
....................       rlf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
....................       rlcf   0x20 
....................       rrcf   0x21    
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    return *ret; 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////// 
....................  
.................... //#define STREAM_SERIAL_INPUT STDOUT 
.................... //#include <.\Drivers\input.c> 
....................  
.................... //////////////////////////////////////// 
.................... /* 
.................... typedef int8 int8_t; 
.................... typedef int16 int16_t; 
.................... typedef int32 int32_t; 
.................... typedef long long int64_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef unsigned int32 uint32_t; 
.................... typedef unsigned long long uint64_t; 
.................... */ 
....................  
.................... /* 
.................... typedef (int8_t) (int8); 
.................... typedef (int16) INT16_C; 
.................... typedef (int32) (int32); 
.................... typedef (unsigned int8) (unsigned int8); 
.................... typedef (unsigned int16) (unsigned int16); 
.................... typedef (unsigned int32) U(int32); 
.................... */ 
....................   
.................... /* 
.................... #if !defined(UINT8_C) && !defined(INT8_C) 
.................... #define INT8_C(x)       int8_t(x) 
.................... #define UINT8_C(x)      uint8_t(x) 
.................... #endif 
....................   
.................... #if !defined(UINT16_C) && !defined(INT16_C) 
.................... #define INT16_C(x)      int16_t(x) 
.................... #define UINT16_C(x)     uint16_t(x) 
.................... #endif 
....................   
.................... #if !defined(INT32_C) && !defined(UINT32_C) 
.................... #define INT32_C(x)      int32_t(x) 
.................... #define UINT32_C(x)     uint32_t(x) 
.................... #endif 
....................   
.................... #if !defined(INT64_C) && !defined(UINT64_C) 
.................... #define INT64_C(x)      int64_t(x) 
.................... #define UINT64_C(x)     uint64_t(x) 
.................... #endif 
....................  */ 
....................   
.................... /**@}*/ 
....................   
.................... /**\name C standard macros */ 
.................... #ifndef NULL 
.................... #ifdef __cplusplus 
.................... #define NULL   0 
.................... #else 
.................... #define NULL   ((void *) 0) 
.................... #endif 
.................... #endif 
....................   
.................... /** BME680 configuration macros */ 
.................... /** Enable or un-comment the macro to provide floating point data output */ 
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
.................... // #define BME680_FLOAT_POINT_COMPENSATION */ 
.................... #endif 
....................   
.................... /** BME680 General config */ 
.................... #define BME680_POLL_PERIOD_MS             (unsigned int8)(10) 
....................   
.................... /** BME680 I2C addresses */ 
.................... //  T. Luu Check this address shifting compatibility!!!!! 
.................... #define BME680_I2C_ADDR_PRIMARY           (unsigned int8)( 0x76 )        // [MANUAL] Address compatible with mBed 
.................... #define BME680_I2C_ADDR_SECONDARY         (unsigned int8)( 0x77 )        // [MANUAL] Address compatible with mBed 
....................   
.................... #define BME680_I2C_Read_addr            ((BME680_I2C_ADDR_PRIMARY << 1) | 0x01) 
.................... #define BME680_I2C_Write_addr           ((BME680_I2C_ADDR_PRIMARY << 1) & 0xFE) 
....................  
.................... /** BME680 unique chip identifier */ 
.................... #define BME680_CHIP_ID                    (unsigned int8)(0x61) 
....................  
....................  
.................... /** BME680 coefficients related defines */ 
.................... #define BME680_COEFF_SIZE                 (unsigned int8)(41) 
.................... #define BME680_COEFF_ADDR1_LEN            (unsigned int8)(25) 
.................... #define BME680_COEFF_ADDR2_LEN            (unsigned int8)(16) 
....................   
.................... /** BME680 field_x related defines */ 
.................... #define BME680_FIELD_LENGTH               (unsigned int8)(15) 
.................... #define BME680_FIELD_ADDR_OFFSET          (unsigned int8)(17) 
....................   
.................... /** Soft reset command */ 
.................... #define BME680_SOFT_RESET_CMD             (unsigned int8)(0xb6) 
....................   
.................... /** Error code definitions */ 
.................... #define BME680_OK                         (unsigned int8)(0)//(int8)(0) 
....................  
.................... /* Errors */ 
.................... #define BME680_E_NULL_PTR                 (unsigned int8)(1) 
.................... #define BME680_E_COM_FAIL                 (unsigned int8)(2) 
.................... #define BME680_E_DEV_NOT_FOUND            (unsigned int8)(4) 
.................... #define BME680_E_INVALID_LENGTH           (unsigned int8)(8) 
.................... #define BME680_E_SET_MEM_PAGE_FAIL        (unsigned int8)(16) 
.................... #define BME680_E_XXXX_FAIL                (unsigned int8)(32) 
.................... #define BME680_E_XXXX1_FAIL               (unsigned int8)(64) 
.................... #define BME680_E_XXXX2_FAIL               (unsigned int8)(128) 
....................   
.................... /* Warnings */ 
.................... #define BME680_W_DEFINE_PWR_MODE          (int8)(1) 
.................... #define BME680_W_NO_NEW_DATA              (int8)(2) 
....................   
.................... /* Info's */ 
.................... #define BME680_I_MIN_CORRECTION           (unsigned int8)(1) 
.................... #define BME680_I_MAX_CORRECTION           (unsigned int8)(2) 
....................   
.................... /** Register map */ 
.................... /** Other coefficient's address */ 
.................... #define BME680_ADDR_RES_HEAT_VAL_ADDR     (unsigned int8)(0x00) 
.................... #define BME680_ADDR_RES_HEAT_RANGE_ADDR   (unsigned int8)(0x02) 
.................... #define BME680_ADDR_RANGE_SW_ERR_ADDR     (unsigned int8)(0x04) 
.................... #define BME680_ADDR_SENS_CONF_START       (unsigned int8)(0x5A) 
.................... #define BME680_ADDR_GAS_CONF_START        (unsigned int8)(0x64) 
....................   
.................... /** Field settings */ 
.................... #define BME680_FIELD0_ADDR                (unsigned int8)(0x1d) 
....................   
.................... /** Heater settings */ 
.................... #define BME680_RES_HEAT0_ADDR             (unsigned int8)(0x5a) 
.................... #define BME680_GAS_WAIT0_ADDR             (unsigned int8)(0x64) 
....................   
.................... /** Sensor configuration registers */ 
.................... #define BME680_CONF_HEAT_CTRL_ADDR        (unsigned int8)(0x70) 
.................... #define BME680_CONF_ODR_RUN_GAS_NBC_ADDR  (unsigned int8)(0x71) 
.................... #define BME680_CONF_OS_H_ADDR             (unsigned int8)(0x72) 
.................... #define BME680_MEM_PAGE_ADDR              (unsigned int8)(0x73) 
.................... #define BME680_CONF_T_P_MODE_ADDR         (unsigned int8)(0x74) 
.................... #define BME680_CONF_ODR_FILT_ADDR         (unsigned int8)(0x75) 
....................   
.................... /** Coefficient's address */ 
.................... #define BME680_COEFF_ADDR1                (unsigned int8)(0x89) 
.................... #define BME680_COEFF_ADDR2                (unsigned int8)(0xe1) 
....................   
.................... /** Chip identifier */ 
.................... #define BME680_I2CCHIP_ID_ADDR            (unsigned int8)(0xd0) 
.................... #define BME680_SPI_CHIP_ID_ADDR           (unsigned int8)(0x50)  
....................  
.................... /** Soft reset register */ 
.................... #define BME680_I2C_SOFT_RESET_ADDR        (unsigned int8)(0xe0) 
.................... #define BME680_SPI_SOFT_RESET_ADDR        (unsigned int8)(0x60)  
....................  
.................... /** Heater control settings */ 
.................... #define BME680_ENABLE_HEATER              (unsigned int8)(0x00) 
.................... #define BME680_DISABLE_HEATER             (unsigned int8)(0x08) 
....................   
.................... /** Gas measurement settings */ 
.................... #define BME680_DISABLE_GAS_MEAS           (unsigned int8)(0x00) 
.................... #define BME680_ENABLE_GAS_MEAS            (unsigned int8)(0x01) 
....................   
.................... /** Over-sampling settings */ 
.................... #define BME680_OS_NONE                    (unsigned int8)(0) 
.................... #define BME680_OS_1X                      (unsigned int8)(1) 
.................... #define BME680_OS_2X                      (unsigned int8)(2) 
.................... #define BME680_OS_4X                      (unsigned int8)(3) 
.................... #define BME680_OS_8X                      (unsigned int8)(4) 
.................... #define BME680_OS_16X                     (unsigned int8)(5) 
....................   
.................... /** IIR filter settings */ 
.................... #define BME680_FILTER_SIZE_0              (unsigned int8)(0) 
.................... #define BME680_FILTER_SIZE_1              (unsigned int8)(1) 
.................... #define BME680_FILTER_SIZE_3              (unsigned int8)(2) 
.................... #define BME680_FILTER_SIZE_7              (unsigned int8)(3) 
.................... #define BME680_FILTER_SIZE_15             (unsigned int8)(4) 
.................... #define BME680_FILTER_SIZE_31             (unsigned int8)(5) 
.................... #define BME680_FILTER_SIZE_63             (unsigned int8)(6) 
.................... #define BME680_FILTER_SIZE_127            (unsigned int8)(7) 
....................   
.................... /** Power mode settings */ 
.................... #define BME680_SLEEP_MODE                 (unsigned int8)(0) 
.................... #define BME680_FORCED_MODE                (unsigned int8)(1) 
....................   
.................... /** Delay related macro declaration */ 
.................... //#define BME680_RESET_PERIOD               (unsigned int32)(int32)(10) 
.................... #define BME680_RESET_PERIOD               (unsigned int32)(10)  
....................  
.................... /** SPI memory page settings */ 
.................... #define BME680_MEM_PAGE0                  (unsigned int8)(0x0) 
.................... #define BME680_MEM_PAGE1                  (unsigned int8)(0x2) 
....................  
.................... /** SPI register settings */ 
.................... #define BME680_SPI_STATUS                (unsigned int8)(0x73) 
.................... #define BME680_SPI_RESET                 (unsigned int8)(0x60) 
.................... #define BME680_SPI_DEVICE_ID             (unsigned int8)(0x50) 
.................... #define BME680_SPI_CONFIG                (unsigned int8)(0x75) 
.................... #define BME680_SPI_CTRL                  (unsigned int8)(0x74) 
.................... #define BME680_SPI_CTRL_HUM              (unsigned int8)(0x72) 
.................... #define BME680_SPI_CTRL_GAS_1            (unsigned int8)(0x71) 
.................... #define BME680_SPI_CTRL_GAS_0            (unsigned int8)(0x70) 
.................... #define BME680_SPI_GAS_WAIT              (unsigned int8)(0x64)  
.................... #define BME680_SPI_RES_HEAT_X            (unsigned int8)(0x5a) 
.................... #define BME680_SPI_IDAC_HEAT_X           (unsigned int8)(0x50) 
.................... #define BME680_SPI_GAS_R_LSB             (unsigned int8)(0x2b) 
.................... #define BME680_SPI_GAS_R_MSB             (unsigned int8)(0x2a)  
.................... #define BME680_SPI_HUM_LSB               (unsigned int8)(0x26) 
.................... #define BME680_SPI_HUM_MSB               (unsigned int8)(0x25) 
.................... #define BME680_SPI_TEMP_XLSB             (unsigned int8)(0x24) 
.................... #define BME680_SPI_TEMP_LSB              (unsigned int8)(0x23) 
.................... #define BME680_SPI_TEMP_MSB              (unsigned int8)(0x22) 
.................... #define BME680_SPI_PRESS_XLSB            (unsigned int8)(0x21) 
.................... #define BME680_SPI_PRESS_LSB             (unsigned int8)(0x20) 
.................... #define BME680_SPI_PRESS_MSB             (unsigned int8)(0x1f) 
.................... #define BME680_SPI_EAS_STATUS_0          (unsigned int8)(0x1d) 
....................   
.................... #define SLEEP_MODE      (unsigned int8)0X0 
.................... #define FORCED_MODE     (unsigned int8)0X1 
....................  
.................... #define PORTC           (unsigned int8)0XF82 
.................... #define LATC            (unsigned int8)0xF8B 
.................... #define ANSELC          (unsigned int8)0xF3A 
.................... #define TRISC           (unsigned int8)0xF94 
.................... #define SSP1CON1        (unsigned int8)0XFC6 
.................... #define SSP1STAT        (unsigned int8)0XFC7 
....................  
.................... #define TMP_HUM_ADDR    (unsigned int8)0X25 
.................... #define TMP_MSB_ADDR    (unsigned int8)0X22 
.................... #define PRESS_MSB_ADDR  (unsigned int8)0X1F 
.................... #define IDAX_HEAT_X     (unsigned int8)0X50 
.................... #define RES_WAIT_X      (unsigned int8)0X5A 
.................... #define GAS_WAIT_X      (unsigned int8)0X64 
.................... #define CTRL_GAS_1      (unsigned int8)0X71 
....................  
.................... #define BME680_W_SELF_TEST_FAILED 3 
....................  
.................... #define MIN_TEMPERATURE (uint16)(0)      /* 0 degree Celsius */ 
.................... #define MAX_TEMPERATURE (uint16)(6000)    /* 60 degree Celsius */ 
....................  
.................... #define MIN_PRESSURE (uint32)(90000)   /* 900 hecto Pascals */ 
.................... #define MAX_PRESSURE (uint32)(110000)    /* 1100 hecto Pascals */ 
....................  
.................... #define MIN_HUMIDITY (uint32)(20000)   /* 20% relative humidity */ 
.................... #define MAX_HUMIDITY (uint32)(80000)    /* 80% relative humidity*/ 
....................  
.................... #define HEATR_DUR          2000 
.................... #define N_MEAS             6 
.................... #define LOW_TEMP           150 
.................... #define HIGH_TEMP          350 
....................   
....................   
.................... /** Ambient humidity shift value for compensation */ 
.................... #define BME680_HUM_REG_SHIFT_VAL          (unsigned int8)(4) 
....................   
.................... /** Run gas enable and disable settings */ 
.................... #define BME680_RUN_GAS_DISABLE            (unsigned int8)(0) 
.................... #define BME680_RUN_GAS_ENABLE             (unsigned int8)(1) 
....................   
.................... /** Buffer length macro declaration */ 
.................... #define BME680_TMP_BUFFER_LENGTH          (unsigned int8)(40) 
.................... #define BME680_REG_BUFFER_LENGTH          (unsigned int8)(6) 
.................... #define BME680_FIELD_DATA_LENGTH          (unsigned int8)(3) 
.................... #define BME680_GAS_REG_BUF_LENGTH         (unsigned int8)(20) 
....................   
.................... /** Settings selector */ 
.................... #define BME680_OST_SEL                    (unsigned int16)(1) 
.................... #define BME680_OSP_SEL                    (unsigned int16)(2) 
.................... #define BME680_OSH_SEL                    (unsigned int16)(4) 
.................... #define BME680_GAS_MEAS_SEL               (unsigned int16)(8) 
.................... #define BME680_FILTER_SEL                 (unsigned int16)(16) 
.................... #define BME680_HCNTRL_SEL                 (unsigned int16)(32) 
.................... #define BME680_RUN_GAS_SEL                (unsigned int16)(64) 
.................... #define BME680_NBCONV_SEL                 (unsigned int16)(128) 
.................... #define BME680_GAS_SENSOR_SEL             (BME680_GAS_MEAS_SEL | BME680_RUN_GAS_SEL | BME680_NBCONV_SEL) 
....................   
.................... /** Number of conversion settings*/ 
.................... #define BME680_NBCONV_MIN        (unsigned int8)(0) 
.................... #define BME680_NBCONV_MAX        (unsigned int8)(10) 
....................   
.................... /** Mask definitions */ 
.................... #define BME680_GAS_MEAS_MSK      (unsigned int8)(0x30) 
.................... #define BME680_NBCONV_MSK        (unsigned int8)(0X0F) 
.................... #define BME680_FILTER_MSK        (unsigned int8)(0X1C) 
.................... #define BME680_OST_MSK           (unsigned int8)(0XE0) 
.................... #define BME680_OSP_MSK           (unsigned int8)(0X1C) 
.................... #define BME680_OSH_MSK           (unsigned int8)(0X07) 
.................... #define BME680_HCTRL_MSK         (unsigned int8)(0x08) 
.................... #define BME680_RUN_GAS_MSK       (unsigned int8)(0x10) 
.................... #define BME680_MODE_MSK          (unsigned int8)(0x03) 
.................... #define BME680_RHRANGE_MSK       (unsigned int8)(0x30) 
.................... #define BME680_RSERROR_MSK       (unsigned int8)(0xf0) 
.................... #define BME680_NEW_DATA_MSK      (unsigned int8)(0x80) 
.................... #define BME680_GAS_INDEX_MSK     (unsigned int8)(0x0f) 
.................... #define BME680_GAS_RANGE_MSK     (unsigned int8)(0x0f) 
.................... #define BME680_GASM_VALID_MSK    (unsigned int8)(0x20) 
.................... #define BME680_HEAT_STAB_MSK     (unsigned int8)(0x10) 
.................... #define BME680_MEM_PAGE_MSK      (unsigned int8)(0x10) 
.................... #define BME680_SPI_RD_MSK        (unsigned int8)(0x80) 
.................... #define BME680_SPI_WR_MSK        (unsigned int8)(0x7f) 
.................... #define BME680_BIT_H1_DATA_MSK   (unsigned int8)(0x0F) 
....................   
.................... /** Bit position definitions for sensor settings */ 
.................... #define BME680_GAS_MEAS_POS      (unsigned int8)(4) 
.................... #define BME680_FILTER_POS        (unsigned int8)(2) 
.................... #define BME680_OST_POS           (unsigned int8)(5) 
.................... #define BME680_OSP_POS           (unsigned int8)(2) 
.................... #define BME680_RUN_GAS_POS       (unsigned int8)(4) 
....................   
.................... /** Array Index to Field data mapping for Calibration Data*/ 
.................... #define BME680_T2_LSB_REG   (1) 
.................... #define BME680_T2_MSB_REG   (2) 
.................... #define BME680_T3_REG       (3) 
.................... #define BME680_P1_LSB_REG   (5) 
.................... #define BME680_P1_MSB_REG   (6) 
.................... #define BME680_P2_LSB_REG   (7) 
.................... #define BME680_P2_MSB_REG   (8) 
.................... #define BME680_P3_REG       (9) 
.................... #define BME680_P4_LSB_REG   (11) 
.................... #define BME680_P4_MSB_REG   (12) 
.................... #define BME680_P5_LSB_REG   (13) 
.................... #define BME680_P5_MSB_REG   (14) 
.................... #define BME680_P7_REG       (15) 
.................... #define BME680_P6_REG       (16) 
.................... #define BME680_P8_LSB_REG   (19) 
.................... #define BME680_P8_MSB_REG   (20) 
.................... #define BME680_P9_LSB_REG   (21) 
.................... #define BME680_P9_MSB_REG   (22) 
.................... #define BME680_P10_REG      (23) 
.................... #define BME680_H2_MSB_REG   (25) 
.................... #define BME680_H2_LSB_REG   (26) 
.................... #define BME680_H1_LSB_REG   (26) 
.................... #define BME680_H1_MSB_REG   (27) 
.................... #define BME680_H3_REG       (28) 
.................... #define BME680_H4_REG       (29) 
.................... #define BME680_H5_REG       (30) 
.................... #define BME680_H6_REG       (31) 
.................... #define BME680_H7_REG       (32) 
.................... #define BME680_T1_LSB_REG   (33) 
.................... #define BME680_T1_MSB_REG   (34) 
.................... #define BME680_GH2_LSB_REG  (35) 
.................... #define BME680_GH2_MSB_REG  (36) 
.................... #define BME680_GH1_REG      (37) 
.................... #define BME680_GH3_REG      (38) 
....................   
.................... /** BME680 register buffer index settings*/ 
.................... #define BME680_REG_FILTER_INDEX        (unsigned int8)(5) 
.................... #define BME680_REG_TEMP_INDEX          (unsigned int8)(4) 
.................... #define BME680_REG_PRES_INDEX          (unsigned int8)(4) 
.................... #define BME680_REG_HUM_INDEX           (unsigned int8)(2) 
.................... #define BME680_REG_NBCONV_INDEX        (unsigned int8)(1) 
.................... #define BME680_REG_RUN_GAS_INDEX       (unsigned int8)(1) 
.................... #define BME680_REG_HCTRL_INDEX         (unsigned int8)(0) 
....................   
.................... /** BME680 pressure calculation macros */ 
.................... /*! This max value is used to provide precedence to multiplication or division 
....................  * in pressure compensation equation to achieve least loss of precision and 
....................  * avoiding overflows. 
....................  * i.e Comparing value, BME680_MAX_OVERFLOW_VAL = (int32)(1 << 30) 
....................  */ 
.................... #define BME680_MAX_OVERFLOW_VAL      (int32)(0x40000000) 
....................   
.................... /** Macro to combine two 8 bit data's to form a 16 bit data */ 
.................... #define BME680_CONCAT_BYTES(msb, lsb)   (((uint16_t)msb << 8) | (uint16_t)lsb) 
....................   
.................... /** Macro to SET and GET BITS of a register */ 
.................... #define BME680_SET_BITS(reg_data, bitname, data) \ 
....................         ((reg_data & ~(bitname##_MSK)) | \ 
....................         ((data << bitname##_POS) & bitname##_MSK)) 
.................... #define BME680_GET_BITS(reg_data, bitname)  ((reg_data & (bitname##_MSK)) >> \ 
....................     (bitname##_POS)) 
....................   
.................... /** Macro variant to handle the bitname position if it is zero */ 
.................... #define BME680_SET_BITS_POS_0(reg_data, bitname, data) \ 
....................                 ((reg_data & ~(bitname##_MSK)) | \ 
....................                 (data & bitname##_MSK)) 
.................... #define BME680_GET_BITS_POS_0(reg_data, bitname)  (reg_data & (bitname##_MSK)) 
....................   
.................... /** Type definitions */ 
.................... /*! 
....................  * Generic communication function pointer 
....................  * @param[in] dev_id: Place holder to store the id of the device structure 
....................  *                    Can be used to store the index of the Chip select or 
....................  *                    I2C address of the device. 
....................  * @param[in] reg_addr: Used to select the register the where data needs to 
....................  *                      be read from or written to. 
....................  * @param[in/out] reg_data: Data array to read/write 
....................  * @param[in] len: Length of the data array 
....................  */ 
.................... typedef int8_t (*bme680_com_fptr_t)(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len); 
....................   
.................... /*! 
....................  * Delay function pointer 
....................  * @param[in] period: Time period in milliseconds 
....................  */ 
.................... typedef void (*bme680_delay_fptr_t)(uint32_t period); 
....................   
.................... /*! 
....................  * @brief Interface selection Enumerations 
....................  */ 
.................... enum bme680_intf { 
....................     /*! SPI interface */ 
....................     BME680_SPI_INTF, 
....................     /*! I2C interface */ 
....................     BME680_I2C_INTF 
.................... }; 
....................   
.................... /* structure definitions */ 
.................... /*! 
....................  * @brief Sensor field data structure 
....................  */ 
.................... struct  bme680_field_data { 
....................     /*! Contains new_data, gasm_valid & heat_stab */ 
....................     uint8_t status; 
....................     /*! The index of the heater profile used */ 
....................     uint8_t gas_index; 
....................     /*! Measurement index to track order */ 
....................     uint8_t meas_index; 
....................   
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
....................     /*! Temperature in degree celsius x100 */ 
....................     int16_t temperature; 
....................     /*! Pressure in Pascal */ 
....................     uint32_t pressure; 
....................     /*! Humidity in % relative humidity x1000 */ 
....................     uint32_t humidity; 
....................     /*! Gas resistance in Ohms */ 
....................     uint32_t gas_resistance; 
.................... #else 
....................     /*! Temperature in degree celsius */ 
....................     float temperature; 
....................     /*! Pressure in Pascal */ 
....................     float pressure; 
....................     /*! Humidity in % relative humidity x1000 */ 
....................     float humidity; 
....................     /*! Gas resistance in Ohms */ 
....................     float gas_resistance; 
....................   
.................... #endif 
....................   
.................... }; 
....................   
.................... /*! 
....................  * @brief Structure to hold the Calibration data 
....................  */ 
.................... struct  bme680_calib_data { 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint16_t par_h1; 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint16_t par_h2; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h3; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h4; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h5; 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint8_t par_h6; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h7; 
....................     /*! Variable to store calibrated gas data */ 
....................     int8_t par_gh1; 
....................     /*! Variable to store calibrated gas data */ 
....................     int16_t par_gh2; 
....................     /*! Variable to store calibrated gas data */ 
....................     int8_t par_gh3; 
....................     /*! Variable to store calibrated temperature data */ 
....................     uint16_t par_t1; 
....................     /*! Variable to store calibrated temperature data */ 
....................     int16_t par_t2; 
....................     /*! Variable to store calibrated temperature data */ 
....................     int8_t par_t3; 
....................     /*! Variable to store calibrated pressure data */ 
....................     uint16_t par_p1; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p2; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p3; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p4; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p5; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p6; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p7; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p8; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p9; 
....................     /*! Variable to store calibrated pressure data */ 
....................     uint8_t par_p10; 
....................   
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
....................     /*! Variable to store t_fine size */ 
....................     int32_t t_fine; 
.................... #else 
....................     /*! Variable to store t_fine size */ 
....................     float t_fine; 
.................... #endif 
....................     /*! Variable to store heater resistance range */ 
....................     uint8_t res_heat_range; 
....................     /*! Variable to store heater resistance value */ 
....................     int8_t res_heat_val; 
....................     /*! Variable to store error range */ 
....................     int8_t range_sw_err; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 sensor settings structure which comprises of ODR, 
....................  * over-sampling and filter settings. 
....................  */ 
.................... struct  bme680_tph_sett { 
....................     /*! Humidity oversampling */ 
....................     uint8_t os_hum; 
....................     /*! Temperature oversampling */ 
....................     uint8_t os_temp; 
....................     /*! Pressure oversampling */ 
....................     uint8_t os_pres; 
....................     /*! Filter coefficient */ 
....................     uint8_t filter; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 gas sensor which comprises of gas settings 
....................  *  and status parameters 
....................  */ 
.................... struct  bme680_gas_sett { 
....................     /*! Variable to store nb conversion */ 
....................     uint8_t nb_conv; 
....................     /*! Variable to store heater control */ 
....................     uint8_t heatr_ctrl; 
....................     /*! Run gas enable value */ 
....................     uint8_t run_gas; 
....................     /*! Heater temperature value */ 
....................     uint16_t heatr_temp; 
....................     /*! Duration profile value */ 
....................     uint16_t heatr_dur; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 device structure 
....................  */ 
.................... struct  bme680_dev { 
....................     /*! Chip Id */ 
....................     uint8_t chip_id; 
....................     /*! Device Id */ 
....................     uint8_t dev_id; 
....................     /*! SPI/I2C interface */ 
....................     enum bme680_intf intf; 
....................     /*! Memory page used */ 
....................     uint8_t mem_page; 
....................     /*! Ambient temperature in Degree C */ 
....................     int8_t amb_temp; 
....................     /*! Sensor calibration data */ 
....................     struct bme680_calib_data calib; 
....................     /*! Sensor settings */ 
....................     struct bme680_tph_sett tph_sett; 
....................     /*! Gas Sensor settings */ 
....................     struct bme680_gas_sett gas_sett; 
....................     /*! Sensor power modes */ 
....................     uint8_t power_mode; 
....................     /*! New sensor fields */ 
....................     uint8_t new_fields; 
....................     /*! Store the info messages */ 
....................     uint8_t info_msg; 
....................     /*! Bus read function pointer */ 
....................     bme680_com_fptr_t read; 
....................     /*! Bus write function pointer */ 
....................     bme680_com_fptr_t write; 
....................     /*! delay function pointer */ 
....................     bme680_delay_fptr_t delay_ms; 
....................     /*! Communication function result */ 
....................     int8_t com_rslt; 
.................... }; 
.................... #endif /* BME680_DEFS_H_ */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* function prototype declarations */ 
.................... /*! 
....................  *  @brief This API is the entry point. 
....................  *  It reads the chip-id and calibration data from the sensor. 
....................  * 
....................  *  @param[in,out] dev : Structure instance of bme680_dev 
....................  * 
....................  *  @return Result of API execution status 
....................  *  @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_init(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API writes the given data to the register address 
....................  * of the sensor. 
....................  * 
....................  * @param[in] reg_addr : Register address from where the data to be written. 
....................  * @param[in] reg_data : Pointer to data buffer which is to be written 
....................  * in the sensor. 
....................  * @param[in] len : No of bytes of data to write.. 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_set_regs(const uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API reads the data from the given register address of the sensor. 
....................  * 
....................  * @param[in] reg_addr : Register address from where the data to be read 
....................  * @param[out] reg_data : Pointer to data buffer to store the read data. 
....................  * @param[in] len : No of bytes of data to be read. 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint16_t len, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API performs the soft reset of the sensor. 
....................  * 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error. 
....................  */ 
.................... int8_t bme680_soft_reset(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to set the power mode of the sensor. 
....................  * 
....................  * @param[in] dev : Structure instance of bme680_dev 
....................  * @note : Pass the value to bme680_dev.power_mode structure variable. 
....................  * 
....................  *  value   |   mode 
....................  * -------------|------------------ 
....................  *   0x00   |   BME680_SLEEP_MODE 
....................  *   0x01   |   BME680_FORCED_MODE 
....................  * 
....................  * * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_set_sensor_mode(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to get the power mode of the sensor. 
....................  * 
....................  * @param[in] dev : Structure instance of bme680_dev 
....................  * @note : bme680_dev.power_mode structure variable hold the power mode. 
....................  * 
....................  *  value   |   mode 
....................  * ---------|------------------ 
....................  *   0x00   |   BME680_SLEEP_MODE 
....................  *   0x01   |   BME680_FORCED_MODE 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_get_sensor_mode(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to set the profile duration of the sensor. 
....................  * 
....................  * @param[in] dev      : Structure instance of bme680_dev. 
....................  * @param[in] duration : Duration of the measurement in ms. 
....................  * 
....................  * @return Nothing 
....................  */ 
.................... void bme680_set_profile_dur(uint16_t duration, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to get the profile duration of the sensor. 
....................  * 
....................  * @param[in] dev      : Structure instance of bme680_dev. 
....................  * @param[in] duration : Duration of the measurement in ms. 
....................  * 
....................  * @return Nothing 
....................  */ 
.................... void bme680_get_profile_dur(uint16_t *duration, const struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API reads the pressure, temperature and humidity and gas data 
....................  * from the sensor, compensates the data and store it in the bme680_data 
....................  * structure instance passed by the user. 
....................  * 
....................  * @param[out] data: Structure instance to hold the data. 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error 
....................  */ 
.................... int8_t bme680_get_sensor_data(struct bme680_field_data *data, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to set the oversampling, filter and T,P,H, gas selection 
....................  * settings in the sensor. 
....................  * 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * @param[in] desired_settings : Variable used to select the settings which 
....................  * are to be set in the sensor. 
....................  * 
....................  *    Macros                      |  Functionality 
....................  *---------------------------------|---------------------------------------------- 
....................  *   BME680_OST_SEL             |    To set temperature oversampling. 
....................  *   BME680_OSP_SEL             |    To set pressure oversampling. 
....................  *   BME680_OSH_SEL             |    To set humidity oversampling. 
....................  *   BME680_GAS_MEAS_SEL        |    To set gas measurement setting. 
....................  *   BME680_FILTER_SEL          |    To set filter setting. 
....................  *   BME680_HCNTRL_SEL          |    To set humidity control setting. 
....................  *   BME680_RUN_GAS_SEL         |    To set run gas setting. 
....................  *   BME680_NBCONV_SEL          |    To set NB conversion setting. 
....................  *   BME680_GAS_SENSOR_SEL      |    To set all gas sensor related settings 
....................  * 
....................  * @note : Below are the macros to be used by the user for selecting the 
....................  * desired settings. User can do OR operation of these macros for configuring 
....................  * multiple settings. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error. 
....................  */ 
.................... int8_t bme680_set_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This API is used to get the oversampling, filter and T,P,H, gas selection 
....................  * settings in the sensor. 
....................  * 
....................  * @param[in] dev : Structure instance of bme680_dev. 
....................  * @param[in] desired_settings : Variable used to select the settings which 
....................  * are to be get from the sensor. 
....................  * 
....................  * @return Result of API execution status 
....................  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error. 
....................  */ 
.................... int8_t bme680_get_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to validate the device structure pointer for 
....................  * null conditions. 
....................  */ 
.................... int8_t null_ptr_check(const struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to read the calibrated data from the sensor. 
....................  */ 
.................... int8_t get_calib_data(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to set the memory page based on register address. 
....................  */ 
.................... int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to get the memory page based on register address. 
....................  */ 
.................... int8_t get_mem_page(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to set the gas configuration of the sensor. 
....................  */ 
.................... int8_t set_gas_config(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to validate the boundary 
....................  * conditions. 
....................  */ 
.................... int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to get the gas configuration of the sensor. 
....................  * @note heatr_temp and heatr_dur values are currently register data 
....................  * and not the actual values set 
....................  */ 
.................... int8_t get_gas_config(struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to calculate the field data of sensor. 
....................  */ 
.................... int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to calculate the Heat Resistance value. 
....................  */ 
.................... uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev); 
....................  
.................... /*! 
....................  * @brief This internal API is used to calculate the Heat duration value. 
....................  */ 
.................... uint8_t calc_heater_dur(uint16_t dur); 
....................  
....................  
.................... int8_t Write(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len); 
.................... int8_t Read(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len); 
....................  
.................... void Write_Byte(uint8_t reg_addr, uint8_t data); 
.................... uint8_t Read_Byte(uint8_t reg_addr); 
....................  
.................... int8_t checkBMEPowerUp(struct bme680_dev *dev); 
.................... int8_t SetBME_Oversampling_and_00IIR(struct bme680_dev *dev, uint8 osrs_h, uint8 osrs_t, uint8 osrs_p, uint8 filter); 
....................  
.................... int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev); 
.................... float GetFlowByInterpolation(float x0, float y0, float x1, float y1, float x); 
.................... float GetFlowFromLUTable(uint32_t dPressure); 
.................... float GetNewVolume(uint32_t dPressure, uint32_t timeIntervalMs); 
.................... int8_t Compute_Breath_Volume(struct bme680_dev *dev); 
....................  
....................  
....................  
.................... #ifdef __cplusplus 
.................... } 
.................... #endif /* End of CPP guard */ 
.................... #endif /* BME680_H_ */ 
.................... /** @}*/ 
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  /* 
.................... BME680::BME680 ( PinName sda, PinName scl, uint32_t freq ) 
....................     : _i2c          ( sda, scl ) 
.................... { 
....................     _i2c.frequency  ( freq ); 
.................... } 
....................   
....................   
.................... BME680::~BME680() 
.................... { 
.................... } 
....................  */ 
....................  
.................... extern uint16  breathVolume; 
.................... extern struct  testInfoPara    testStat; 
....................  
....................  
.................... float flowLPM = 0.0; 
....................  
.................... //const int dP = 0, FlowRate = 1; 
....................  
.................... float polynomialfit(int32_t dPressure) 
*
099DC:  MOVFF  825,831
099E0:  MOVFF  824,830
099E4:  MOVFF  823,82F
099E8:  MOVFF  822,82E
099EC:  RCALL  9982
099EE:  MOVFF  03,82D
099F2:  MOVFF  02,82C
099F6:  MOVFF  01,82B
099FA:  MOVFF  00,82A
.................... { 
....................    float flow; 
....................    float deltaPressure = (float)dPressure; 
....................     
....................    flow = (0.0000000001*(deltaPressure*deltaPressure*deltaPressure)) - (0.000001*(deltaPressure*deltaPressure)) + (0.0042*deltaPressure) + 1.7646; 
099FE:  MOVFF  82D,835
09A02:  MOVFF  82C,834
09A06:  MOVFF  82B,833
09A0A:  MOVFF  82A,832
09A0E:  MOVFF  82D,839
09A12:  MOVFF  82C,838
09A16:  MOVFF  82B,837
09A1A:  MOVFF  82A,836
09A1E:  CALL   3F30
09A22:  MOVFF  03,831
09A26:  MOVFF  02,830
09A2A:  MOVFF  01,82F
09A2E:  MOVFF  00,82E
09A32:  MOVFF  03,835
09A36:  MOVFF  02,834
09A3A:  MOVFF  01,833
09A3E:  MOVFF  00,832
09A42:  MOVFF  82D,839
09A46:  MOVFF  82C,838
09A4A:  MOVFF  82B,837
09A4E:  MOVFF  82A,836
09A52:  CALL   3F30
09A56:  MOVLB  8
09A58:  SETF   x35
09A5A:  MOVLW  E6
09A5C:  MOVWF  x34
09A5E:  MOVLW  5B
09A60:  MOVWF  x33
09A62:  MOVLW  5D
09A64:  MOVWF  x32
09A66:  MOVFF  03,839
09A6A:  MOVFF  02,838
09A6E:  MOVFF  01,837
09A72:  MOVFF  00,836
09A76:  MOVLB  0
09A78:  CALL   3F30
09A7C:  MOVFF  03,831
09A80:  MOVFF  02,830
09A84:  MOVFF  01,82F
09A88:  MOVFF  00,82E
09A8C:  MOVFF  82D,835
09A90:  MOVFF  82C,834
09A94:  MOVFF  82B,833
09A98:  MOVFF  82A,832
09A9C:  MOVFF  82D,839
09AA0:  MOVFF  82C,838
09AA4:  MOVFF  82B,837
09AA8:  MOVFF  82A,836
09AAC:  CALL   3F30
09AB0:  MOVLW  BD
09AB2:  MOVLB  8
09AB4:  MOVWF  x35
09AB6:  MOVLW  37
09AB8:  MOVWF  x34
09ABA:  MOVLW  06
09ABC:  MOVWF  x33
09ABE:  MOVLW  6B
09AC0:  MOVWF  x32
09AC2:  MOVFF  03,839
09AC6:  MOVFF  02,838
09ACA:  MOVFF  01,837
09ACE:  MOVFF  00,836
09AD2:  MOVLB  0
09AD4:  CALL   3F30
09AD8:  BSF    FD8.1
09ADA:  MOVFF  831,835
09ADE:  MOVFF  830,834
09AE2:  MOVFF  82F,833
09AE6:  MOVFF  82E,832
09AEA:  MOVFF  03,839
09AEE:  MOVFF  02,838
09AF2:  MOVFF  01,837
09AF6:  MOVFF  00,836
09AFA:  CALL   6880
09AFE:  MOVFF  03,831
09B02:  MOVFF  02,830
09B06:  MOVFF  01,82F
09B0A:  MOVFF  00,82E
09B0E:  MOVLW  27
09B10:  MOVLB  8
09B12:  MOVWF  x35
09B14:  MOVLW  A0
09B16:  MOVWF  x34
09B18:  MOVLW  09
09B1A:  MOVWF  x33
09B1C:  MOVLW  77
09B1E:  MOVWF  x32
09B20:  MOVFF  82D,839
09B24:  MOVFF  82C,838
09B28:  MOVFF  82B,837
09B2C:  MOVFF  82A,836
09B30:  MOVLB  0
09B32:  CALL   3F30
09B36:  BCF    FD8.1
09B38:  MOVFF  831,835
09B3C:  MOVFF  830,834
09B40:  MOVFF  82F,833
09B44:  MOVFF  82E,832
09B48:  MOVFF  03,839
09B4C:  MOVFF  02,838
09B50:  MOVFF  01,837
09B54:  MOVFF  00,836
09B58:  CALL   6880
09B5C:  MOVFF  03,831
09B60:  MOVFF  02,830
09B64:  MOVFF  01,82F
09B68:  MOVFF  00,82E
09B6C:  BCF    FD8.1
09B6E:  MOVFF  03,835
09B72:  MOVFF  02,834
09B76:  MOVFF  01,833
09B7A:  MOVFF  00,832
09B7E:  MOVLW  6A
09B80:  MOVLB  8
09B82:  MOVWF  x39
09B84:  MOVLW  DE
09B86:  MOVWF  x38
09B88:  MOVLW  61
09B8A:  MOVWF  x37
09B8C:  MOVLW  7F
09B8E:  MOVWF  x36
09B90:  MOVLB  0
09B92:  CALL   6880
09B96:  MOVFF  03,829
09B9A:  MOVFF  02,828
09B9E:  MOVFF  01,827
09BA2:  MOVFF  00,826
.................... //   flow = ((0.0000000002*(deltaPressure*deltaPressure*deltaPressure)) - (0.000002*(deltaPressure*deltaPressure)) + (0.0059*deltaPressure) + 0.0152); 
.................... //   flow = ((0.0000000002*(deltaPressure*deltaPressure*deltaPressure)) - (0.000002*(deltaPressure*deltaPressure)) + (0.0069*deltaPressure) + 0.0152); 
.................... //   fprintf(STDOUT, "********** yaman dP %lu, flowLPM1 = %.2f \r\n", dPressure,flow); 
....................    return flow; 
09BA6:  MOVFF  826,00
09BAA:  MOVFF  827,01
09BAE:  MOVFF  828,02
09BB2:  MOVFF  829,03
09BB6:  GOTO   9BD8 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... float GetNewVolume(uint32_t dPressure, uint32_t timeIntervalMs) 
09BBA:  MOVLB  8
09BBC:  CLRF   x21
09BBE:  CLRF   x20
09BC0:  CLRF   x1F
09BC2:  CLRF   x1E
.................... { 
....................   float newVolume_ml = 0.0; 
....................    
....................   flowLPM = polynomialfit(dPressure); 
09BC4:  MOVFF  819,825
09BC8:  MOVFF  818,824
09BCC:  MOVFF  817,823
09BD0:  MOVFF  816,822
09BD4:  MOVLB  0
09BD6:  BRA    99DC
09BD8:  MOVFF  03,45C
09BDC:  MOVFF  02,45B
09BE0:  MOVFF  01,45A
09BE4:  MOVFF  00,459
....................   newVolume_ml = (flowLPM*(float)timeIntervalMs)*(1.0/60.0); 
09BE8:  MOVFF  81D,825
09BEC:  MOVFF  81C,824
09BF0:  MOVFF  81B,823
09BF4:  MOVFF  81A,822
09BF8:  RCALL  994A
09BFA:  MOVFF  45C,835
09BFE:  MOVFF  45B,834
09C02:  MOVFF  45A,833
09C06:  MOVFF  459,832
09C0A:  MOVFF  03,839
09C0E:  MOVFF  02,838
09C12:  MOVFF  01,837
09C16:  MOVFF  00,836
09C1A:  CALL   3F30
09C1E:  MOVFF  03,825
09C22:  MOVFF  02,824
09C26:  MOVFF  01,823
09C2A:  MOVFF  00,822
09C2E:  MOVFF  03,835
09C32:  MOVFF  02,834
09C36:  MOVFF  01,833
09C3A:  MOVFF  00,832
09C3E:  MOVLW  89
09C40:  MOVLB  8
09C42:  MOVWF  x39
09C44:  MOVLW  88
09C46:  MOVWF  x38
09C48:  MOVLW  08
09C4A:  MOVWF  x37
09C4C:  MOVLW  79
09C4E:  MOVWF  x36
09C50:  MOVLB  0
09C52:  CALL   3F30
09C56:  MOVFF  03,821
09C5A:  MOVFF  02,820
09C5E:  MOVFF  01,81F
09C62:  MOVFF  00,81E
....................   return newVolume_ml; 
09C66:  MOVFF  81E,00
09C6A:  MOVFF  81F,01
09C6E:  MOVFF  820,02
09C72:  MOVFF  821,03
09C76:  RETURN 0
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... int8_t Compute_Breath_Volume(struct bme680_dev *dev) 
*
09D38:  MOVLB  7
09D3A:  CLRF   x06
09D3C:  CLRF   x05
09D3E:  CLRF   x04
09D40:  CLRF   x03
09D42:  CLRF   x0E
09D44:  CLRF   x0D
09D46:  CLRF   x0C
09D48:  MOVLW  05
09D4A:  MOVWF  x0B
09D4C:  CLRF   x12
09D4E:  CLRF   x11
09D50:  CLRF   x10
09D52:  CLRF   x0F
09D54:  CLRF   x16
09D56:  CLRF   x15
09D58:  CLRF   x14
09D5A:  CLRF   x13
09D5C:  CLRF   x1A
09D5E:  CLRF   x19
09D60:  CLRF   x18
09D62:  CLRF   x17
09D64:  CLRF   x1E
09D66:  CLRF   x1D
09D68:  CLRF   x1C
09D6A:  CLRF   x1B
09D6C:  CLRF   x22
09D6E:  CLRF   x21
09D70:  CLRF   x20
09D72:  CLRF   x1F
09D74:  CLRF   x26
09D76:  CLRF   x25
09D78:  CLRF   x24
09D7A:  CLRF   x23
09D7C:  CLRF   x2A
09D7E:  CLRF   x29
09D80:  CLRF   x28
09D82:  CLRF   x27
09D84:  CLRF   x2E
09D86:  CLRF   x2D
09D88:  CLRF   x2C
09D8A:  CLRF   x2B
09D8C:  CLRF   xA6
09D8E:  CLRF   xA5
09D90:  CLRF   xA4
09D92:  CLRF   xA3
09D94:  CLRF   xA7
09D96:  MOVLW  01
09D98:  MOVWF  xAE
09D9A:  CLRF   xB1
09D9C:  MOVWF  xB2
09D9E:  CLRF   xB6
09DA0:  CLRF   xB5
09DA2:  CLRF   xB4
09DA4:  MOVLW  64
09DA6:  MOVWF  xB3
09DA8:  CLRF   xBA
09DAA:  CLRF   xB9
09DAC:  CLRF   xB8
09DAE:  MOVWF  xB7
09DB0:  CLRF   xC2
09DB2:  CLRF   xC1
09DB4:  CLRF   xC0
09DB6:  CLRF   xBF
09DB8:  CLRF   xC6
09DBA:  CLRF   xC5
09DBC:  CLRF   xC4
09DBE:  CLRF   xC3
09DC0:  CLRF   xCA
09DC2:  CLRF   xC9
09DC4:  CLRF   xC8
09DC6:  CLRF   xC7
09DC8:  CLRF   xCB
09DCA:  CLRF   xCC
09DCC:  CLRF   xD1
.................... { 
....................    uint32_t    timerCtr = 0; 
....................    uint32_t    startPressure;                                     // = 34120;//34132+10;//99837+5; 
....................    uint32_t    startCount = 5; 
....................    uint32_t    lowPressureLastCount = 0; 
....................    uint32_t    inVolumeAccumulation = 0; 
....................    uint32_t    accumulatedTimeMs = 0;    
....................    uint32_t    pressure1 = 0; 
....................    uint32_t    timeStamp1 = 0, deltaT = 0, deltaP = 0, prevdeltaP = 0; 
....................    uint32_t    temperature_received,pressure_received, _Pressure,humidity_received,gas_received, _T1,_T2,_T3,_tfine,temperature_comp; 
....................    uint32_t    temperatureXLSB, temperatureLSB, temperatureMSB,pressureXLSB, pressureLSB, pressureMSB; 
....................    uint32_t    _Temperature,_P1,_P2,_P4,_P8,_P9,_P5,_P10; 
....................    int32_t     _P3,_P6,_P7;        
....................     
....................    uint32_t    timer_current, timer_diff, timer_previous = 0; 
....................     
....................    uint8_t     timerFlag = OFF; 
....................    uint8       osrs_h, osrs_t, osrs_p, filter, value,control_reg; 
....................    uint8       numberOfAttempts = 1;       
....................    uint8       temp, temp1, pressureChangeNotDetected= 0;       
....................    uint8       earlyWarningFlag = ON; 
....................     
.................... //   uint32_5    lowPressureLastCountLimit = 3;//6; 
.................... //   uint32_t    prevPressure1 = 0, prevPressure2 = 0; 
.................... //   uint32_t    pressure_comp,humidity_comp, gas_comp,gas_resistance_MSB, gas_resistance_LSB, humidityMSB, humidityLSB;    
.................... //   uint8       ctr, initSensorCmds[4],*regPtr = NULL;   
....................  
....................    const uint32_t dPressureThresheldStart = 100;                //20;//20;//12; 
....................    const uint32_t dPressureThresheldEnd = 100;                 //30;//6; 
....................        
....................    static uint32_t prevTimeStamp1 = 0; 
....................     
....................    float temperature; 
....................    float AccumulatedVolume1_ml = 0.0; 
....................     
....................    float deltaVol_1 = 0.0; 
....................    float tmpVol = 0; 
....................     
....................    //   float humi, AccumulatedVolume2_ml = 0.0;; 
....................   
....................    enum  BreathTestState breathTestState = BREATH_TEST_NOT_RUN; 
....................     
.................... //   struct      bme680_field_data data[N_MEAS]; 
....................    uint8       status = MYSTATUS_OK; 
....................    uint32_t    count; 
....................    uint8 rslt = BME680_OK; 
....................     
....................    temp = temp1 = 0; 
09DCE:  CLRF   xB0
09DD0:  MOVFF  7B0,7AF
....................    get_mem_page( dev ); 
09DD4:  MOVFF  702,819
09DD8:  MOVFF  701,818
09DDC:  MOVLB  0
09DDE:  CALL   3292
....................     
.................... #ifdef DEBUG    
....................    fprintf(STDOUT, "Current mem_page before writing control registers = %02X\r\n", dev->mem_page); 
....................    fprintf(STDOUT, "***************************************************************************\r\n"); 
.................... #endif    
....................     
....................    delay_ms(100); 
09DE2:  MOVLW  64
09DE4:  MOVLB  8
09DE6:  MOVWF  x18
09DE8:  MOVLB  0
09DEA:  CALL   2D2E
....................     
....................    osrs_h = BME680_OS_NONE;                       //oversampling none 
09DEE:  MOVLB  7
09DF0:  CLRF   xA8
....................    osrs_t = BME680_OS_8X << 5;                    //oversampling x 8 
09DF2:  MOVLW  80
09DF4:  MOVWF  xA9
....................    osrs_p = BME680_OS_4X << 2;                    //oversampling x 4 
09DF6:  MOVLW  0C
09DF8:  MOVWF  xAA
....................    control_reg = osrs_t | osrs_p; 
09DFA:  MOVF   xA9,W
09DFC:  IORWF  xAA,W
09DFE:  MOVWF  xAD
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "**********control_reg = %02X\r\n", control_reg); 
....................     
....................    //set oversampling 
....................    fprintf(STDOUT, "*********************************************************************\r\n"); 
....................    fprintf(STDOUT, "********************    MODE   SELECT  ******************************\r\n"); 
....................    fprintf(STDOUT, "*********************************************************************\r\n"); 
....................  
....................    //Read values of oversampling register before writing 
....................    temp = Read_Byte(BME680_SPI_CTRL);               //(0x74) 
....................    temp = Read_Byte(BME680_SPI_CTRL_HUM);           //(0x72) 
.................... #endif    
....................  
....................    /********************/ 
....................    /* Set Oversampling */ 
....................    /********************/ 
....................    //Set oversampling values for temperature, pressure, and humidity 
....................    Write_Byte( BME680_SPI_CTRL, control_reg ); //0x74 
09E00:  MOVLW  74
09E02:  MOVLB  8
09E04:  MOVWF  x18
09E06:  MOVFF  7AD,819
09E0A:  MOVLB  0
09E0C:  CALL   31D0
....................    Write_Byte( BME680_SPI_CTRL_HUM, osrs_h );  //0x72 
09E10:  MOVLW  72
09E12:  MOVLB  8
09E14:  MOVWF  x18
09E16:  MOVFF  7A8,819
09E1A:  MOVLB  0
09E1C:  CALL   31D0
....................  
.................... #ifdef DEBUG    
....................    //Read values of oversampling register after writing 
....................    temp = Read_Byte(0x74); //BME680_SPI_CTRL 
....................    temp = Read_Byte(0x72); //BME680_SPI_CTRL_HUM 
....................     
....................    //Read values of filter register before writing 
....................    temp = Read_Byte(BME680_SPI_CONFIG); //0x75 
.................... #endif 
....................    /********************/ 
....................    /* Set Filter       */ 
....................    /********************/ 
....................    filter = 0x3 << 2; 
09E20:  MOVLW  0C
09E22:  MOVLB  7
09E24:  MOVWF  xAB
....................    //filter = 0x5 << 2; 
....................     
....................    //Set filter values for temperature and pressure 
....................    Write_Byte(BME680_SPI_CONFIG, filter ); //BME680_SPI_CONFIG 
09E26:  MOVLW  75
09E28:  MOVLB  8
09E2A:  MOVWF  x18
09E2C:  MOVFF  7AB,819
09E30:  MOVLB  0
09E32:  CALL   31D0
....................  
.................... #ifdef DEBUG 
....................    //Read values of filter register after writing 
....................    Read_Byte(0x75); //BME680_SPI_CONFIG 
.................... #endif    
....................     
.................... #if 0 
.................... /* Enable Gas Measurment and Heater Set-Point Index */ 
....................    run_gas = 0x1 << 4; 
....................    nb_conv = 0x1; 
....................    ctrl_gas = run_gas | nb_conv; 
....................     
....................    //Read values of run_gas register before writing 
....................    Read_Byte(BME680_SPI_CTRL_GAS_1); 
....................     
....................    //Set the enable bit for gas measurements 
....................    Write_Byte(BME680_SPI_CTRL_GAS_1, ctrl_gas );   
....................  
....................    //Read values of run_gas register after writing 
....................    Read_Byte(BME680_SPI_CTRL_GAS_1); 
....................     
.................... /* Set heat-on time */ 
....................  
....................    //Read values of gas wait register before writing 
....................    Read_Byte(BME680_SPI_GAS_WAIT); 
....................     
....................    //Set the time to wait for heating 
....................    Write_Byte(BME680_SPI_GAS_WAIT, 0x59 );   
....................  
....................    //Read values of gas_wait register after writing 
....................    Read_Byte(BME680_SPI_GAS_WAIT); 
....................     
.................... /* Set hot plate temperature setting res_heat_x */ 
.................... /* first compute the value of the destination register */ 
....................    par_g1 = 0xED; 
....................    par_g2 = 0xEB; 
....................    par_g3 = 0xEE; 
....................    res 
....................    var1 = (((int32_t)amb_temp * par_g3) / 10) << 8; 
....................    var2 = (par_g1 + 784) * (((((par_g2 + 154009) * target_temp * 5) / 100) + 3276800) / 10); 
....................    var3 = var1 + (var2 >> 1); 
....................    var4 = (var3 / (res_heat_range + 4)); 
....................    var5 = (131 * res_heat_val) + 65536; 
....................    res_heat_x100 = (int32_t)(((var4 / var5) - 250) * 34); 
....................    res_heat_x = (uint8_t)((res_heat_x100 + 50) / 100); 
....................     
....................    //Read values of res_heat register before writing 
....................    Read_Byte(BME680_SPI_RES_HEAT_X); 
....................     
....................    //Set the target temperature for the hot plate 
....................    Write_Byte(BME680_SPI_RES_HEAT_X, 0x59 );   
....................  
....................    //Read values of res_heat register after writing 
....................    Read_Byte(BME680_SPI_RES_HEAT_X); 
....................    
.................... #endif    
....................  
....................    /* Fset mode to force mode*/ 
....................    //Read values of ctrl_meas register before writing 
....................    value = Read_Byte(BME680_SPI_CTRL); //0x74 
09E36:  MOVLW  74
09E38:  MOVLB  8
09E3A:  MOVWF  x1B
09E3C:  MOVLB  0
09E3E:  CALL   3222
09E42:  MOVFF  01,7AC
....................     
....................    //Set the mode to force mode 
....................    Write_Byte(BME680_SPI_CTRL, value + 0x1 ); //0x74   
09E46:  MOVLW  01
09E48:  MOVLB  7
09E4A:  ADDWF  xAC,W
09E4C:  MOVLB  8
09E4E:  MOVWF  x12
09E50:  MOVLW  74
09E52:  MOVWF  x18
09E54:  MOVFF  812,819
09E58:  MOVLB  0
09E5A:  CALL   31D0
....................  
.................... #ifdef DEBUG 
....................    //Read values of ctrl_meas register after writing 
....................    temp = Read_Byte(0x74); //BME680_SPI_CTRL 
....................     
....................    //retreive raw data output 
....................    fprintf(STDOUT, "***************************************************************************\r\n"); 
....................    fprintf(STDOUT, "***************    Capture Calibration Coefficants  ***********************\r\n"); 
....................    fprintf(STDOUT, "***************************************************************************\r\n"); 
.................... #endif 
....................  
....................    if( dev->intf == BME680_SPI_INTF ) 
09E5E:  MOVLW  02
09E60:  MOVLB  7
09E62:  ADDWF  x01,W
09E64:  MOVWF  01
09E66:  MOVLW  00
09E68:  ADDWFC x02,W
09E6A:  MOVWF  03
09E6C:  MOVFF  01,FE9
09E70:  MOVWF  FEA
09E72:  BTFSC  FEF.0
09E74:  BRA    9EA4
....................    { 
....................       rslt = set_mem_page( 0x50, dev ); 
09E76:  MOVLW  50
09E78:  MOVLB  8
09E7A:  MOVWF  x12
09E7C:  MOVFF  702,814
09E80:  MOVFF  701,813
09E84:  MOVLB  0
09E86:  CALL   32CC
09E8A:  MOVFF  01,7D1
....................        
....................       if( rslt != BME680_OK )  
09E8E:  MOVLB  7
09E90:  MOVF   xD1,F
09E92:  BZ    9EA4
....................          fprintf(STDOUT, " Failed set mem page xxxx \r\n\r\n"); 
09E94:  MOVLW  5A
09E96:  MOVWF  FF6
09E98:  MOVLW  1A
09E9A:  MOVWF  FF7
09E9C:  MOVLB  0
09E9E:  CALL   2CA0
09EA2:  MOVLB  7
....................    } 
....................     
....................    /**************************************/ 
....................    /* Set up Calib Temperature data t1-t3*/ 
....................    /**************************************/ 
....................    _T1 = ( Read_Byte(0xEA) << 8 ); 
09EA4:  MOVLW  EA
09EA6:  MOVLB  8
09EA8:  MOVWF  x1B
09EAA:  MOVLB  0
09EAC:  CALL   3222
09EB0:  MOVFF  01,744
09EB4:  MOVLB  7
09EB6:  CLRF   x43
09EB8:  CLRF   x45
09EBA:  CLRF   x46
....................    _T1 |= Read_Byte(0xE9); 
09EBC:  MOVLW  E9
09EBE:  MOVLB  8
09EC0:  MOVWF  x1B
09EC2:  MOVLB  0
09EC4:  CALL   3222
09EC8:  MOVF   01,W
09ECA:  MOVLB  7
09ECC:  IORWF  x43,F
....................    dev->calib.par_t1 = _T1; 
09ECE:  MOVLW  12
09ED0:  ADDWF  x01,W
09ED2:  MOVWF  FE9
09ED4:  MOVLW  00
09ED6:  ADDWFC x02,W
09ED8:  MOVWF  FEA
09EDA:  MOVFF  743,FEF
09EDE:  MOVFF  744,FEC
....................  
....................    _T2 = ( Read_Byte(0x8B) << 8 ); 
09EE2:  MOVLW  8B
09EE4:  MOVLB  8
09EE6:  MOVWF  x1B
09EE8:  MOVLB  0
09EEA:  CALL   3222
09EEE:  MOVFF  01,748
09EF2:  MOVLB  7
09EF4:  CLRF   x47
09EF6:  CLRF   x49
09EF8:  CLRF   x4A
....................    _T2 |= Read_Byte(0x8A); 
09EFA:  MOVLW  8A
09EFC:  MOVLB  8
09EFE:  MOVWF  x1B
09F00:  MOVLB  0
09F02:  CALL   3222
09F06:  MOVF   01,W
09F08:  MOVLB  7
09F0A:  IORWF  x47,F
....................    dev->calib.par_t2 = _T2; 
09F0C:  MOVLW  14
09F0E:  ADDWF  x01,W
09F10:  MOVWF  FE9
09F12:  MOVLW  00
09F14:  ADDWFC x02,W
09F16:  MOVWF  FEA
09F18:  MOVFF  748,FEC
09F1C:  MOVF   FED,F
09F1E:  MOVFF  747,FEF
....................        
....................    _T3 = Read_Byte(0x8C); 
09F22:  MOVLW  8C
09F24:  MOVLB  8
09F26:  MOVWF  x1B
09F28:  MOVLB  0
09F2A:  CALL   3222
09F2E:  MOVLB  7
09F30:  CLRF   x4E
09F32:  CLRF   x4D
09F34:  CLRF   x4C
09F36:  MOVFF  01,74B
....................    dev->calib.par_t3 = _T3; 
09F3A:  MOVLW  16
09F3C:  ADDWF  x01,W
09F3E:  MOVWF  FE9
09F40:  MOVLW  00
09F42:  ADDWFC x02,W
09F44:  MOVWF  FEA
09F46:  MOVFF  74B,FEF
....................     
....................    /************************************/ 
....................    /* Set up Calib Pressure data p1-p10*/ 
....................    /************************************/ 
....................        
....................    _P1 = ( Read_Byte(0x8F) << 8 ); 
09F4A:  MOVLW  8F
09F4C:  MOVLB  8
09F4E:  MOVWF  x1B
09F50:  MOVLB  0
09F52:  CALL   3222
09F56:  MOVFF  01,774
09F5A:  MOVLB  7
09F5C:  CLRF   x73
09F5E:  CLRF   x75
09F60:  CLRF   x76
....................    _P1 |= Read_Byte(0x8E); 
09F62:  MOVLW  8E
09F64:  MOVLB  8
09F66:  MOVWF  x1B
09F68:  MOVLB  0
09F6A:  CALL   3222
09F6E:  MOVF   01,W
09F70:  MOVLB  7
09F72:  IORWF  x73,F
....................    //_P1 = 0xFFFF0000 | _P1; 
....................    dev->calib.par_p1 = _P1; 
09F74:  MOVLW  17
09F76:  ADDWF  x01,W
09F78:  MOVWF  FE9
09F7A:  MOVLW  00
09F7C:  ADDWFC x02,W
09F7E:  MOVWF  FEA
09F80:  MOVFF  773,FEF
09F84:  MOVFF  774,FEC
....................  
....................    _P2 = ( Read_Byte(0x91) << 8 ); 
09F88:  MOVLW  91
09F8A:  MOVLB  8
09F8C:  MOVWF  x1B
09F8E:  MOVLB  0
09F90:  CALL   3222
09F94:  MOVFF  01,778
09F98:  MOVLB  7
09F9A:  CLRF   x77
09F9C:  CLRF   x79
09F9E:  CLRF   x7A
....................    _P2 |= Read_Byte(0x90); 
09FA0:  MOVLW  90
09FA2:  MOVLB  8
09FA4:  MOVWF  x1B
09FA6:  MOVLB  0
09FA8:  CALL   3222
09FAC:  MOVF   01,W
09FAE:  MOVLB  7
09FB0:  IORWF  x77,F
....................    _P2 = 0xFFFF0000 | _P2; 
09FB2:  MOVLW  FF
09FB4:  IORWF  x79,F
09FB6:  IORWF  x7A,F
....................    dev->calib.par_p2 = _P2; 
09FB8:  MOVLW  19
09FBA:  ADDWF  x01,W
09FBC:  MOVWF  FE9
09FBE:  MOVLW  00
09FC0:  ADDWFC x02,W
09FC2:  MOVWF  FEA
09FC4:  MOVFF  778,FEC
09FC8:  MOVF   FED,F
09FCA:  MOVFF  777,FEF
....................     
....................    _P3 = Read_Byte(0x92); 
09FCE:  MOVLW  92
09FD0:  MOVLB  8
09FD2:  MOVWF  x1B
09FD4:  MOVLB  0
09FD6:  CALL   3222
09FDA:  MOVFF  01,78F
09FDE:  CLRF   01
09FE0:  CLRF   02
09FE2:  CLRF   03
09FE4:  MOVFF  03,792
09FE8:  MOVFF  02,791
09FEC:  MOVFF  01,790
....................    dev->calib.par_p3 = _P3; 
09FF0:  MOVLW  1B
09FF2:  MOVLB  7
09FF4:  ADDWF  x01,W
09FF6:  MOVWF  FE9
09FF8:  MOVLW  00
09FFA:  ADDWFC x02,W
09FFC:  MOVWF  FEA
09FFE:  MOVFF  78F,FEF
....................  
....................    _P4 = ( Read_Byte(0x95) << 8 ); 
0A002:  MOVLW  95
0A004:  MOVLB  8
0A006:  MOVWF  x1B
0A008:  MOVLB  0
0A00A:  CALL   3222
0A00E:  MOVFF  01,77C
0A012:  MOVLB  7
0A014:  CLRF   x7B
0A016:  CLRF   x7D
0A018:  CLRF   x7E
....................    _P4 |= Read_Byte(0x94); 
0A01A:  MOVLW  94
0A01C:  MOVLB  8
0A01E:  MOVWF  x1B
0A020:  MOVLB  0
0A022:  CALL   3222
0A026:  MOVF   01,W
0A028:  MOVLB  7
0A02A:  IORWF  x7B,F
....................    //_P4 = 0xFFFF0000 | _P4; 
....................    dev->calib.par_p4 = _P4; 
0A02C:  MOVLW  1C
0A02E:  ADDWF  x01,W
0A030:  MOVWF  FE9
0A032:  MOVLW  00
0A034:  ADDWFC x02,W
0A036:  MOVWF  FEA
0A038:  MOVFF  77C,FEC
0A03C:  MOVF   FED,F
0A03E:  MOVFF  77B,FEF
....................  
....................    _P5 = ( Read_Byte(0x97) << 8 ); 
0A042:  MOVLW  97
0A044:  MOVLB  8
0A046:  MOVWF  x1B
0A048:  MOVLB  0
0A04A:  CALL   3222
0A04E:  MOVFF  01,788
0A052:  MOVLB  7
0A054:  CLRF   x87
0A056:  CLRF   x89
0A058:  CLRF   x8A
....................    _P5 |=  Read_Byte(0x96); 
0A05A:  MOVLW  96
0A05C:  MOVLB  8
0A05E:  MOVWF  x1B
0A060:  MOVLB  0
0A062:  CALL   3222
0A066:  MOVF   01,W
0A068:  MOVLB  7
0A06A:  IORWF  x87,F
....................    _P5 = 0xFFFF0000 | _P5; 
0A06C:  MOVLW  FF
0A06E:  IORWF  x89,F
0A070:  IORWF  x8A,F
....................    dev->calib.par_p5 = _P5; 
0A072:  MOVLW  1E
0A074:  ADDWF  x01,W
0A076:  MOVWF  FE9
0A078:  MOVLW  00
0A07A:  ADDWFC x02,W
0A07C:  MOVWF  FEA
0A07E:  MOVFF  788,FEC
0A082:  MOVF   FED,F
0A084:  MOVFF  787,FEF
....................     
....................    _P6 = Read_Byte(0x99); 
0A088:  MOVLW  99
0A08A:  MOVLB  8
0A08C:  MOVWF  x1B
0A08E:  MOVLB  0
0A090:  CALL   3222
0A094:  MOVFF  01,793
0A098:  CLRF   01
0A09A:  CLRF   02
0A09C:  CLRF   03
0A09E:  MOVFF  03,796
0A0A2:  MOVFF  02,795
0A0A6:  MOVFF  01,794
....................    dev->calib.par_p6 = _P6; 
0A0AA:  MOVLW  20
0A0AC:  MOVLB  7
0A0AE:  ADDWF  x01,W
0A0B0:  MOVWF  FE9
0A0B2:  MOVLW  00
0A0B4:  ADDWFC x02,W
0A0B6:  MOVWF  FEA
0A0B8:  MOVFF  793,FEF
....................  
....................     
....................    _P7 = Read_Byte(0x98); 
0A0BC:  MOVLW  98
0A0BE:  MOVLB  8
0A0C0:  MOVWF  x1B
0A0C2:  MOVLB  0
0A0C4:  CALL   3222
0A0C8:  MOVFF  01,797
0A0CC:  CLRF   01
0A0CE:  CLRF   02
0A0D0:  CLRF   03
0A0D2:  MOVFF  03,79A
0A0D6:  MOVFF  02,799
0A0DA:  MOVFF  01,798
....................    dev->calib.par_p7 = _P7; 
0A0DE:  MOVLW  21
0A0E0:  MOVLB  7
0A0E2:  ADDWF  x01,W
0A0E4:  MOVWF  FE9
0A0E6:  MOVLW  00
0A0E8:  ADDWFC x02,W
0A0EA:  MOVWF  FEA
0A0EC:  MOVFF  797,FEF
....................  
....................    _P8 = ( Read_Byte(0x9D) << 8 ); 
0A0F0:  MOVLW  9D
0A0F2:  MOVLB  8
0A0F4:  MOVWF  x1B
0A0F6:  MOVLB  0
0A0F8:  CALL   3222
0A0FC:  MOVFF  01,780
0A100:  MOVLB  7
0A102:  CLRF   x7F
0A104:  CLRF   x81
0A106:  CLRF   x82
....................    _P8 |= Read_Byte(0x9C); 
0A108:  MOVLW  9C
0A10A:  MOVLB  8
0A10C:  MOVWF  x1B
0A10E:  MOVLB  0
0A110:  CALL   3222
0A114:  MOVF   01,W
0A116:  MOVLB  7
0A118:  IORWF  x7F,F
....................    _P8 = 0xFFFF0000 | _P8; 
0A11A:  MOVLW  FF
0A11C:  IORWF  x81,F
0A11E:  IORWF  x82,F
....................    dev->calib.par_p8 = _P8; 
0A120:  MOVLW  22
0A122:  ADDWF  x01,W
0A124:  MOVWF  FE9
0A126:  MOVLW  00
0A128:  ADDWFC x02,W
0A12A:  MOVWF  FEA
0A12C:  MOVFF  780,FEC
0A130:  MOVF   FED,F
0A132:  MOVFF  77F,FEF
....................  
....................    _P9 = ( Read_Byte(0x9F) << 8 ); 
0A136:  MOVLW  9F
0A138:  MOVLB  8
0A13A:  MOVWF  x1B
0A13C:  MOVLB  0
0A13E:  CALL   3222
0A142:  MOVFF  01,784
0A146:  MOVLB  7
0A148:  CLRF   x83
0A14A:  CLRF   x85
0A14C:  CLRF   x86
....................    _P9 |= Read_Byte(0x9E); 
0A14E:  MOVLW  9E
0A150:  MOVLB  8
0A152:  MOVWF  x1B
0A154:  MOVLB  0
0A156:  CALL   3222
0A15A:  MOVF   01,W
0A15C:  MOVLB  7
0A15E:  IORWF  x83,F
....................    _P9 = 0xFFFF0000 | _P9; 
0A160:  MOVLW  FF
0A162:  IORWF  x85,F
0A164:  IORWF  x86,F
....................    dev->calib.par_p9 = _P9; 
0A166:  MOVLW  24
0A168:  ADDWF  x01,W
0A16A:  MOVWF  FE9
0A16C:  MOVLW  00
0A16E:  ADDWFC x02,W
0A170:  MOVWF  FEA
0A172:  MOVFF  784,FEC
0A176:  MOVF   FED,F
0A178:  MOVFF  783,FEF
....................  
....................    _P10 = Read_Byte(0xA0); 
0A17C:  MOVLW  A0
0A17E:  MOVLB  8
0A180:  MOVWF  x1B
0A182:  MOVLB  0
0A184:  CALL   3222
0A188:  MOVLB  7
0A18A:  CLRF   x8E
0A18C:  CLRF   x8D
0A18E:  CLRF   x8C
0A190:  MOVFF  01,78B
....................    _P10 = 0xFFFF0000 | _P10; 
0A194:  MOVLW  FF
0A196:  IORWF  x8D,F
0A198:  IORWF  x8E,F
....................    dev->calib.par_p10 = _P10; 
0A19A:  MOVLW  26
0A19C:  ADDWF  x01,W
0A19E:  MOVWF  FE9
0A1A0:  MOVLW  00
0A1A2:  ADDWFC x02,W
0A1A4:  MOVWF  FEA
0A1A6:  MOVFF  78B,FEF
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "**********   _T1 = %Lu\r\n\r\n", _T1); 
....................    fprintf(STDOUT, "**********   _T2 = %Lu\r\n\r\n", _T2); 
....................    fprintf(STDOUT, "**********   _T3 = %Lu\r\n\r\n", _T3); 
....................    fprintf(STDOUT, "**********   _P1 = %Lu\r\n\r\n", _P1); 
....................    fprintf(STDOUT, "**********   _P2 = %Lu\r\n\r\n", _P2); 
....................    fprintf(STDOUT, "**********   _P3 = %Lu\r\n\r\n", _P3); 
....................    fprintf(STDOUT, "**********   _P4 = %Lu\r\n\r\n", _P4); 
....................    fprintf(STDOUT, "**********   _P5 = %Lu\r\n\r\n", _P5); 
....................    fprintf(STDOUT, "**********   _P6 = %Lu\r\n\r\n", _P6); 
....................    fprintf(STDOUT, "**********   _P7 = %Lu\r\n\r\n", _P7); 
....................    fprintf(STDOUT, "**********   _P8 = %Lu\r\n\r\n", _P8); 
....................    fprintf(STDOUT, "**********   _P9 = %Lu\r\n\r\n", _P9); 
....................    fprintf(STDOUT, "**********   _P10 = %Lu\r\n\r\n", _P10); 
.................... #endif 
....................  
....................  
.................... #ifdef HUMUDITY_ON 
....................    /***********************************/ 
....................    /* Set up Calib Humidity data h1-h7*/ 
....................    /***********************************/ 
....................    if( getHumidity ) 
....................    { 
....................       temp16 =  ( Read_Byte(0xE3) << 8 ); 
....................       temp16 |=  Read_Byte(0xE2); 
....................       temp16 = ( temp16 | temp1 ) >> 4; 
....................        
....................       dev->calib.par_h1 = temp16; 
....................       dev->calib.par_h1 = 638; 
....................  
....................       temp16 =  ( Read_Byte(0xE1) << 8); 
....................       temp16 |=  Read_Byte(0xE2); 
....................       temp16 = ( temp16 | temp1 ) >> 4; 
....................       dev->calib.par_h2 = temp16; 
....................       dev->calib.par_h2 = 1036; 
....................     
....................       temp = Read_Byte(0xE4); 
....................       dev->calib.par_h3 = temp; 
....................       dev->calib.par_h3 = 0; 
....................        
....................       temp = Read_Byte(0xE5); 
....................       dev->calib.par_h4 = temp; 
....................       dev->calib.par_h4 = 45;       
....................        
....................       temp = Read_Byte(0xE6); 
....................       dev->calib.par_h5 = temp; 
....................       dev->calib.par_h5 = 20;       
....................        
....................       temp = Read_Byte(0xE7); 
....................       dev->calib.par_h6 = temp; 
....................       dev->calib.par_h6 = 120; 
....................        
....................       temp = Read_Byte(0xE8); 
....................       dev->calib.par_h7 = temp;  
....................       dev->calib.par_h7 = -100; 
....................    } 
....................        
....................  #endif 
....................   
....................  #ifdef GAS_ON 
....................        /******************************/ 
....................        /* Set up Calib Gas data g1-g3*/ 
....................        /******************************/ 
....................         
.................... //      temp = Read_Byte(0xED); 
.................... //      dev->calib.par_gh1 = temp; 
....................          
.................... //      temp16 = ( Read_Byte(0xEC) << 8 ); 
.................... //      temp16 |= Read_Byte(0xEB); 
.................... //      dev->calib.par_gh2 = temp16; 
....................  
.................... //      temp = Read_Byte(0xEE); 
.................... //      dev->calib.par_gh3 = temp; 
.................... #endif 
....................  
....................  
....................    rslt = set_mem_page( 0x1, dev ); 
0A1AA:  MOVLW  01
0A1AC:  MOVLB  8
0A1AE:  MOVWF  x12
0A1B0:  MOVFF  702,814
0A1B4:  MOVFF  701,813
0A1B8:  MOVLB  0
0A1BA:  CALL   32CC
0A1BE:  MOVFF  01,7D1
....................        
....................    if( rslt != BME680_OK )  
0A1C2:  MOVLB  7
0A1C4:  MOVF   xD1,F
0A1C6:  BZ    A1D8
....................       fprintf(STDOUT, " Failed set mem page \r\n"); 
0A1C8:  MOVLW  7A
0A1CA:  MOVWF  FF6
0A1CC:  MOVLW  1A
0A1CE:  MOVWF  FF7
0A1D0:  MOVLB  0
0A1D2:  CALL   2CA0
0A1D6:  MOVLB  7
....................   
....................    //Read values of ctrl_meas register after writing 
....................    //Read values of ctrl_meas register before writing 
....................    delay_ms(100); 
0A1D8:  MOVLW  64
0A1DA:  MOVLB  8
0A1DC:  MOVWF  x18
0A1DE:  MOVLB  0
0A1E0:  CALL   2D2E
....................  
.................... #ifdef DEBUG 
....................    value = Read_Byte(BME680_SPI_CTRL); 
....................  
....................    //retrieve raw data output 
....................    fprintf(STDOUT, "***************************************************************************\r\n"); 
....................    fprintf(STDOUT, "********************    Raw Data Output      ******************************\r\n"); 
....................    fprintf(STDOUT, "***************************************************************************\r\n"); 
.................... #endif    
....................     
....................    count = 0; 
0A1E4:  MOVLB  7
0A1E6:  CLRF   xD0
0A1E8:  CLRF   xCF
0A1EA:  CLRF   xCE
0A1EC:  CLRF   xCD
....................    timer_previous = get_ticks(); 
0A1EE:  MOVLB  0
0A1F0:  CALL   43C2
0A1F4:  MOVFF  03,7A6
0A1F8:  MOVFF  02,7A5
0A1FC:  MOVFF  01,7A4
0A200:  MOVFF  00,7A3
....................  
....................    while(TRUE) 
....................    { 
....................       //Set the mode to force mode 
....................       Write_Byte(BME680_SPI_CTRL, value+ 0x1 );  //0x74 
0A204:  MOVLW  01
0A206:  MOVLB  7
0A208:  ADDWF  xAC,W
0A20A:  MOVLB  8
0A20C:  MOVWF  x12
0A20E:  MOVLW  74
0A210:  MOVWF  x18
0A212:  MOVFF  812,819
0A216:  MOVLB  0
0A218:  CALL   31D0
....................  
.................... #ifdef DEBUG 
....................       //Read values of ctrl_meas register after writing 
....................       temp = Read_Byte(BME680_SPI_CTRL); //0x74 
.................... #endif 
....................  
....................       //********************************************************************************// 
....................       //********************************************************************************// 
....................       //***************************    Raw Data Output   *******************************// 
....................       //********************************************************************************// 
....................  
....................       //**************************************// 
....................       //           Read temperature           // 
....................       //**************************************// 
....................       temperatureXLSB = Read_Byte(0x24); //BME680_SPI_TEMP_XLSB 
0A21C:  MOVLW  24
0A21E:  MOVLB  8
0A220:  MOVWF  x1B
0A222:  MOVLB  0
0A224:  CALL   3222
0A228:  MOVLB  7
0A22A:  CLRF   x5A
0A22C:  CLRF   x59
0A22E:  CLRF   x58
0A230:  MOVFF  01,757
....................       temperatureLSB = Read_Byte(0x23);  //BME680_SPI_TEMP_LSB 
0A234:  MOVLW  23
0A236:  MOVLB  8
0A238:  MOVWF  x1B
0A23A:  MOVLB  0
0A23C:  CALL   3222
0A240:  MOVLB  7
0A242:  CLRF   x5E
0A244:  CLRF   x5D
0A246:  CLRF   x5C
0A248:  MOVFF  01,75B
....................       temperatureMSB = Read_Byte(0x22);  //BME680_SPI_TEMP_MSB 
0A24C:  MOVLW  22
0A24E:  MOVLB  8
0A250:  MOVWF  x1B
0A252:  MOVLB  0
0A254:  CALL   3222
0A258:  MOVLB  7
0A25A:  CLRF   x62
0A25C:  CLRF   x61
0A25E:  CLRF   x60
0A260:  MOVFF  01,75F
....................       temperature_received = ( (temperatureMSB << 12 ) | (temperatureLSB << 4 ) | (temperatureXLSB >> 4 ) ); 
0A264:  MOVLB  8
0A266:  CLRF   x13
0A268:  MOVLB  7
0A26A:  RLCF   x5F,W
0A26C:  MOVLB  8
0A26E:  MOVWF  x14
0A270:  MOVLB  7
0A272:  RLCF   x60,W
0A274:  MOVLB  8
0A276:  MOVWF  x15
0A278:  MOVLB  7
0A27A:  RLCF   x61,W
0A27C:  MOVLB  8
0A27E:  MOVWF  x16
0A280:  RLCF   x14,F
0A282:  RLCF   x15,F
0A284:  RLCF   x16,F
0A286:  RLCF   x14,F
0A288:  RLCF   x15,F
0A28A:  RLCF   x16,F
0A28C:  RLCF   x14,F
0A28E:  RLCF   x15,F
0A290:  RLCF   x16,F
0A292:  MOVLW  F0
0A294:  ANDWF  x14,F
0A296:  MOVLB  7
0A298:  RLCF   x5B,W
0A29A:  MOVWF  00
0A29C:  RLCF   x5C,W
0A29E:  MOVWF  01
0A2A0:  RLCF   x5D,W
0A2A2:  MOVWF  02
0A2A4:  RLCF   x5E,W
0A2A6:  MOVWF  03
0A2A8:  RLCF   00,F
0A2AA:  RLCF   01,F
0A2AC:  RLCF   02,F
0A2AE:  RLCF   03,F
0A2B0:  RLCF   00,F
0A2B2:  RLCF   01,F
0A2B4:  RLCF   02,F
0A2B6:  RLCF   03,F
0A2B8:  RLCF   00,F
0A2BA:  RLCF   01,F
0A2BC:  RLCF   02,F
0A2BE:  RLCF   03,F
0A2C0:  MOVLW  F0
0A2C2:  ANDWF  00,F
0A2C4:  MOVF   00,W
0A2C6:  MOVLB  8
0A2C8:  IORWF  x13,F
0A2CA:  MOVF   01,W
0A2CC:  IORWF  x14,F
0A2CE:  MOVF   02,W
0A2D0:  IORWF  x15,F
0A2D2:  MOVF   03,W
0A2D4:  IORWF  x16,F
0A2D6:  MOVLB  7
0A2D8:  RRCF   x5A,W
0A2DA:  MOVWF  03
0A2DC:  RRCF   x59,W
0A2DE:  MOVWF  02
0A2E0:  RRCF   x58,W
0A2E2:  MOVWF  01
0A2E4:  RRCF   x57,W
0A2E6:  MOVWF  00
0A2E8:  RRCF   03,F
0A2EA:  RRCF   02,F
0A2EC:  RRCF   01,F
0A2EE:  RRCF   00,F
0A2F0:  RRCF   03,F
0A2F2:  RRCF   02,F
0A2F4:  RRCF   01,F
0A2F6:  RRCF   00,F
0A2F8:  RRCF   03,F
0A2FA:  RRCF   02,F
0A2FC:  RRCF   01,F
0A2FE:  RRCF   00,F
0A300:  MOVLW  0F
0A302:  ANDWF  03,F
0A304:  MOVF   00,W
0A306:  MOVLB  8
0A308:  IORWF  x13,W
0A30A:  MOVLB  7
0A30C:  MOVWF  x2F
0A30E:  MOVF   01,W
0A310:  MOVLB  8
0A312:  IORWF  x14,W
0A314:  MOVLB  7
0A316:  MOVWF  x30
0A318:  MOVF   02,W
0A31A:  MOVLB  8
0A31C:  IORWF  x15,W
0A31E:  MOVLB  7
0A320:  MOVWF  x31
0A322:  MOVF   03,W
0A324:  MOVLB  8
0A326:  IORWF  x16,W
0A328:  MOVLB  7
0A32A:  MOVWF  x32
....................     
....................       //**************************************// 
....................       //           Read Pressure              // 
....................       //**************************************// 
....................       pressureXLSB = Read_Byte(0x21); //BME680_SPI_PRESS_XLSB 
0A32C:  MOVLW  21
0A32E:  MOVLB  8
0A330:  MOVWF  x1B
0A332:  MOVLB  0
0A334:  CALL   3222
0A338:  MOVLB  7
0A33A:  CLRF   x66
0A33C:  CLRF   x65
0A33E:  CLRF   x64
0A340:  MOVFF  01,763
....................       pressureLSB = Read_Byte(0x20);  //BME680_SPI_PRESS_LSB 
0A344:  MOVLW  20
0A346:  MOVLB  8
0A348:  MOVWF  x1B
0A34A:  MOVLB  0
0A34C:  CALL   3222
0A350:  MOVLB  7
0A352:  CLRF   x6A
0A354:  CLRF   x69
0A356:  CLRF   x68
0A358:  MOVFF  01,767
....................       pressureMSB = Read_Byte(0x1f);  //BME680_SPI_PRESS_MSB 
0A35C:  MOVLW  1F
0A35E:  MOVLB  8
0A360:  MOVWF  x1B
0A362:  MOVLB  0
0A364:  CALL   3222
0A368:  MOVLB  7
0A36A:  CLRF   x6E
0A36C:  CLRF   x6D
0A36E:  CLRF   x6C
0A370:  MOVFF  01,76B
....................       timeStamp1 = get_ticks(); 
0A374:  MOVLB  0
0A376:  CALL   43C2
0A37A:  MOVFF  03,722
0A37E:  MOVFF  02,721
0A382:  MOVFF  01,720
0A386:  MOVFF  00,71F
....................       pressure_received = ( (pressureMSB << 12 ) | (pressureLSB << 4 ) | (pressureXLSB >> 4 ) ); 
0A38A:  MOVLB  8
0A38C:  CLRF   x13
0A38E:  MOVLB  7
0A390:  RLCF   x6B,W
0A392:  MOVLB  8
0A394:  MOVWF  x14
0A396:  MOVLB  7
0A398:  RLCF   x6C,W
0A39A:  MOVLB  8
0A39C:  MOVWF  x15
0A39E:  MOVLB  7
0A3A0:  RLCF   x6D,W
0A3A2:  MOVLB  8
0A3A4:  MOVWF  x16
0A3A6:  RLCF   x14,F
0A3A8:  RLCF   x15,F
0A3AA:  RLCF   x16,F
0A3AC:  RLCF   x14,F
0A3AE:  RLCF   x15,F
0A3B0:  RLCF   x16,F
0A3B2:  RLCF   x14,F
0A3B4:  RLCF   x15,F
0A3B6:  RLCF   x16,F
0A3B8:  MOVLW  F0
0A3BA:  ANDWF  x14,F
0A3BC:  MOVLB  7
0A3BE:  RLCF   x67,W
0A3C0:  MOVWF  00
0A3C2:  RLCF   x68,W
0A3C4:  MOVWF  01
0A3C6:  RLCF   x69,W
0A3C8:  MOVWF  02
0A3CA:  RLCF   x6A,W
0A3CC:  MOVWF  03
0A3CE:  RLCF   00,F
0A3D0:  RLCF   01,F
0A3D2:  RLCF   02,F
0A3D4:  RLCF   03,F
0A3D6:  RLCF   00,F
0A3D8:  RLCF   01,F
0A3DA:  RLCF   02,F
0A3DC:  RLCF   03,F
0A3DE:  RLCF   00,F
0A3E0:  RLCF   01,F
0A3E2:  RLCF   02,F
0A3E4:  RLCF   03,F
0A3E6:  MOVLW  F0
0A3E8:  ANDWF  00,F
0A3EA:  MOVF   00,W
0A3EC:  MOVLB  8
0A3EE:  IORWF  x13,F
0A3F0:  MOVF   01,W
0A3F2:  IORWF  x14,F
0A3F4:  MOVF   02,W
0A3F6:  IORWF  x15,F
0A3F8:  MOVF   03,W
0A3FA:  IORWF  x16,F
0A3FC:  MOVLB  7
0A3FE:  RRCF   x66,W
0A400:  MOVWF  03
0A402:  RRCF   x65,W
0A404:  MOVWF  02
0A406:  RRCF   x64,W
0A408:  MOVWF  01
0A40A:  RRCF   x63,W
0A40C:  MOVWF  00
0A40E:  RRCF   03,F
0A410:  RRCF   02,F
0A412:  RRCF   01,F
0A414:  RRCF   00,F
0A416:  RRCF   03,F
0A418:  RRCF   02,F
0A41A:  RRCF   01,F
0A41C:  RRCF   00,F
0A41E:  RRCF   03,F
0A420:  RRCF   02,F
0A422:  RRCF   01,F
0A424:  RRCF   00,F
0A426:  MOVLW  0F
0A428:  ANDWF  03,F
0A42A:  MOVF   00,W
0A42C:  MOVLB  8
0A42E:  IORWF  x13,W
0A430:  MOVLB  7
0A432:  MOVWF  x33
0A434:  MOVF   01,W
0A436:  MOVLB  8
0A438:  IORWF  x14,W
0A43A:  MOVLB  7
0A43C:  MOVWF  x34
0A43E:  MOVF   02,W
0A440:  MOVLB  8
0A442:  IORWF  x15,W
0A444:  MOVLB  7
0A446:  MOVWF  x35
0A448:  MOVF   03,W
0A44A:  MOVLB  8
0A44C:  IORWF  x16,W
0A44E:  MOVLB  7
0A450:  MOVWF  x36
....................  
....................     
.................... #ifdef HUMIDITY_AND_GAS_RESISTANCE    
....................       //**************************************// 
....................       //          Read Humidity               // 
....................       //**************************************// 
....................       humidityLSB = Read_Byte(BME680_SPI_HUM_LSB); 
....................       humidityMSB = Read_Byte(BME680_SPI_HUM_MSB); 
....................  
....................       fprintf(STDOUT, "**********   Humidity MSB_LSB = %02X %02X \r\n", humidityMSB, humidityLSB); 
....................       humidity_received = ( (humidityMSB << 8 ) | humidityLSB ); 
....................       fprintf(STDOUT, "**********   humidity_receive %08LX \r\n", humidity_received); 
....................     
....................       humidity_comp = calc_humidity( humidity_received, dev); 
....................       fprintf(STDOUT, "**********   Humidity %Lu %% \r\n\r\n", humidity_comp/1000); 
....................        
....................       //**************************************// 
....................       //          Read Gas resistance         // 
....................       //**************************************// 
....................       gas_resistance_LSB = Read_Byte(BME680_SPI_GAS_R_LSB); 
....................       gas_resistance_MSB = Read_Byte(BME680_SPI_GAS_R_MSB); 
....................  
....................       fprintf(STDOUT, "**********   Gas MSB_LSB = %02X %02X \r\n", gas_resistance_MSB, gas_resistance_LSB); 
....................       gas_received = ( (gas_resistance_MSB  << 8 ) | gas_resistance_LSB ); 
....................       fprintf(STDOUT, "**********   Gas_receive %08LX \r\n", gas_received); 
....................  
....................       gas_range = ( Read_Byte( BME680_FIELD0_ADDR + 14 ) & BME680_GAS_RANGE_MSK );   
....................       gas_comp = calc_gas_resistance( gas_received, gas_range, dev); 
....................       fprintf(STDOUT, "**********   Gas resistance %Lu Ohm \r\n\r\n", gas_comp); 
.................... #endif 
....................       //*************************************// 
....................       // Calculate temperature adjustment    // 
....................       //*************************************// 
....................       int32_t var1; 
....................       int32_t var2; 
....................       int32_t var3; 
.................... //      int16_t calc_temp; 
....................        
....................       var1 = ((int32_t)temperature_received>>3)-((int32_t)_T1<<1); 
0A452:  RRCF   x32,W
0A454:  MOVLB  8
0A456:  MOVWF  x16
0A458:  MOVLB  7
0A45A:  RRCF   x31,W
0A45C:  MOVLB  8
0A45E:  MOVWF  x15
0A460:  MOVLB  7
0A462:  RRCF   x30,W
0A464:  MOVLB  8
0A466:  MOVWF  x14
0A468:  MOVLB  7
0A46A:  RRCF   x2F,W
0A46C:  MOVLB  8
0A46E:  MOVWF  x13
0A470:  RRCF   x16,F
0A472:  RRCF   x15,F
0A474:  RRCF   x14,F
0A476:  RRCF   x13,F
0A478:  RRCF   x16,F
0A47A:  RRCF   x15,F
0A47C:  RRCF   x14,F
0A47E:  RRCF   x13,F
0A480:  MOVLW  1F
0A482:  ANDWF  x16,F
0A484:  BCF    FD8.0
0A486:  MOVLB  7
0A488:  RLCF   x43,W
0A48A:  MOVWF  00
0A48C:  RLCF   x44,W
0A48E:  MOVWF  01
0A490:  RLCF   x45,W
0A492:  MOVWF  02
0A494:  RLCF   x46,W
0A496:  MOVWF  03
0A498:  MOVF   00,W
0A49A:  MOVLB  8
0A49C:  SUBWF  x13,W
0A49E:  MOVWF  00
0A4A0:  MOVF   01,W
0A4A2:  SUBWFB x14,W
0A4A4:  MOVWF  01
0A4A6:  MOVF   02,W
0A4A8:  SUBWFB x15,W
0A4AA:  MOVWF  02
0A4AC:  MOVF   03,W
0A4AE:  SUBWFB x16,W
0A4B0:  MOVFF  FE8,7D5
0A4B4:  MOVFF  02,7D4
0A4B8:  MOVFF  01,7D3
0A4BC:  MOVFF  00,7D2
....................       var2 = (var1*(int32_t)_T2)>>11; 
0A4C0:  MOVFF  7D5,833
0A4C4:  MOVFF  7D4,832
0A4C8:  MOVFF  7D3,831
0A4CC:  MOVFF  7D2,830
0A4D0:  MOVFF  74A,837
0A4D4:  MOVFF  749,836
0A4D8:  MOVFF  748,835
0A4DC:  MOVFF  747,834
0A4E0:  MOVLB  0
0A4E2:  CALL   95AE
0A4E6:  MOVFF  03,815
0A4EA:  MOVFF  02,814
0A4EE:  MOVFF  01,813
0A4F2:  MOVFF  00,812
0A4F6:  CLRF   03
0A4F8:  MOVLB  8
0A4FA:  RRCF   x15,W
0A4FC:  MOVWF  02
0A4FE:  RRCF   x14,W
0A500:  MOVWF  01
0A502:  RRCF   x13,W
0A504:  MOVWF  00
0A506:  RRCF   02,F
0A508:  RRCF   01,F
0A50A:  RRCF   00,F
0A50C:  RRCF   02,F
0A50E:  RRCF   01,F
0A510:  RRCF   00,F
0A512:  MOVLW  1F
0A514:  ANDWF  02,F
0A516:  MOVFF  03,7D9
0A51A:  MOVFF  02,7D8
0A51E:  MOVFF  01,7D7
0A522:  MOVFF  00,7D6
....................       var3 = ((var1>>1)*(var1>>1))>>12; 
0A526:  BCF    FD8.0
0A528:  MOVLB  7
0A52A:  RRCF   xD5,W
0A52C:  MOVLB  8
0A52E:  MOVWF  x16
0A530:  MOVLB  7
0A532:  RRCF   xD4,W
0A534:  MOVLB  8
0A536:  MOVWF  x15
0A538:  MOVLB  7
0A53A:  RRCF   xD3,W
0A53C:  MOVLB  8
0A53E:  MOVWF  x14
0A540:  MOVLB  7
0A542:  RRCF   xD2,W
0A544:  MOVLB  8
0A546:  MOVWF  x13
0A548:  BCF    FD8.0
0A54A:  MOVLB  7
0A54C:  RRCF   xD5,W
0A54E:  MOVWF  03
0A550:  RRCF   xD4,W
0A552:  MOVWF  02
0A554:  RRCF   xD3,W
0A556:  MOVWF  01
0A558:  RRCF   xD2,W
0A55A:  MOVWF  00
0A55C:  MOVFF  03,81B
0A560:  MOVFF  02,81A
0A564:  MOVFF  01,819
0A568:  MOVFF  FE8,818
0A56C:  MOVFF  816,833
0A570:  MOVFF  815,832
0A574:  MOVFF  814,831
0A578:  MOVFF  813,830
0A57C:  MOVFF  03,837
0A580:  MOVFF  02,836
0A584:  MOVFF  01,835
0A588:  MOVFF  FE8,834
0A58C:  MOVLB  0
0A58E:  CALL   95AE
0A592:  MOVFF  03,816
0A596:  MOVFF  02,815
0A59A:  MOVFF  01,814
0A59E:  MOVFF  00,813
0A5A2:  CLRF   03
0A5A4:  MOVLB  8
0A5A6:  RRCF   x16,W
0A5A8:  MOVWF  02
0A5AA:  RRCF   x15,W
0A5AC:  MOVWF  01
0A5AE:  RRCF   x14,W
0A5B0:  MOVWF  00
0A5B2:  RRCF   02,F
0A5B4:  RRCF   01,F
0A5B6:  RRCF   00,F
0A5B8:  RRCF   02,F
0A5BA:  RRCF   01,F
0A5BC:  RRCF   00,F
0A5BE:  RRCF   02,F
0A5C0:  RRCF   01,F
0A5C2:  RRCF   00,F
0A5C4:  MOVLW  0F
0A5C6:  ANDWF  02,F
0A5C8:  MOVFF  03,7DD
0A5CC:  MOVFF  02,7DC
0A5D0:  MOVFF  01,7DB
0A5D4:  MOVFF  00,7DA
....................       var3 = ((var3)*((int32_t)_T3<<4))>>14; 
0A5D8:  MOVLB  7
0A5DA:  RLCF   x4B,W
0A5DC:  MOVWF  00
0A5DE:  RLCF   x4C,W
0A5E0:  MOVWF  01
0A5E2:  RLCF   x4D,W
0A5E4:  MOVWF  02
0A5E6:  RLCF   x4E,W
0A5E8:  MOVWF  03
0A5EA:  RLCF   00,F
0A5EC:  RLCF   01,F
0A5EE:  RLCF   02,F
0A5F0:  RLCF   03,F
0A5F2:  RLCF   00,F
0A5F4:  RLCF   01,F
0A5F6:  RLCF   02,F
0A5F8:  RLCF   03,F
0A5FA:  RLCF   00,F
0A5FC:  RLCF   01,F
0A5FE:  RLCF   02,F
0A600:  RLCF   03,F
0A602:  MOVLW  F0
0A604:  ANDWF  00,F
0A606:  MOVFF  03,816
0A60A:  MOVFF  02,815
0A60E:  MOVFF  01,814
0A612:  MOVFF  00,813
0A616:  MOVFF  7DD,833
0A61A:  MOVFF  7DC,832
0A61E:  MOVFF  7DB,831
0A622:  MOVFF  7DA,830
0A626:  MOVFF  03,837
0A62A:  MOVFF  02,836
0A62E:  MOVFF  01,835
0A632:  MOVFF  00,834
0A636:  MOVLB  0
0A638:  CALL   95AE
0A63C:  MOVFF  03,816
0A640:  MOVFF  02,815
0A644:  MOVFF  01,814
0A648:  MOVFF  00,813
0A64C:  CLRF   03
0A64E:  MOVLB  8
0A650:  RRCF   x16,W
0A652:  MOVWF  02
0A654:  RRCF   x15,W
0A656:  MOVWF  01
0A658:  RRCF   x14,W
0A65A:  MOVWF  00
0A65C:  RRCF   02,F
0A65E:  RRCF   01,F
0A660:  RRCF   00,F
0A662:  RRCF   02,F
0A664:  RRCF   01,F
0A666:  RRCF   00,F
0A668:  RRCF   02,F
0A66A:  RRCF   01,F
0A66C:  RRCF   00,F
0A66E:  RRCF   02,F
0A670:  RRCF   01,F
0A672:  RRCF   00,F
0A674:  RRCF   02,F
0A676:  RRCF   01,F
0A678:  RRCF   00,F
0A67A:  MOVLW  03
0A67C:  ANDWF  02,F
0A67E:  MOVFF  03,7DD
0A682:  MOVFF  02,7DC
0A686:  MOVFF  01,7DB
0A68A:  MOVFF  00,7DA
....................       _tfine  = (int32_t)(var2+var3); 
0A68E:  MOVLB  7
0A690:  MOVF   xDA,W
0A692:  ADDWF  xD6,W
0A694:  MOVWF  00
0A696:  MOVF   xDB,W
0A698:  ADDWFC xD7,W
0A69A:  MOVWF  01
0A69C:  MOVF   xDC,W
0A69E:  ADDWFC xD8,W
0A6A0:  MOVWF  02
0A6A2:  MOVF   xDD,W
0A6A4:  ADDWFC xD9,W
0A6A6:  MOVWF  x52
0A6A8:  MOVFF  02,751
0A6AC:  MOVFF  01,750
0A6B0:  MOVFF  00,74F
....................       _Temperature = (int16_t)(((_tfine*5)+128)>>8); 
0A6B4:  MOVFF  752,833
0A6B8:  MOVFF  751,832
0A6BC:  MOVFF  750,831
0A6C0:  MOVFF  74F,830
0A6C4:  MOVLB  8
0A6C6:  CLRF   x37
0A6C8:  CLRF   x36
0A6CA:  CLRF   x35
0A6CC:  MOVLW  05
0A6CE:  MOVWF  x34
0A6D0:  MOVLB  0
0A6D2:  CALL   95AE
0A6D6:  MOVFF  03,815
0A6DA:  MOVFF  02,814
0A6DE:  MOVFF  01,813
0A6E2:  MOVFF  00,812
0A6E6:  MOVLW  80
0A6E8:  MOVLB  8
0A6EA:  ADDWF  x12,F
0A6EC:  MOVLW  00
0A6EE:  ADDWFC x13,F
0A6F0:  ADDWFC x14,F
0A6F2:  ADDWFC x15,F
0A6F4:  MOVFF  813,76F
0A6F8:  MOVFF  814,770
0A6FC:  MOVFF  815,02
0A700:  CLRF   03
0A702:  CLRF   02
0A704:  CLRF   03
0A706:  MOVFF  03,772
0A70A:  MOVFF  02,771
....................        
....................        
.................... #ifdef DEBUG      
....................       //fprintf(STDOUT, "**********   var1 = %Lu\r\n\r\n", var1); 
....................       //fprintf(STDOUT, "**********   var2 = %Lu\r\n\r\n", var2); 
....................       //fprintf(STDOUT, "**********   var3 = %Lu\r\n\r\n", var3); 
....................       //fprintf(STDOUT, "**********   t_fine = %Lu\r\n\r\n", _tfine); 
....................       fprintf(STDOUT, "*   Temperature %.2f Celsius \r\n\r\n", (float)_Temperature / 100); 
.................... #endif 
....................  
....................       //Verify temperature calculation matches BME library calculation 
....................    
....................       temperature_comp = calc_temperature(temperature_received, dev); 
0A70E:  MOVFF  732,815
0A712:  MOVFF  731,814
0A716:  MOVFF  730,813
0A71A:  MOVFF  72F,812
0A71E:  MOVFF  702,817
0A722:  MOVFF  701,816
0A726:  MOVLB  0
0A728:  GOTO   960A
0A72C:  MOVFF  01,753
0A730:  MOVFF  02,754
0A734:  CLRF   02
0A736:  CLRF   03
0A738:  MOVFF  03,756
0A73C:  MOVFF  02,755
....................       temperature = (float)temperature_comp / 100.0; 
0A740:  MOVFF  756,825
0A744:  MOVFF  755,824
0A748:  MOVFF  754,823
0A74C:  MOVFF  753,822
0A750:  CALL   994A
0A754:  MOVFF  03,815
0A758:  MOVFF  02,814
0A75C:  MOVFF  01,813
0A760:  MOVFF  00,812
0A764:  MOVFF  03,819
0A768:  MOVFF  02,818
0A76C:  MOVFF  01,817
0A770:  MOVFF  00,816
0A774:  MOVLB  8
0A776:  CLRF   x1D
0A778:  CLRF   x1C
0A77A:  MOVLW  48
0A77C:  MOVWF  x1B
0A77E:  MOVLW  85
0A780:  MOVWF  x1A
0A782:  MOVLB  0
0A784:  CALL   6272
0A788:  MOVFF  03,7BE
0A78C:  MOVFF  02,7BD
0A790:  MOVFF  01,7BC
0A794:  MOVFF  00,7BB
....................        
....................       /*fprintf(STDOUT, "**********   BME Library Temperature %.2f Celsius \r\n\r\n", (float)temperature_comp / 100);*/ 
....................         
....................       //*******************************// 
....................       // Now compute the pressure      // 
....................       //*******************************// 
....................       int32_t var11; 
....................       int32_t var22; 
....................       int32_t var33; 
....................       int32_t var4; 
....................       int32_t _Pressure; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 1 : var11  = (((int32_t)dev->calib.t_fine) >> 1) - 64000; 
.................... //////////////////////////////////////////////////////////////////////////// 
....................       var11  = (((int32_t)_tfine) >> 1) - 64000; 
0A798:  BCF    FD8.0
0A79A:  MOVLB  7
0A79C:  RRCF   x52,W
0A79E:  MOVLB  8
0A7A0:  MOVWF  x16
0A7A2:  MOVLB  7
0A7A4:  RRCF   x51,W
0A7A6:  MOVLB  8
0A7A8:  MOVWF  x15
0A7AA:  MOVLB  7
0A7AC:  RRCF   x50,W
0A7AE:  MOVLB  8
0A7B0:  MOVWF  x14
0A7B2:  MOVLB  7
0A7B4:  RRCF   x4F,W
0A7B6:  MOVLB  8
0A7B8:  MOVWF  x13
0A7BA:  MOVLW  00
0A7BC:  SUBWF  x13,W
0A7BE:  MOVWF  00
0A7C0:  MOVLW  FA
0A7C2:  SUBWFB x14,W
0A7C4:  MOVWF  01
0A7C6:  MOVLW  00
0A7C8:  SUBWFB x15,W
0A7CA:  MOVWF  02
0A7CC:  MOVLW  00
0A7CE:  SUBWFB x16,W
0A7D0:  MOVFF  FE8,7E1
0A7D4:  MOVFF  02,7E0
0A7D8:  MOVFF  01,7DF
0A7DC:  MOVFF  00,7DE
....................       //fprintf(STDOUT, "**********   Equation 1 var1 = %Lu\r\n\r\n", var11); 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 2 :  var22  = ((((var11 >> 2)*(var11 >> 2)) >> 11)*(int32_t)_P6) >> 2; 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
....................       var22 = ((var11 >> 2)); 
0A7E0:  MOVLB  7
0A7E2:  RRCF   xE1,W
0A7E4:  MOVWF  03
0A7E6:  RRCF   xE0,W
0A7E8:  MOVWF  02
0A7EA:  RRCF   xDF,W
0A7EC:  MOVWF  01
0A7EE:  RRCF   xDE,W
0A7F0:  MOVWF  00
0A7F2:  RRCF   03,F
0A7F4:  RRCF   02,F
0A7F6:  RRCF   01,F
0A7F8:  RRCF   00,F
0A7FA:  MOVLW  3F
0A7FC:  ANDWF  03,F
0A7FE:  MOVFF  03,7E5
0A802:  MOVFF  02,7E4
0A806:  MOVFF  01,7E3
0A80A:  MOVFF  00,7E2
....................       if (var11 < 0) 
0A80E:  BTFSS  xE1.7
0A810:  BRA    A816
....................       { 
....................          var22 = var22 + 0xc0000000; 
0A812:  MOVLW  C0
0A814:  ADDWF  xE5,F
....................       }       
....................       //fprintf(STDOUT, "**********   Equation 2 var2 = %Lu\r\n\r\n", var22); 
....................       var22 = var22 * var22; 
0A816:  MOVFF  7E5,833
0A81A:  MOVFF  7E4,832
0A81E:  MOVFF  7E3,831
0A822:  MOVFF  7E2,830
0A826:  MOVFF  7E5,837
0A82A:  MOVFF  7E4,836
0A82E:  MOVFF  7E3,835
0A832:  MOVFF  7E2,834
0A836:  MOVLB  0
0A838:  CALL   95AE
0A83C:  MOVFF  03,7E5
0A840:  MOVFF  02,7E4
0A844:  MOVFF  01,7E3
0A848:  MOVFF  00,7E2
....................        
....................       //fprintf(STDOUT, "**********   Equation 2 var2 = %Lu\r\n\r\n", var22);       
....................        
....................       if (var22 < 0) 
0A84C:  MOVLB  7
0A84E:  BTFSS  xE5.7
0A850:  BRA    A88A
....................       { 
....................          var22 = var22 >> 11; 
0A852:  CLRF   03
0A854:  RRCF   xE5,W
0A856:  MOVWF  02
0A858:  RRCF   xE4,W
0A85A:  MOVWF  01
0A85C:  RRCF   xE3,W
0A85E:  MOVWF  00
0A860:  RRCF   02,F
0A862:  RRCF   01,F
0A864:  RRCF   00,F
0A866:  RRCF   02,F
0A868:  RRCF   01,F
0A86A:  RRCF   00,F
0A86C:  MOVLW  1F
0A86E:  ANDWF  02,F
0A870:  MOVFF  03,7E5
0A874:  MOVFF  02,7E4
0A878:  MOVFF  01,7E3
0A87C:  MOVFF  00,7E2
....................          var22 = var22 + 0xffe00000; 
0A880:  MOVLW  E0
0A882:  ADDWF  xE4,F
0A884:  MOVLW  FF
0A886:  ADDWFC xE5,F
....................       } 
0A888:  BRA    A8B8
....................       else 
....................       { 
....................       var22 = var22 >> 11; 
0A88A:  CLRF   03
0A88C:  RRCF   xE5,W
0A88E:  MOVWF  02
0A890:  RRCF   xE4,W
0A892:  MOVWF  01
0A894:  RRCF   xE3,W
0A896:  MOVWF  00
0A898:  RRCF   02,F
0A89A:  RRCF   01,F
0A89C:  RRCF   00,F
0A89E:  RRCF   02,F
0A8A0:  RRCF   01,F
0A8A2:  RRCF   00,F
0A8A4:  MOVLW  1F
0A8A6:  ANDWF  02,F
0A8A8:  MOVFF  03,7E5
0A8AC:  MOVFF  02,7E4
0A8B0:  MOVFF  01,7E3
0A8B4:  MOVFF  00,7E2
....................       } 
....................       //fprintf(STDOUT, "**********   Equation 2 var2 = %Lu\r\n\r\n", var22); 
....................        
....................       var22 = var22*(int32_t)_P6; 
0A8B8:  MOVFF  7E5,833
0A8BC:  MOVFF  7E4,832
0A8C0:  MOVFF  7E3,831
0A8C4:  MOVFF  7E2,830
0A8C8:  MOVFF  796,837
0A8CC:  MOVFF  795,836
0A8D0:  MOVFF  794,835
0A8D4:  MOVFF  793,834
0A8D8:  MOVLB  0
0A8DA:  CALL   95AE
0A8DE:  MOVFF  03,7E5
0A8E2:  MOVFF  02,7E4
0A8E6:  MOVFF  01,7E3
0A8EA:  MOVFF  00,7E2
....................       //fprintf(STDOUT, "**********   Equation 2 var2 = %Lu\r\n\r\n", var22); 
....................        
....................       var22 = var22 >> 2; 
0A8EE:  MOVLB  7
0A8F0:  RRCF   xE5,W
0A8F2:  MOVWF  03
0A8F4:  RRCF   xE4,W
0A8F6:  MOVWF  02
0A8F8:  RRCF   xE3,W
0A8FA:  MOVWF  01
0A8FC:  RRCF   xE2,W
0A8FE:  MOVWF  00
0A900:  RRCF   03,F
0A902:  RRCF   02,F
0A904:  RRCF   01,F
0A906:  RRCF   00,F
0A908:  MOVLW  3F
0A90A:  ANDWF  03,F
0A90C:  MOVFF  03,7E5
0A910:  MOVFF  02,7E4
0A914:  MOVFF  01,7E3
0A918:  MOVFF  00,7E2
....................       //fprintf(STDOUT, "**********   Equation 2 final output = %Lu\r\n\r\n", var22); 
....................        
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 3 : var22  = var22 + ((var11 * (int32_t)_P5) << 1); 
.................... ///////////////////////////////////////////////////////////////////////////// 
....................        
....................       var22  = var22 + ((var11 * (int32_t)_P5) << 1); 
0A91C:  MOVFF  7E1,833
0A920:  MOVFF  7E0,832
0A924:  MOVFF  7DF,831
0A928:  MOVFF  7DE,830
0A92C:  MOVFF  78A,837
0A930:  MOVFF  789,836
0A934:  MOVFF  788,835
0A938:  MOVFF  787,834
0A93C:  MOVLB  0
0A93E:  CALL   95AE
0A942:  MOVFF  03,815
0A946:  MOVFF  02,814
0A94A:  MOVFF  01,813
0A94E:  MOVFF  00,812
0A952:  BCF    FD8.0
0A954:  MOVLB  8
0A956:  RLCF   00,W
0A958:  MOVWF  00
0A95A:  RLCF   01,W
0A95C:  MOVWF  01
0A95E:  RLCF   02,W
0A960:  MOVWF  02
0A962:  RLCF   03,W
0A964:  MOVWF  03
0A966:  MOVF   00,W
0A968:  MOVLB  7
0A96A:  ADDWF  xE2,F
0A96C:  MOVF   01,W
0A96E:  ADDWFC xE3,F
0A970:  MOVF   02,W
0A972:  ADDWFC xE4,F
0A974:  MOVF   03,W
0A976:  ADDWFC xE5,F
....................       //fprintf(STDOUT, "**********   Equation 3 final output = %Lu\r\n\r\n", var22); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 4 : var22  = (var22 >> 2) + ((int32_t)_P4 << 16); 
.................... ///////////////////////////////////////////////////////////////////////////// 
....................       if (var22 < 0) 
0A978:  BTFSS  xE5.7
0A97A:  BRA    A9AE
....................       { 
....................          var22  = (var22 >> 2); 
0A97C:  RRCF   xE5,W
0A97E:  MOVWF  03
0A980:  RRCF   xE4,W
0A982:  MOVWF  02
0A984:  RRCF   xE3,W
0A986:  MOVWF  01
0A988:  RRCF   xE2,W
0A98A:  MOVWF  00
0A98C:  RRCF   03,F
0A98E:  RRCF   02,F
0A990:  RRCF   01,F
0A992:  RRCF   00,F
0A994:  MOVLW  3F
0A996:  ANDWF  03,F
0A998:  MOVFF  03,7E5
0A99C:  MOVFF  02,7E4
0A9A0:  MOVFF  01,7E3
0A9A4:  MOVFF  00,7E2
....................          var22 = var22 + 0xc0000000; 
0A9A8:  MOVLW  C0
0A9AA:  ADDWF  xE5,F
....................       } 
0A9AC:  BRA    A9DA
....................        
....................       else 
....................       { 
....................          var22  = (var22 >> 2); 
0A9AE:  RRCF   xE5,W
0A9B0:  MOVWF  03
0A9B2:  RRCF   xE4,W
0A9B4:  MOVWF  02
0A9B6:  RRCF   xE3,W
0A9B8:  MOVWF  01
0A9BA:  RRCF   xE2,W
0A9BC:  MOVWF  00
0A9BE:  RRCF   03,F
0A9C0:  RRCF   02,F
0A9C2:  RRCF   01,F
0A9C4:  RRCF   00,F
0A9C6:  MOVLW  3F
0A9C8:  ANDWF  03,F
0A9CA:  MOVFF  03,7E5
0A9CE:  MOVFF  02,7E4
0A9D2:  MOVFF  01,7E3
0A9D6:  MOVFF  00,7E2
....................       } 
....................        
....................       var22 = var22 + ((int32_t)_P4 << 16); 
0A9DA:  MOVFF  77C,03
0A9DE:  MOVFF  77B,02
0A9E2:  CLRF   00
0A9E4:  CLRF   01
0A9E6:  MOVF   00,W
0A9E8:  ADDWF  xE2,F
0A9EA:  MOVF   01,W
0A9EC:  ADDWFC xE3,F
0A9EE:  MOVF   02,W
0A9F0:  ADDWFC xE4,F
0A9F2:  MOVF   03,W
0A9F4:  ADDWFC xE5,F
....................       //fprintf(STDOUT, "**********   Equation 4 final output = %Lu\r\n\r\n", var22); 
....................        
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 5 : var11  = (((((var11>>2)*(var11>>2))>>13)*((int32_t)dev->calib.par_p3<<5))>>3)+(((int32_t)dev->calib.par_p2*var11)>>1) 
.................... ///////////////////////////////////////////////////////////////////////////// 
....................       int32_t var1_2 = var11 >> 2; 
0A9F6:  RRCF   xE1,W
0A9F8:  MOVWF  03
0A9FA:  RRCF   xE0,W
0A9FC:  MOVWF  02
0A9FE:  RRCF   xDF,W
0AA00:  MOVWF  01
0AA02:  RRCF   xDE,W
0AA04:  MOVWF  00
0AA06:  RRCF   03,F
0AA08:  RRCF   02,F
0AA0A:  RRCF   01,F
0AA0C:  RRCF   00,F
0AA0E:  MOVLW  3F
0AA10:  ANDWF  03,F
0AA12:  MOVFF  03,7F5
0AA16:  MOVFF  02,7F4
0AA1A:  MOVFF  01,7F3
0AA1E:  MOVFF  00,7F2
....................        
....................       if (var11 < 0) 
0AA22:  BTFSC  xE1.7
0AA24:  BRA    AA28
0AA26:  BRA    AA2C
....................       { 
....................          var1_2 = var1_2 + 0xc0000000; 
0AA28:  MOVLW  C0
0AA2A:  ADDWF  xF5,F
....................       } 
....................        
....................       int32_t var1_13 = ((var1_2)*(var1_2)) >> 13; 
0AA2C:  MOVFF  7F5,833
0AA30:  MOVFF  7F4,832
0AA34:  MOVFF  7F3,831
0AA38:  MOVFF  7F2,830
0AA3C:  MOVFF  7F5,837
0AA40:  MOVFF  7F4,836
0AA44:  MOVFF  7F3,835
0AA48:  MOVFF  7F2,834
0AA4C:  MOVLB  0
0AA4E:  CALL   95AE
0AA52:  MOVFF  03,815
0AA56:  MOVFF  02,814
0AA5A:  MOVFF  01,813
0AA5E:  MOVFF  00,812
0AA62:  CLRF   03
0AA64:  MOVLB  8
0AA66:  RRCF   x15,W
0AA68:  MOVWF  02
0AA6A:  RRCF   x14,W
0AA6C:  MOVWF  01
0AA6E:  RRCF   x13,W
0AA70:  MOVWF  00
0AA72:  RRCF   02,F
0AA74:  RRCF   01,F
0AA76:  RRCF   00,F
0AA78:  RRCF   02,F
0AA7A:  RRCF   01,F
0AA7C:  RRCF   00,F
0AA7E:  RRCF   02,F
0AA80:  RRCF   01,F
0AA82:  RRCF   00,F
0AA84:  RRCF   02,F
0AA86:  RRCF   01,F
0AA88:  RRCF   00,F
0AA8A:  MOVLW  07
0AA8C:  ANDWF  02,F
0AA8E:  MOVFF  03,7F9
0AA92:  MOVFF  02,7F8
0AA96:  MOVFF  01,7F7
0AA9A:  MOVFF  00,7F6
....................       //fprintf(STDOUT, "**********   Equation 5 var1_13 = %Lu\r\n\r\n", var1_13); 
....................        
....................       var1_13 = (var1_13)*((int32_t)_P3 << 5); 
0AA9E:  MOVLB  7
0AAA0:  RLCF   x8F,W
0AAA2:  MOVWF  00
0AAA4:  RLCF   x90,W
0AAA6:  MOVWF  01
0AAA8:  RLCF   x91,W
0AAAA:  MOVWF  02
0AAAC:  RLCF   x92,W
0AAAE:  MOVWF  03
0AAB0:  RLCF   00,F
0AAB2:  RLCF   01,F
0AAB4:  RLCF   02,F
0AAB6:  RLCF   03,F
0AAB8:  RLCF   00,F
0AABA:  RLCF   01,F
0AABC:  RLCF   02,F
0AABE:  RLCF   03,F
0AAC0:  RLCF   00,F
0AAC2:  RLCF   01,F
0AAC4:  RLCF   02,F
0AAC6:  RLCF   03,F
0AAC8:  RLCF   00,F
0AACA:  RLCF   01,F
0AACC:  RLCF   02,F
0AACE:  RLCF   03,F
0AAD0:  MOVLW  E0
0AAD2:  ANDWF  00,F
0AAD4:  MOVFF  03,816
0AAD8:  MOVFF  02,815
0AADC:  MOVFF  01,814
0AAE0:  MOVFF  00,813
0AAE4:  MOVFF  7F9,833
0AAE8:  MOVFF  7F8,832
0AAEC:  MOVFF  7F7,831
0AAF0:  MOVFF  7F6,830
0AAF4:  MOVFF  03,837
0AAF8:  MOVFF  02,836
0AAFC:  MOVFF  01,835
0AB00:  MOVFF  00,834
0AB04:  MOVLB  0
0AB06:  CALL   95AE
0AB0A:  MOVFF  03,7F9
0AB0E:  MOVFF  02,7F8
0AB12:  MOVFF  01,7F7
0AB16:  MOVFF  00,7F6
....................       //fprintf(STDOUT, "**********   Equation 5 var1_13 = %Lu\r\n\r\n", var1_13); 
....................        
....................       if (var1_13 < 0) 
0AB1A:  MOVLB  7
0AB1C:  BTFSC  xF9.7
0AB1E:  BRA    AB22
0AB20:  BRA    AB5C
....................       { 
....................          var1_13 = var1_13 >> 3; 
0AB22:  RRCF   xF9,W
0AB24:  MOVWF  03
0AB26:  RRCF   xF8,W
0AB28:  MOVWF  02
0AB2A:  RRCF   xF7,W
0AB2C:  MOVWF  01
0AB2E:  RRCF   xF6,W
0AB30:  MOVWF  00
0AB32:  RRCF   03,F
0AB34:  RRCF   02,F
0AB36:  RRCF   01,F
0AB38:  RRCF   00,F
0AB3A:  RRCF   03,F
0AB3C:  RRCF   02,F
0AB3E:  RRCF   01,F
0AB40:  RRCF   00,F
0AB42:  MOVLW  1F
0AB44:  ANDWF  03,F
0AB46:  MOVFF  03,7F9
0AB4A:  MOVFF  02,7F8
0AB4E:  MOVFF  01,7F7
0AB52:  MOVFF  00,7F6
....................          //fprintf(STDOUT, "**********   Equation 5 var1_13 = %Lu\r\n\r\n", var1_13); 
....................          var1_13 = var1_13 + 0xE0000000; 
0AB56:  MOVLW  E0
0AB58:  ADDWF  xF9,F
....................       } 
0AB5A:  BRA    AB90
....................        
....................       else 
....................       { 
....................          var1_13 = var1_13 >> 3; 
0AB5C:  RRCF   xF9,W
0AB5E:  MOVWF  03
0AB60:  RRCF   xF8,W
0AB62:  MOVWF  02
0AB64:  RRCF   xF7,W
0AB66:  MOVWF  01
0AB68:  RRCF   xF6,W
0AB6A:  MOVWF  00
0AB6C:  RRCF   03,F
0AB6E:  RRCF   02,F
0AB70:  RRCF   01,F
0AB72:  RRCF   00,F
0AB74:  RRCF   03,F
0AB76:  RRCF   02,F
0AB78:  RRCF   01,F
0AB7A:  RRCF   00,F
0AB7C:  MOVLW  1F
0AB7E:  ANDWF  03,F
0AB80:  MOVFF  03,7F9
0AB84:  MOVFF  02,7F8
0AB88:  MOVFF  01,7F7
0AB8C:  MOVFF  00,7F6
....................          //fprintf(STDOUT, "**********   Equation 5 var1_13 = %Lu\r\n\r\n", var1_13); 
....................       } 
....................        
....................       int32_t var1_1 = ((int32_t)_P2 * var11); 
0AB90:  MOVFF  77A,833
0AB94:  MOVFF  779,832
0AB98:  MOVFF  778,831
0AB9C:  MOVFF  777,830
0ABA0:  MOVFF  7E1,837
0ABA4:  MOVFF  7E0,836
0ABA8:  MOVFF  7DF,835
0ABAC:  MOVFF  7DE,834
0ABB0:  MOVLB  0
0ABB2:  CALL   95AE
0ABB6:  MOVFF  03,7FD
0ABBA:  MOVFF  02,7FC
0ABBE:  MOVFF  01,7FB
0ABC2:  MOVFF  00,7FA
....................        
....................       if (var1_1 < 0) 
0ABC6:  MOVLB  7
0ABC8:  BTFSC  xFD.7
0ABCA:  BRA    ABCE
0ABCC:  BRA    ABF2
....................       { 
....................          var1_1 = var1_1 >> 1; 
0ABCE:  BCF    FD8.0
0ABD0:  RRCF   xFD,W
0ABD2:  MOVWF  03
0ABD4:  RRCF   xFC,W
0ABD6:  MOVWF  02
0ABD8:  RRCF   xFB,W
0ABDA:  MOVWF  01
0ABDC:  RRCF   xFA,W
0ABDE:  MOVFF  03,7FD
0ABE2:  MOVFF  02,7FC
0ABE6:  MOVFF  01,7FB
0ABEA:  MOVWF  xFA
....................          var1_1 = var1_1 + 0x80000000; 
0ABEC:  MOVLW  80
0ABEE:  ADDWF  xFD,F
....................       } 
0ABF0:  BRA    AC10
....................        
....................       else 
....................       { 
....................          var1_1 = var1_1 >> 1; 
0ABF2:  BCF    FD8.0
0ABF4:  RRCF   xFD,W
0ABF6:  MOVWF  03
0ABF8:  RRCF   xFC,W
0ABFA:  MOVWF  02
0ABFC:  RRCF   xFB,W
0ABFE:  MOVWF  01
0AC00:  RRCF   xFA,W
0AC02:  MOVFF  03,7FD
0AC06:  MOVFF  02,7FC
0AC0A:  MOVFF  01,7FB
0AC0E:  MOVWF  xFA
....................       } 
....................        
....................       //fprintf(STDOUT, "**********   Equation 5 var1_1 = %Lu\r\n\r\n", var1_1); 
....................       var11 = var1_13 + var1_1; 
0AC10:  MOVF   xFA,W
0AC12:  ADDWF  xF6,W
0AC14:  MOVWF  xDE
0AC16:  MOVF   xFB,W
0AC18:  ADDWFC xF7,W
0AC1A:  MOVWF  xDF
0AC1C:  MOVF   xFC,W
0AC1E:  ADDWFC xF8,W
0AC20:  MOVWF  xE0
0AC22:  MOVF   xFD,W
0AC24:  ADDWFC xF9,W
0AC26:  MOVWF  xE1
....................       //fprintf(STDOUT, "**********   Equation 5 final output = %Lu\r\n\r\n", var11); 
....................        
....................        
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 6 : var11 = var11 >> 18; 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................       if (var11 < 0) 
0AC28:  BTFSC  xE1.7
0AC2A:  BRA    AC2E
0AC2C:  BRA    AC5E
....................       { 
....................          var11  = var11 >> 18; 
0AC2E:  CLRF   03
0AC30:  CLRF   02
0AC32:  RRCF   xE1,W
0AC34:  MOVWF  01
0AC36:  RRCF   xE0,W
0AC38:  MOVWF  00
0AC3A:  RRCF   01,F
0AC3C:  RRCF   00,F
0AC3E:  MOVLW  3F
0AC40:  ANDWF  01,F
0AC42:  MOVFF  03,7E1
0AC46:  MOVFF  02,7E0
0AC4A:  MOVFF  01,7DF
0AC4E:  MOVFF  00,7DE
....................          var11 = var11 + 0xffffc000; 
0AC52:  MOVLW  C0
0AC54:  ADDWF  xDF,F
0AC56:  MOVLW  FF
0AC58:  ADDWFC xE0,F
0AC5A:  ADDWFC xE1,F
....................       } 
0AC5C:  BRA    AC82
....................        
....................       else 
....................       { 
....................          var11  = var11 >> 18; 
0AC5E:  CLRF   03
0AC60:  CLRF   02
0AC62:  RRCF   xE1,W
0AC64:  MOVWF  01
0AC66:  RRCF   xE0,W
0AC68:  MOVWF  00
0AC6A:  RRCF   01,F
0AC6C:  RRCF   00,F
0AC6E:  MOVLW  3F
0AC70:  ANDWF  01,F
0AC72:  MOVFF  03,7E1
0AC76:  MOVFF  02,7E0
0AC7A:  MOVFF  01,7DF
0AC7E:  MOVFF  00,7DE
....................       } 
....................       //fprintf(STDOUT, "**********   Equation 6 final output = %Lu\r\n\r\n", var11); 
....................        
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 7 : var11  = ((32768 + var11) * (int32_t)_P1) >> 15; 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................       var11  = ((32768 + var11) * (int32_t)_P1) >> 15; 
0AC82:  MOVFF  7DE,830
0AC86:  MOVLW  80
0AC88:  MOVLB  7
0AC8A:  ADDWF  xDF,W
0AC8C:  MOVLB  8
0AC8E:  MOVWF  x13
0AC90:  MOVLW  00
0AC92:  MOVLB  7
0AC94:  ADDWFC xE0,W
0AC96:  MOVLB  8
0AC98:  MOVWF  x14
0AC9A:  MOVLW  00
0AC9C:  MOVLB  7
0AC9E:  ADDWFC xE1,W
0ACA0:  MOVLB  8
0ACA2:  MOVWF  x15
0ACA4:  MOVWF  x33
0ACA6:  MOVFF  814,832
0ACAA:  MOVFF  813,831
0ACAE:  MOVFF  776,837
0ACB2:  MOVFF  775,836
0ACB6:  MOVFF  774,835
0ACBA:  MOVFF  773,834
0ACBE:  MOVLB  0
0ACC0:  CALL   95AE
0ACC4:  MOVFF  03,815
0ACC8:  MOVFF  02,814
0ACCC:  MOVFF  01,813
0ACD0:  MOVFF  00,812
0ACD4:  CLRF   03
0ACD6:  MOVLB  8
0ACD8:  RRCF   x15,W
0ACDA:  MOVWF  02
0ACDC:  RRCF   x14,W
0ACDE:  MOVWF  01
0ACE0:  RRCF   x13,W
0ACE2:  MOVWF  00
0ACE4:  RRCF   02,F
0ACE6:  RRCF   01,F
0ACE8:  RRCF   00,F
0ACEA:  RRCF   02,F
0ACEC:  RRCF   01,F
0ACEE:  RRCF   00,F
0ACF0:  RRCF   02,F
0ACF2:  RRCF   01,F
0ACF4:  RRCF   00,F
0ACF6:  RRCF   02,F
0ACF8:  RRCF   01,F
0ACFA:  RRCF   00,F
0ACFC:  RRCF   02,F
0ACFE:  RRCF   01,F
0AD00:  RRCF   00,F
0AD02:  RRCF   02,F
0AD04:  RRCF   01,F
0AD06:  RRCF   00,F
0AD08:  MOVLW  01
0AD0A:  ANDWF  02,F
0AD0C:  MOVFF  03,7E1
0AD10:  MOVFF  02,7E0
0AD14:  MOVFF  01,7DF
0AD18:  MOVFF  00,7DE
....................       //fprintf(STDOUT, "**********   Equation 7 final output = %Lu\r\n\r\n", var11); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 8 : _Pressure = 1048576 - (uint32_t)pressure_received; 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................       _Pressure = 1048576 - pressure_received; 
0AD1C:  MOVLW  00
0AD1E:  BSF    FD8.0
0AD20:  MOVLB  7
0AD22:  SUBFWB x33,W
0AD24:  MOVWF  00
0AD26:  MOVLW  00
0AD28:  SUBFWB x34,W
0AD2A:  MOVWF  01
0AD2C:  MOVLW  10
0AD2E:  SUBFWB x35,W
0AD30:  MOVWF  02
0AD32:  MOVLW  00
0AD34:  SUBFWB x36,W
0AD36:  MOVWF  xF1
0AD38:  MOVFF  02,7F0
0AD3C:  MOVFF  01,7EF
0AD40:  MOVFF  00,7EE
....................       //_Pressure = 1048576 - _pressure_received; 
....................       //fprintf(STDOUT, "**********   Equation 8  final output = %Lu\r\n\r\n", _Pressure); 
....................        
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //     Equation 9 : _Pressure = (int32_t)((_Pressure - (var22 >> 12)) * ((uint32_t)3125)); 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................       _Pressure = (int32_t)((_Pressure - (var22 >> 12)) * ((uint32_t)3125)); 
0AD44:  CLRF   03
0AD46:  RRCF   xE5,W
0AD48:  MOVWF  02
0AD4A:  RRCF   xE4,W
0AD4C:  MOVWF  01
0AD4E:  RRCF   xE3,W
0AD50:  MOVWF  00
0AD52:  RRCF   02,F
0AD54:  RRCF   01,F
0AD56:  RRCF   00,F
0AD58:  RRCF   02,F
0AD5A:  RRCF   01,F
0AD5C:  RRCF   00,F
0AD5E:  RRCF   02,F
0AD60:  RRCF   01,F
0AD62:  RRCF   00,F
0AD64:  MOVLW  0F
0AD66:  ANDWF  02,F
0AD68:  MOVF   00,W
0AD6A:  SUBWF  xEE,W
0AD6C:  MOVLB  8
0AD6E:  MOVWF  x13
0AD70:  MOVF   01,W
0AD72:  MOVLB  7
0AD74:  SUBWFB xEF,W
0AD76:  MOVLB  8
0AD78:  MOVWF  x14
0AD7A:  MOVF   02,W
0AD7C:  MOVLB  7
0AD7E:  SUBWFB xF0,W
0AD80:  MOVLB  8
0AD82:  MOVWF  x15
0AD84:  MOVF   03,W
0AD86:  MOVLB  7
0AD88:  SUBWFB xF1,W
0AD8A:  MOVLB  8
0AD8C:  MOVWF  x16
0AD8E:  MOVWF  x33
0AD90:  MOVFF  815,832
0AD94:  MOVFF  814,831
0AD98:  MOVFF  813,830
0AD9C:  CLRF   x37
0AD9E:  CLRF   x36
0ADA0:  MOVLW  0C
0ADA2:  MOVWF  x35
0ADA4:  MOVLW  35
0ADA6:  MOVWF  x34
0ADA8:  MOVLB  0
0ADAA:  CALL   95AE
0ADAE:  MOVFF  03,7F1
0ADB2:  MOVFF  02,7F0
0ADB6:  MOVFF  01,7EF
0ADBA:  MOVFF  00,7EE
....................       //fprintf(STDOUT, "**********   Equation 9 final output = %Lu\r\n\r\n", _Pressure); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 10 : Check pressure maximum condition 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................       if (_Pressure < 0) 
0ADBE:  MOVLB  7
0ADC0:  BTFSS  xF1.7
0ADC2:  BRA    AE42
....................       { 
....................          uint32_t pressure = _Pressure; 
....................          uint32_t _var11 = var11; 
0ADC4:  MOVFF  7F1,801
0ADC8:  MOVFF  7F0,800
0ADCC:  MOVFF  7EF,7FF
0ADD0:  MOVFF  7EE,7FE
0ADD4:  MOVFF  7E1,805
0ADD8:  MOVFF  7E0,804
0ADDC:  MOVFF  7DF,803
0ADE0:  MOVFF  7DE,802
....................          _Pressure = ((pressure/_var11) << 1); 
0ADE4:  BCF    FD8.1
0ADE6:  MOVFF  801,822
0ADEA:  MOVFF  800,821
0ADEE:  MOVFF  7FF,820
0ADF2:  MOVFF  7FE,81F
0ADF6:  MOVFF  805,826
0ADFA:  MOVFF  804,825
0ADFE:  MOVFF  803,824
0AE02:  MOVFF  802,823
0AE06:  MOVLB  0
0AE08:  CALL   406A
0AE0C:  MOVFF  03,815
0AE10:  MOVFF  02,814
0AE14:  MOVFF  01,813
0AE18:  MOVFF  00,812
0AE1C:  BCF    FD8.0
0AE1E:  MOVLB  8
0AE20:  RLCF   00,W
0AE22:  MOVWF  00
0AE24:  RLCF   01,W
0AE26:  MOVWF  01
0AE28:  RLCF   02,W
0AE2A:  MOVWF  02
0AE2C:  RLCF   03,W
0AE2E:  MOVFF  FE8,7F1
0AE32:  MOVFF  02,7F0
0AE36:  MOVFF  01,7EF
0AE3A:  MOVFF  00,7EE
....................          //fprintf(STDOUT, "**********   Equation 10 Pressure = %Lu\r\n\r\n", _Pressure); 
....................       } 
0AE3E:  BRA    AE62
0AE40:  MOVLB  7
....................       
....................       else 
....................       { 
....................          //fprintf(STDOUT, "**********  Equation 10 va11 = %Lu\r\n\r\n", (uint32_t)var11); 
....................          _Pressure = ((_Pressure << 1)); 
0AE42:  BCF    FD8.0
0AE44:  RLCF   xEE,W
0AE46:  MOVWF  00
0AE48:  RLCF   xEF,W
0AE4A:  MOVWF  01
0AE4C:  RLCF   xF0,W
0AE4E:  MOVWF  02
0AE50:  RLCF   xF1,W
0AE52:  MOVWF  xF1
0AE54:  MOVFF  02,7F0
0AE58:  MOVFF  01,7EF
0AE5C:  MOVFF  00,7EE
0AE60:  MOVLB  8
....................          //fprintf(STDOUT, "**********   Equation 10 Pressure = %Lu\r\n\r\n", _Pressure); 
....................       } 
....................        
....................       uint32_t pressure = _Pressure; 
....................       uint32_t _var11 = var11; 
0AE62:  MOVFF  7F1,809
0AE66:  MOVFF  7F0,808
0AE6A:  MOVFF  7EF,807
0AE6E:  MOVFF  7EE,806
0AE72:  MOVFF  7E1,80D
0AE76:  MOVFF  7E0,80C
0AE7A:  MOVFF  7DF,80B
0AE7E:  MOVFF  7DE,80A
....................       _Pressure = pressure/_var11; 
0AE82:  BCF    FD8.1
0AE84:  MOVFF  809,822
0AE88:  MOVFF  808,821
0AE8C:  MOVFF  807,820
0AE90:  MOVFF  806,81F
0AE94:  MOVFF  80D,826
0AE98:  MOVFF  80C,825
0AE9C:  MOVFF  80B,824
0AEA0:  MOVFF  80A,823
0AEA4:  MOVLB  0
0AEA6:  CALL   406A
0AEAA:  MOVFF  03,7F1
0AEAE:  MOVFF  02,7F0
0AEB2:  MOVFF  01,7EF
0AEB6:  MOVFF  00,7EE
....................        
....................       //fprintf(STDOUT, "**********   Equation 10 final output = %Lu\r\n\r\n", _Pressure); 
....................       //_Pressure = 3593256250/35863; 
....................       /*fprintf(STDOUT, "**********   Look Here Pressure = %Lu\r\n\r\n", _Pressure);*/ 
....................         
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //     Equation 11 : var11 = ((int32_t)_P9*(int32_t)(((_Pressure>>3)*(_Pressure>>3))>>13))>>12; 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................       var11 = (_Pressure>>3)*(_Pressure>>3); 
0AEBA:  MOVLB  7
0AEBC:  RRCF   xF1,W
0AEBE:  MOVLB  8
0AEC0:  MOVWF  x16
0AEC2:  MOVLB  7
0AEC4:  RRCF   xF0,W
0AEC6:  MOVLB  8
0AEC8:  MOVWF  x15
0AECA:  MOVLB  7
0AECC:  RRCF   xEF,W
0AECE:  MOVLB  8
0AED0:  MOVWF  x14
0AED2:  MOVLB  7
0AED4:  RRCF   xEE,W
0AED6:  MOVLB  8
0AED8:  MOVWF  x13
0AEDA:  RRCF   x16,F
0AEDC:  RRCF   x15,F
0AEDE:  RRCF   x14,F
0AEE0:  RRCF   x13,F
0AEE2:  RRCF   x16,F
0AEE4:  RRCF   x15,F
0AEE6:  RRCF   x14,F
0AEE8:  RRCF   x13,F
0AEEA:  MOVLW  1F
0AEEC:  ANDWF  x16,F
0AEEE:  MOVLB  7
0AEF0:  RRCF   xF1,W
0AEF2:  MOVWF  03
0AEF4:  RRCF   xF0,W
0AEF6:  MOVWF  02
0AEF8:  RRCF   xEF,W
0AEFA:  MOVWF  01
0AEFC:  RRCF   xEE,W
0AEFE:  MOVWF  00
0AF00:  RRCF   03,F
0AF02:  RRCF   02,F
0AF04:  RRCF   01,F
0AF06:  RRCF   00,F
0AF08:  RRCF   03,F
0AF0A:  RRCF   02,F
0AF0C:  RRCF   01,F
0AF0E:  RRCF   00,F
0AF10:  MOVLW  1F
0AF12:  ANDWF  03,F
0AF14:  MOVFF  03,81B
0AF18:  MOVFF  02,81A
0AF1C:  MOVFF  01,819
0AF20:  MOVFF  00,818
0AF24:  MOVFF  816,833
0AF28:  MOVFF  815,832
0AF2C:  MOVFF  814,831
0AF30:  MOVFF  813,830
0AF34:  MOVFF  03,837
0AF38:  MOVFF  02,836
0AF3C:  MOVFF  01,835
0AF40:  MOVFF  00,834
0AF44:  MOVLB  0
0AF46:  CALL   95AE
0AF4A:  MOVFF  03,7E1
0AF4E:  MOVFF  02,7E0
0AF52:  MOVFF  01,7DF
0AF56:  MOVFF  00,7DE
....................        
....................       //fprintf(STDOUT, "**********   Equation 11 var11 = %Lu\r\n\r\n", var11); 
....................  
....................       if (var11 < 0) 
0AF5A:  MOVLB  7
0AF5C:  BTFSS  xE1.7
0AF5E:  BRA    AFA8
....................       { 
....................          var11 = (int32_t)( var11 >> 13); 
0AF60:  CLRF   03
0AF62:  RRCF   xE1,W
0AF64:  MOVWF  02
0AF66:  RRCF   xE0,W
0AF68:  MOVWF  01
0AF6A:  RRCF   xDF,W
0AF6C:  MOVWF  00
0AF6E:  RRCF   02,F
0AF70:  RRCF   01,F
0AF72:  RRCF   00,F
0AF74:  RRCF   02,F
0AF76:  RRCF   01,F
0AF78:  RRCF   00,F
0AF7A:  RRCF   02,F
0AF7C:  RRCF   01,F
0AF7E:  RRCF   00,F
0AF80:  RRCF   02,F
0AF82:  RRCF   01,F
0AF84:  RRCF   00,F
0AF86:  MOVLW  07
0AF88:  ANDWF  02,F
0AF8A:  MOVFF  03,7E1
0AF8E:  MOVFF  02,7E0
0AF92:  MOVFF  01,7DF
0AF96:  MOVFF  00,7DE
....................          var11 = var11 + 0xfff8000; 
0AF9A:  MOVLW  80
0AF9C:  ADDWF  xDF,F
0AF9E:  MOVLW  FF
0AFA0:  ADDWFC xE0,F
0AFA2:  MOVLW  0F
0AFA4:  ADDWFC xE1,F
....................       } 
0AFA6:  BRA    AFE2
....................        
....................       else 
....................       { 
....................          var11 = (int32_t)( var11 >> 13); 
0AFA8:  CLRF   03
0AFAA:  RRCF   xE1,W
0AFAC:  MOVWF  02
0AFAE:  RRCF   xE0,W
0AFB0:  MOVWF  01
0AFB2:  RRCF   xDF,W
0AFB4:  MOVWF  00
0AFB6:  RRCF   02,F
0AFB8:  RRCF   01,F
0AFBA:  RRCF   00,F
0AFBC:  RRCF   02,F
0AFBE:  RRCF   01,F
0AFC0:  RRCF   00,F
0AFC2:  RRCF   02,F
0AFC4:  RRCF   01,F
0AFC6:  RRCF   00,F
0AFC8:  RRCF   02,F
0AFCA:  RRCF   01,F
0AFCC:  RRCF   00,F
0AFCE:  MOVLW  07
0AFD0:  ANDWF  02,F
0AFD2:  MOVFF  03,7E1
0AFD6:  MOVFF  02,7E0
0AFDA:  MOVFF  01,7DF
0AFDE:  MOVFF  00,7DE
....................       } 
....................        
....................       //fprintf(STDOUT, "**********   Equation 11 var11 = %Lu\r\n\r\n", var11); 
....................        
....................       var11 = (int32_t)_P9*(int32_t)var11; 
0AFE2:  MOVFF  786,833
0AFE6:  MOVFF  785,832
0AFEA:  MOVFF  784,831
0AFEE:  MOVFF  783,830
0AFF2:  MOVFF  7E1,837
0AFF6:  MOVFF  7E0,836
0AFFA:  MOVFF  7DF,835
0AFFE:  MOVFF  7DE,834
0B002:  MOVLB  0
0B004:  CALL   95AE
0B008:  MOVFF  03,7E1
0B00C:  MOVFF  02,7E0
0B010:  MOVFF  01,7DF
0B014:  MOVFF  00,7DE
....................       //fprintf(STDOUT, "**********   Equation 11 var11 = %Lu\r\n\r\n", var11); 
....................         
....................       if (var11 < 0) 
0B018:  MOVLB  7
0B01A:  BTFSS  xE1.7
0B01C:  BRA    B05C
....................       { 
....................          var11 = var11 >> 12; 
0B01E:  CLRF   03
0B020:  RRCF   xE1,W
0B022:  MOVWF  02
0B024:  RRCF   xE0,W
0B026:  MOVWF  01
0B028:  RRCF   xDF,W
0B02A:  MOVWF  00
0B02C:  RRCF   02,F
0B02E:  RRCF   01,F
0B030:  RRCF   00,F
0B032:  RRCF   02,F
0B034:  RRCF   01,F
0B036:  RRCF   00,F
0B038:  RRCF   02,F
0B03A:  RRCF   01,F
0B03C:  RRCF   00,F
0B03E:  MOVLW  0F
0B040:  ANDWF  02,F
0B042:  MOVFF  03,7E1
0B046:  MOVFF  02,7E0
0B04A:  MOVFF  01,7DF
0B04E:  MOVFF  00,7DE
....................          var11 = var11 + 0xFFF00000; 
0B052:  MOVLW  F0
0B054:  ADDWF  xE0,F
0B056:  MOVLW  FF
0B058:  ADDWFC xE1,F
....................       } 
0B05A:  BRA    B090
....................        
....................       else 
....................       { 
....................          var11 = var11 >> 12; 
0B05C:  CLRF   03
0B05E:  RRCF   xE1,W
0B060:  MOVWF  02
0B062:  RRCF   xE0,W
0B064:  MOVWF  01
0B066:  RRCF   xDF,W
0B068:  MOVWF  00
0B06A:  RRCF   02,F
0B06C:  RRCF   01,F
0B06E:  RRCF   00,F
0B070:  RRCF   02,F
0B072:  RRCF   01,F
0B074:  RRCF   00,F
0B076:  RRCF   02,F
0B078:  RRCF   01,F
0B07A:  RRCF   00,F
0B07C:  MOVLW  0F
0B07E:  ANDWF  02,F
0B080:  MOVFF  03,7E1
0B084:  MOVFF  02,7E0
0B088:  MOVFF  01,7DF
0B08C:  MOVFF  00,7DE
....................       } 
....................        
....................       //fprintf(STDOUT, "**********   Equation 11 final output = %Lu\r\n\r\n", var11); 
....................         
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //    Equation 12 : var22 = ((int32_t)(_Pressure >> 2) * (int32_t)dev->calib.par_p8) >> 13; 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................         
....................       var22 = ((int32_t)(_Pressure >> 2) *(int32_t)_P8); 
0B090:  RRCF   xF1,W
0B092:  MOVWF  03
0B094:  RRCF   xF0,W
0B096:  MOVWF  02
0B098:  RRCF   xEF,W
0B09A:  MOVWF  01
0B09C:  RRCF   xEE,W
0B09E:  MOVWF  00
0B0A0:  RRCF   03,F
0B0A2:  RRCF   02,F
0B0A4:  RRCF   01,F
0B0A6:  RRCF   00,F
0B0A8:  MOVLW  3F
0B0AA:  ANDWF  03,F
0B0AC:  MOVFF  03,816
0B0B0:  MOVFF  02,815
0B0B4:  MOVFF  01,814
0B0B8:  MOVFF  00,813
0B0BC:  MOVFF  03,833
0B0C0:  MOVFF  02,832
0B0C4:  MOVFF  01,831
0B0C8:  MOVFF  00,830
0B0CC:  MOVFF  782,837
0B0D0:  MOVFF  781,836
0B0D4:  MOVFF  780,835
0B0D8:  MOVFF  77F,834
0B0DC:  MOVLB  0
0B0DE:  CALL   95AE
0B0E2:  MOVFF  03,7E5
0B0E6:  MOVFF  02,7E4
0B0EA:  MOVFF  01,7E3
0B0EE:  MOVFF  00,7E2
....................        
....................       //fprintf(STDOUT, "**********   Equation 12 var22 = %Lu\r\n\r\n", var22); 
....................       if (var22 < 0) 
0B0F2:  MOVLB  7
0B0F4:  BTFSS  xE5.7
0B0F6:  BRA    B13C
....................       { 
....................          var22 = var22 >> 13; 
0B0F8:  CLRF   03
0B0FA:  RRCF   xE5,W
0B0FC:  MOVWF  02
0B0FE:  RRCF   xE4,W
0B100:  MOVWF  01
0B102:  RRCF   xE3,W
0B104:  MOVWF  00
0B106:  RRCF   02,F
0B108:  RRCF   01,F
0B10A:  RRCF   00,F
0B10C:  RRCF   02,F
0B10E:  RRCF   01,F
0B110:  RRCF   00,F
0B112:  RRCF   02,F
0B114:  RRCF   01,F
0B116:  RRCF   00,F
0B118:  RRCF   02,F
0B11A:  RRCF   01,F
0B11C:  RRCF   00,F
0B11E:  MOVLW  07
0B120:  ANDWF  02,F
0B122:  MOVFF  03,7E5
0B126:  MOVFF  02,7E4
0B12A:  MOVFF  01,7E3
0B12E:  MOVFF  00,7E2
....................          var22 = var22 + 0xfff80000; 
0B132:  MOVLW  F8
0B134:  ADDWF  xE4,F
0B136:  MOVLW  FF
0B138:  ADDWFC xE5,F
....................       } 
0B13A:  BRA    B176
....................        
....................       else 
....................       { 
....................          var22 = var22 >> 13; 
0B13C:  CLRF   03
0B13E:  RRCF   xE5,W
0B140:  MOVWF  02
0B142:  RRCF   xE4,W
0B144:  MOVWF  01
0B146:  RRCF   xE3,W
0B148:  MOVWF  00
0B14A:  RRCF   02,F
0B14C:  RRCF   01,F
0B14E:  RRCF   00,F
0B150:  RRCF   02,F
0B152:  RRCF   01,F
0B154:  RRCF   00,F
0B156:  RRCF   02,F
0B158:  RRCF   01,F
0B15A:  RRCF   00,F
0B15C:  RRCF   02,F
0B15E:  RRCF   01,F
0B160:  RRCF   00,F
0B162:  MOVLW  07
0B164:  ANDWF  02,F
0B166:  MOVFF  03,7E5
0B16A:  MOVFF  02,7E4
0B16E:  MOVFF  01,7E3
0B172:  MOVFF  00,7E2
....................       } 
....................        
....................       //fprintf(STDOUT, "**********   Equation 12 final output = %Lu\r\n\r\n", var22); 
....................         
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //     Equation 13 : var33 = ((int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) *   (int32_t)(_Pressure >> 8) * (int32_t)dev->calib.par_p10) >> 17; 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................       var33 = ((int32_t)(_Pressure >> 8)*(int32_t)(_Pressure >> 8)*(int32_t)(_Pressure >> 8)*(int32_t)_P10); 
0B176:  MOVFF  7EF,830
0B17A:  MOVFF  7F0,831
0B17E:  MOVFF  7F1,832
0B182:  CLRF   03
0B184:  MOVFF  03,833
0B188:  MOVFF  7EF,834
0B18C:  MOVFF  7F0,01
0B190:  MOVFF  7F1,02
0B194:  CLRF   03
0B196:  MOVFF  03,837
0B19A:  MOVFF  02,836
0B19E:  MOVFF  01,835
0B1A2:  MOVLB  0
0B1A4:  CALL   95AE
0B1A8:  MOVFF  03,833
0B1AC:  MOVFF  02,832
0B1B0:  MOVFF  01,831
0B1B4:  MOVFF  00,830
0B1B8:  MOVFF  7EF,834
0B1BC:  MOVFF  7F0,01
0B1C0:  MOVFF  7F1,02
0B1C4:  CLRF   03
0B1C6:  MOVFF  03,837
0B1CA:  MOVFF  02,836
0B1CE:  MOVFF  01,835
0B1D2:  CALL   95AE
0B1D6:  MOVFF  03,816
0B1DA:  MOVFF  02,815
0B1DE:  MOVFF  01,814
0B1E2:  MOVFF  00,813
0B1E6:  MOVFF  03,833
0B1EA:  MOVFF  02,832
0B1EE:  MOVFF  01,831
0B1F2:  MOVFF  00,830
0B1F6:  MOVFF  78E,837
0B1FA:  MOVFF  78D,836
0B1FE:  MOVFF  78C,835
0B202:  MOVFF  78B,834
0B206:  CALL   95AE
0B20A:  MOVFF  03,7E9
0B20E:  MOVFF  02,7E8
0B212:  MOVFF  01,7E7
0B216:  MOVFF  00,7E6
....................        
....................       //fprintf(STDOUT, "**********   Equation 13 var33 = %Lu\r\n\r\n", var33); 
....................       if (var33 < 0) 
0B21A:  MOVLB  7
0B21C:  BTFSS  xE9.7
0B21E:  BRA    B246
....................       { 
....................          var33 = (var33 >> 17); 
0B220:  BCF    FD8.0
0B222:  CLRF   03
0B224:  CLRF   02
0B226:  RRCF   xE9,W
0B228:  MOVWF  01
0B22A:  RRCF   xE8,W
0B22C:  MOVFF  03,7E9
0B230:  MOVFF  02,7E8
0B234:  MOVFF  01,7E7
0B238:  MOVWF  xE6
....................          var33 = var33 + 0xffff8000; 
0B23A:  MOVLW  80
0B23C:  ADDWF  xE7,F
0B23E:  MOVLW  FF
0B240:  ADDWFC xE8,F
0B242:  ADDWFC xE9,F
....................          //fprintf(STDOUT, "**********   Equation 13 var33 = %Lu\r\n\r\n", var33); 
....................       } 
0B244:  BRA    B260
....................        
....................       else 
....................       { 
....................          var33 = (var33 >> 17); 
0B246:  BCF    FD8.0
0B248:  CLRF   03
0B24A:  CLRF   02
0B24C:  RRCF   xE9,W
0B24E:  MOVWF  01
0B250:  RRCF   xE8,W
0B252:  MOVFF  03,7E9
0B256:  MOVFF  02,7E8
0B25A:  MOVFF  01,7E7
0B25E:  MOVWF  xE6
....................          //fprintf(STDOUT, "**********   Equation 13 final output = %Lu\r\n\r\n", var33); 
....................       } 
.................... //////////////////////////////////////////////////////////////////////////////////////////// 
.................... //     Equation 14 : _Pressure = (int32_t)(_Pressure)+((var11+var22+var33+((int32_t)dev->calib.par_p7<<7))>>4); 
.................... //////////////////////////////////////////////////////////////////////////////////////////// 
....................       var4 = (var11+var22+var33+((int32_t)_P7<<7)); 
0B260:  MOVF   xE2,W
0B262:  ADDWF  xDE,W
0B264:  MOVLB  8
0B266:  MOVWF  x12
0B268:  MOVLB  7
0B26A:  MOVF   xE3,W
0B26C:  ADDWFC xDF,W
0B26E:  MOVLB  8
0B270:  MOVWF  x13
0B272:  MOVLB  7
0B274:  MOVF   xE4,W
0B276:  ADDWFC xE0,W
0B278:  MOVLB  8
0B27A:  MOVWF  x14
0B27C:  MOVLB  7
0B27E:  MOVF   xE5,W
0B280:  ADDWFC xE1,W
0B282:  MOVLB  8
0B284:  MOVWF  x15
0B286:  MOVLB  7
0B288:  MOVF   xE6,W
0B28A:  MOVLB  8
0B28C:  ADDWF  x12,F
0B28E:  MOVLB  7
0B290:  MOVF   xE7,W
0B292:  MOVLB  8
0B294:  ADDWFC x13,F
0B296:  MOVLB  7
0B298:  MOVF   xE8,W
0B29A:  MOVLB  8
0B29C:  ADDWFC x14,F
0B29E:  MOVLB  7
0B2A0:  MOVF   xE9,W
0B2A2:  MOVLB  8
0B2A4:  ADDWFC x15,F
0B2A6:  MOVLB  7
0B2A8:  RLCF   x97,W
0B2AA:  MOVWF  00
0B2AC:  RLCF   x98,W
0B2AE:  MOVWF  01
0B2B0:  RLCF   x99,W
0B2B2:  MOVWF  02
0B2B4:  RLCF   x9A,W
0B2B6:  MOVWF  03
0B2B8:  RLCF   00,F
0B2BA:  RLCF   01,F
0B2BC:  RLCF   02,F
0B2BE:  RLCF   03,F
0B2C0:  RLCF   00,F
0B2C2:  RLCF   01,F
0B2C4:  RLCF   02,F
0B2C6:  RLCF   03,F
0B2C8:  RLCF   00,F
0B2CA:  RLCF   01,F
0B2CC:  RLCF   02,F
0B2CE:  RLCF   03,F
0B2D0:  RLCF   00,F
0B2D2:  RLCF   01,F
0B2D4:  RLCF   02,F
0B2D6:  RLCF   03,F
0B2D8:  RLCF   00,F
0B2DA:  RLCF   01,F
0B2DC:  RLCF   02,F
0B2DE:  RLCF   03,F
0B2E0:  RLCF   00,F
0B2E2:  RLCF   01,F
0B2E4:  RLCF   02,F
0B2E6:  RLCF   03,F
0B2E8:  MOVLW  80
0B2EA:  ANDWF  00,F
0B2EC:  MOVF   00,W
0B2EE:  MOVLB  8
0B2F0:  ADDWF  x12,W
0B2F2:  MOVLB  7
0B2F4:  MOVWF  xEA
0B2F6:  MOVF   01,W
0B2F8:  MOVLB  8
0B2FA:  ADDWFC x13,W
0B2FC:  MOVLB  7
0B2FE:  MOVWF  xEB
0B300:  MOVF   02,W
0B302:  MOVLB  8
0B304:  ADDWFC x14,W
0B306:  MOVLB  7
0B308:  MOVWF  xEC
0B30A:  MOVF   03,W
0B30C:  MOVLB  8
0B30E:  ADDWFC x15,W
0B310:  MOVLB  7
0B312:  MOVWF  xED
....................        
....................       //fprintf(STDOUT, "**********   Equation 14 var4 = %Lu\r\n\r\n", var4); 
....................       if (var4 < 0) 
0B314:  BTFSS  xED.7
0B316:  BRA    B35A
....................       { 
....................          var4 = var4 >> 4; 
0B318:  RRCF   xED,W
0B31A:  MOVWF  03
0B31C:  RRCF   xEC,W
0B31E:  MOVWF  02
0B320:  RRCF   xEB,W
0B322:  MOVWF  01
0B324:  RRCF   xEA,W
0B326:  MOVWF  00
0B328:  RRCF   03,F
0B32A:  RRCF   02,F
0B32C:  RRCF   01,F
0B32E:  RRCF   00,F
0B330:  RRCF   03,F
0B332:  RRCF   02,F
0B334:  RRCF   01,F
0B336:  RRCF   00,F
0B338:  RRCF   03,F
0B33A:  RRCF   02,F
0B33C:  RRCF   01,F
0B33E:  RRCF   00,F
0B340:  MOVLW  0F
0B342:  ANDWF  03,F
0B344:  MOVFF  03,7ED
0B348:  MOVFF  02,7EC
0B34C:  MOVFF  01,7EB
0B350:  MOVFF  00,7EA
....................          var4 = var4 + 0xf0000000; 
0B354:  MOVLW  F0
0B356:  ADDWF  xED,F
....................       } 
0B358:  BRA    B396
....................        
....................       else 
....................       { 
....................          var4 = var4 >> 4; 
0B35A:  RRCF   xED,W
0B35C:  MOVWF  03
0B35E:  RRCF   xEC,W
0B360:  MOVWF  02
0B362:  RRCF   xEB,W
0B364:  MOVWF  01
0B366:  RRCF   xEA,W
0B368:  MOVWF  00
0B36A:  RRCF   03,F
0B36C:  RRCF   02,F
0B36E:  RRCF   01,F
0B370:  RRCF   00,F
0B372:  RRCF   03,F
0B374:  RRCF   02,F
0B376:  RRCF   01,F
0B378:  RRCF   00,F
0B37A:  RRCF   03,F
0B37C:  RRCF   02,F
0B37E:  RRCF   01,F
0B380:  RRCF   00,F
0B382:  MOVLW  0F
0B384:  ANDWF  03,F
0B386:  MOVFF  03,7ED
0B38A:  MOVFF  02,7EC
0B38E:  MOVFF  01,7EB
0B392:  MOVFF  00,7EA
....................       } 
....................        
....................       //fprintf(STDOUT, "**********   Equation 14 var4 = %Lu\r\n\r\n", var4); 
....................       _Pressure = (int32_t)(_Pressure)+ var4; 
0B396:  MOVF   xEA,W
0B398:  ADDWF  xEE,F
0B39A:  MOVF   xEB,W
0B39C:  ADDWFC xEF,F
0B39E:  MOVF   xEC,W
0B3A0:  ADDWFC xF0,F
0B3A2:  MOVF   xED,W
0B3A4:  ADDWFC xF1,F
....................       //fprintf(STDOUT, "\r\n\r\n*   Final Pressure  before %Lu Pascal \r\n", _Pressure); 
....................         
.................... ///////////////////////////////////////////////////////////////////////////////////////////// 
.................... //     Update variable counts 
.................... ///////////////////////////////////////////////////////////////////////////////////////////// 
....................       count +=1; 
0B3A6:  MOVLW  01
0B3A8:  ADDWF  xCD,F
0B3AA:  MOVLW  00
0B3AC:  ADDWFC xCE,F
0B3AE:  ADDWFC xCF,F
0B3B0:  ADDWFC xD0,F
....................       temperature_received = pressure_received = humidity_received = gas_received = 0; 
0B3B2:  CLRF   x42
0B3B4:  CLRF   x41
0B3B6:  CLRF   x40
0B3B8:  CLRF   x3F
0B3BA:  MOVFF  742,73E
0B3BE:  MOVFF  741,73D
0B3C2:  MOVFF  740,73C
0B3C6:  MOVFF  73F,73B
0B3CA:  MOVFF  73E,736
0B3CE:  MOVFF  73D,735
0B3D2:  MOVFF  73C,734
0B3D6:  MOVFF  73B,733
0B3DA:  MOVFF  736,732
0B3DE:  MOVFF  735,731
0B3E2:  MOVFF  734,730
0B3E6:  MOVFF  733,72F
....................       var11 = var22 = var33 = var1 = var2 = var3 = var4 =0;      
0B3EA:  CLRF   xED
0B3EC:  CLRF   xEC
0B3EE:  CLRF   xEB
0B3F0:  CLRF   xEA
0B3F2:  MOVFF  7ED,7DD
0B3F6:  MOVFF  7EC,7DC
0B3FA:  MOVFF  7EB,7DB
0B3FE:  MOVFF  7EA,7DA
0B402:  MOVFF  7DD,7D9
0B406:  MOVFF  7DC,7D8
0B40A:  MOVFF  7DB,7D7
0B40E:  MOVFF  7DA,7D6
0B412:  MOVFF  7D9,7D5
0B416:  MOVFF  7D8,7D4
0B41A:  MOVFF  7D7,7D3
0B41E:  MOVFF  7D6,7D2
0B422:  MOVFF  7D5,7E9
0B426:  MOVFF  7D4,7E8
0B42A:  MOVFF  7D3,7E7
0B42E:  MOVFF  7D2,7E6
0B432:  MOVFF  7E9,7E5
0B436:  MOVFF  7E8,7E4
0B43A:  MOVFF  7E7,7E3
0B43E:  MOVFF  7E6,7E2
0B442:  MOVFF  7E5,7E1
0B446:  MOVFF  7E4,7E0
0B44A:  MOVFF  7E3,7DF
0B44E:  MOVFF  7E2,7DE
....................        
....................       //fprintf(STDOUT, "*   Final Pressure after %Lu Pascal \r\n", _Pressure); 
....................       //uint32_t Pressure = calc_pressure(pressure_received,dev); 
....................       //fprintf(STDOUT, "*   Pressure  %Lu Pascal \r\n", _Pressure); 
....................       //fprintf(STDOUT, "**********   Library Pressure  %Lu Pascal \r\n", _Pressure); 
....................        
....................       pressure1 = _Pressure; 
0B452:  MOVFF  7F1,71E
0B456:  MOVFF  7F0,71D
0B45A:  MOVFF  7EF,71C
0B45E:  MOVFF  7EE,71B
....................        
....................       //fprintf(STDOUT, "Current Pressure %lu", pressure1 ); 
....................       if(startCount) 
0B462:  MOVF   x0B,F
0B464:  BNZ   B472
0B466:  MOVF   x0C,F
0B468:  BNZ   B472
0B46A:  MOVF   x0D,F
0B46C:  BNZ   B472
0B46E:  MOVF   x0E,F
0B470:  BZ    B492
....................       { 
....................          startCount--; 
0B472:  MOVLW  FF
0B474:  ADDWF  x0B,F
0B476:  BTFSS  FD8.0
0B478:  ADDWF  x0C,F
0B47A:  BTFSS  FD8.0
0B47C:  ADDWF  x0D,F
0B47E:  BTFSS  FD8.0
0B480:  ADDWF  x0E,F
....................          startPressure = pressure1; 
0B482:  MOVFF  71E,70A
0B486:  MOVFF  71D,709
0B48A:  MOVFF  71C,708
0B48E:  MOVFF  71B,707
....................       }       
....................        
.................... #ifdef OLD_FLOW_TALBE   
....................       deltaP = abs((int32_t)pressure1-(int32_t)startPressure); 
.................... #else 
....................       if( pressure1 > startPressure ) 
0B492:  MOVF   x0A,W
0B494:  SUBWF  x1E,W
0B496:  BNC   B4D6
0B498:  BNZ   B4B0
0B49A:  MOVF   x09,W
0B49C:  SUBWF  x1D,W
0B49E:  BNC   B4D6
0B4A0:  BNZ   B4B0
0B4A2:  MOVF   x08,W
0B4A4:  SUBWF  x1C,W
0B4A6:  BNC   B4D6
0B4A8:  BNZ   B4B0
0B4AA:  MOVF   x1B,W
0B4AC:  SUBWF  x07,W
0B4AE:  BC    B4D6
....................       { 
....................          deltaP = (int32_t)pressure1-(int32_t)startPressure; 
0B4B0:  MOVF   x07,W
0B4B2:  SUBWF  x1B,W
0B4B4:  MOVWF  00
0B4B6:  MOVF   x08,W
0B4B8:  SUBWFB x1C,W
0B4BA:  MOVWF  01
0B4BC:  MOVF   x09,W
0B4BE:  SUBWFB x1D,W
0B4C0:  MOVWF  02
0B4C2:  MOVF   x0A,W
0B4C4:  SUBWFB x1E,W
0B4C6:  MOVWF  x2A
0B4C8:  MOVFF  02,729
0B4CC:  MOVFF  01,728
0B4D0:  MOVFF  00,727
....................       } 
0B4D4:  BRA    B4DE
....................        
....................       else 
....................       { 
....................          deltaP = 0; 
0B4D6:  CLRF   x2A
0B4D8:  CLRF   x29
0B4DA:  CLRF   x28
0B4DC:  CLRF   x27
....................       }  
.................... #endif       
....................     
....................       if(timeStamp1<prevTimeStamp1) deltaT = 65535-prevTimeStamp1+timeStamp1; 
0B4DE:  MOVF   x22,W
0B4E0:  MOVLB  4
0B4E2:  SUBWF  x60,W
0B4E4:  BNC   B566
0B4E6:  BNZ   B510
0B4E8:  MOVLB  7
0B4EA:  MOVF   x21,W
0B4EC:  MOVLB  4
0B4EE:  SUBWF  x5F,W
0B4F0:  BNC   B566
0B4F2:  BNZ   B510
0B4F4:  MOVLB  7
0B4F6:  MOVF   x20,W
0B4F8:  MOVLB  4
0B4FA:  SUBWF  x5E,W
0B4FC:  BNC   B566
0B4FE:  BNZ   B510
0B500:  MOVF   x5D,W
0B502:  MOVLB  7
0B504:  SUBWF  x1F,W
0B506:  BTFSS  FD8.0
0B508:  BRA    B50E
0B50A:  MOVLB  4
0B50C:  BRA    B566
0B50E:  MOVLB  4
0B510:  MOVLW  FF
0B512:  BSF    FD8.0
0B514:  SUBFWB x5D,W
0B516:  MOVLB  8
0B518:  MOVWF  x12
0B51A:  MOVLW  FF
0B51C:  MOVLB  4
0B51E:  SUBFWB x5E,W
0B520:  MOVLB  8
0B522:  MOVWF  x13
0B524:  MOVLW  00
0B526:  MOVLB  4
0B528:  SUBFWB x5F,W
0B52A:  MOVLB  8
0B52C:  MOVWF  x14
0B52E:  MOVLW  00
0B530:  MOVLB  4
0B532:  SUBFWB x60,W
0B534:  MOVLB  8
0B536:  MOVWF  x15
0B538:  MOVLB  7
0B53A:  MOVF   x1F,W
0B53C:  MOVLB  8
0B53E:  ADDWF  x12,W
0B540:  MOVLB  7
0B542:  MOVWF  x23
0B544:  MOVF   x20,W
0B546:  MOVLB  8
0B548:  ADDWFC x13,W
0B54A:  MOVLB  7
0B54C:  MOVWF  x24
0B54E:  MOVF   x21,W
0B550:  MOVLB  8
0B552:  ADDWFC x14,W
0B554:  MOVLB  7
0B556:  MOVWF  x25
0B558:  MOVF   x22,W
0B55A:  MOVLB  8
0B55C:  ADDWFC x15,W
0B55E:  MOVLB  7
0B560:  MOVWF  x26
0B562:  BRA    B58C
0B564:  MOVLB  4
....................     
....................       else                          deltaT = timeStamp1-prevTimeStamp1; 
0B566:  MOVF   x5D,W
0B568:  MOVLB  7
0B56A:  SUBWF  x1F,W
0B56C:  MOVWF  x23
0B56E:  MOVLB  4
0B570:  MOVF   x5E,W
0B572:  MOVLB  7
0B574:  SUBWFB x20,W
0B576:  MOVWF  x24
0B578:  MOVLB  4
0B57A:  MOVF   x5F,W
0B57C:  MOVLB  7
0B57E:  SUBWFB x21,W
0B580:  MOVWF  x25
0B582:  MOVLB  4
0B584:  MOVF   x60,W
0B586:  MOVLB  7
0B588:  SUBWFB x22,W
0B58A:  MOVWF  x26
....................  
....................  
....................       switch (breathTestState) 
0B58C:  MOVF   xCB,W
0B58E:  XORLW  00
0B590:  MOVLB  0
0B592:  BZ    B5A8
0B594:  XORLW  01
0B596:  BTFSC  FD8.2
0B598:  BRA    B778
0B59A:  XORLW  03
0B59C:  BTFSC  FD8.2
0B59E:  BRA    BBF8
0B5A0:  XORLW  01
0B5A2:  BTFSC  FD8.2
0B5A4:  BRA    BC0A
0B5A6:  BRA    BC46
....................       {    
....................          case BREATH_TEST_NOT_RUN: 
....................             
....................             if( deltaP >= dPressureThresheldStart )//&& abs((int32_t)deltaP - (int32_t)prevdeltaP)>6)//Start or continue volume accumulation 
0B5A8:  MOVLB  7
0B5AA:  MOVF   xB6,W
0B5AC:  SUBWF  x2A,W
0B5AE:  BNC   B65A
0B5B0:  BNZ   B5C8
0B5B2:  MOVF   xB5,W
0B5B4:  SUBWF  x29,W
0B5B6:  BNC   B65A
0B5B8:  BNZ   B5C8
0B5BA:  MOVF   xB4,W
0B5BC:  SUBWF  x28,W
0B5BE:  BNC   B65A
0B5C0:  BNZ   B5C8
0B5C2:  MOVF   xB3,W
0B5C4:  SUBWF  x27,W
0B5C6:  BNC   B65A
....................             { 
....................                deltaVol_1 = GetNewVolume(dPressureThresheldStart/2, deltaT); // 
0B5C8:  BCF    FD8.0
0B5CA:  RRCF   xB6,W
0B5CC:  MOVLB  8
0B5CE:  MOVWF  x15
0B5D0:  MOVLB  7
0B5D2:  RRCF   xB5,W
0B5D4:  MOVLB  8
0B5D6:  MOVWF  x14
0B5D8:  MOVLB  7
0B5DA:  RRCF   xB4,W
0B5DC:  MOVLB  8
0B5DE:  MOVWF  x13
0B5E0:  MOVLB  7
0B5E2:  RRCF   xB3,W
0B5E4:  MOVLB  8
0B5E6:  MOVWF  x12
0B5E8:  MOVFF  815,819
0B5EC:  MOVFF  814,818
0B5F0:  MOVFF  813,817
0B5F4:  MOVWF  x16
0B5F6:  MOVFF  726,81D
0B5FA:  MOVFF  725,81C
0B5FE:  MOVFF  724,81B
0B602:  MOVFF  723,81A
0B606:  MOVLB  0
0B608:  CALL   9BBA
0B60C:  MOVFF  03,7C6
0B610:  MOVFF  02,7C5
0B614:  MOVFF  01,7C4
0B618:  MOVFF  00,7C3
....................                AccumulatedVolume1_ml = deltaVol_1; 
0B61C:  MOVFF  7C6,7C2
0B620:  MOVFF  7C5,7C1
0B624:  MOVFF  7C4,7C0
0B628:  MOVFF  7C3,7BF
....................                accumulatedTimeMs = deltaT; 
0B62C:  MOVFF  726,71A
0B630:  MOVFF  725,719
0B634:  MOVFF  724,718
0B638:  MOVFF  723,717
....................                lowPressureLastCount = 0; 
0B63C:  MOVLB  7
0B63E:  CLRF   x12
0B640:  CLRF   x11
0B642:  CLRF   x10
0B644:  CLRF   x0F
....................                breathTestState = BREATH_TEST_STARTED; 
0B646:  MOVLW  01
0B648:  MOVWF  xCB
....................                timerFlag = ON; 
0B64A:  MOVWF  xA7
....................  
....................                //Test stared turn of notification light 
....................                output_low(ILLUMINATION_588); 
0B64C:  BCF    F94.0
0B64E:  BCF    F8B.0
....................                inVolumeAccumulation = 1;//no longer needed 
0B650:  CLRF   x16
0B652:  CLRF   x15
0B654:  CLRF   x14
0B656:  MOVWF  x13
....................                 
.................... #ifdef DEBUG 
....................                fprintf(STDOUT, "\r\n\r\n"); 
.................... #endif                
....................             } 
0B658:  BRA    B776
....................        
....................             else 
....................             { 
....................                startPressure = pressure1;   
0B65A:  MOVFF  71E,70A
0B65E:  MOVFF  71D,709
0B662:  MOVFF  71C,708
0B666:  MOVFF  71B,707
....................                timer_current = get_ticks(); 
0B66A:  MOVLB  0
0B66C:  CALL   43C2
0B670:  MOVFF  03,79E
0B674:  MOVFF  02,79D
0B678:  MOVFF  01,79C
0B67C:  MOVFF  00,79B
....................                timer_diff = timer_current - timer_previous; 
0B680:  MOVLB  7
0B682:  MOVF   xA3,W
0B684:  SUBWF  x9B,W
0B686:  MOVWF  x9F
0B688:  MOVF   xA4,W
0B68A:  SUBWFB x9C,W
0B68C:  MOVWF  xA0
0B68E:  MOVF   xA5,W
0B690:  SUBWFB x9D,W
0B692:  MOVWF  xA1
0B694:  MOVF   xA6,W
0B696:  SUBWFB x9E,W
0B698:  MOVWF  xA2
....................                 
....................                 
....................                if( timer_diff > 4500 ) 
0B69A:  MOVF   xA2,F
0B69C:  BNZ   B6B2
0B69E:  MOVF   xA1,F
0B6A0:  BNZ   B6B2
0B6A2:  MOVF   xA0,W
0B6A4:  SUBLW  10
0B6A6:  BC    B6D0
0B6A8:  XORLW  FF
0B6AA:  BNZ   B6B2
0B6AC:  MOVF   x9F,W
0B6AE:  SUBLW  94
0B6B0:  BC    B6D0
....................                { 
....................                   illumination_brightness( 30 ); 
0B6B2:  MOVLW  1E
0B6B4:  MOVLB  8
0B6B6:  MOVWF  x12
0B6B8:  MOVLB  0
0B6BA:  CALL   42F2
....................                   illumination_use(ILLUMINATION_588); 
0B6BE:  MOVLW  7C
0B6C0:  MOVLB  8
0B6C2:  MOVWF  x13
0B6C4:  MOVLW  10
0B6C6:  MOVWF  x12
0B6C8:  MOVLB  0
0B6CA:  CALL   4394
0B6CE:  MOVLB  7
....................                } 
....................                 
....................                if( timer_diff > FIVE_SECONDS ) 
0B6D0:  MOVF   xA2,F
0B6D2:  BNZ   B6E8
0B6D4:  MOVF   xA1,F
0B6D6:  BNZ   B6E8
0B6D8:  MOVF   xA0,W
0B6DA:  SUBLW  12
0B6DC:  BC    B71C
0B6DE:  XORLW  FF
0B6E0:  BNZ   B6E8
0B6E2:  MOVF   x9F,W
0B6E4:  SUBLW  88
0B6E6:  BC    B71C
....................                { 
....................                   output_low(ILLUMINATION_588); 
0B6E8:  BCF    F94.0
0B6EA:  BCF    F8B.0
....................                   timerCtr += timer_diff; 
0B6EC:  MOVF   x9F,W
0B6EE:  ADDWF  x03,F
0B6F0:  MOVF   xA0,W
0B6F2:  ADDWFC x04,F
0B6F4:  MOVF   xA1,W
0B6F6:  ADDWFC x05,F
0B6F8:  MOVF   xA2,W
0B6FA:  ADDWFC x06,F
....................                   timer_previous = timer_current; 
0B6FC:  MOVFF  79E,7A6
0B700:  MOVFF  79D,7A5
0B704:  MOVFF  79C,7A4
0B708:  MOVFF  79B,7A3
....................                   fprintf(STDOUT, "Unit is ready for testing, please start breathing into the mouth piece\r\n\r\n"); 
0B70C:  MOVLW  92
0B70E:  MOVWF  FF6
0B710:  MOVLW  1A
0B712:  MOVWF  FF7
0B714:  MOVLB  0
0B716:  CALL   2CA0
0B71A:  MOVLB  7
....................                } 
....................  
....................                if( timerCtr > FOUR_MINUTES ) 
0B71C:  MOVF   x06,F
0B71E:  BNZ   B73A
0B720:  MOVF   x05,W
0B722:  SUBLW  02
0B724:  BC    B776
0B726:  XORLW  FF
0B728:  BNZ   B73A
0B72A:  MOVF   x04,W
0B72C:  SUBLW  A8
0B72E:  BC    B776
0B730:  XORLW  FF
0B732:  BNZ   B73A
0B734:  MOVF   x03,W
0B736:  SUBLW  80
0B738:  BC    B776
....................                { 
....................                   breathTestState = BREATH_TEST_ENDED; 
0B73A:  MOVLW  04
0B73C:  MOVWF  xCB
....................                   bleNotifyErrorSet(TIME_OUT); 
0B73E:  MOVLW  64
0B740:  MOVLB  8
0B742:  MOVWF  x12
0B744:  MOVLB  0
0B746:  CALL   3A78
....................                   delay_ms( ONE_MINUTE ); 
0B74A:  MOVLW  F0
0B74C:  MOVLB  8
0B74E:  MOVWF  x12
0B750:  MOVLW  FA
0B752:  MOVWF  x18
0B754:  MOVLB  0
0B756:  CALL   2D2E
0B75A:  MOVLB  8
0B75C:  DECFSZ x12,F
0B75E:  BRA    B750
....................                   testResult.status = TIME_OUT; 
0B760:  MOVLW  64
0B762:  MOVLB  2
0B764:  MOVWF  x18
....................                   illumination_all_off();     
0B766:  MOVLB  0
0B768:  CALL   4344
....................                   timer_previous = 0; 
0B76C:  MOVLB  7
0B76E:  CLRF   xA6
0B770:  CLRF   xA5
0B772:  CLRF   xA4
0B774:  CLRF   xA3
....................                } 
....................             }       
....................              
....................             break; 
0B776:  BRA    BC5C
....................     
....................          case BREATH_TEST_STARTED: 
....................             
.................... //            fprintf(STDOUT, "Breath volume setting %lu\r\n", breathVolume);    
....................             output_low(ILLUMINATION_588); 
0B778:  BCF    F94.0
0B77A:  BCF    F8B.0
....................             deltaVol_1 = GetNewVolume(deltaP, deltaT); 
0B77C:  MOVFF  72A,819
0B780:  MOVFF  729,818
0B784:  MOVFF  728,817
0B788:  MOVFF  727,816
0B78C:  MOVFF  726,81D
0B790:  MOVFF  725,81C
0B794:  MOVFF  724,81B
0B798:  MOVFF  723,81A
0B79C:  CALL   9BBA
0B7A0:  MOVFF  03,7C6
0B7A4:  MOVFF  02,7C5
0B7A8:  MOVFF  01,7C4
0B7AC:  MOVFF  00,7C3
....................             tmpVol = AccumulatedVolume1_ml += deltaVol_1; 
0B7B0:  BCF    FD8.1
0B7B2:  MOVFF  7C2,835
0B7B6:  MOVFF  7C1,834
0B7BA:  MOVFF  7C0,833
0B7BE:  MOVFF  7BF,832
0B7C2:  MOVFF  7C6,839
0B7C6:  MOVFF  7C5,838
0B7CA:  MOVFF  7C4,837
0B7CE:  MOVFF  7C3,836
0B7D2:  CALL   6880
0B7D6:  MOVFF  03,7C2
0B7DA:  MOVFF  02,7C1
0B7DE:  MOVFF  01,7C0
0B7E2:  MOVFF  00,7BF
0B7E6:  MOVFF  7C2,7CA
0B7EA:  MOVFF  7C1,7C9
0B7EE:  MOVFF  7C0,7C8
0B7F2:  MOVFF  7BF,7C7
....................             accumulatedTimeMs += deltaT; 
0B7F6:  MOVLB  7
0B7F8:  MOVF   x23,W
0B7FA:  ADDWF  x17,F
0B7FC:  MOVF   x24,W
0B7FE:  ADDWFC x18,F
0B800:  MOVF   x25,W
0B802:  ADDWFC x19,F
0B804:  MOVF   x26,W
0B806:  ADDWFC x1A,F
....................  
....................             tmpVol = breathVolume + 10 - tmpVol; 
0B808:  MOVLW  0A
0B80A:  MOVLB  2
0B80C:  ADDWF  x03,W
0B80E:  MOVLB  8
0B810:  MOVWF  x12
0B812:  MOVLW  00
0B814:  MOVLB  2
0B816:  ADDWFC x04,W
0B818:  MOVLB  8
0B81A:  MOVWF  x13
0B81C:  CLRF   19
0B81E:  BTFSC  FF2.7
0B820:  BSF    19.7
0B822:  BCF    FF2.7
0B824:  MOVFF  FE8,967
0B828:  MOVFF  812,966
0B82C:  MOVLB  0
0B82E:  CALL   099A
0B832:  BTFSC  19.7
0B834:  BSF    FF2.7
0B836:  BSF    FD8.1
0B838:  MOVFF  03,835
0B83C:  MOVFF  02,834
0B840:  MOVFF  01,833
0B844:  MOVFF  00,832
0B848:  MOVFF  7CA,839
0B84C:  MOVFF  7C9,838
0B850:  MOVFF  7C8,837
0B854:  MOVFF  7C7,836
0B858:  CALL   6880
0B85C:  MOVFF  03,7CA
0B860:  MOVFF  02,7C9
0B864:  MOVFF  01,7C8
0B868:  MOVFF  00,7C7
0B86C:  CLRF   19
0B86E:  BTFSC  FF2.7
0B870:  BSF    19.7
0B872:  BCF    FF2.7
....................             float tmpVol1 = tmpVol / breathVolume;  
0B874:  MOVFF  204,967
0B878:  MOVFF  203,966
0B87C:  CALL   099A
0B880:  BTFSC  19.7
0B882:  BSF    FF2.7
0B884:  MOVFF  7CA,819
0B888:  MOVFF  7C9,818
0B88C:  MOVFF  7C8,817
0B890:  MOVFF  7C7,816
0B894:  MOVFF  03,81D
0B898:  MOVFF  02,81C
0B89C:  MOVFF  01,81B
0B8A0:  MOVFF  00,81A
0B8A4:  CALL   6272
0B8A8:  MOVFF  03,811
0B8AC:  MOVFF  02,810
0B8B0:  MOVFF  01,80F
0B8B4:  MOVFF  00,80E
....................             tmpVol1 *= 100;               
0B8B8:  MOVFF  811,835
0B8BC:  MOVFF  810,834
0B8C0:  MOVFF  80F,833
0B8C4:  MOVFF  80E,832
0B8C8:  MOVLB  8
0B8CA:  CLRF   x39
0B8CC:  CLRF   x38
0B8CE:  MOVLW  48
0B8D0:  MOVWF  x37
0B8D2:  MOVLW  85
0B8D4:  MOVWF  x36
0B8D6:  MOVLB  0
0B8D8:  CALL   3F30
0B8DC:  MOVFF  03,811
0B8E0:  MOVFF  02,810
0B8E4:  MOVFF  01,80F
0B8E8:  MOVFF  00,80E
....................  
....................             //illumination_brightness( tmpVol1 ); 
....................             //illumination_use(ILLUMINATION_588); 
....................              
....................             //Reach the test mid-point - update the BLE data struct 
....................             if( ( tmpVol1 > 48 ) && ( tmpVol1 < 52 ) )       
0B8EC:  MOVLB  8
0B8EE:  CLRF   x15
0B8F0:  CLRF   x14
0B8F2:  MOVLW  40
0B8F4:  MOVWF  x13
0B8F6:  MOVLW  84
0B8F8:  MOVWF  x12
0B8FA:  MOVFF  811,819
0B8FE:  MOVFF  810,818
0B902:  MOVFF  80F,817
0B906:  MOVFF  80E,816
0B90A:  MOVLB  0
0B90C:  CALL   3EB6
0B910:  BNC   B96C
0B912:  MOVFF  811,815
0B916:  MOVFF  810,814
0B91A:  MOVFF  80F,813
0B91E:  MOVFF  80E,812
0B922:  MOVLB  8
0B924:  CLRF   x19
0B926:  CLRF   x18
0B928:  MOVLW  50
0B92A:  MOVWF  x17
0B92C:  MOVLW  84
0B92E:  MOVWF  x16
0B930:  MOVLB  0
0B932:  CALL   3EB6
0B936:  BNC   B96C
....................             { 
....................                //update the pressure  
....................                testStat.pressure = deltaP; 
0B938:  MOVFF  72A,241
0B93C:  MOVFF  729,240
0B940:  MOVFF  728,23F
0B944:  MOVFF  727,23E
....................                 
....................                //update the temperature 
....................                testStat.temperature = f_PICtoIEEE(temperature); 
0B948:  MOVFF  7BE,23
0B94C:  MOVFF  7BD,22
0B950:  MOVFF  7BC,21
0B954:  MOVFF  7BB,20
0B958:  CALL   66E0
0B95C:  MOVFF  03,23D
0B960:  MOVFF  02,23C
0B964:  MOVFF  01,23B
0B968:  MOVFF  00,23A
....................                 
....................                //update the humidity 
....................                //Note - humidity not define yet... 
....................                 
....................             } 
....................  
....................             if( (AccumulatedVolume1_ml > ( breathVolume - 15 ))  && earlyWarningFlag )       
0B96C:  MOVLW  0F
0B96E:  MOVLB  2
0B970:  SUBWF  x03,W
0B972:  MOVWF  00
0B974:  MOVLW  00
0B976:  SUBWFB x04,W
0B978:  MOVWF  03
0B97A:  MOVF   00,W
0B97C:  CLRF   19
0B97E:  BTFSC  FF2.7
0B980:  BSF    19.7
0B982:  BCF    FF2.7
0B984:  MOVLB  9
0B986:  MOVWF  x66
0B988:  MOVFF  03,967
0B98C:  MOVLB  0
0B98E:  CALL   099A
0B992:  BTFSC  19.7
0B994:  BSF    FF2.7
0B996:  MOVFF  03,815
0B99A:  MOVFF  02,814
0B99E:  MOVFF  01,813
0B9A2:  MOVFF  00,812
0B9A6:  MOVFF  7C2,819
0B9AA:  MOVFF  7C1,818
0B9AE:  MOVFF  7C0,817
0B9B2:  MOVFF  7BF,816
0B9B6:  CALL   3EB6
0B9BA:  BNC   B9E8
0B9BC:  MOVLB  7
0B9BE:  MOVF   xB2,F
0B9C0:  BTFSS  FD8.2
0B9C2:  BRA    B9C8
0B9C4:  MOVLB  0
0B9C6:  BRA    B9E8
....................             { 
....................                //fprintf(STDOUT, "\r\n\r\n Early warning Accumulated Volume %.2f \r\n\r\n", AccumulatedVolume1_ml); 
....................                pwm_on(BUZZER); 
0B9C8:  MOVLW  0C
0B9CA:  MOVLB  F
0B9CC:  IORWF  x57,F
....................                tone(360); 
0B9CE:  MOVLB  8
0B9D0:  CLRF   x15
0B9D2:  CLRF   x14
0B9D4:  MOVLW  01
0B9D6:  MOVWF  x13
0B9D8:  MOVLW  68
0B9DA:  MOVWF  x12
0B9DC:  MOVLB  0
0B9DE:  CALL   4512
....................                earlyWarningFlag = OFF; 
0B9E2:  MOVLB  7
0B9E4:  CLRF   xB2
0B9E6:  MOVLB  0
0B9E8:  CLRF   19
0B9EA:  BTFSC  FF2.7
0B9EC:  BSF    19.7
0B9EE:  BCF    FF2.7
....................             } 
....................  
....................             if( AccumulatedVolume1_ml >= breathVolume )    
0B9F0:  MOVFF  204,967
0B9F4:  MOVFF  203,966
0B9F8:  CALL   099A
0B9FC:  BTFSC  19.7
0B9FE:  BSF    FF2.7
0BA00:  MOVFF  03,815
0BA04:  MOVFF  02,814
0BA08:  MOVFF  01,813
0BA0C:  MOVFF  00,812
0BA10:  MOVFF  7C2,819
0BA14:  MOVFF  7C1,818
0BA18:  MOVFF  7C0,817
0BA1C:  MOVFF  7BF,816
0BA20:  CALL   3EB6
0BA24:  BC    BA28
0BA26:  BNZ   BA5C
....................             { 
....................                testStat.volume = (uint16_t)AccumulatedVolume1_ml; 
0BA28:  MOVFF  7C2,815
0BA2C:  MOVFF  7C1,814
0BA30:  MOVFF  7C0,813
0BA34:  MOVFF  7BF,812
0BA38:  CALL   3B6C
0BA3C:  MOVFF  02,243
0BA40:  MOVFF  01,242
....................                breathTestState = BREATH_TEST_COMPLETED; 
0BA44:  MOVLW  03
0BA46:  MOVLB  7
0BA48:  MOVWF  xCB
....................                bleNotifyErrorSet(NO_ERROR); 
0BA4A:  MOVLB  8
0BA4C:  CLRF   x12
0BA4E:  MOVLB  0
0BA50:  CALL   3A78
....................                status = PASS; 
0BA54:  MOVLW  01
0BA56:  MOVLB  7
0BA58:  MOVWF  xCC
0BA5A:  MOVLB  0
....................             } 
....................              
....................             if( prevdeltaP == deltaP || prevdeltaP + 1 == deltaP || prevdeltaP - 1 == deltaP ) 
0BA5C:  MOVLB  7
0BA5E:  MOVF   x27,W
0BA60:  SUBWF  x2B,W
0BA62:  BNZ   BA76
0BA64:  MOVF   x28,W
0BA66:  SUBWF  x2C,W
0BA68:  BNZ   BA76
0BA6A:  MOVF   x29,W
0BA6C:  SUBWF  x2D,W
0BA6E:  BNZ   BA76
0BA70:  MOVF   x2A,W
0BA72:  SUBWF  x2E,W
0BA74:  BZ    BB1C
0BA76:  MOVLW  01
0BA78:  ADDWF  x2B,W
0BA7A:  MOVLB  8
0BA7C:  MOVWF  x12
0BA7E:  MOVLW  00
0BA80:  MOVLB  7
0BA82:  ADDWFC x2C,W
0BA84:  MOVLB  8
0BA86:  MOVWF  x13
0BA88:  MOVLW  00
0BA8A:  MOVLB  7
0BA8C:  ADDWFC x2D,W
0BA8E:  MOVLB  8
0BA90:  MOVWF  x14
0BA92:  MOVLW  00
0BA94:  MOVLB  7
0BA96:  ADDWFC x2E,W
0BA98:  MOVLB  8
0BA9A:  MOVWF  x15
0BA9C:  MOVLB  7
0BA9E:  MOVF   x27,W
0BAA0:  MOVLB  8
0BAA2:  SUBWF  x12,W
0BAA4:  BNZ   BACA
0BAA6:  MOVLB  7
0BAA8:  MOVF   x28,W
0BAAA:  MOVLB  8
0BAAC:  SUBWF  x13,W
0BAAE:  BNZ   BACA
0BAB0:  MOVLB  7
0BAB2:  MOVF   x29,W
0BAB4:  MOVLB  8
0BAB6:  SUBWF  x14,W
0BAB8:  BNZ   BACA
0BABA:  MOVLB  7
0BABC:  MOVF   x2A,W
0BABE:  MOVLB  8
0BAC0:  SUBWF  x15,W
0BAC2:  BTFSS  FD8.2
0BAC4:  BRA    BACA
0BAC6:  MOVLB  7
0BAC8:  BRA    BB1C
0BACA:  MOVLW  01
0BACC:  MOVLB  7
0BACE:  SUBWF  x2B,W
0BAD0:  MOVLB  8
0BAD2:  MOVWF  x12
0BAD4:  MOVLW  00
0BAD6:  MOVLB  7
0BAD8:  SUBWFB x2C,W
0BADA:  MOVLB  8
0BADC:  MOVWF  x13
0BADE:  MOVLW  00
0BAE0:  MOVLB  7
0BAE2:  SUBWFB x2D,W
0BAE4:  MOVLB  8
0BAE6:  MOVWF  x14
0BAE8:  MOVLW  00
0BAEA:  MOVLB  7
0BAEC:  SUBWFB x2E,W
0BAEE:  MOVLB  8
0BAF0:  MOVWF  x15
0BAF2:  MOVLB  7
0BAF4:  MOVF   x27,W
0BAF6:  MOVLB  8
0BAF8:  SUBWF  x12,W
0BAFA:  BNZ   BB22
0BAFC:  MOVLB  7
0BAFE:  MOVF   x28,W
0BB00:  MOVLB  8
0BB02:  SUBWF  x13,W
0BB04:  BNZ   BB22
0BB06:  MOVLB  7
0BB08:  MOVF   x29,W
0BB0A:  MOVLB  8
0BB0C:  SUBWF  x14,W
0BB0E:  BNZ   BB22
0BB10:  MOVLB  7
0BB12:  MOVF   x2A,W
0BB14:  MOVLB  8
0BB16:  SUBWF  x15,W
0BB18:  BNZ   BB22
0BB1A:  MOVLB  7
....................             { 
....................                pressureChangeNotDetected++; 
0BB1C:  INCF   xB1,F
.................... //               fprintf(STDOUT, "\r\nChange in deltaP not detected**** %d \r\n\r\n", pressureChangeNotDetected); 
....................             } 
0BB1E:  BRA    BB26
0BB20:  MOVLB  8
....................                 
....................             else 
....................             { 
....................                pressureChangeNotDetected = 0; 
0BB22:  MOVLB  7
0BB24:  CLRF   xB1
.................... //               fprintf(STDOUT, "\r\nPressure change detected \r\n\r\n"); 
....................             } 
....................  
.................... //            if( ( deltaP < dPressureThresheldEnd ) ||  ( abs((int32_t)deltaP - (int32_t)prevdeltaP)<4 ) ) 
.................... //            if( deltaP < dPressureThresheldEnd ) 
....................  
....................             if( deltaP < dPressureThresheldEnd || pressureChangeNotDetected >= 2 ) 
0BB26:  MOVF   x2A,W
0BB28:  SUBWF  xBA,W
0BB2A:  BNC   BB44
0BB2C:  BNZ   BB4A
0BB2E:  MOVF   x29,W
0BB30:  SUBWF  xB9,W
0BB32:  BNC   BB44
0BB34:  BNZ   BB4A
0BB36:  MOVF   x28,W
0BB38:  SUBWF  xB8,W
0BB3A:  BNC   BB44
0BB3C:  BNZ   BB4A
0BB3E:  MOVF   xB7,W
0BB40:  SUBWF  x27,W
0BB42:  BNC   BB4A
0BB44:  MOVF   xB1,W
0BB46:  SUBLW  01
0BB48:  BC    BBF6
....................             {   
....................                lowPressureLastCount++; 
0BB4A:  MOVLW  01
0BB4C:  ADDWF  x0F,F
0BB4E:  BTFSC  FD8.0
0BB50:  INCF   x10,F
0BB52:  BTFSC  FD8.2
0BB54:  INCF   x11,F
0BB56:  BTFSC  FD8.2
0BB58:  INCF   x12,F
....................                 
....................                if(lowPressureLastCount > 2) 
0BB5A:  MOVF   x12,F
0BB5C:  BNZ   BB6C
0BB5E:  MOVF   x11,F
0BB60:  BNZ   BB6C
0BB62:  MOVF   x10,F
0BB64:  BNZ   BB6C
0BB66:  MOVF   x0F,W
0BB68:  SUBLW  02
0BB6A:  BC    BBF4
....................                { 
....................                   output_low(ILLUMINATION_588); 
0BB6C:  BCF    F94.0
0BB6E:  BCF    F8B.0
....................                   startCount = 5; 
0BB70:  CLRF   x0E
0BB72:  CLRF   x0D
0BB74:  CLRF   x0C
0BB76:  MOVLW  05
0BB78:  MOVWF  x0B
....................                   deltaP = pressure1 = _Pressure = pressure_received = 0; 
0BB7A:  CLRF   x36
0BB7C:  CLRF   x35
0BB7E:  CLRF   x34
0BB80:  CLRF   x33
0BB82:  MOVFF  736,7F1
0BB86:  MOVFF  735,7F0
0BB8A:  MOVFF  734,7EF
0BB8E:  MOVFF  733,7EE
0BB92:  MOVFF  7F1,71E
0BB96:  MOVFF  7F0,71D
0BB9A:  MOVFF  7EF,71C
0BB9E:  MOVFF  7EE,71B
0BBA2:  MOVFF  71E,72A
0BBA6:  MOVFF  71D,729
0BBAA:  MOVFF  71C,728
0BBAE:  MOVFF  71B,727
....................                   AccumulatedVolume1_ml = 0.0; //AccumulatedVolume2_ml = 0.0; 
0BBB2:  CLRF   xC2
0BBB4:  CLRF   xC1
0BBB6:  CLRF   xC0
0BBB8:  CLRF   xBF
....................                   accumulatedTimeMs = 0; 
0BBBA:  CLRF   x1A
0BBBC:  CLRF   x19
0BBBE:  CLRF   x18
0BBC0:  CLRF   x17
....................                   numberOfAttempts++; 
0BBC2:  INCF   xAE,F
....................                   inVolumeAccumulation = 0; 
0BBC4:  CLRF   x16
0BBC6:  CLRF   x15
0BBC8:  CLRF   x14
0BBCA:  CLRF   x13
....................                   lowPressureLastCount = 0; 
0BBCC:  CLRF   x12
0BBCE:  CLRF   x11
0BBD0:  CLRF   x10
0BBD2:  CLRF   x0F
....................                   earlyWarningFlag = ON; 
0BBD4:  MOVLW  01
0BBD6:  MOVWF  xB2
....................                   pwm_off(BUZZER); 
0BBD8:  MOVLW  F0
0BBDA:  MOVLB  F
0BBDC:  ANDWF  x57,F
....................                   breathTestState = BREATH_TEST_NOT_RUN; 
0BBDE:  MOVLB  7
0BBE0:  CLRF   xCB
....................                   bleNotifyErrorSet(BAD_BLOW_PRESSURE); 
0BBE2:  MOVLW  08
0BBE4:  MOVLB  8
0BBE6:  MOVWF  x12
0BBE8:  MOVLB  0
0BBEA:  CALL   3A78
....................                   status = LOW_PRESSURE_BREATH; 
0BBEE:  MOVLW  03
0BBF0:  MOVLB  7
0BBF2:  MOVWF  xCC
....................                    
.................... #ifdef DEBUG 
....................                   fprintf(STDOUT, "\r\n\r\n Volume reset to 0, P1= %lu, lowPressureLastCount= %lu,  deltaP= %lu/%lu \r\n\r\n", pressure1, lowPressureLastCount, prevdeltaP, deltaP); 
.................... #endif         
....................               
....................                } 
....................                 
....................                pressureChangeNotDetected = 0; 
0BBF4:  CLRF   xB1
....................             } 
....................  
....................             break; 
0BBF6:  BRA    BC5C
....................  
....................          case BREATH_TEST_EXITING: 
....................             breathTestState = BREATH_TEST_COMPLETED; 
0BBF8:  MOVLW  03
0BBFA:  MOVLB  7
0BBFC:  MOVWF  xCB
....................             testStat.numOfBlowAttempts = numberOfAttempts; 
0BBFE:  MOVLB  2
0BC00:  CLRF   x47
0BC02:  MOVFF  7AE,246
....................              
....................             break; 
0BC06:  MOVLB  7
0BC08:  BRA    BC5C
....................     
....................          case BREATH_TEST_COMPLETED: 
....................             fprintf(STDOUT, "\r\n\r\n"); 
0BC0A:  MOVLW  DE
0BC0C:  MOVWF  FF6
0BC0E:  MOVLW  1A
0BC10:  MOVWF  FF7
0BC12:  CALL   2CA0
....................             pwm_off(BUZZER); 
0BC16:  MOVLW  F0
0BC18:  MOVLB  F
0BC1A:  ANDWF  x57,F
....................             AccumulatedVolume1_ml = 0.0; //AccumulatedVolume2_ml = 0.0; 
0BC1C:  MOVLB  7
0BC1E:  CLRF   xC2
0BC20:  CLRF   xC1
0BC22:  CLRF   xC0
0BC24:  CLRF   xBF
....................             deltaVol_1 = 0.0; 
0BC26:  CLRF   xC6
0BC28:  CLRF   xC5
0BC2A:  CLRF   xC4
0BC2C:  CLRF   xC3
....................             accumulatedTimeMs = 0; 
0BC2E:  CLRF   x1A
0BC30:  CLRF   x19
0BC32:  CLRF   x18
0BC34:  CLRF   x17
....................             inVolumeAccumulation = 0; 
0BC36:  CLRF   x16
0BC38:  CLRF   x15
0BC3A:  CLRF   x14
0BC3C:  CLRF   x13
....................             breathTestState = BREATH_TEST_ENDED; 
0BC3E:  MOVLW  04
0BC40:  MOVWF  xCB
....................             break;   
0BC42:  BRA    BC5C
0BC44:  MOVLB  0
....................     
....................          default: 
....................             status = BME680_SENSOR_FAIL;  
0BC46:  MOVLW  10
0BC48:  MOVLB  7
0BC4A:  MOVWF  xCC
....................             fprintf(STDOUT, " ******* BME state machine failed *******");  
0BC4C:  MOVLW  E4
0BC4E:  MOVWF  FF6
0BC50:  MOVLW  1A
0BC52:  MOVWF  FF7
0BC54:  MOVLB  0
0BC56:  CALL   2CA0
0BC5A:  MOVLB  7
....................       } 
....................  
....................       prevTimeStamp1 = timeStamp1;  
0BC5C:  MOVFF  722,460
0BC60:  MOVFF  721,45F
0BC64:  MOVFF  720,45E
0BC68:  MOVFF  71F,45D
....................  
.................... #ifdef DEBUG 
....................       float BreathTimePeriod = (float)accumulatedTimeMs/(1000.0); 
....................       fprintf(STDOUT, "%lu / %05lu ms: Humidity %0.2f%%, Temp %lu / %.2f, pressure_received %lu pressure_comp %lu\r\n",   
....................       count, timeTickMs, humi, temperature_received, temperature, pressure_received, pressure_comp); 
....................       fprintf(STDOUT, "%lu / %05lu ms: Temp %08LX / %.2f, pressure_received %08LX pressure_comp %lu\r\n",   
....................       count, timeTickMs, temperature_received, temperature, pressure_received, pressure_comp); 
....................       temperature_received = pressure_received = humidity_received = gas_received = 0;       
.................... #endif 
....................  
....................        
....................  
....................       if( breathTestState == BREATH_TEST_ENDED ) 
0BC6C:  MOVF   xCB,W
0BC6E:  SUBLW  04
0BC70:  BNZ   BC76
....................          break; 
0BC72:  BRA    BF44
0BC74:  BRA    BF2C
....................        
....................       else 
....................       { 
....................          if( AccumulatedVolume1_ml > 0 ) 
0BC76:  MOVLB  8
0BC78:  CLRF   x15
0BC7A:  CLRF   x14
0BC7C:  CLRF   x13
0BC7E:  CLRF   x12
0BC80:  MOVFF  7C2,819
0BC84:  MOVFF  7C1,818
0BC88:  MOVFF  7C0,817
0BC8C:  MOVFF  7BF,816
0BC90:  MOVLB  0
0BC92:  CALL   3EB6
0BC96:  BTFSS  FD8.0
0BC98:  BRA    BF2A
....................          { 
....................             fprintf(STDOUT, "%lu / %05lu ms: state %d, %lu; Temp %.2f; CurrentPressure: %lu; BasePressure: %lu; deltaP: %lu/%lu; flowLPM: %.2f; deltaVol: %.2f; AccumulatedVolume: %.2f ml\r\n",   
....................             count, timeStamp1, breathTestState, lowPressureLastCount, temperature, pressure1, startPressure, prevdeltaP, deltaP, flowLPM, deltaVol_1, AccumulatedVolume1_ml ); 
0BC9A:  MOVLW  41
0BC9C:  MOVWF  FE9
0BC9E:  MOVFF  7D0,815
0BCA2:  MOVFF  7CF,814
0BCA6:  MOVFF  7CE,813
0BCAA:  MOVFF  7CD,812
0BCAE:  CALL   9C78
0BCB2:  MOVLW  11
0BCB4:  MOVWF  FF6
0BCB6:  MOVLW  1B
0BCB8:  MOVWF  FF7
0BCBA:  CLRF   19
0BCBC:  BTFSC  FF2.7
0BCBE:  BSF    19.7
0BCC0:  BCF    FF2.7
0BCC2:  MOVLW  03
0BCC4:  MOVLB  9
0BCC6:  MOVWF  x66
0BCC8:  MOVLB  0
0BCCA:  CALL   0AAC
0BCCE:  BTFSC  19.7
0BCD0:  BSF    FF2.7
0BCD2:  MOVLW  45
0BCD4:  MOVWF  FE9
0BCD6:  MOVFF  722,815
0BCDA:  MOVFF  721,814
0BCDE:  MOVFF  720,813
0BCE2:  MOVFF  71F,812
0BCE6:  CALL   9C78
0BCEA:  MOVLW  19
0BCEC:  MOVWF  FF6
0BCEE:  MOVLW  1B
0BCF0:  MOVWF  FF7
0BCF2:  CLRF   19
0BCF4:  BTFSC  FF2.7
0BCF6:  BSF    19.7
0BCF8:  BCF    FF2.7
0BCFA:  MOVLW  0B
0BCFC:  MOVLB  9
0BCFE:  MOVWF  x66
0BD00:  MOVLB  0
0BD02:  CALL   0AAC
0BD06:  BTFSC  19.7
0BD08:  BSF    FF2.7
0BD0A:  MOVFF  7CB,812
0BD0E:  MOVLW  18
0BD10:  MOVLB  8
0BD12:  MOVWF  x13
0BD14:  MOVLB  0
0BD16:  CALL   2AEC
0BD1A:  MOVLW  2C
0BD1C:  BTFSS  FA4.4
0BD1E:  BRA    BD1C
0BD20:  MOVWF  F73
0BD22:  MOVLW  20
0BD24:  BTFSS  FA4.4
0BD26:  BRA    BD24
0BD28:  MOVWF  F73
0BD2A:  MOVLW  41
0BD2C:  MOVWF  FE9
0BD2E:  MOVFF  712,815
0BD32:  MOVFF  711,814
0BD36:  MOVFF  710,813
0BD3A:  MOVFF  70F,812
0BD3E:  CALL   9C78
0BD42:  MOVLW  2B
0BD44:  MOVWF  FF6
0BD46:  MOVLW  1B
0BD48:  MOVWF  FF7
0BD4A:  CLRF   19
0BD4C:  BTFSC  FF2.7
0BD4E:  BSF    19.7
0BD50:  BCF    FF2.7
0BD52:  MOVLW  07
0BD54:  MOVLB  9
0BD56:  MOVWF  x66
0BD58:  MOVLB  0
0BD5A:  CALL   0AAC
0BD5E:  BTFSC  19.7
0BD60:  BSF    FF2.7
0BD62:  MOVLW  89
0BD64:  MOVWF  FE9
0BD66:  MOVFF  7BE,815
0BD6A:  MOVFF  7BD,814
0BD6E:  MOVFF  7BC,813
0BD72:  MOVFF  7BB,812
0BD76:  MOVLW  02
0BD78:  MOVLB  8
0BD7A:  MOVWF  x16
0BD7C:  MOVLB  0
0BD7E:  CALL   40FE
0BD82:  MOVLW  36
0BD84:  MOVWF  FF6
0BD86:  MOVLW  1B
0BD88:  MOVWF  FF7
0BD8A:  CLRF   19
0BD8C:  BTFSC  FF2.7
0BD8E:  BSF    19.7
0BD90:  BCF    FF2.7
0BD92:  MOVLW  13
0BD94:  MOVLB  9
0BD96:  MOVWF  x66
0BD98:  MOVLB  0
0BD9A:  CALL   0AAC
0BD9E:  BTFSC  19.7
0BDA0:  BSF    FF2.7
0BDA2:  MOVLW  41
0BDA4:  MOVWF  FE9
0BDA6:  MOVFF  71E,815
0BDAA:  MOVFF  71D,814
0BDAE:  MOVFF  71C,813
0BDB2:  MOVFF  71B,812
0BDB6:  CALL   9C78
0BDBA:  MOVLW  4C
0BDBC:  MOVWF  FF6
0BDBE:  MOVLW  1B
0BDC0:  MOVWF  FF7
0BDC2:  CLRF   19
0BDC4:  BTFSC  FF2.7
0BDC6:  BSF    19.7
0BDC8:  BCF    FF2.7
0BDCA:  MOVLW  10
0BDCC:  MOVLB  9
0BDCE:  MOVWF  x66
0BDD0:  MOVLB  0
0BDD2:  CALL   0AAC
0BDD6:  BTFSC  19.7
0BDD8:  BSF    FF2.7
0BDDA:  MOVLW  41
0BDDC:  MOVWF  FE9
0BDDE:  MOVFF  70A,815
0BDE2:  MOVFF  709,814
0BDE6:  MOVFF  708,813
0BDEA:  MOVFF  707,812
0BDEE:  CALL   9C78
0BDF2:  MOVLW  5F
0BDF4:  MOVWF  FF6
0BDF6:  MOVLW  1B
0BDF8:  MOVWF  FF7
0BDFA:  CLRF   19
0BDFC:  BTFSC  FF2.7
0BDFE:  BSF    19.7
0BE00:  BCF    FF2.7
0BE02:  MOVLW  0A
0BE04:  MOVLB  9
0BE06:  MOVWF  x66
0BE08:  MOVLB  0
0BE0A:  CALL   0AAC
0BE0E:  BTFSC  19.7
0BE10:  BSF    FF2.7
0BE12:  MOVLW  41
0BE14:  MOVWF  FE9
0BE16:  MOVFF  72E,815
0BE1A:  MOVFF  72D,814
0BE1E:  MOVFF  72C,813
0BE22:  MOVFF  72B,812
0BE26:  CALL   9C78
0BE2A:  MOVLW  2F
0BE2C:  BTFSS  FA4.4
0BE2E:  BRA    BE2C
0BE30:  MOVWF  F73
0BE32:  MOVLW  41
0BE34:  MOVWF  FE9
0BE36:  MOVFF  72A,815
0BE3A:  MOVFF  729,814
0BE3E:  MOVFF  728,813
0BE42:  MOVFF  727,812
0BE46:  CALL   9C78
0BE4A:  MOVLW  70
0BE4C:  MOVWF  FF6
0BE4E:  MOVLW  1B
0BE50:  MOVWF  FF7
0BE52:  CLRF   19
0BE54:  BTFSC  FF2.7
0BE56:  BSF    19.7
0BE58:  BCF    FF2.7
0BE5A:  MOVLW  0B
0BE5C:  MOVLB  9
0BE5E:  MOVWF  x66
0BE60:  MOVLB  0
0BE62:  CALL   0AAC
0BE66:  BTFSC  19.7
0BE68:  BSF    FF2.7
0BE6A:  MOVLW  89
0BE6C:  MOVWF  FE9
0BE6E:  MOVFF  45C,815
0BE72:  MOVFF  45B,814
0BE76:  MOVFF  45A,813
0BE7A:  MOVFF  459,812
0BE7E:  MOVLW  02
0BE80:  MOVLB  8
0BE82:  MOVWF  x16
0BE84:  MOVLB  0
0BE86:  CALL   40FE
0BE8A:  MOVLW  7F
0BE8C:  MOVWF  FF6
0BE8E:  MOVLW  1B
0BE90:  MOVWF  FF7
0BE92:  CLRF   19
0BE94:  BTFSC  FF2.7
0BE96:  BSF    19.7
0BE98:  BCF    FF2.7
0BE9A:  MOVLW  0C
0BE9C:  MOVLB  9
0BE9E:  MOVWF  x66
0BEA0:  MOVLB  0
0BEA2:  CALL   0AAC
0BEA6:  BTFSC  19.7
0BEA8:  BSF    FF2.7
0BEAA:  MOVLW  89
0BEAC:  MOVWF  FE9
0BEAE:  MOVFF  7C6,815
0BEB2:  MOVFF  7C5,814
0BEB6:  MOVFF  7C4,813
0BEBA:  MOVFF  7C3,812
0BEBE:  MOVLW  02
0BEC0:  MOVLB  8
0BEC2:  MOVWF  x16
0BEC4:  MOVLB  0
0BEC6:  CALL   40FE
0BECA:  MOVLW  8F
0BECC:  MOVWF  FF6
0BECE:  MOVLW  1B
0BED0:  MOVWF  FF7
0BED2:  CLRF   19
0BED4:  BTFSC  FF2.7
0BED6:  BSF    19.7
0BED8:  BCF    FF2.7
0BEDA:  MOVLW  15
0BEDC:  MOVLB  9
0BEDE:  MOVWF  x66
0BEE0:  MOVLB  0
0BEE2:  CALL   0AAC
0BEE6:  BTFSC  19.7
0BEE8:  BSF    FF2.7
0BEEA:  MOVLW  89
0BEEC:  MOVWF  FE9
0BEEE:  MOVFF  7C2,815
0BEF2:  MOVFF  7C1,814
0BEF6:  MOVFF  7C0,813
0BEFA:  MOVFF  7BF,812
0BEFE:  MOVLW  02
0BF00:  MOVLB  8
0BF02:  MOVWF  x16
0BF04:  MOVLB  0
0BF06:  CALL   40FE
0BF0A:  MOVLW  A8
0BF0C:  MOVWF  FF6
0BF0E:  MOVLW  1B
0BF10:  MOVWF  FF7
0BF12:  CLRF   19
0BF14:  BTFSC  FF2.7
0BF16:  BSF    19.7
0BF18:  BCF    FF2.7
0BF1A:  MOVLW  05
0BF1C:  MOVLB  9
0BF1E:  MOVWF  x66
0BF20:  MOVLB  0
0BF22:  CALL   0AAC
0BF26:  BTFSC  19.7
0BF28:  BSF    FF2.7
0BF2A:  MOVLB  7
....................          } 
....................       } 
....................        
....................       prevdeltaP = deltaP;       
0BF2C:  MOVFF  72A,72E
0BF30:  MOVFF  729,72D
0BF34:  MOVFF  728,72C
0BF38:  MOVFF  727,72B
0BF3C:  MOVLB  0
0BF3E:  GOTO   A204
0BF42:  MOVLB  7
....................    } 
....................     
....................    illumination_all_off(); 
0BF44:  MOVLB  0
0BF46:  CALL   4344
....................    return status; 
0BF4A:  MOVLB  7
0BF4C:  MOVFF  7CC,01
0BF50:  MOVLB  0
0BF52:  GOTO   DAC2 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... int8_t SetBME_Oversampling_and_00IIR(struct bme680_dev *dev, uint8 osrs_h, uint8 osrs_t, uint8 osrs_p, uint8 filter) 
.................... { 
....................    uint8    control_reg; 
....................    uint8    tmp, tmp1; 
....................    uint8    temp_mem_page; 
....................    uint8    tmp_osrs_h, tmp_osrs_t, tmp_osrs_p; 
....................     
....................    tmp_osrs_h = osrs_h; 
....................    tmp_osrs_t = osrs_t;    
....................    tmp_osrs_p = osrs_p; 
....................     
....................    tmp_osrs_t <<= 5;                   
....................    tmp_osrs_p <<= 2;                   
....................     
....................    //Get mem page 
....................    temp_mem_page = Read_Byte(BME680_SPI_STATUS); 
....................     
....................    if( temp_mem_page != BME680_MEM_PAGE1 ) 
....................       Write_Byte( BME680_SPI_STATUS, BME680_MEM_PAGE1 );   //Set mem page to 1 
....................      
....................    //Check the mem page 
....................    temp_mem_page = Read_Byte(BME680_SPI_STATUS); 
....................    temp_mem_page &= 0x10; 
....................     
....................    if( temp_mem_page != BME680_MEM_PAGE1 ) 
....................    { 
.................... #ifdef DEBUG    
....................       fprintf(STDOUT, " Set mem page failed at Oversampling \r\n"); 
.................... #endif       
....................       return BME680_SENSOR_FAIL; 
....................    } 
....................     
....................    //Update the gas sensor structure 
....................    dev->mem_page = temp_mem_page; 
....................  
....................    //Set oversampling for temperature and pressure value 
....................    control_reg = tmp_osrs_t | tmp_osrs_p; 
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "**********control_reg = %02X\r\n", control_reg); 
....................    fprintf(STDOUT, "*********    SPI   MODE   SELECT  *******\r\n"); 
....................  
....................    /* Set Oversampling */ 
....................    //Read values of oversampling register before writing 
....................    Read_Byte(BME680_SPI_CTRL); 
....................    Read_Byte(BME680_SPI_CTRL_HUM); 
.................... #endif 
....................    
....................    //Set oversampling values for temperature, pressure, and humidity 
....................    Write_Byte( BME680_SPI_CTRL_HUM, tmp_osrs_h );   
....................    Write_Byte( BME680_SPI_CTRL, control_reg ); 
....................     
....................    //Read back and verify  
....................    tmp1 = Read_Byte(BME680_SPI_CTRL_HUM); 
....................    tmp = Read_Byte(BME680_SPI_CTRL); 
....................     
....................    tmp1 &= 0x7;     //Mask the 5 MSb  
....................    tmp &= 0xFC;     //Mask the 2 LSb 
....................     
....................    if( tmp1 != osrs_h || tmp != control_reg ) 
....................    { 
.................... #ifdef DEBUG    
....................       fprintf(STDOUT, "*** Failed oversampling setting ***\r\n"); 
.................... #endif    
....................       return BME680_SENSOR_FAIL; 
....................    } 
....................     
....................    //Update the gas sensor structure 
....................    dev->tph_sett.os_hum = osrs_h; 
....................    dev->tph_sett.os_temp = osrs_t; 
....................    dev->tph_sett.os_pres = osrs_p; 
....................     
....................    //Read values of oversampling register after writing 
....................    Read_Byte(BME680_SPI_CTRL); 
....................    Read_Byte(BME680_SPI_CTRL_HUM); 
....................  
....................    /* Set IIR Filter */ 
....................    filter <<= 2; 
....................     
....................    //Set filter values for temperature 
....................    Write_Byte( BME680_SPI_CONFIG, filter );   
....................  
....................    //Read back and verify 
....................    tmp = Read_Byte(BME680_SPI_CONFIG); 
....................    if( tmp != filter ) 
....................    { 
.................... #ifdef DEBUG    
....................       fprintf(STDOUT, "*** Failed IIR setting ***\r\n"); 
.................... #endif    
....................       return BME680_SENSOR_FAIL; 
....................    } 
....................     
....................    //Update the gas sensor structure 
....................    dev->tph_sett.filter = filter; 
....................     
....................    return BME680_OK; 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... int8_t checkBMEPowerUp(struct bme680_dev *dev) 
*
03906:  MOVLB  7
03908:  CLRF   x1C
.................... { 
....................    int8_t rslt = BME680_OK; 
....................    uint8  chipIDAddr; 
....................        
....................    if( dev->intf  == BME680_I2C_INTF)  
0390A:  MOVLW  02
0390C:  ADDWF  x1A,W
0390E:  MOVWF  01
03910:  MOVLW  00
03912:  ADDWFC x1B,W
03914:  MOVWF  03
03916:  MOVFF  01,FE9
0391A:  MOVWF  FEA
0391C:  BTFSS  FEF.0
0391E:  BRA    3926
....................       chipIDAddr = BME680_I2CCHIP_ID_ADDR; 
03920:  MOVLW  D0
03922:  MOVWF  x1D
03924:  BRA    392A
....................  
....................    else       
....................       chipIDAddr = BME680_SPI_CHIP_ID_ADDR; 
03926:  MOVLW  50
03928:  MOVWF  x1D
....................        
....................    /* Check for null pointer in the device structure*/ 
....................    rslt = null_ptr_check(dev); 
0392A:  MOVFF  71B,760
0392E:  MOVFF  71A,75F
03932:  MOVLB  0
03934:  RCALL  317C
03936:  MOVFF  01,71C
....................     
....................    if (rslt != BME680_OK)  
0393A:  MOVLB  7
0393C:  MOVF   x1C,F
0393E:  BZ    3946
....................       return NULL_POINTER_DETECTED; 
03940:  MOVLW  80
03942:  MOVWF  01
03944:  BRA    39D6
....................     
....................    /* Soft reset to restore it to default values*/ 
....................    rslt = bme680_soft_reset(dev); 
03946:  MOVFF  71B,71F
0394A:  MOVFF  71A,71E
0394E:  MOVLB  0
03950:  BRA    333A
03952:  MOVFF  01,71C
....................        
....................    if (rslt != BME680_OK) 
03956:  MOVLB  7
03958:  MOVF   x1C,F
0395A:  BZ    3972
....................    { 
....................       fprintf(STDOUT, "Failed BME_SOFT_RESET \r\n"); 
0395C:  MOVLW  AE
0395E:  MOVWF  FF6
03960:  MOVLW  1B
03962:  MOVWF  FF7
03964:  MOVLB  0
03966:  CALL   2CA0
....................       return BME680_SENSOR_FAIL; 
0396A:  MOVLW  10
0396C:  MOVWF  01
0396E:  MOVLB  7
03970:  BRA    39D6
....................    } 
....................  
....................    dev->chip_id = Read_Byte(chipIDAddr);   
03972:  MOVFF  71A,01
03976:  MOVFF  71B,71F
0397A:  MOVFF  01,71E
0397E:  MOVFF  71D,81B
03982:  MOVLB  0
03984:  RCALL  3222
03986:  MOVFF  71F,FEA
0398A:  MOVFF  71E,FE9
0398E:  MOVFF  01,FEF
....................    if (dev->chip_id != BME680_CHIP_ID)  
03992:  MOVLB  7
03994:  MOVFF  71A,FE9
03998:  MOVFF  71B,FEA
0399C:  MOVF   FEF,W
0399E:  SUBLW  61
039A0:  BZ    39A8
....................       return BME680_SENSOR_FAIL; 
039A2:  MOVLW  10
039A4:  MOVWF  01
039A6:  BRA    39D6
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "BME680_CHIP_ID = %02X\r\n", dev->chip_id); 
.................... #endif    
....................     
....................    /* Get the Calibration data */ 
....................    rslt = get_calib_data(dev); 
039A8:  MOVFF  71B,71F
039AC:  MOVFF  71A,71E
039B0:  MOVLB  0
039B2:  BRA    34EE
039B4:  MOVFF  01,71C
....................     
....................    if (rslt != BME680_OK) 
039B8:  MOVLB  7
039BA:  MOVF   x1C,F
039BC:  BZ    39D2
....................    { 
....................       fprintf(STDOUT, "BME Calib Init failed \r\n"); 
039BE:  MOVLW  C8
039C0:  MOVWF  FF6
039C2:  MOVLW  1B
039C4:  MOVWF  FF7
039C6:  MOVLB  0
039C8:  CALL   2CA0
....................       rslt = BME680_E_DEV_NOT_FOUND; 
039CC:  MOVLW  04
039CE:  MOVLB  7
039D0:  MOVWF  x1C
....................    } 
....................  
.................... #ifdef DEBUG    
....................     rslt = bme680_get_regs(TMP_HUM_ADDR, &temp, 1, dev); 
....................     fprintf(STDOUT, "hum_msb default value = %02X\r\n", temp); 
....................      
....................     rslt = bme680_get_regs(TMP_MSB_ADDR, &temp, 1, dev); 
....................     fprintf(STDOUT, "tmp_msb default value = %02X\r\n", temp); 
....................      
....................     rslt = bme680_get_regs(PRESS_MSB_ADDR, &temp, 1, dev); 
....................     fprintf(STDOUT, "press_msb default value = %02X\r\n", temp); 
.................... #endif 
....................  
....................    return rslt; 
039D2:  MOVFF  71C,01
039D6:  MOVLB  0
039D8:  GOTO   48D8 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /*! 
....................  * @brief This API performs the soft reset of the sensor. 
....................  */ 
.................... int8_t bme680_soft_reset(struct bme680_dev *dev) 
*
0333A:  MOVLB  7
0333C:  CLRF   x20
0333E:  MOVLW  B6
03340:  MOVWF  x23
.................... { 
....................    int8_t   rslt = BME680_OK; 
....................    uint8    temp_mem_page; 
....................    uint8_t  reg_addr; 
....................     
....................    /* 0xb6 is the soft reset command */ 
....................    uint8_t soft_rst_cmd = BME680_SOFT_RESET_CMD; 
....................     
....................    //Set mem page only apply to SPI mode 
....................    if( dev->intf == BME680_I2C_INTF ) 
03342:  MOVLW  02
03344:  ADDWF  x1E,W
03346:  MOVWF  01
03348:  MOVLW  00
0334A:  ADDWFC x1F,W
0334C:  MOVWF  03
0334E:  MOVFF  01,FE9
03352:  MOVWF  FEA
03354:  BTFSS  FEF.0
03356:  BRA    335E
....................       reg_addr = BME680_I2C_SOFT_RESET_ADDR; 
03358:  MOVLW  E0
0335A:  MOVWF  x22
0335C:  BRA    3378
....................     
....................    else 
....................    { 
....................       reg_addr = BME680_SPI_SOFT_RESET_ADDR; 
0335E:  MOVLW  60
03360:  MOVWF  x22
....................       rslt = set_mem_page( reg_addr, dev ); 
03362:  MOVFF  722,812
03366:  MOVFF  71F,814
0336A:  MOVFF  71E,813
0336E:  MOVLB  0
03370:  RCALL  32CC
03372:  MOVFF  01,720
03376:  MOVLB  7
....................    } 
....................          
....................    /* Reset the device */ 
....................    if (rslt != BME680_OK)  
03378:  MOVF   x20,F
0337A:  BZ    3382
....................       return BME680_SENSOR_FAIL; 
0337C:  MOVLW  10
0337E:  MOVWF  01
03380:  BRA    33C0
....................     
....................    Write_Byte(reg_addr, soft_rst_cmd); 
03382:  MOVFF  722,818
03386:  MOVFF  723,819
0338A:  MOVLB  0
0338C:  RCALL  31D0
....................  
....................    /* Wait for 20ms */ 
....................    delay_ms(20); 
0338E:  MOVLW  14
03390:  MOVLB  8
03392:  MOVWF  x18
03394:  MOVLB  0
03396:  RCALL  2D2E
....................    temp_mem_page = Read_Byte(BME680_SPI_STATUS);   
03398:  MOVLW  73
0339A:  MOVLB  8
0339C:  MOVWF  x1B
0339E:  MOVLB  0
033A0:  RCALL  3222
033A2:  MOVFF  01,721
....................    temp_mem_page &= 0x10; 
033A6:  MOVLW  10
033A8:  MOVLB  7
033AA:  ANDWF  x21,F
....................         
....................    //Update the gas sensor structure 
....................    dev->mem_page = temp_mem_page; 
033AC:  MOVLW  03
033AE:  ADDWF  x1E,W
033B0:  MOVWF  FE9
033B2:  MOVLW  00
033B4:  ADDWFC x1F,W
033B6:  MOVWF  FEA
033B8:  MOVFF  721,FEF
....................  
....................    return rslt; 
033BC:  MOVFF  720,01
033C0:  MOVLB  0
033C2:  GOTO   3952 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /*! 
....................  * @brief This API reads the data from the given register address of the sensor. 
....................  */ 
.................... int8_t bme680_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint16_t len, struct bme680_dev *dev) 
.................... { 
....................    int8_t rslt; 
....................  
....................    /* Check for null pointer in the device structure*/ 
....................    rslt = null_ptr_check(dev); 
*
0341A:  MOVFF  75D,760
0341E:  MOVFF  75C,75F
03422:  RCALL  317C
03424:  MOVFF  01,75E
....................    if (rslt == BME680_OK) { 
03428:  MOVLB  7
0342A:  MOVF   x5E,F
0342C:  BNZ   3498
....................       if (dev->intf == BME680_SPI_INTF) { 
0342E:  MOVLW  02
03430:  ADDWF  x5C,W
03432:  MOVWF  01
03434:  MOVLW  00
03436:  ADDWFC x5D,W
03438:  MOVWF  03
0343A:  MOVFF  01,FE9
0343E:  MOVWF  FEA
03440:  BTFSC  FEF.0
03442:  BRA    3460
....................          /* Set the memory page */ 
....................          rslt = set_mem_page(reg_addr, dev); 
03444:  MOVFF  757,812
03448:  MOVFF  75D,814
0344C:  MOVFF  75C,813
03450:  MOVLB  0
03452:  RCALL  32CC
03454:  MOVFF  01,75E
....................          if (rslt == BME680_OK) 
03458:  MOVLB  7
0345A:  MOVF   x5E,F
0345C:  BNZ   3460
....................             reg_addr = reg_addr | BME680_SPI_RD_MSK; 
0345E:  BSF    x57.7
....................       } 
....................        
....................       //rslt = dev->read(dev->dev_id, reg_addr, reg_data, len); 
....................       rslt = Read(dev->dev_id, reg_addr, reg_data, len); 
03460:  MOVLW  01
03462:  ADDWF  x5C,W
03464:  MOVWF  FE9
03466:  MOVLW  00
03468:  ADDWFC x5D,W
0346A:  MOVWF  FEA
0346C:  MOVFF  FEF,760
03470:  MOVFF  757,761
03474:  MOVFF  759,763
03478:  MOVFF  758,762
0347C:  MOVFF  75B,765
03480:  MOVFF  75A,764
03484:  MOVLB  0
03486:  BRA    33C6
03488:  MOVFF  01,75E
....................       if ( rslt != BME680_OK) 
0348C:  MOVLB  7
0348E:  MOVF   x5E,F
03490:  BZ    3498
....................          return BME680_E_COM_FAIL; 
03492:  MOVLW  02
03494:  MOVWF  01
03496:  BRA    349C
....................    } 
....................  
....................    return rslt; 
03498:  MOVFF  75E,01
0349C:  MOVLB  0
0349E:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************************/ 
.................... /*! 
....................  * @brief This internal API is used to calculate the temperature value. 
....................  */ 
.................... int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev) 
.................... { 
....................    int32_t var1; 
....................    int32_t var2; 
....................    int32_t var3; 
....................    int16_t calc_temp; 
....................   
....................    var1 = ((int32_t) temp_adc >> 3) - ((int32_t) dev->calib.par_t1 << 1); 
*
0960A:  MOVLB  8
0960C:  RRCF   x15,W
0960E:  MOVWF  x2A
09610:  RRCF   x14,W
09612:  MOVWF  x29
09614:  RRCF   x13,W
09616:  MOVWF  x28
09618:  RRCF   x12,W
0961A:  MOVWF  x27
0961C:  RRCF   x2A,F
0961E:  RRCF   x29,F
09620:  RRCF   x28,F
09622:  RRCF   x27,F
09624:  RRCF   x2A,F
09626:  RRCF   x29,F
09628:  RRCF   x28,F
0962A:  RRCF   x27,F
0962C:  MOVLW  1F
0962E:  ANDWF  x2A,F
09630:  MOVLW  12
09632:  ADDWF  x16,W
09634:  MOVWF  FE9
09636:  MOVLW  00
09638:  ADDWFC x17,W
0963A:  MOVWF  FEA
0963C:  MOVFF  FEC,82C
09640:  MOVF   FED,F
09642:  MOVFF  FEF,82B
09646:  CLRF   x2D
09648:  CLRF   x2E
0964A:  BCF    FD8.0
0964C:  RLCF   x2B,W
0964E:  MOVWF  00
09650:  RLCF   x2C,W
09652:  MOVWF  01
09654:  RLCF   x2D,W
09656:  MOVWF  02
09658:  RLCF   x2E,W
0965A:  MOVWF  03
0965C:  MOVF   00,W
0965E:  SUBWF  x27,W
09660:  MOVWF  00
09662:  MOVF   01,W
09664:  SUBWFB x28,W
09666:  MOVWF  01
09668:  MOVF   02,W
0966A:  SUBWFB x29,W
0966C:  MOVWF  02
0966E:  MOVF   03,W
09670:  SUBWFB x2A,W
09672:  MOVWF  x1B
09674:  MOVFF  02,81A
09678:  MOVFF  01,819
0967C:  MOVFF  00,818
....................    var2 = (var1 * (int32_t) dev->calib.par_t2) >> 11; 
09680:  MOVLW  14
09682:  ADDWF  x16,W
09684:  MOVWF  FE9
09686:  MOVLW  00
09688:  ADDWFC x17,W
0968A:  MOVWF  FEA
0968C:  MOVFF  FEC,03
09690:  MOVF   FED,F
09692:  MOVFF  FEF,00
09696:  MOVFF  03,01
0969A:  CLRF   02
0969C:  CLRF   03
0969E:  BTFSS  01.7
096A0:  BRA    96A6
096A2:  DECF   02,F
096A4:  DECF   03,F
096A6:  MOVFF  03,829
096AA:  MOVFF  02,828
096AE:  MOVFF  01,827
096B2:  MOVFF  00,826
096B6:  MOVFF  FEA,82B
096BA:  MOVFF  FE9,82A
096BE:  MOVFF  81B,833
096C2:  MOVFF  81A,832
096C6:  MOVFF  819,831
096CA:  MOVFF  818,830
096CE:  MOVFF  03,837
096D2:  MOVFF  02,836
096D6:  MOVFF  01,835
096DA:  MOVFF  00,834
096DE:  MOVLB  0
096E0:  RCALL  95AE
096E2:  MOVFF  82B,FEA
096E6:  MOVFF  82A,FE9
096EA:  MOVFF  03,829
096EE:  MOVFF  02,828
096F2:  MOVFF  01,827
096F6:  MOVFF  00,826
096FA:  CLRF   03
096FC:  MOVLB  8
096FE:  RRCF   x29,W
09700:  MOVWF  02
09702:  RRCF   x28,W
09704:  MOVWF  01
09706:  RRCF   x27,W
09708:  MOVWF  00
0970A:  RRCF   02,F
0970C:  RRCF   01,F
0970E:  RRCF   00,F
09710:  RRCF   02,F
09712:  RRCF   01,F
09714:  RRCF   00,F
09716:  MOVLW  1F
09718:  ANDWF  02,F
0971A:  MOVFF  03,81F
0971E:  MOVFF  02,81E
09722:  MOVFF  01,81D
09726:  MOVFF  00,81C
....................    var3 = ((var1 >> 1) * (var1 >> 1)) >> 12; 
0972A:  BCF    FD8.0
0972C:  RRCF   x1B,W
0972E:  MOVWF  x2A
09730:  RRCF   x1A,W
09732:  MOVWF  x29
09734:  RRCF   x19,W
09736:  MOVWF  x28
09738:  RRCF   x18,W
0973A:  MOVWF  x27
0973C:  BCF    FD8.0
0973E:  RRCF   x1B,W
09740:  MOVWF  03
09742:  RRCF   x1A,W
09744:  MOVWF  02
09746:  RRCF   x19,W
09748:  MOVWF  01
0974A:  RRCF   x18,W
0974C:  MOVWF  00
0974E:  MOVFF  03,82F
09752:  MOVFF  02,82E
09756:  MOVFF  01,82D
0975A:  MOVWF  x2C
0975C:  MOVFF  82A,833
09760:  MOVFF  829,832
09764:  MOVFF  828,831
09768:  MOVFF  827,830
0976C:  MOVFF  03,837
09770:  MOVFF  02,836
09774:  MOVFF  01,835
09778:  MOVWF  x34
0977A:  MOVLB  0
0977C:  RCALL  95AE
0977E:  MOVFF  03,82A
09782:  MOVFF  02,829
09786:  MOVFF  01,828
0978A:  MOVFF  00,827
0978E:  CLRF   03
09790:  MOVLB  8
09792:  RRCF   x2A,W
09794:  MOVWF  02
09796:  RRCF   x29,W
09798:  MOVWF  01
0979A:  RRCF   x28,W
0979C:  MOVWF  00
0979E:  RRCF   02,F
097A0:  RRCF   01,F
097A2:  RRCF   00,F
097A4:  RRCF   02,F
097A6:  RRCF   01,F
097A8:  RRCF   00,F
097AA:  RRCF   02,F
097AC:  RRCF   01,F
097AE:  RRCF   00,F
097B0:  MOVLW  0F
097B2:  ANDWF  02,F
097B4:  MOVFF  03,823
097B8:  MOVFF  02,822
097BC:  MOVFF  01,821
097C0:  MOVFF  00,820
....................    var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14; 
097C4:  MOVLW  16
097C6:  ADDWF  x16,W
097C8:  MOVWF  FE9
097CA:  MOVLW  00
097CC:  ADDWFC x17,W
097CE:  MOVWF  FEA
097D0:  MOVF   FEF,W
097D2:  CLRF   x29
097D4:  CLRF   x28
097D6:  CLRF   x27
097D8:  MOVWF  x26
097DA:  BTFSS  FE8.7
097DC:  BRA    97E4
097DE:  DECF   x27,F
097E0:  DECF   x28,F
097E2:  DECF   x29,F
097E4:  RLCF   x26,W
097E6:  MOVWF  00
097E8:  RLCF   x27,W
097EA:  MOVWF  01
097EC:  RLCF   x28,W
097EE:  MOVWF  02
097F0:  RLCF   x29,W
097F2:  MOVWF  03
097F4:  RLCF   00,F
097F6:  RLCF   01,F
097F8:  RLCF   02,F
097FA:  RLCF   03,F
097FC:  RLCF   00,F
097FE:  RLCF   01,F
09800:  RLCF   02,F
09802:  RLCF   03,F
09804:  RLCF   00,F
09806:  RLCF   01,F
09808:  RLCF   02,F
0980A:  RLCF   03,F
0980C:  MOVLW  F0
0980E:  ANDWF  00,F
09810:  MOVFF  03,829
09814:  MOVFF  02,828
09818:  MOVFF  01,827
0981C:  MOVFF  00,826
09820:  MOVFF  FEA,82C
09824:  MOVFF  FE9,82B
09828:  MOVFF  823,833
0982C:  MOVFF  822,832
09830:  MOVFF  821,831
09834:  MOVFF  820,830
09838:  MOVFF  03,837
0983C:  MOVFF  02,836
09840:  MOVFF  01,835
09844:  MOVFF  00,834
09848:  MOVLB  0
0984A:  RCALL  95AE
0984C:  MOVFF  82C,FEA
09850:  MOVFF  82B,FE9
09854:  MOVFF  03,829
09858:  MOVFF  02,828
0985C:  MOVFF  01,827
09860:  MOVFF  00,826
09864:  CLRF   03
09866:  MOVLB  8
09868:  RRCF   x29,W
0986A:  MOVWF  02
0986C:  RRCF   x28,W
0986E:  MOVWF  01
09870:  RRCF   x27,W
09872:  MOVWF  00
09874:  RRCF   02,F
09876:  RRCF   01,F
09878:  RRCF   00,F
0987A:  RRCF   02,F
0987C:  RRCF   01,F
0987E:  RRCF   00,F
09880:  RRCF   02,F
09882:  RRCF   01,F
09884:  RRCF   00,F
09886:  RRCF   02,F
09888:  RRCF   01,F
0988A:  RRCF   00,F
0988C:  RRCF   02,F
0988E:  RRCF   01,F
09890:  RRCF   00,F
09892:  MOVLW  03
09894:  ANDWF  02,F
09896:  MOVFF  03,823
0989A:  MOVFF  02,822
0989E:  MOVFF  01,821
098A2:  MOVFF  00,820
....................    dev->calib.t_fine = (int32_t) (var2 + var3); 
098A6:  MOVLW  27
098A8:  ADDWF  x16,W
098AA:  MOVWF  FE9
098AC:  MOVLW  00
098AE:  ADDWFC x17,W
098B0:  MOVWF  FEA
098B2:  MOVF   x20,W
098B4:  ADDWF  x1C,W
098B6:  MOVWF  00
098B8:  MOVF   x21,W
098BA:  ADDWFC x1D,W
098BC:  MOVWF  01
098BE:  MOVF   x22,W
098C0:  ADDWFC x1E,W
098C2:  MOVWF  02
098C4:  MOVF   x23,W
098C6:  ADDWFC x1F,W
098C8:  MOVFF  00,FEF
098CC:  MOVFF  01,FEC
098D0:  MOVFF  02,FEC
098D4:  MOVWF  FEC
....................    calc_temp = (int16_t) (((dev->calib.t_fine * 5) + 128) >> 8); 
098D6:  MOVLW  27
098D8:  ADDWF  x16,W
098DA:  MOVWF  FE9
098DC:  MOVLW  00
098DE:  ADDWFC x17,W
098E0:  MOVWF  FEA
098E2:  MOVFF  FEF,830
098E6:  MOVFF  FEC,831
098EA:  MOVFF  FEC,832
098EE:  MOVFF  FEC,833
098F2:  MOVFF  FEA,82B
098F6:  MOVFF  FE9,82A
098FA:  CLRF   x37
098FC:  CLRF   x36
098FE:  CLRF   x35
09900:  MOVLW  05
09902:  MOVWF  x34
09904:  MOVLB  0
09906:  RCALL  95AE
09908:  MOVFF  82B,FEA
0990C:  MOVFF  82A,FE9
09910:  MOVFF  03,829
09914:  MOVFF  02,828
09918:  MOVFF  01,827
0991C:  MOVFF  00,826
09920:  MOVLW  80
09922:  MOVLB  8
09924:  ADDWF  x26,F
09926:  MOVLW  00
09928:  ADDWFC x27,F
0992A:  ADDWFC x28,F
0992C:  ADDWFC x29,F
0992E:  MOVFF  827,824
09932:  MOVFF  828,825
09936:  MOVFF  829,02
0993A:  CLRF   03
....................   
....................    return calc_temp; 
0993C:  MOVFF  824,01
09940:  MOVFF  825,02
09944:  MOVLB  0
09946:  GOTO   A72C (RETURN)
.................... } 
.................... /*****************************************************************************/ 
.................... /*! 
....................  * @brief This internal API is used to read the calibrated data from the sensor. 
....................  */ 
.................... int8_t get_calib_data(struct bme680_dev *dev) 
*
034EE:  MOVLB  7
034F0:  CLRF   x54
034F2:  CLRF   x56
.................... { 
....................    uint32_t    _T1,_T2,_T3; 
....................    uint32_t    _P1,_P2,_P4,_P8,_P9,_P5,_P10; 
....................    int32_t     _P3,_P6,_P7;        
....................     
....................     int8_t  rslt = BME680_OK; 
.................... //    int8_t  temp8; 
.................... //    int16   temp16; 
.................... //    uint8   u_temp8; 
.................... //    uint16  u_temp16; 
....................     uint8   temp_mem_page; 
....................     uint8_t temp_var = 0;     /* Temporary variable */ 
....................      
....................    if( dev->intf != BME680_I2C_INTF )        
034F4:  MOVLW  02
034F6:  ADDWF  x1E,W
034F8:  MOVWF  01
034FA:  MOVLW  00
034FC:  ADDWFC x1F,W
034FE:  MOVWF  03
03500:  MOVFF  01,FE9
03504:  MOVWF  FEA
03506:  BTFSC  FEF.0
03508:  BRA    3556
....................    { 
....................       //Check for mem page 0 
....................       temp_mem_page = Read_Byte(BME680_SPI_STATUS);   
0350A:  MOVLW  73
0350C:  MOVLB  8
0350E:  MOVWF  x1B
03510:  MOVLB  0
03512:  RCALL  3222
03514:  MOVFF  01,755
....................       temp_mem_page >>= 4; 
03518:  MOVLB  7
0351A:  SWAPF  x55,F
0351C:  MOVLW  0F
0351E:  ANDWF  x55,F
....................       temp_mem_page &= 0x1; 
03520:  MOVLW  01
03522:  ANDWF  x55,F
....................  
....................       if( temp_mem_page != BME680_MEM_PAGE0 ) 
03524:  MOVF   x55,F
03526:  BZ    3556
....................       { 
....................          //Set mem page to 0 
....................          Write_Byte( BME680_SPI_STATUS, BME680_MEM_PAGE0 );   
03528:  MOVLW  73
0352A:  MOVLB  8
0352C:  MOVWF  x18
0352E:  CLRF   x19
03530:  MOVLB  0
03532:  RCALL  31D0
....................           
....................          //Check the mem page 
....................          temp_mem_page = Read_Byte(BME680_SPI_STATUS);       
03534:  MOVLW  73
03536:  MOVLB  8
03538:  MOVWF  x1B
0353A:  MOVLB  0
0353C:  RCALL  3222
0353E:  MOVFF  01,755
....................     
....................          if( temp_mem_page == BME680_MEM_PAGE0 ) 
03542:  MOVLB  7
03544:  MOVF   x55,F
03546:  BNZ   3556
....................             dev->mem_page = BME680_MEM_PAGE0; 
03548:  MOVLW  03
0354A:  ADDWF  x1E,W
0354C:  MOVWF  FE9
0354E:  MOVLW  00
03550:  ADDWFC x1F,W
03552:  MOVWF  FEA
03554:  CLRF   FEF
....................       } 
....................    } 
....................  
....................    if (rslt == BME680_OK) 
03556:  MOVF   x54,F
03558:  BTFSS  FD8.2
0355A:  BRA    38FC
....................    { 
....................       /**************************************/ 
....................       /* Set up Calib Temperature data t1-t3*/ 
....................       /**************************************/ 
....................       _T1 = ( Read_Byte(0xEA) << 8 ); 
0355C:  MOVLW  EA
0355E:  MOVLB  8
03560:  MOVWF  x1B
03562:  MOVLB  0
03564:  RCALL  3222
03566:  MOVFF  01,721
0356A:  MOVLB  7
0356C:  CLRF   x20
0356E:  CLRF   x22
03570:  CLRF   x23
....................       _T1 |= Read_Byte(0xE9); 
03572:  MOVLW  E9
03574:  MOVLB  8
03576:  MOVWF  x1B
03578:  MOVLB  0
0357A:  RCALL  3222
0357C:  MOVF   01,W
0357E:  MOVLB  7
03580:  IORWF  x20,F
....................       dev->calib.par_t1 = _T1; 
03582:  MOVLW  12
03584:  ADDWF  x1E,W
03586:  MOVWF  FE9
03588:  MOVLW  00
0358A:  ADDWFC x1F,W
0358C:  MOVWF  FEA
0358E:  MOVFF  720,FEF
03592:  MOVFF  721,FEC
....................  
....................       _T2 = ( Read_Byte(0x8B) << 8 ); 
03596:  MOVLW  8B
03598:  MOVLB  8
0359A:  MOVWF  x1B
0359C:  MOVLB  0
0359E:  RCALL  3222
035A0:  MOVFF  01,725
035A4:  MOVLB  7
035A6:  CLRF   x24
035A8:  CLRF   x26
035AA:  CLRF   x27
....................       _T2 |= Read_Byte(0x8A); 
035AC:  MOVLW  8A
035AE:  MOVLB  8
035B0:  MOVWF  x1B
035B2:  MOVLB  0
035B4:  RCALL  3222
035B6:  MOVF   01,W
035B8:  MOVLB  7
035BA:  IORWF  x24,F
....................       dev->calib.par_t2 = _T2; 
035BC:  MOVLW  14
035BE:  ADDWF  x1E,W
035C0:  MOVWF  FE9
035C2:  MOVLW  00
035C4:  ADDWFC x1F,W
035C6:  MOVWF  FEA
035C8:  MOVFF  725,FEC
035CC:  MOVF   FED,F
035CE:  MOVFF  724,FEF
....................        
....................       _T3 = Read_Byte(0x8C); 
035D2:  MOVLW  8C
035D4:  MOVLB  8
035D6:  MOVWF  x1B
035D8:  MOVLB  0
035DA:  RCALL  3222
035DC:  MOVLB  7
035DE:  CLRF   x2B
035E0:  CLRF   x2A
035E2:  CLRF   x29
035E4:  MOVFF  01,728
....................       dev->calib.par_t3 = _T3; 
035E8:  MOVLW  16
035EA:  ADDWF  x1E,W
035EC:  MOVWF  FE9
035EE:  MOVLW  00
035F0:  ADDWFC x1F,W
035F2:  MOVWF  FEA
035F4:  MOVFF  728,FEF
....................     
....................       /************************************/ 
....................       /* Set up Calib Pressure data p1-p10*/ 
....................       /************************************/ 
....................        
....................       _P1 = ( Read_Byte(0x8F) << 8 ); 
035F8:  MOVLW  8F
035FA:  MOVLB  8
035FC:  MOVWF  x1B
035FE:  MOVLB  0
03600:  RCALL  3222
03602:  MOVFF  01,72D
03606:  MOVLB  7
03608:  CLRF   x2C
0360A:  CLRF   x2E
0360C:  CLRF   x2F
....................       _P1 |= Read_Byte(0x8E); 
0360E:  MOVLW  8E
03610:  MOVLB  8
03612:  MOVWF  x1B
03614:  MOVLB  0
03616:  RCALL  3222
03618:  MOVF   01,W
0361A:  MOVLB  7
0361C:  IORWF  x2C,F
....................       //_P1 = 0xFFFF0000 | _P1; 
....................       dev->calib.par_p1 = _P1; 
0361E:  MOVLW  17
03620:  ADDWF  x1E,W
03622:  MOVWF  FE9
03624:  MOVLW  00
03626:  ADDWFC x1F,W
03628:  MOVWF  FEA
0362A:  MOVFF  72C,FEF
0362E:  MOVFF  72D,FEC
....................  
....................       _P2 = ( Read_Byte(0x91) << 8 ); 
03632:  MOVLW  91
03634:  MOVLB  8
03636:  MOVWF  x1B
03638:  MOVLB  0
0363A:  RCALL  3222
0363C:  MOVFF  01,731
03640:  MOVLB  7
03642:  CLRF   x30
03644:  CLRF   x32
03646:  CLRF   x33
....................       _P2 |= Read_Byte(0x90); 
03648:  MOVLW  90
0364A:  MOVLB  8
0364C:  MOVWF  x1B
0364E:  MOVLB  0
03650:  RCALL  3222
03652:  MOVF   01,W
03654:  MOVLB  7
03656:  IORWF  x30,F
....................       _P2 = 0xFFFF0000 | _P2; 
03658:  MOVLW  FF
0365A:  IORWF  x32,F
0365C:  IORWF  x33,F
....................       dev->calib.par_p2 = _P2; 
0365E:  MOVLW  19
03660:  ADDWF  x1E,W
03662:  MOVWF  FE9
03664:  MOVLW  00
03666:  ADDWFC x1F,W
03668:  MOVWF  FEA
0366A:  MOVFF  731,FEC
0366E:  MOVF   FED,F
03670:  MOVFF  730,FEF
....................     
....................       _P3 = Read_Byte(0x92); 
03674:  MOVLW  92
03676:  MOVLB  8
03678:  MOVWF  x1B
0367A:  MOVLB  0
0367C:  RCALL  3222
0367E:  MOVFF  01,748
03682:  CLRF   01
03684:  CLRF   02
03686:  CLRF   03
03688:  MOVFF  03,74B
0368C:  MOVFF  02,74A
03690:  MOVFF  01,749
....................       dev->calib.par_p3 = _P3; 
03694:  MOVLW  1B
03696:  MOVLB  7
03698:  ADDWF  x1E,W
0369A:  MOVWF  FE9
0369C:  MOVLW  00
0369E:  ADDWFC x1F,W
036A0:  MOVWF  FEA
036A2:  MOVFF  748,FEF
....................  
....................       _P4 = ( Read_Byte(0x95) << 8 ); 
036A6:  MOVLW  95
036A8:  MOVLB  8
036AA:  MOVWF  x1B
036AC:  MOVLB  0
036AE:  RCALL  3222
036B0:  MOVFF  01,735
036B4:  MOVLB  7
036B6:  CLRF   x34
036B8:  CLRF   x36
036BA:  CLRF   x37
....................       _P4 |= Read_Byte(0x94); 
036BC:  MOVLW  94
036BE:  MOVLB  8
036C0:  MOVWF  x1B
036C2:  MOVLB  0
036C4:  RCALL  3222
036C6:  MOVF   01,W
036C8:  MOVLB  7
036CA:  IORWF  x34,F
....................       //_P4 = 0xFFFF0000 | _P4; 
....................       dev->calib.par_p4 = _P4; 
036CC:  MOVLW  1C
036CE:  ADDWF  x1E,W
036D0:  MOVWF  FE9
036D2:  MOVLW  00
036D4:  ADDWFC x1F,W
036D6:  MOVWF  FEA
036D8:  MOVFF  735,FEC
036DC:  MOVF   FED,F
036DE:  MOVFF  734,FEF
....................  
....................       _P5 = ( Read_Byte(0x97) << 8 ); 
036E2:  MOVLW  97
036E4:  MOVLB  8
036E6:  MOVWF  x1B
036E8:  MOVLB  0
036EA:  RCALL  3222
036EC:  MOVFF  01,741
036F0:  MOVLB  7
036F2:  CLRF   x40
036F4:  CLRF   x42
036F6:  CLRF   x43
....................       _P5 |=  Read_Byte(0x96); 
036F8:  MOVLW  96
036FA:  MOVLB  8
036FC:  MOVWF  x1B
036FE:  MOVLB  0
03700:  RCALL  3222
03702:  MOVF   01,W
03704:  MOVLB  7
03706:  IORWF  x40,F
....................       _P5 = 0xFFFF0000 | _P5; 
03708:  MOVLW  FF
0370A:  IORWF  x42,F
0370C:  IORWF  x43,F
....................       dev->calib.par_p5 = _P5; 
0370E:  MOVLW  1E
03710:  ADDWF  x1E,W
03712:  MOVWF  FE9
03714:  MOVLW  00
03716:  ADDWFC x1F,W
03718:  MOVWF  FEA
0371A:  MOVFF  741,FEC
0371E:  MOVF   FED,F
03720:  MOVFF  740,FEF
....................    
....................       _P6 = Read_Byte(0x99); 
03724:  MOVLW  99
03726:  MOVLB  8
03728:  MOVWF  x1B
0372A:  MOVLB  0
0372C:  RCALL  3222
0372E:  MOVFF  01,74C
03732:  CLRF   01
03734:  CLRF   02
03736:  CLRF   03
03738:  MOVFF  03,74F
0373C:  MOVFF  02,74E
03740:  MOVFF  01,74D
....................       dev->calib.par_p6 = _P6; 
03744:  MOVLW  20
03746:  MOVLB  7
03748:  ADDWF  x1E,W
0374A:  MOVWF  FE9
0374C:  MOVLW  00
0374E:  ADDWFC x1F,W
03750:  MOVWF  FEA
03752:  MOVFF  74C,FEF
....................    
....................       _P7 = Read_Byte(0x98); 
03756:  MOVLW  98
03758:  MOVLB  8
0375A:  MOVWF  x1B
0375C:  MOVLB  0
0375E:  RCALL  3222
03760:  MOVFF  01,750
03764:  CLRF   01
03766:  CLRF   02
03768:  CLRF   03
0376A:  MOVFF  03,753
0376E:  MOVFF  02,752
03772:  MOVFF  01,751
....................       dev->calib.par_p7 = _P7; 
03776:  MOVLW  21
03778:  MOVLB  7
0377A:  ADDWF  x1E,W
0377C:  MOVWF  FE9
0377E:  MOVLW  00
03780:  ADDWFC x1F,W
03782:  MOVWF  FEA
03784:  MOVFF  750,FEF
....................  
....................       _P8 = ( Read_Byte(0x9D) << 8 ); 
03788:  MOVLW  9D
0378A:  MOVLB  8
0378C:  MOVWF  x1B
0378E:  MOVLB  0
03790:  RCALL  3222
03792:  MOVFF  01,739
03796:  MOVLB  7
03798:  CLRF   x38
0379A:  CLRF   x3A
0379C:  CLRF   x3B
....................       _P8 |= Read_Byte(0x9C); 
0379E:  MOVLW  9C
037A0:  MOVLB  8
037A2:  MOVWF  x1B
037A4:  MOVLB  0
037A6:  RCALL  3222
037A8:  MOVF   01,W
037AA:  MOVLB  7
037AC:  IORWF  x38,F
....................       _P8 = 0xFFFF0000 | _P8; 
037AE:  MOVLW  FF
037B0:  IORWF  x3A,F
037B2:  IORWF  x3B,F
....................       dev->calib.par_p8 = _P8; 
037B4:  MOVLW  22
037B6:  ADDWF  x1E,W
037B8:  MOVWF  FE9
037BA:  MOVLW  00
037BC:  ADDWFC x1F,W
037BE:  MOVWF  FEA
037C0:  MOVFF  739,FEC
037C4:  MOVF   FED,F
037C6:  MOVFF  738,FEF
....................  
....................       _P9 = ( Read_Byte(0x9F) << 8 ); 
037CA:  MOVLW  9F
037CC:  MOVLB  8
037CE:  MOVWF  x1B
037D0:  MOVLB  0
037D2:  RCALL  3222
037D4:  MOVFF  01,73D
037D8:  MOVLB  7
037DA:  CLRF   x3C
037DC:  CLRF   x3E
037DE:  CLRF   x3F
....................       _P9 |= Read_Byte(0x9E); 
037E0:  MOVLW  9E
037E2:  MOVLB  8
037E4:  MOVWF  x1B
037E6:  MOVLB  0
037E8:  RCALL  3222
037EA:  MOVF   01,W
037EC:  MOVLB  7
037EE:  IORWF  x3C,F
....................       _P9 = 0xFFFF0000 | _P9; 
037F0:  MOVLW  FF
037F2:  IORWF  x3E,F
037F4:  IORWF  x3F,F
....................       dev->calib.par_p9 = _P9; 
037F6:  MOVLW  24
037F8:  ADDWF  x1E,W
037FA:  MOVWF  FE9
037FC:  MOVLW  00
037FE:  ADDWFC x1F,W
03800:  MOVWF  FEA
03802:  MOVFF  73D,FEC
03806:  MOVF   FED,F
03808:  MOVFF  73C,FEF
....................  
....................       _P10 = Read_Byte(0xA0); 
0380C:  MOVLW  A0
0380E:  MOVLB  8
03810:  MOVWF  x1B
03812:  MOVLB  0
03814:  RCALL  3222
03816:  MOVLB  7
03818:  CLRF   x47
0381A:  CLRF   x46
0381C:  CLRF   x45
0381E:  MOVFF  01,744
....................       _P10 = 0xFFFF0000 | _P10; 
03822:  MOVLW  FF
03824:  IORWF  x46,F
03826:  IORWF  x47,F
....................       dev->calib.par_p10 = _P10; 
03828:  MOVLW  26
0382A:  ADDWF  x1E,W
0382C:  MOVWF  FE9
0382E:  MOVLW  00
03830:  ADDWFC x1F,W
03832:  MOVWF  FEA
03834:  MOVFF  744,FEF
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "**********   _T1 = %Lu\r\n\r\n", _T1); 
....................    fprintf(STDOUT, "**********   _T2 = %Lu\r\n\r\n", _T2); 
....................    fprintf(STDOUT, "**********   _T3 = %Lu\r\n\r\n", _T3); 
....................    fprintf(STDOUT, "**********   _P1 = %Lu\r\n\r\n", _P1); 
....................    fprintf(STDOUT, "**********   _P2 = %Lu\r\n\r\n", _P2); 
....................    fprintf(STDOUT, "**********   _P3 = %Lu\r\n\r\n", _P3); 
....................    fprintf(STDOUT, "**********   _P4 = %Lu\r\n\r\n", _P4); 
....................    fprintf(STDOUT, "**********   _P5 = %Lu\r\n\r\n", _P5); 
....................    fprintf(STDOUT, "**********   _P6 = %Lu\r\n\r\n", _P6); 
....................    fprintf(STDOUT, "**********   _P7 = %Lu\r\n\r\n", _P7); 
....................    fprintf(STDOUT, "**********   _P8 = %Lu\r\n\r\n", _P8); 
....................    fprintf(STDOUT, "**********   _P9 = %Lu\r\n\r\n", _P9); 
....................    fprintf(STDOUT, "**********   _P10 = %Lu\r\n\r\n", _P10); 
.................... #endif 
....................         
....................          /* Other coefficients */ 
....................       if (rslt == BME680_OK)  
03838:  MOVF   x54,F
0383A:  BNZ   38DA
....................       { 
....................          rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_RANGE_ADDR, &temp_var, 1, dev); 
0383C:  MOVLW  02
0383E:  MOVWF  x57
03840:  MOVLW  07
03842:  MOVWF  x59
03844:  MOVLW  56
03846:  MOVWF  x58
03848:  CLRF   x5B
0384A:  MOVLW  01
0384C:  MOVWF  x5A
0384E:  MOVFF  71F,75D
03852:  MOVFF  71E,75C
03856:  MOVLB  0
03858:  RCALL  341A
0385A:  MOVFF  01,754
....................          dev->calib.res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16); 
0385E:  MOVLW  2B
03860:  MOVLB  7
03862:  ADDWF  x1E,W
03864:  MOVWF  FE9
03866:  MOVLW  00
03868:  ADDWFC x1F,W
0386A:  MOVWF  FEA
0386C:  MOVF   x56,W
0386E:  ANDLW  30
03870:  MOVWF  00
03872:  SWAPF  00,F
03874:  MOVLW  0F
03876:  ANDWF  00,F
03878:  MOVFF  00,FEF
....................     
....................          if (rslt == BME680_OK) 
0387C:  MOVF   x54,F
0387E:  BNZ   38DA
....................          { 
....................             rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_VAL_ADDR, &temp_var, 1, dev); 
03880:  CLRF   x57
03882:  MOVLW  07
03884:  MOVWF  x59
03886:  MOVLW  56
03888:  MOVWF  x58
0388A:  CLRF   x5B
0388C:  MOVLW  01
0388E:  MOVWF  x5A
03890:  MOVFF  71F,75D
03894:  MOVFF  71E,75C
03898:  MOVLB  0
0389A:  RCALL  341A
0389C:  MOVFF  01,754
....................             dev->calib.res_heat_val = (int8_t) temp_var; 
038A0:  MOVLW  2C
038A2:  MOVLB  7
038A4:  ADDWF  x1E,W
038A6:  MOVWF  FE9
038A8:  MOVLW  00
038AA:  ADDWFC x1F,W
038AC:  MOVWF  FEA
038AE:  MOVFF  756,FEF
....................           
....................             if (rslt == BME680_OK) 
038B2:  MOVF   x54,F
038B4:  BNZ   38DA
....................                rslt = bme680_get_regs(BME680_ADDR_RANGE_SW_ERR_ADDR, &temp_var, 1, dev); 
038B6:  MOVLW  04
038B8:  MOVWF  x57
038BA:  MOVLW  07
038BC:  MOVWF  x59
038BE:  MOVLW  56
038C0:  MOVWF  x58
038C2:  CLRF   x5B
038C4:  MOVLW  01
038C6:  MOVWF  x5A
038C8:  MOVFF  71F,75D
038CC:  MOVFF  71E,75C
038D0:  MOVLB  0
038D2:  RCALL  341A
038D4:  MOVFF  01,754
038D8:  MOVLB  7
....................          } 
....................       } 
....................          
....................       dev->calib.range_sw_err = ((int8_t) temp_var & (int8_t) BME680_RSERROR_MSK) / 16; 
038DA:  MOVLW  2D
038DC:  ADDWF  x1E,W
038DE:  MOVWF  FE9
038E0:  MOVLW  00
038E2:  ADDWFC x1F,W
038E4:  MOVWF  FEA
038E6:  MOVF   x56,W
038E8:  ANDLW  F0
038EA:  MOVWF  x5A
038EC:  MOVWF  x5B
038EE:  MOVLW  10
038F0:  MOVWF  x5C
038F2:  MOVLB  0
038F4:  BRA    34A0
038F6:  MOVFF  01,FEF
038FA:  MOVLB  7
....................  
....................    } 
....................   
....................    return rslt; 
038FC:  MOVFF  754,01
03900:  MOVLB  0
03902:  GOTO   39B4 (RETURN)
.................... } 
....................  
.................... /*****************************************************************************/ 
.................... /*! 
....................  * @brief This internal API is used to set the memory page based on register address. 
....................  */ 
.................... int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev) 
*
032CC:  MOVLB  8
032CE:  CLRF   x15
.................... { 
....................    int8_t rslt = BME680_OK; 
....................    uint8_t mem_page, tmp; 
....................      
....................    if ( reg_addr == 0x60 || reg_addr == 0x50 || reg_addr == 0xE0 || reg_addr == 0xD0 ) 
032D0:  MOVF   x12,W
032D2:  SUBLW  60
032D4:  BZ    32E8
032D6:  MOVF   x12,W
032D8:  SUBLW  50
032DA:  BZ    32E8
032DC:  MOVF   x12,W
032DE:  SUBLW  E0
032E0:  BZ    32E8
032E2:  MOVF   x12,W
032E4:  SUBLW  D0
032E6:  BNZ   32EC
....................          mem_page = BME680_MEM_PAGE0; 
032E8:  CLRF   x16
032EA:  BRA    32F0
....................     
....................    else 
....................       mem_page = BME680_MEM_PAGE1; 
032EC:  MOVLW  02
032EE:  MOVWF  x16
....................  
.................... #ifdef DEBUG     
....................    fprintf(STDOUT, "Current Mem_page %02X\r\n", dev->mem_page); 
....................    fprintf(STDOUT, "Set mem_page to %02X\r\n", mem_page); 
.................... #endif 
....................  
....................    //update the mem_page setting 
....................    Write_Byte(BME680_MEM_PAGE_ADDR, mem_page); 
032F0:  MOVLW  73
032F2:  MOVWF  x18
032F4:  MOVFF  816,819
032F8:  MOVLB  0
032FA:  RCALL  31D0
....................    delay_ms(100); 
032FC:  MOVLW  64
032FE:  MOVLB  8
03300:  MOVWF  x18
03302:  MOVLB  0
03304:  RCALL  2D2E
....................          
....................    //Verify 
....................    tmp = get_mem_page(dev); 
03306:  MOVFF  814,819
0330A:  MOVFF  813,818
0330E:  RCALL  3292
03310:  MOVFF  01,817
....................         
....................    if ( tmp != mem_page) 
03314:  MOVLB  8
03316:  MOVF   x16,W
03318:  SUBWF  x17,W
0331A:  BZ    3322
....................       rslt = BME680_E_COM_FAIL; 
0331C:  MOVLW  02
0331E:  MOVWF  x15
03320:  BRA    3332
....................           
....................    else 
....................       dev->mem_page = mem_page; 
03322:  MOVLW  03
03324:  ADDWF  x13,W
03326:  MOVWF  FE9
03328:  MOVLW  00
0332A:  ADDWFC x14,W
0332C:  MOVWF  FEA
0332E:  MOVFF  816,FEF
....................   
....................     return rslt; 
03332:  MOVFF  815,01
03336:  MOVLB  0
03338:  RETURN 0
.................... } 
....................   
.................... /*****************************************************************************/  
.................... /*! 
....................  * @brief This internal API is used to get the memory page based on register address. 
....................  */ 
.................... int8_t get_mem_page(struct bme680_dev *dev) 
.................... { 
....................    int8_t rslt; 
....................      
....................    rslt = Read_Byte(BME680_MEM_PAGE_ADDR); 
*
03292:  MOVLW  73
03294:  MOVLB  8
03296:  MOVWF  x1B
03298:  MOVLB  0
0329A:  RCALL  3222
0329C:  MOVFF  01,81A
....................     
....................    if ( rslt != 0 || rslt != 0x10 ) 
032A0:  MOVLB  8
032A2:  MOVF   x1A,F
032A4:  BNZ   32AC
032A6:  MOVF   x1A,W
032A8:  SUBLW  10
032AA:  BZ    32B4
....................       return BME680_E_COM_FAIL; 
032AC:  MOVLW  02
032AE:  MOVWF  01
032B0:  BRA    32C8
032B2:  BRA    32C8
....................          
....................    else 
....................    { 
....................       dev->mem_page = rslt; 
032B4:  MOVLW  03
032B6:  ADDWF  x18,W
032B8:  MOVWF  FE9
032BA:  MOVLW  00
032BC:  ADDWFC x19,W
032BE:  MOVWF  FEA
032C0:  MOVFF  81A,FEF
....................       return BME680_OK; 
032C4:  MOVLW  00
032C6:  MOVWF  01
....................    } 
032C8:  MOVLB  0
032CA:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************************/ 
.................... /*! 
....................  * @brief This internal API is used to validate the device structure pointer for 
....................  * null conditions. 
....................  */ 
.................... int8_t null_ptr_check(const struct bme680_dev *dev) 
.................... { 
....................     if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL))  
*
0317C:  MOVLB  7
0317E:  MOVF   x5F,F
03180:  BNZ   3186
03182:  MOVF   x60,F
03184:  BZ    31C2
03186:  MOVLW  3C
03188:  ADDWF  x5F,W
0318A:  MOVWF  FE9
0318C:  MOVLW  00
0318E:  ADDWFC x60,W
03190:  MOVWF  FEA
03192:  MOVFF  FEC,762
03196:  MOVF   FED,F
03198:  MOVFF  FEF,761
0319C:  MOVF   x61,F
0319E:  BNZ   31A4
031A0:  MOVF   x62,F
031A2:  BZ    31C2
031A4:  MOVLW  3E
031A6:  ADDWF  x5F,W
031A8:  MOVWF  FE9
031AA:  MOVLW  00
031AC:  ADDWFC x60,W
031AE:  MOVWF  FEA
031B0:  MOVFF  FEC,762
031B4:  MOVF   FED,F
031B6:  MOVFF  FEF,761
031BA:  MOVF   x61,F
031BC:  BNZ   31C8
031BE:  MOVF   x62,F
031C0:  BNZ   31C8
....................     { 
.................... #ifdef DEBUG    
....................       fprintf(STDOUT, "Null pointer detected in null_ptr_check\r\n"); 
.................... #endif 
....................       return NULL_POINTER_DETECTED;                     
031C2:  MOVLW  80
031C4:  MOVWF  01
031C6:  BRA    31CC
....................     } 
....................   
....................     return BME680_OK; 
031C8:  MOVLW  00
031CA:  MOVWF  01
031CC:  MOVLB  0
031CE:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************************/ 
.................... void Write_Byte(uint8_t reg_addr, uint8_t data) 
.................... { 
.................... #ifdef DEBUG    
....................    fprintf(STDOUT, "Write_Byte 0x%X to reg 0x%X\r\n", data, reg_addr); 
.................... #endif 
....................  
.................... #ifdef BME_SPI_MODE 
....................    uint8_t bit0 = 1; 
....................    uint8_t regAddr = reg_addr&0x7F; //Bit7 = 0 for write 
....................     
....................  
....................    output_low(PIN_E2); 
....................    delay_ms(1);  
....................    //send reg address 
....................    for(int i=0; i<8;i++) 
....................    { 
....................       output_low(PIN_C3);//clk low 
....................       delay_ms(1);  
....................       if(regAddr&(bit0<<(7-i))) 
....................          output_high(PIN_C4); 
....................       else                       
....................          output_low(PIN_C4); 
....................       delay_ms(1);  
....................       output_high(PIN_C3);//clk hi 
....................       delay_ms(1);  
....................    } 
....................    delay_ms(2);  
....................    //send data byte  
....................    for(int i=0; i<8;i++) 
....................    { 
....................       output_low(PIN_C3);//clk low 
....................       delay_ms(1);  
....................       if(data&(bit0<<(7-i))) 
....................          output_high(PIN_C4); 
....................       else                       
....................          output_low(PIN_C4); 
....................       delay_ms(1);  
....................       output_high(PIN_C3);//clk hi 
....................       delay_ms(1);  
....................    }    
....................     
....................    output_high(PIN_E2); 
....................    delay_ms(1);  
....................  
.................... #else // use I2C 
....................    output_low(PIN_D4); 
031D0:  BCF    F95.4
031D2:  BCF    F8C.4
.................... //   output_high(PIN_D4); 
....................    i2c_start(); 
031D4:  BSF    FC5.0
031D6:  BTFSC  FC5.0
031D8:  BRA    31D6
031DA:  CLRF   19
031DC:  BTFSC  FF2.7
031DE:  BSF    19.7
031E0:  BCF    FF2.7
....................    i2c_write(BME680_I2C_Write_addr); 
031E2:  MOVLW  EC
031E4:  MOVLB  9
031E6:  MOVWF  x7A
031E8:  MOVLB  0
031EA:  CALL   09D0
031EE:  BTFSC  19.7
031F0:  BSF    FF2.7
031F2:  CLRF   19
031F4:  BTFSC  FF2.7
031F6:  BSF    19.7
031F8:  BCF    FF2.7
....................    i2c_write(reg_addr); 
031FA:  MOVFF  818,97A
031FE:  CALL   09D0
03202:  BTFSC  19.7
03204:  BSF    FF2.7
03206:  CLRF   19
03208:  BTFSC  FF2.7
0320A:  BSF    19.7
0320C:  BCF    FF2.7
....................    i2c_write(data); 
0320E:  MOVFF  819,97A
03212:  CALL   09D0
03216:  BTFSC  19.7
03218:  BSF    FF2.7
....................    i2c_stop(); 
0321A:  BSF    FC5.2
0321C:  BTFSC  FC5.2
0321E:  BRA    321C
.................... #endif 
03220:  RETURN 0
.................... } 
....................  
.................... uint8_t Read_Byte(uint8_t reg_addr) 
03222:  MOVLB  8
03224:  CLRF   x1C
.................... { 
....................    uint8_t dataByte = 0; 
....................  
.................... #ifdef BME_SPI_MODE 
....................    uint8_t bit0 = 1; 
....................    uint8_t regAddr = reg_addr|0x80; //Bit7 = 1 for read 
....................  
....................    output_low(PIN_E2); 
....................    delay_ms(1);  
....................    //send reg address 
....................    for(int i=0; i<8;i++) 
....................    { 
....................       output_low(PIN_C3);//clk low 
....................       if(regAddr&(bit0<<(7-i))) 
....................          output_high(PIN_C4); 
....................       else                       
....................          output_low(PIN_C4); 
....................       output_high(PIN_C3);//clk hi 
....................    } 
....................    delay_ms(4);  
....................    //get data byte  
....................    for(int i=0; i<8;i++) 
....................    { 
....................       output_low(PIN_C3);//clk low 
....................       if( input(PIN_D4) ) 
....................          dataByte |= (bit0<<(7-i)); 
....................       output_high(PIN_C3);//clk hi 
....................    }    
....................     
....................    output_high(PIN_E2); 
....................    delay_ms(1);  
....................     
.................... #else // use I2C 
....................    output_low(PIN_D4); 
03226:  BCF    F95.4
03228:  BCF    F8C.4
.................... //   output_high(PIN_D4); 
....................    i2c_start(); 
0322A:  BSF    FC5.0
0322C:  BTFSC  FC5.0
0322E:  BRA    322C
03230:  CLRF   19
03232:  BTFSC  FF2.7
03234:  BSF    19.7
03236:  BCF    FF2.7
....................    i2c_write(BME680_I2C_Write_addr); 
03238:  MOVLW  EC
0323A:  MOVLB  9
0323C:  MOVWF  x7A
0323E:  MOVLB  0
03240:  CALL   09D0
03244:  BTFSC  19.7
03246:  BSF    FF2.7
03248:  CLRF   19
0324A:  BTFSC  FF2.7
0324C:  BSF    19.7
0324E:  BCF    FF2.7
....................    i2c_write(reg_addr); 
03250:  MOVFF  81B,97A
03254:  CALL   09D0
03258:  BTFSC  19.7
0325A:  BSF    FF2.7
....................    i2c_start(); 
0325C:  BSF    FC5.1
0325E:  BTFSC  FC5.1
03260:  BRA    325E
03262:  CLRF   19
03264:  BTFSC  FF2.7
03266:  BSF    19.7
03268:  BCF    FF2.7
....................    i2c_write(BME680_I2C_Read_addr); 
0326A:  MOVLW  ED
0326C:  MOVLB  9
0326E:  MOVWF  x7A
03270:  MOVLB  0
03272:  CALL   09D0
03276:  BTFSC  19.7
03278:  BSF    FF2.7
....................    dataByte = i2c_read(0); 
0327A:  CLRF   00
0327C:  RCALL  2BFE
0327E:  MOVFF  01,81C
....................    i2c_stop();   
03282:  BSF    FC5.2
03284:  BTFSC  FC5.2
03286:  BRA    3284
.................... #endif 
....................  
.................... #ifdef DEBUG     
....................    fprintf(STDOUT, "Read_Ryte 0x%X from reg 0x%X\r\n", dataByte, reg_addr); 
.................... #endif 
....................  
....................    return dataByte; 
03288:  MOVLB  8
0328A:  MOVFF  81C,01
0328E:  MOVLB  0
03290:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************************/ 
.................... /*****************************************************************************/ 
.................... int8_t Write(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len) 
.................... {   
....................    for(int i=0; i<len; i++) 
....................    { 
....................       Write_Byte(reg_addr+i,*(data+i)); 
....................    } 
....................     
....................    return BME680_OK; 
.................... } 
....................  
.................... int8_t Read(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len) 
*
033C6:  MOVLB  7
033C8:  CLRF   x67
.................... { 
....................    uint8_t     command; 
....................    int8_t      status = BME680_OK; 
....................    uint8_t     tmp_data; 
....................     
....................    if( !len ) 
033CA:  MOVF   x64,W
033CC:  IORWF  x65,W
033CE:  BNZ   33D6
....................       return BME680_E_INVALID_LENGTH; 
033D0:  MOVLW  08
033D2:  MOVWF  01
033D4:  BRA    3414
....................        
....................    command = reg_addr; 
033D6:  MOVFF  761,766
.................... #ifdef DEBUG    
....................    fprintf(STDOUT, "read command number 0x%LX\r\n", command); 
.................... #endif 
....................    while( len-- ) 
033DA:  MOVFF  765,03
033DE:  MOVF   x64,W
033E0:  BTFSC  FD8.2
033E2:  DECF   x65,F
033E4:  DECF   x64,F
033E6:  IORWF  03,W
033E8:  BZ    3410
....................    { 
....................       //Assumtion - Only one byte read at this time for BME.  CCS compiler limitation of using spi_xfer. 
....................       tmp_data = Read_Byte(command); 
033EA:  MOVFF  766,81B
033EE:  MOVLB  0
033F0:  RCALL  3222
033F2:  MOVFF  01,768
....................       *data++ = tmp_data; 
033F6:  MOVLB  7
033F8:  MOVFF  763,03
033FC:  MOVF   x62,W
033FE:  INCF   x62,F
03400:  BTFSC  FD8.2
03402:  INCF   x63,F
03404:  MOVWF  FE9
03406:  MOVFF  03,FEA
0340A:  MOVFF  768,FEF
.................... #ifdef DEBUG       
0340E:  BRA    33DA
....................       fprintf(STDOUT, "Contents of read command 0x%X\r\n", tmp_data); 
.................... #endif       
....................    }   
....................    return status; 
03410:  MOVFF  767,01
03414:  MOVLB  0
03416:  GOTO   3488 (RETURN)
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef BME_CODE 
....................  
.................... /*! 
....................  *@brief This API is the entry point. 
....................  *It reads the chip-id and calibration data from the sensor. 
....................  */ 
.................... int8_t bme680_init(struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     uint8_t temp; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................      
....................     if (rslt == BME680_OK)  
....................     { 
....................         /* Soft reset to restore it to default values*/ 
....................         rslt = bme680_soft_reset(dev); 
....................         if (rslt != BME680_OK) 
....................            fprintf(STDOUT, "Failed BME_SOFT_RESET \r\n"); 
....................          
....................         if (rslt == BME680_OK) 
....................         { 
....................             rslt = bme680_get_regs(BME680_SPI_CHIP_ID_ADDR, &temp, 1, dev); 
....................             if (rslt == BME680_OK)  
....................             { 
....................                fprintf(STDOUT, "\r\n\r\n"); 
....................                 
....................                if (temp == BME680_CHIP_ID) 
....................                { 
....................                   dev->chip_id = temp; 
....................                   fprintf(STDOUT, "BME680_CHIP_ID = %02X\r\n", dev->chip_id); 
....................                    
....................                   /* Get the Calibration data */ 
....................                   rslt = get_calib_data(dev); 
....................                } 
....................                  
....................                else  
....................                { 
....................                   fprintf(STDOUT, "BME680_CHIP_ID = %02X/%02X\r\n", dev->chip_id, BME680_CHIP_ID); 
....................                   rslt = BME680_E_DEV_NOT_FOUND; 
....................                } 
....................             } 
....................         } 
....................     }  
....................      
....................     else 
....................        fprintf(STDOUT, "      ERROR in    bme680_init = %u\r\n", rslt); 
....................  
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API writes the given data to the register address 
....................  * of the sensor. 
....................  */ 
.................... int8_t bme680_set_regs(const uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, struct bme680_dev *dev) 
.................... { 
....................    int8_t rslt; 
....................    /* Length of the temporary buffer is 2*(length of register)*/ 
....................    uint8_t tmp_buff[BME680_TMP_BUFFER_LENGTH] = { 0 }; 
....................    uint16_t index; 
....................  
....................    /* Check for null pointer in the device structure*/ 
....................    rslt = null_ptr_check(dev); 
....................    if (rslt == BME680_OK) { 
....................       if ((len > 0) && (len < BME680_TMP_BUFFER_LENGTH / 2)) { 
....................          /* Interleave the 2 arrays */ 
....................          for (index = 0; index < len; index++) { 
....................             if (dev->intf == BME680_SPI_INTF) { 
....................                /* Set the memory page */ 
....................                rslt = set_mem_page(reg_addr[index], dev); 
....................                tmp_buff[(2 * index)] = reg_addr[index] & BME680_SPI_WR_MSK; 
....................             } else { 
....................                tmp_buff[(2 * index)] = reg_addr[index]; 
....................             } 
....................             tmp_buff[(2 * index) + 1] = reg_data[index]; 
....................          } 
....................          /* Write the interleaved array */ 
....................          if (rslt == BME680_OK) 
....................          { 
....................             //dev->com_rslt = dev->write(dev->dev_id, tmp_buff[0], &tmp_buff[1], (2 * len) - 1); 
....................             dev->com_rslt = Write(dev->dev_id, tmp_buff[0], &tmp_buff[1], (2 * len) - 1); 
....................             if (dev->com_rslt != 0) 
....................                rslt = BME680_E_COM_FAIL; 
....................          } 
....................       } else { 
....................          rslt = BME680_E_INVALID_LENGTH; 
....................       } 
....................    } 
....................  
....................    return rslt; 
.................... } 
....................   
....................  
....................   
.................... /*! 
....................  * @brief This API is used to set the oversampling, filter and T,P,H, gas selection 
....................  * settings in the sensor. 
....................  */ 
.................... int8_t bme680_set_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     uint8_t reg_addr; 
....................     uint8_t data = 0; 
....................     uint8_t count = 0; 
....................     uint8_t reg_array[BME680_REG_BUFFER_LENGTH] = { 0 }; 
....................     uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 }; 
....................     uint8_t intended_power_mode = dev->power_mode; /* Save intended power mode */ 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................         if (desired_settings & BME680_GAS_MEAS_SEL) 
....................             rslt = set_gas_config(dev); 
....................   
....................         dev->power_mode = BME680_SLEEP_MODE; 
....................         if (rslt == BME680_OK) 
....................             rslt = bme680_set_sensor_mode(dev); 
....................   
....................         /* Selecting the filter */ 
....................         if (desired_settings & BME680_FILTER_SEL) { 
....................             rslt = boundary_check(&dev->tph_sett.filter, BME680_FILTER_SIZE_0, BME680_FILTER_SIZE_127, dev); 
....................             reg_addr = BME680_CONF_ODR_FILT_ADDR; 
....................   
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_get_regs(reg_addr, &data, 1, dev); 
....................   
....................             if (desired_settings & BME680_FILTER_SEL) 
....................                 data = BME680_SET_BITS(data, BME680_FILTER, dev->tph_sett.filter); 
....................   
....................             reg_array[count] = reg_addr; /* Append configuration */ 
....................             data_array[count] = data; 
....................             count++; 
....................         } 
....................   
....................         /* Selecting heater control for the sensor */ 
....................         if (desired_settings & BME680_HCNTRL_SEL) { 
....................             rslt = boundary_check(&dev->gas_sett.heatr_ctrl, BME680_ENABLE_HEATER, 
....................                                   BME680_DISABLE_HEATER, dev); 
....................             reg_addr = BME680_CONF_HEAT_CTRL_ADDR; 
....................   
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_get_regs(reg_addr, &data, 1, dev); 
....................             data = BME680_SET_BITS_POS_0(data, BME680_HCTRL, dev->gas_sett.heatr_ctrl); 
....................   
....................             reg_array[count] = reg_addr; /* Append configuration */ 
....................             data_array[count] = data; 
....................             count++; 
....................         } 
....................   
....................         /* Selecting heater T,P oversampling for the sensor */ 
....................         if (desired_settings & (BME680_OST_SEL | BME680_OSP_SEL)) { 
....................             rslt = boundary_check(&dev->tph_sett.os_temp, BME680_OS_NONE, BME680_OS_16X, dev); 
....................             reg_addr = BME680_CONF_T_P_MODE_ADDR; 
....................   
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_get_regs(reg_addr, &data, 1, dev); 
....................   
....................             if (desired_settings & BME680_OST_SEL) 
....................                 data = BME680_SET_BITS(data, BME680_OST, dev->tph_sett.os_temp); 
....................   
....................             if (desired_settings & BME680_OSP_SEL) 
....................                 data = BME680_SET_BITS(data, BME680_OSP, dev->tph_sett.os_pres); 
....................   
....................             reg_array[count] = reg_addr; 
....................             data_array[count] = data; 
....................             count++; 
....................         } 
....................   
....................         /* Selecting humidity oversampling for the sensor */ 
....................         if (desired_settings & BME680_OSH_SEL) { 
....................             rslt = boundary_check(&dev->tph_sett.os_hum, BME680_OS_NONE, BME680_OS_16X, dev); 
....................             reg_addr = BME680_CONF_OS_H_ADDR; 
....................   
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_get_regs(reg_addr, &data, 1, dev); 
....................             data = BME680_SET_BITS_POS_0(data, BME680_OSH, dev->tph_sett.os_hum); 
....................   
....................             reg_array[count] = reg_addr; /* Append configuration */ 
....................             data_array[count] = data; 
....................             count++; 
....................         } 
....................   
....................         /* Selecting the runGas and NB conversion settings for the sensor */ 
....................         if (desired_settings & (BME680_RUN_GAS_SEL | BME680_NBCONV_SEL)) { 
....................             rslt = boundary_check(&dev->gas_sett.run_gas, BME680_RUN_GAS_DISABLE, 
....................                                   BME680_RUN_GAS_ENABLE, dev); 
....................             if (rslt == BME680_OK) { 
....................                 /* Validate boundary conditions */ 
....................                 rslt = boundary_check(&dev->gas_sett.nb_conv, BME680_NBCONV_MIN, 
....................                                       BME680_NBCONV_MAX, dev); 
....................             } 
....................   
....................             reg_addr = BME680_CONF_ODR_RUN_GAS_NBC_ADDR; 
....................   
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_get_regs(reg_addr, &data, 1, dev); 
....................   
....................             if (desired_settings & BME680_RUN_GAS_SEL) 
....................                 data = BME680_SET_BITS(data, BME680_RUN_GAS, dev->gas_sett.run_gas); 
....................   
....................             if (desired_settings & BME680_NBCONV_SEL) 
....................                 data = BME680_SET_BITS_POS_0(data, BME680_NBCONV, dev->gas_sett.nb_conv); 
....................   
....................             reg_array[count] = reg_addr; /* Append configuration */ 
....................             data_array[count] = data; 
....................             count++; 
....................         } 
....................   
....................         if (rslt == BME680_OK) 
....................             rslt = bme680_set_regs(reg_array, data_array, count, dev); 
....................   
....................         /* Restore previous intended power mode */ 
....................         dev->power_mode = intended_power_mode; 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API is used to get the oversampling, filter and T,P,H, gas selection 
....................  * settings in the sensor. 
....................  */ 
.................... int8_t bme680_get_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     /* starting address of the register array for burst read*/ 
....................     uint8_t reg_addr = BME680_CONF_HEAT_CTRL_ADDR; 
....................     uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 }; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................         rslt = bme680_get_regs(reg_addr, data_array, BME680_REG_BUFFER_LENGTH, dev); 
....................   
....................         if (rslt == BME680_OK) { 
....................             if (desired_settings & BME680_GAS_MEAS_SEL) 
....................                 rslt = get_gas_config(dev); 
....................   
....................             /* get the T,P,H ,Filter,ODR settings here */ 
....................             if (desired_settings & BME680_FILTER_SEL) 
....................                 dev->tph_sett.filter = BME680_GET_BITS(data_array[BME680_REG_FILTER_INDEX], 
....................                                                        BME680_FILTER); 
....................   
....................             if (desired_settings & (BME680_OST_SEL | BME680_OSP_SEL)) { 
....................                 dev->tph_sett.os_temp = BME680_GET_BITS(data_array[BME680_REG_TEMP_INDEX], BME680_OST); 
....................                 dev->tph_sett.os_pres = BME680_GET_BITS(data_array[BME680_REG_PRES_INDEX], BME680_OSP); 
....................             } 
....................   
....................             if (desired_settings & BME680_OSH_SEL) 
....................                 dev->tph_sett.os_hum = BME680_GET_BITS_POS_0(data_array[BME680_REG_HUM_INDEX], 
....................                                        BME680_OSH); 
....................   
....................             /* get the gas related settings */ 
....................             if (desired_settings & BME680_HCNTRL_SEL) 
....................                 dev->gas_sett.heatr_ctrl = BME680_GET_BITS_POS_0(data_array[BME680_REG_HCTRL_INDEX], 
....................                                            BME680_HCTRL); 
....................   
....................             if (desired_settings & (BME680_RUN_GAS_SEL | BME680_NBCONV_SEL)) { 
....................                 dev->gas_sett.nb_conv = BME680_GET_BITS_POS_0(data_array[BME680_REG_NBCONV_INDEX], 
....................                                         BME680_NBCONV); 
....................                 dev->gas_sett.run_gas = BME680_GET_BITS(data_array[BME680_REG_RUN_GAS_INDEX], 
....................                                                         BME680_RUN_GAS); 
....................             } 
....................         } 
....................     } else { 
....................         rslt = BME680_E_NULL_PTR; 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API is used to set the power mode of the sensor. 
....................  */ 
.................... int8_t bme680_set_sensor_mode(struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     uint8_t tmp_pow_mode; 
....................     uint8_t pow_mode = 0; 
....................     uint8_t reg_addr = BME680_CONF_T_P_MODE_ADDR; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................         /* Call repeatedly until in sleep */ 
....................         do { 
....................             rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &tmp_pow_mode, 1, dev); 
....................             if (rslt == BME680_OK) { 
....................                 /* Put to sleep before changing mode */ 
....................                 pow_mode = (tmp_pow_mode & BME680_MODE_MSK); 
....................   
....................                 if (pow_mode != BME680_SLEEP_MODE) { 
....................                     tmp_pow_mode = tmp_pow_mode & (~BME680_MODE_MSK); /* Set to sleep */ 
....................                     rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev); 
....................                     delay_ms(BME680_POLL_PERIOD_MS); 
....................                 } 
....................             } 
....................         } while (pow_mode != BME680_SLEEP_MODE); 
....................   
....................         /* Already in sleep */ 
....................         if (dev->power_mode != BME680_SLEEP_MODE) { 
....................             tmp_pow_mode = (tmp_pow_mode & ~BME680_MODE_MSK) | (dev->power_mode & BME680_MODE_MSK); 
....................             if (rslt == BME680_OK) 
....................                 rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev); 
....................         } 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API is used to get the power mode of the sensor. 
....................  */ 
.................... int8_t bme680_get_sensor_mode(struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     uint8_t mode; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................         rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &mode, 1, dev); 
....................         /* Masking the other register bit info*/ 
....................         dev->power_mode = mode & BME680_MODE_MSK; 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API is used to set the profile duration of the sensor. 
....................  */ 
.................... void bme680_set_profile_dur(uint16_t duration, struct bme680_dev *dev) 
.................... { 
....................     uint32_t tph_dur; /* Calculate in us */ 
....................     uint32_t meas_cycles; 
....................     uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16}; 
....................   
....................     meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp]; 
....................     meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres]; 
....................     meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum]; 
....................   
....................     /* TPH measurement duration */ 
....................    tph_dur = meas_cycles * (uint32_t)(1963); 
....................    tph_dur += (uint32_t)(477 * 4); /* TPH switching duration */ 
....................    tph_dur += (uint32_t)(477 * 5); /* Gas measurement duration */ 
....................    tph_dur += (uint32_t)(500); /* Get it to the closest whole number.*/ 
....................    tph_dur /= (uint32_t)(1000); /* Convert to ms */ 
....................   
....................    tph_dur += (uint32_t)(1); /* Wake up duration of 1ms */ 
....................     /* The remaining time should be used for heating */ 
....................     dev->gas_sett.heatr_dur = duration - (uint16_t) tph_dur; 
.................... } 
....................   
.................... /*! 
....................  * @brief This API is used to get the profile duration of the sensor. 
....................  */ 
.................... void bme680_get_profile_dur(uint16_t *duration, const struct bme680_dev *dev) 
.................... { 
....................     uint32_t tph_dur; /* Calculate in us */ 
....................     uint32_t meas_cycles; 
....................     uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16}; 
....................   
....................     meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp]; 
....................     meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres]; 
....................     meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum]; 
....................   
....................     /* TPH measurement duration */ 
....................    tph_dur = meas_cycles * (uint32_t)(1963); 
....................    tph_dur += (uint32_t)(477 * 4); /* TPH switching duration */ 
....................    tph_dur += (uint32_t)(477 * 5); /* Gas measurement duration */ 
....................    tph_dur += (uint32_t)(500); /* Get it to the closest whole number.*/ 
....................    tph_dur /= (uint32_t)(1000); /* Convert to ms */ 
....................   
....................    tph_dur += (uint32_t)(1); /* Wake up duration of 1ms */ 
....................   
....................     *duration = (uint16_t) tph_dur; 
....................   
....................     /* Get the gas duration only when the run gas is enabled */ 
....................     if (dev->gas_sett.run_gas) { 
....................         /* The remaining time should be used for heating */ 
....................         *duration += dev->gas_sett.heatr_dur; 
....................     } 
.................... } 
....................   
.................... /*! 
....................  * @brief This API reads the pressure, temperature and humidity and gas data 
....................  * from the sensor, compensates the data and store it in the bme680_data 
....................  * structure instance passed by the user. 
....................  */ 
.................... int8_t bme680_get_sensor_data(struct bme680_field_data *data, struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt = BME680_OK; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK)  
....................     { 
....................         /* Reading the sensor data in forced mode only */ 
....................         rslt = read_field_data(data, dev); 
....................         if (rslt == BME680_OK) { 
....................             if (data->status & BME680_NEW_DATA_MSK) 
....................                 dev->new_fields = 1; 
....................             else 
....................                 dev->new_fields = 0; 
....................         }  
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to read the calibrated data from the sensor. 
....................  */ 
.................... int8_t get_calib_data(struct bme680_dev *dev) 
.................... { 
....................    uint32_t    _T1,_T2,_T3; 
....................    uint32_t    _P1,_P2,_P4,_P8,_P9,_P5,_P10; 
....................    int32_t     _P3,_P6,_P7;        
....................     
....................     int8_t  rslt = BME680_OK; 
....................     int8_t  temp8; 
....................     int16   temp16; 
....................     uint8   u_temp8; 
....................     uint16  u_temp16; 
....................     uint8   temp_mem_page; 
....................     uint8_t temp_var = 0;     /* Temporary variable */ 
....................      
....................    if( dev->intf != BME680_I2C_INTF )        
....................    { 
....................       //Check for mem page 0 
....................       temp_mem_page = Read_Byte(BME680_SPI_STATUS);   
....................       temp_mem_page >>= 4; 
....................       temp_mem_page &= 0x1; 
....................  
....................       if( temp_mem_page != BME680_MEM_PAGE0 ) 
....................       { 
....................          //Set mem page to 0 
....................          Write_Byte( BME680_SPI_STATUS, BME680_MEM_PAGE0 );   
....................           
....................          //Check the mem page 
....................          temp_mem_page = Read_Byte(BME680_SPI_STATUS);       
....................     
....................          if( temp_mem_page == BME680_MEM_PAGE0 ) 
....................             dev->mem_page = BME680_MEM_PAGE0; 
....................       } 
....................    } 
....................  
....................    if (rslt == BME680_OK) 
....................    { 
....................      
.................... #ifndef ADUINO_CODE 
....................    /**************************************/ 
....................    /* Set up Calib Temperature data t1-t3*/ 
....................    /**************************************/ 
....................    _T1 = ( Read_Byte(0xEA) << 8 ); 
....................    _T1 |= Read_Byte(0xE9); 
....................    dev->calib.par_t1 = _T1; 
....................  
....................    _T2 = ( Read_Byte(0x8B) << 8 ); 
....................    _T2 |= Read_Byte(0x8A); 
....................    dev->calib.par_t2 = _T2; 
....................        
....................    _T3 = Read_Byte(0x8C); 
....................    dev->calib.par_t3 = _T3; 
....................     
....................    /************************************/ 
....................    /* Set up Calib Pressure data p1-p10*/ 
....................    /************************************/ 
....................        
....................    _P1 = ( Read_Byte(0x8F) << 8 ); 
....................    _P1 |= Read_Byte(0x8E); 
....................    //_P1 = 0xFFFF0000 | _P1; 
....................    dev->calib.par_p1 = _P1; 
....................  
....................    _P2 = ( Read_Byte(0x91) << 8 ); 
....................    _P2 |= Read_Byte(0x90); 
....................    _P2 = 0xFFFF0000 | _P2; 
....................    dev->calib.par_p2 = _P2; 
....................     
....................    _P3 = Read_Byte(0x92); 
....................    dev->calib.par_p3 = _P3; 
....................  
....................    _P4 = ( Read_Byte(0x95) << 8 ); 
....................    _P4 |= Read_Byte(0x94); 
....................    //_P4 = 0xFFFF0000 | _P4; 
....................    dev->calib.par_p4 = _P4; 
....................  
....................    _P5 = ( Read_Byte(0x97) << 8 ); 
....................    _P5 |=  Read_Byte(0x96); 
....................    _P5 = 0xFFFF0000 | _P5; 
....................    dev->calib.par_p5 = _P5; 
....................  
....................     
....................    _P6 = Read_Byte(0x99); 
....................    dev->calib.par_p6 = _P6; 
....................  
....................     
....................    _P7 = Read_Byte(0x98); 
....................    dev->calib.par_p7 = _P7; 
....................  
....................    _P8 = ( Read_Byte(0x9D) << 8 ); 
....................    _P8 |= Read_Byte(0x9C); 
....................    _P8 = 0xFFFF0000 | _P8; 
....................    dev->calib.par_p8 = _P8; 
....................  
....................    _P9 = ( Read_Byte(0x9F) << 8 ); 
....................    _P9 |= Read_Byte(0x9E); 
....................    _P9 = 0xFFFF0000 | _P9; 
....................    dev->calib.par_p9 = _P9; 
....................  
....................    _P10 = Read_Byte(0xA0); 
....................    _P10 = 0xFFFF0000 | _P10; 
....................    dev->calib.par_p10 = _P10; 
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "**********   _T1 = %Lu\r\n\r\n", _T1); 
....................    fprintf(STDOUT, "**********   _T2 = %Lu\r\n\r\n", _T2); 
....................    fprintf(STDOUT, "**********   _T3 = %Lu\r\n\r\n", _T3); 
....................    fprintf(STDOUT, "**********   _P1 = %Lu\r\n\r\n", _P1); 
....................    fprintf(STDOUT, "**********   _P2 = %Lu\r\n\r\n", _P2); 
....................    fprintf(STDOUT, "**********   _P3 = %Lu\r\n\r\n", _P3); 
....................    fprintf(STDOUT, "**********   _P4 = %Lu\r\n\r\n", _P4); 
....................    fprintf(STDOUT, "**********   _P5 = %Lu\r\n\r\n", _P5); 
....................    fprintf(STDOUT, "**********   _P6 = %Lu\r\n\r\n", _P6); 
....................    fprintf(STDOUT, "**********   _P7 = %Lu\r\n\r\n", _P7); 
....................    fprintf(STDOUT, "**********   _P8 = %Lu\r\n\r\n", _P8); 
....................    fprintf(STDOUT, "**********   _P9 = %Lu\r\n\r\n", _P9); 
....................    fprintf(STDOUT, "**********   _P10 = %Lu\r\n\r\n", _P10); 
.................... #endif 
....................  
....................  
.................... #else    
....................  
....................     uint8_t coeff_array[BME680_COEFF_SIZE] = { 0 }; 
....................     uint8_t temp_var = 0; /* Temporary variable */ 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     //Null pointer should be check before getting to this point 
....................     //    rslt = null_ptr_check(dev); 
....................  
....................     rslt = bme680_get_regs(BME680_COEFF_ADDR1, coeff_array, BME680_COEFF_ADDR1_LEN, dev); 
....................         /* Append the second half in the same array */ 
....................         if (rslt == BME680_OK) 
....................             rslt = bme680_get_regs(BME680_COEFF_ADDR2, &coeff_array[BME680_COEFF_ADDR1_LEN] 
....................                                    , BME680_COEFF_ADDR2_LEN, dev); 
....................   
....................         /* Temperature related coefficients */ 
....................         dev->calib.par_t1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T1_MSB_REG], 
....................                                         coeff_array[BME680_T1_LSB_REG])); 
....................         dev->calib.par_t2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T2_MSB_REG], 
....................                                        coeff_array[BME680_T2_LSB_REG])); 
....................         dev->calib.par_t3 = (int8_t) (coeff_array[BME680_T3_REG]); 
....................   
....................         /* Pressure related coefficients */ 
....................         dev->calib.par_p1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P1_MSB_REG], 
....................                                         coeff_array[BME680_P1_LSB_REG])); 
....................         dev->calib.par_p2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P2_MSB_REG], 
....................                                        coeff_array[BME680_P2_LSB_REG])); 
....................         dev->calib.par_p3 = (int8_t) coeff_array[BME680_P3_REG]; 
....................         dev->calib.par_p4 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P4_MSB_REG], 
....................                                        coeff_array[BME680_P4_LSB_REG])); 
....................         dev->calib.par_p5 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P5_MSB_REG], 
....................                                        coeff_array[BME680_P5_LSB_REG])); 
....................         dev->calib.par_p6 = (int8_t) (coeff_array[BME680_P6_REG]); 
....................         dev->calib.par_p7 = (int8_t) (coeff_array[BME680_P7_REG]); 
....................         dev->calib.par_p8 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P8_MSB_REG], 
....................                                        coeff_array[BME680_P8_LSB_REG])); 
....................         dev->calib.par_p9 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P9_MSB_REG], 
....................                                        coeff_array[BME680_P9_LSB_REG])); 
....................         dev->calib.par_p10 = (uint8_t) (coeff_array[BME680_P10_REG]); 
....................   
....................         /* Humidity related coefficients */ 
....................         dev->calib.par_h1 = (uint16_t) (((uint16_t) coeff_array[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) 
....................                                         | (coeff_array[BME680_H1_LSB_REG] & BME680_BIT_H1_DATA_MSK)); 
....................         dev->calib.par_h2 = (uint16_t) (((uint16_t) coeff_array[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) 
....................                                         | ((coeff_array[BME680_H2_LSB_REG]) >> BME680_HUM_REG_SHIFT_VAL)); 
....................         dev->calib.par_h3 = (int8_t) coeff_array[BME680_H3_REG]; 
....................         dev->calib.par_h4 = (int8_t) coeff_array[BME680_H4_REG]; 
....................         dev->calib.par_h5 = (int8_t) coeff_array[BME680_H5_REG]; 
....................         dev->calib.par_h6 = (uint8_t) coeff_array[BME680_H6_REG]; 
....................         dev->calib.par_h7 = (int8_t) coeff_array[BME680_H7_REG]; 
....................   
....................         /* Gas heater related coefficients */ 
....................         dev->calib.par_gh1 = (int8_t) coeff_array[BME680_GH1_REG]; 
....................         dev->calib.par_gh2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_GH2_MSB_REG], 
....................                                         coeff_array[BME680_GH2_LSB_REG])); 
....................         dev->calib.par_gh3 = (int8_t) coeff_array[BME680_GH3_REG]; 
....................  
.................... #endif         
....................          /* Other coefficients */ 
....................       if (rslt == BME680_OK)  
....................       { 
....................          rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_RANGE_ADDR, &temp_var, 1, dev); 
....................          dev->calib.res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16); 
....................     
....................          if (rslt == BME680_OK) 
....................          { 
....................             rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_VAL_ADDR, &temp_var, 1, dev); 
....................             dev->calib.res_heat_val = (int8_t) temp_var; 
....................           
....................             if (rslt == BME680_OK) 
....................                rslt = bme680_get_regs(BME680_ADDR_RANGE_SW_ERR_ADDR, &temp_var, 1, dev); 
....................          } 
....................       } 
....................          
....................       dev->calib.range_sw_err = ((int8_t) temp_var & (int8_t) BME680_RSERROR_MSK) / 16; 
....................  
....................    } 
....................   
....................    return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to set the gas configuration of the sensor. 
....................  */ 
.................... int8_t set_gas_config(struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................   
....................         uint8_t reg_addr[2] = {0}; 
....................         uint8_t reg_data[2] = {0}; 
....................   
....................         if (dev->power_mode == BME680_FORCED_MODE) { 
....................             reg_addr[0] = BME680_RES_HEAT0_ADDR; 
....................             reg_data[0] = calc_heater_res(dev->gas_sett.heatr_temp, dev); 
....................             reg_addr[1] = BME680_GAS_WAIT0_ADDR; 
....................             reg_data[1] = calc_heater_dur(dev->gas_sett.heatr_dur); 
....................             dev->gas_sett.nb_conv = 0; 
....................         } else { 
....................             rslt = BME680_W_DEFINE_PWR_MODE; 
....................         } 
....................         if (rslt == BME680_OK) 
....................             rslt = bme680_set_regs(reg_addr, reg_data, 2, dev); 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to get the gas configuration of the sensor. 
....................  * @note heatr_temp and heatr_dur values are currently register data 
....................  * and not the actual values set 
....................  */ 
.................... int8_t get_gas_config(struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     /* starting address of the register array for burst read*/ 
....................     uint8_t reg_addr1 = BME680_ADDR_SENS_CONF_START; 
....................     uint8_t reg_addr2 = BME680_ADDR_GAS_CONF_START; 
....................     uint8_t reg_data = 0; 
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     if (rslt == BME680_OK) { 
....................         if (BME680_SPI_INTF == dev->intf) { 
....................             /* Memory page switch the SPI address*/ 
....................             rslt = set_mem_page(reg_addr1, dev); 
....................         } 
....................   
....................         if (rslt == BME680_OK) { 
....................             rslt = bme680_get_regs(reg_addr1, &reg_data, 1, dev); 
....................             if (rslt == BME680_OK) { 
....................                 dev->gas_sett.heatr_temp = reg_data; 
....................                 rslt = bme680_get_regs(reg_addr2, &reg_data, 1, dev); 
....................                 if (rslt == BME680_OK) { 
....................                     /* Heating duration register value */ 
....................                     dev->gas_sett.heatr_dur = reg_data; 
....................                 } 
....................             } 
....................         } 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
....................   
....................  
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the pressure value. 
....................  */ 
.................... uint32_t calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev) 
.................... { 
....................     int32_t var1; 
....................     int32_t var2; 
....................     int32_t var3; 
....................     int32_t pressure_comp; 
....................   
....................     var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000; 
....................     var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)dev->calib.par_p6) >> 2; 
....................     var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1); 
....................     var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16); 
....................     var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) + (((int32_t)dev->calib.par_p2 * var1) >> 1); 
....................     var1 = var1 >> 18; 
....................     var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15; 
....................     pressure_comp = 1048576 - pres_adc; 
....................     pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125)); 
....................      
....................     if (pressure_comp >= BME680_MAX_OVERFLOW_VAL) 
....................         pressure_comp = ((pressure_comp / var1) << 1); 
....................      
....................     else 
....................         pressure_comp = ((pressure_comp << 1) / var1); 
....................      
....................     var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) * (pressure_comp >> 3)) >> 13)) >> 12; 
....................     var2 = ((int32_t)(pressure_comp >> 2) * (int32_t)dev->calib.par_p8) >> 13; 
....................     var3 = ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)dev->calib.par_p10) >> 17; 
....................   
....................     pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 + ((int32_t)dev->calib.par_p7 << 7)) >> 4); 
....................   
....................     return (uint32_t)pressure_comp; 
....................   
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the humidity value. 
....................  */ 
.................... uint32_t calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev) 
.................... { 
....................     int32_t var1; 
....................     int32_t var2; 
....................     int32_t var3; 
....................     int32_t var4; 
....................     int32_t var5; 
....................     int32_t var6; 
....................     int32_t temp_scaled; 
....................     int32_t calc_hum; 
....................   
....................     temp_scaled = (((int32_t) dev->calib.t_fine * 5) + 128) >> 8; 
....................     var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16))) 
....................            - (((temp_scaled * (int32_t) dev->calib.par_h3) / ((int32_t) 100)) >> 1); 
....................     var2 = ((int32_t) dev->calib.par_h2 
....................             * (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100)) 
....................                + (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6) 
....................                   / ((int32_t) 100)) + (int32_t) (1 << 14))) >> 10; 
....................     var3 = var1 * var2; 
....................     var4 = (int32_t) dev->calib.par_h6 << 7; 
....................     var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4; 
....................     var5 = ((var3 >> 14) * (var3 >> 14)) >> 10; 
....................     var6 = (var4 * var5) >> 1; 
....................     calc_hum = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12; 
....................   
....................     if (calc_hum > 100000) /* Cap at 100%rH */ 
....................         calc_hum = 100000; 
....................     else if (calc_hum < 0) 
....................         calc_hum = 0; 
....................   
....................     return (uint32_t) calc_hum; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the Gas Resistance value. 
....................  */ 
.................... uint32_t calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev) 
.................... { 
....................     int32_t var1; 
....................     uint32_t var2; 
....................     int32_t var3; 
....................     uint32_t calc_gas_res; 
....................     /**Look up table 1 for the possible gas range values */ 
....................    uint32_t lookupTable1[16] = { (uint32_t)(2147483647), (uint32_t)(2147483647), (uint32_t)(2147483647), (uint32_t)(2147483647), 
....................       (uint32_t)(2147483647), (uint32_t)(2126008810), (uint32_t)(2147483647), (uint32_t)(2130303777), 
....................       (uint32_t)(2147483647), (uint32_t)(2147483647), (uint32_t)(2143188679), (uint32_t)(2136746228), 
....................       (uint32_t)(2147483647), (uint32_t)(2126008810), (uint32_t)(2147483647), (uint32_t)(2147483647) }; 
....................     /**Look up table 2 for the possible gas range values */ 
....................    uint32_t lookupTable2[16] = { (uint32_t)(4096000000), (uint32_t)(2048000000), (uint32_t)(1024000000), (uint32_t)(512000000), 
....................       (uint32_t)(255744255), (uint32_t)(127110228), (uint32_t)(64000000), (uint32_t)(32258064), (uint32_t)(16016016), 
....................       (uint32_t)(8000000), (uint32_t)(4000000), (uint32_t)(2000000), (uint32_t)(1000000), (uint32_t)(500000), 
....................       (uint32_t)(250000), (uint32_t)(125000) }; 
....................   
....................     var1 = (int32_t) ((1340 + (5 * (int32_t) dev->calib.range_sw_err)) * 
....................                       ((int32_t) lookupTable1[gas_range])) >> 16; 
....................     var2 = (((int32_t) ((int32_t) gas_res_adc << 15) - (int32_t) (16777216)) + var1); 
....................     var3 = (((int32_t) lookupTable2[gas_range] * (int32_t) var1) >> 9); 
....................     calc_gas_res = (uint32_t) ((var3 + ((int32_t) var2 >> 1)) / (int32_t) var2); 
....................   
....................     return calc_gas_res; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the Heat Resistance value. 
....................  */ 
.................... uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev) 
.................... { 
....................     uint8_t heatr_res; 
....................     int32_t var1; 
....................     int32_t var2; 
....................     int32_t var3; 
....................     int32_t var4; 
....................     int32_t var5; 
....................     int32_t heatr_res_x100; 
....................   
....................     if (temp > 400) /* Cap temperature */ 
....................         temp = 400; 
....................   
....................     var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256; 
....................     var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10); 
....................     var3 = var1 + (var2 / 2); 
....................     var4 = (var3 / (dev->calib.res_heat_range + 4)); 
....................     var5 = (131 * dev->calib.res_heat_val) + 65536; 
....................     heatr_res_x100 = (int32_t) (((var4 / var5) - 250) * 34); 
....................     heatr_res = (uint8_t) ((heatr_res_x100 + 50) / 100); 
....................   
....................     return heatr_res; 
.................... } 
....................   
.................... #else 
....................   
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the 
....................  * temperature value in float format 
....................  */ 
.................... float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev) 
.................... { 
....................     float var1 = 0; 
....................     float var2 = 0; 
....................     float calc_temp = 0; 
....................   
....................     /* calculate var1 data */ 
....................     var1  = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) 
....................              * ((float)dev->calib.par_t2)); 
....................   
....................     /* calculate var2 data */ 
....................     var2  = (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) * 
....................               (((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) * 
....................              ((float)dev->calib.par_t3 * 16.0f)); 
....................   
....................     /* t_fine value*/ 
....................     dev->calib.t_fine = (var1 + var2); 
....................   
....................     /* compensated temperature data*/ 
....................     calc_temp  = ((dev->calib.t_fine) / 5120.0f); 
....................   
....................     return calc_temp; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the 
....................  * pressure value in float format 
....................  */ 
.................... float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev) 
.................... { 
....................     float var1 = 0; 
....................     float var2 = 0; 
....................     float var3 = 0; 
....................     float calc_pres = 0; 
....................   
....................     var1 = (((float)dev->calib.t_fine / 2.0f) - 64000.0f); 
....................     var2 = var1 * var1 * (((float)dev->calib.par_p6) / (131072.0f)); 
....................     var2 = var2 + (var1 * ((float)dev->calib.par_p5) * 2.0f); 
....................     var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f); 
....................     var1 = (((((float)dev->calib.par_p3 * var1 * var1) / 16384.0f) 
....................              + ((float)dev->calib.par_p2 * var1)) / 524288.0f); 
....................     var1 = ((1.0f + (var1 / 32768.0f)) * ((float)dev->calib.par_p1)); 
....................     calc_pres = (1048576.0f - ((float)pres_adc)); 
....................   
....................     /* Avoid exception caused by division by zero */ 
....................     if ((int)var1 != 0) { 
....................         calc_pres = (((calc_pres - (var2 / 4096.0f)) * 6250.0f) / var1); 
....................         var1 = (((float)dev->calib.par_p9) * calc_pres * calc_pres) / 2147483648.0f; 
....................         var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f); 
....................         var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) 
....................                 * (dev->calib.par_p10 / 131072.0f)); 
....................         calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f); 
....................     } else { 
....................         calc_pres = 0; 
....................     } 
....................   
....................     return calc_pres; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the 
....................  * humidity value in float format 
....................  */ 
.................... float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev) 
.................... { 
....................     float calc_hum = 0; 
....................     float var1 = 0; 
....................     float var2 = 0; 
....................     float var3 = 0; 
....................     float var4 = 0; 
....................     float temp_comp; 
....................   
....................     /* compensated temperature data*/ 
....................     temp_comp  = ((dev->calib.t_fine) / 5120.0f); 
....................   
....................     var1 = (float)((float)hum_adc) - (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f) 
....................                                       * temp_comp)); 
....................   
....................     var2 = var1 * ((float)(((float) dev->calib.par_h2 / 262144.0f) * (1.0f + (((float)dev->calib.par_h4 / 16384.0f) 
....................                            * temp_comp) + (((float)dev->calib.par_h5 / 1048576.0f) * temp_comp * temp_comp)))); 
....................   
....................     var3 = (float) dev->calib.par_h6 / 16384.0f; 
....................   
....................     var4 = (float) dev->calib.par_h7 / 2097152.0f; 
....................   
....................     calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2); 
....................   
....................     if (calc_hum > 100.0f) 
....................         calc_hum = 100.0f; 
....................     else if (calc_hum < 0.0f) 
....................         calc_hum = 0.0f; 
....................   
....................     return calc_hum; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the 
....................  * gas resistance value in float format 
....................  */ 
.................... static float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev) 
.................... { 
....................     float calc_gas_res; 
....................     float var1 = 0; 
....................     float var2 = 0; 
....................     float var3 = 0; 
....................   
....................     const float lookup_k1_range[16] = { 
....................         0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.8, 
....................    0.0, 0.0, -0.2, -0.5, 0.0, -1.0, 0.0, 0.0}; 
....................     const float lookup_k2_range[16] = { 
....................         0.0, 0.0, 0.0, 0.0, 0.1, 0.7, 0.0, -0.8, 
....................    -0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; 
....................   
....................     var1 = (1340.0f + (5.0f * dev->calib.range_sw_err)); 
....................     var2 = (var1) * (1.0f + lookup_k1_range[gas_range]/100.0f); 
....................     var3 = 1.0f + (lookup_k2_range[gas_range]/100.0f); 
....................   
....................     calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * (float)(1 << gas_range) * (((((float)gas_res_adc) 
....................                                   - 512.0f)/var2) + 1.0f)); 
....................   
....................     return calc_gas_res; 
.................... } 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the 
....................  * heater resistance value in float format 
....................  */ 
.................... float calc_heater_res(uint16_t temp, const struct bme680_dev *dev) 
.................... { 
....................     float var1 = 0; 
....................     float var2 = 0; 
....................     float var3 = 0; 
....................     float var4 = 0; 
....................     float var5 = 0; 
....................     float res_heat = 0; 
....................   
....................     if (temp > 400) /* Cap temperature */ 
....................         temp = 400; 
....................   
....................     var1 = (((float)dev->calib.par_gh1 / (16.0f)) + 49.0f); 
....................     var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f); 
....................     var3 = ((float)dev->calib.par_gh3 / (1024.0f)); 
....................     var4 = (var1 * (1.0f + (var2 * (float)temp))); 
....................     var5 = (var4 + (var3 * (float)dev->amb_temp)); 
....................     res_heat = (uint8_t)(3.4f * ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) * 
....................                                   (1/(1 + ((float) dev->calib.res_heat_val * 0.002f)))) - 25)); 
....................   
....................     return res_heat; 
.................... } 
....................   
.................... #endif 
....................   
.................... /*! 
....................  * @brief This internal API is used to calculate the Heat duration value. 
....................  */ 
.................... uint8_t calc_heater_dur(uint16_t dur) 
.................... { 
....................     uint8_t factor = 0; 
....................     uint8_t durval; 
....................   
....................     if (dur >= 0xfc0) { 
....................         durval = 0xff; /* Max duration*/ 
....................     } else { 
....................         while (dur > 0x3F) { 
....................             dur = dur / 4; 
....................             factor += 1; 
....................         } 
....................         durval = (uint8_t) (dur + (factor * 64)); 
....................     } 
....................   
....................     return durval; 
.................... } 
....................   
.................... /*****************************************************************************/ 
.................... /*! 
....................  * @brief This internal API is used to calculate the field data of sensor. 
....................  */ 
.................... /*****************************************************************************/  
.................... int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt; 
....................     uint8_t buff[BME680_FIELD_LENGTH] = { 0 }; 
....................     uint8_t gas_range; 
....................     uint32_t adc_temp; 
....................     uint32_t adc_pres; 
....................     uint16_t adc_hum; 
....................     uint16_t adc_gas_res; 
....................     uint8_t tries = 10; 
....................     uint32_t tmp; 
....................      
....................      
....................   
....................     /* Check for null pointer in the device structure*/ 
....................     rslt = null_ptr_check(dev); 
....................     do { 
....................         if (rslt == BME680_OK) { 
....................             rslt = bme680_get_regs(((uint8_t) (BME680_FIELD0_ADDR)), buff, (uint16_t) BME680_FIELD_LENGTH, 
....................                                    dev); 
....................   
....................             data->status = buff[0] & BME680_NEW_DATA_MSK; 
....................             data->gas_index = buff[0] & BME680_GAS_INDEX_MSK; 
....................             data->meas_index = buff[1]; 
....................   
....................             /* read the raw data from the sensor */ 
....................             adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16) 
....................                                    | ((uint32_t) buff[4] / 16)); 
....................             fprintf(STDOUT, "ADC pressure - %Lu \r\n", adc_pres); 
....................   
....................             adc_temp = (uint32_t) (((uint32_t) buff[5] * 4096) | ((uint32_t) buff[6] * 16) 
....................                                    | ((uint32_t) buff[7] / 16)); 
....................             fprintf(STDOUT, "ADC temperature - %Lu \r\n", adc_temp);                                    
....................                                     
....................             adc_hum = (uint16_t) (((uint32_t) buff[8] * 256) | (uint32_t) buff[9]); 
....................             fprintf(STDOUT, "ADC humidity - %Lu \r\n", adc_hum); 
....................              
....................             adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64)); 
....................             fprintf(STDOUT, "ADC gas resolution  - %Lu \r\n", adc_gas_res); 
....................              
....................             gas_range = buff[14] & BME680_GAS_RANGE_MSK; 
....................   
....................             data->status |= buff[14] & BME680_GASM_VALID_MSK; 
....................             data->status |= buff[14] & BME680_HEAT_STAB_MSK; 
....................             if (data->status & BME680_NEW_DATA_MSK)  
....................             { 
....................                 data->temperature = calc_temperature(adc_temp, dev); 
....................                 tmp = data->temperature; 
....................                 fprintf(STDOUT, "Temperature: %Lu \r\n", tmp); 
....................                  
....................                 data->pressure = calc_pressure(adc_pres, dev); 
....................                 tmp = data->pressure; 
....................                 fprintf(STDOUT, "Pressure: %Lu  \r\n", tmp); 
....................                  
....................                 data->humidity = calc_humidity(adc_hum, dev); 
....................                 tmp = data->humidity; 
....................                 fprintf(STDOUT, "Humidity: %Lu \r\n", tmp); 
....................                  
....................                 data->gas_resistance = calc_gas_resistance(adc_gas_res, gas_range, dev); 
....................                 tmp = data->gas_resistance; 
....................                 fprintf(STDOUT, "Gas resistance : %Lu \r\n", tmp); 
....................  
....................                 //break; 
....................             } 
....................              
....................             /* Delay to poll the data */ 
....................             delay_ms(BME680_POLL_PERIOD_MS); 
....................              
....................        } 
....................         tries--; 
....................     } while (tries); 
....................  
....................       
....................     if (!tries) 
....................         rslt = BME680_W_NO_NEW_DATA; 
....................   
....................     return rslt; 
.................... } 
....................   
....................  
....................   
.................... /*! 
....................  * @brief This internal API is used to validate the boundary 
....................  * conditions. 
....................  */ 
.................... int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev) 
.................... { 
....................     int8_t rslt = BME680_OK; 
....................   
....................     if (value != NULL) { 
....................         /* Check if value is below minimum value */ 
....................         if (*value < min) { 
....................             /* Auto correct the invalid value to minimum value */ 
....................             *value = min; 
....................             dev->info_msg |= BME680_I_MIN_CORRECTION; 
....................         } 
....................         /* Check if value is above maximum value */ 
....................         if (*value > max) { 
....................             /* Auto correct the invalid value to maximum value */ 
....................             *value = max; 
....................             dev->info_msg |= BME680_I_MAX_CORRECTION; 
....................         } 
....................     } else { 
....................         rslt = BME680_E_NULL_PTR; 
....................     } 
....................   
....................     return rslt; 
.................... } 
....................   
.................... #endif   // BME_CODE 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <battery.c> 
.................... //////////////////////////////////////// 
.................... // Module: battery.c 
.................... // 
.................... //////////////////////////////////////// 
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define CHARGER_CONNECT_STATUS_D7   PIN_D7 
....................  
.................... uint8 AlertLowBattery; 
.................... uint8 LowBatteryLedState; 
.................... uint8 BatteryTooLow; 
.................... uint8 ChargerConnected; 
.................... int16 v; 
....................  
.................... //////////////////////////////////////// 
.................... uint16 AdditionlValueInCharge = 50; 
.................... uint16 BatteryVoltagereadingCapacityTable[2][21] =  
.................... { 
....................    { 0,   5,   10,  15,  20,  25,  30,  35,  40,  45,  50,  55,  60,  65,  70,  75,  80,  85,  90,  95,  100 }, 
....................    { 849, 858, 880, 896, 906, 913, 915, 918, 912, 917, 919, 926, 928, 933, 938, 958, 858, 858, 965, 965, 965 } 
.................... }; 
....................  
.................... //////////////////////////////////////// 
.................... void ConstructBatteryModule()  
.................... { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
*
02BCA:  MOVF   FC0,W
02BCC:  ANDLW  C0
02BCE:  IORLW  07
02BD0:  MOVWF  FC0
02BD2:  BSF    FC0.7
02BD4:  BSF    FC2.0
....................    setup_adc_ports(sAN22, VSS_VDD); 
02BD6:  MOVF   FC1,W
02BD8:  ANDLW  F0
02BDA:  MOVWF  FC1
02BDC:  MOVLW  00
02BDE:  MOVLB  F
02BE0:  MOVWF  x38
02BE2:  MOVWF  x3C
02BE4:  MOVWF  x39
02BE6:  MOVWF  x3A
02BE8:  MOVLW  04
02BEA:  MOVWF  x3B
....................    set_adc_channel(22); 
02BEC:  MOVLW  58
02BEE:  MOVWF  01
02BF0:  MOVF   FC2,W
02BF2:  ANDLW  83
02BF4:  IORWF  01,W
02BF6:  MOVWF  FC2
02BF8:  MOVLB  0
02BFA:  GOTO   47C8 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void BatteryManagement()  
.................... { 
....................    static int16 lastVbat; 
.................... //   static uint32 ChargerConnectedTime = 0; 
.................... //   uint32 timeDiff = 0; 
.................... //   static uint8 LastChargerConnected = 0; 
....................     
....................    v = read_adc(); 
*
03D4C:  BSF    FC2.1
03D4E:  BTFSC  FC2.1
03D50:  BRA    3D4E
03D52:  MOVFF  FC4,466
03D56:  MOVLB  4
03D58:  MOVFF  FC3,465
....................  
....................    if (lastVbat != v)  
03D5C:  MOVF   x65,W
03D5E:  SUBWF  xBD,W
03D60:  BNZ   3D68
03D62:  MOVF   x66,W
03D64:  SUBWF  xBE,W
03D66:  BZ    3DDE
....................    { 
....................       fprintf(STDOUT, "Battery reading = %ld", v); 
03D68:  MOVLW  E2
03D6A:  MOVWF  FF6
03D6C:  MOVLW  1B
03D6E:  MOVWF  FF7
03D70:  CLRF   19
03D72:  BTFSC  FF2.7
03D74:  BSF    19.7
03D76:  BCF    FF2.7
03D78:  MOVLW  12
03D7A:  MOVLB  9
03D7C:  MOVWF  x66
03D7E:  MOVLB  0
03D80:  CALL   0AAC
03D84:  BTFSC  19.7
03D86:  BSF    FF2.7
03D88:  MOVLW  10
03D8A:  MOVWF  FE9
03D8C:  MOVFF  466,74C
03D90:  MOVFF  465,74B
03D94:  RCALL  3C60
....................       fprintf(STDOUT, new_line_resp); 
03D96:  MOVLW  01
03D98:  MOVWF  FEA
03D9A:  MOVLW  A7
03D9C:  MOVWF  FE9
03D9E:  CALL   2D08
....................        
....................       lastVbat = v; 
03DA2:  MOVFF  466,4BE
03DA6:  MOVFF  465,4BD
....................       BatteryTooLow = FALSE; 
03DAA:  MOVLB  4
03DAC:  CLRF   x63
....................       AlertLowBattery = FALSE; 
03DAE:  CLRF   x61
....................     
....................       if (v < 767)  
03DB0:  BTFSC  x66.7
03DB2:  BRA    3DC2
03DB4:  MOVF   x66,W
03DB6:  SUBLW  02
03DB8:  BNC   3DDE
03DBA:  BNZ   3DC2
03DBC:  MOVF   x65,W
03DBE:  SUBLW  FE
03DC0:  BNC   3DDE
....................       { 
....................          AlertLowBattery = TRUE; 
03DC2:  MOVLW  01
03DC4:  MOVWF  x61
....................          LowBatteryLedState = FALSE; 
03DC6:  CLRF   x62
....................        
....................          if (v < 500) 
03DC8:  BTFSC  x66.7
03DCA:  BRA    3DDA
03DCC:  MOVF   x66,W
03DCE:  SUBLW  01
03DD0:  BNC   3DDE
03DD2:  BNZ   3DDA
03DD4:  MOVF   x65,W
03DD6:  SUBLW  F3
03DD8:  BNC   3DDE
....................             BatteryTooLow = TRUE; 
03DDA:  MOVLW  01
03DDC:  MOVWF  x63
....................       } 
....................    } 
....................     
....................    ChargerConnected = input(CHARGER_CONNECT_STATUS_D7); 
03DDE:  BSF    F95.7
03DE0:  CLRF   x64
03DE2:  BTFSC  F83.7
03DE4:  INCF   x64,F
03DE6:  MOVLB  0
03DE8:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint8 BatteryCapacity() 
*
03E0C:  MOVLB  7
03E0E:  CLRF   x1D
.................... { 
....................    uint8 i; 
....................    int16 chargerConnectDelta; 
....................    uint8 retPercentage = 0; 
....................    static int16 ValNoCharge = 0; 
....................     
....................    ChargerConnected = input(CHARGER_CONNECT_STATUS_D7); 
03E10:  BSF    F95.7
03E12:  MOVLB  4
03E14:  CLRF   x64
03E16:  BTFSC  F83.7
03E18:  INCF   x64,F
....................     
....................    if( !ChargerConnected ) 
03E1A:  MOVF   x64,F
03E1C:  BNZ   3E28
....................       ValNoCharge = v; 
03E1E:  MOVFF  466,4C0
03E22:  MOVFF  465,4BF
03E26:  BRA    3E56
....................        
....................    else  
....................       chargerConnectDelta = v - ( AdditionlValueInCharge * ChargerConnected ); 
03E28:  MOVFF  468,752
03E2C:  MOVFF  467,751
03E30:  MOVLB  7
03E32:  CLRF   x54
03E34:  MOVFF  464,753
03E38:  MOVLB  0
03E3A:  RCALL  3DEA
03E3C:  MOVFF  02,03
03E40:  MOVF   01,W
03E42:  MOVLB  4
03E44:  SUBWF  x65,W
03E46:  MOVLB  7
03E48:  MOVWF  x1B
03E4A:  MOVF   02,W
03E4C:  MOVLB  4
03E4E:  SUBWFB x66,W
03E50:  MOVLB  7
03E52:  MOVWF  x1C
03E54:  MOVLB  4
....................  
....................    for( i = 20; i > 0; i-- ) 
03E56:  MOVLW  14
03E58:  MOVLB  7
03E5A:  MOVWF  x1A
03E5C:  MOVF   x1A,F
03E5E:  BZ    3EAE
....................       if(  chargerConnectDelta >= BatteryVoltagereadingCapacityTable[1][i] ) 
03E60:  BCF    FD8.0
03E62:  RLCF   x1A,W
03E64:  CLRF   03
03E66:  ADDLW  93
03E68:  MOVWF  FE9
03E6A:  MOVLW  04
03E6C:  ADDWFC 03,W
03E6E:  MOVWF  FEA
03E70:  MOVFF  FEC,03
03E74:  MOVF   FED,F
03E76:  MOVFF  FEF,01
03E7A:  BTFSC  x1C.7
03E7C:  BRA    3EAA
03E7E:  MOVF   03,W
03E80:  SUBWF  x1C,W
03E82:  BNC   3EAA
03E84:  BNZ   3E8C
03E86:  MOVF   01,W
03E88:  SUBWF  x1B,W
03E8A:  BNC   3EAA
....................       { 
....................          retPercentage = BatteryVoltagereadingCapacityTable[0][i+1];    
03E8C:  MOVLW  01
03E8E:  ADDWF  x1A,W
03E90:  MOVWF  00
03E92:  BCF    FD8.0
03E94:  RLCF   00,F
03E96:  MOVF   00,W
03E98:  CLRF   03
03E9A:  ADDLW  69
03E9C:  MOVWF  FE9
03E9E:  MOVLW  04
03EA0:  ADDWFC 03,W
03EA2:  MOVWF  FEA
03EA4:  MOVFF  FEF,71D
....................          break; 
03EA8:  BRA    3EAE
03EAA:  DECF   x1A,F
03EAC:  BRA    3E5C
....................       } 
....................  
....................    return retPercentage; 
03EAE:  MOVFF  71D,01
03EB2:  MOVLB  0
03EB4:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "datatype.h" 
.................... #ifndef DATATYPE_H_ 
.................... #define DATATYPE_H_ 
....................  
....................  
.................... #define PASS         1 
.................... #define FAIL         0 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define YES          1 
.................... #define NO           0 
....................  
.................... #define ONE_HUNDRED  100 
....................  
....................  
.................... #define LED_BRIGHTNESS_DEFAULT_VALUE   50 
.................... #define LED_BRIGHTNESS_MINIMUM_SETTING 40 
.................... #define LED_BRIGHTNESS_MAXIMUM_SETTING 100 
....................  
.................... #define BAD_CARTRIDGE   1 
.................... #define GOOD_CARTRIDGE  0 
....................  
.................... #define NEW_CARTRIDGE_MIN_730   540           //Led 730 
.................... #define NEW_CARTRIDGE_MIN_588   558           //Led 588 
.................... #define NEW_CARTRIDGE_MIN_475   630           //Led 730 
....................  
.................... #define NEW_CARTRIDGE_MAX_730   640 
.................... #define NEW_CARTRIDGE_MAX_588   651 
.................... #define NEW_CARTRIDGE_MAX_475   750 
....................  
....................  
.................... #define NO_CARTRIDGE    75 
.................... #define JUST_WET_CARTRIDGE_MAX_588    410 
.................... #define JUST_WET_CARTRIDGE_MIN_588    170 
....................  
....................  
....................  
....................  
.................... #define UNIT_CALIBRATED 0xAA 
.................... #define SLOPE        .020 
.................... #define INTERCEPT    .090 
....................  
.................... //Test mode 
.................... #define CALIBRATION_TEST         0X1 
.................... #define KETONE_TEST              0X2 
.................... #define AMMONIA_TEST             0X3 
....................  
.................... #define MAXINUM_BREATH_VOLUME    2000 
.................... #define STANDARD_BREATH_VOLUME   600 
.................... #define MININUM_BREATH_VOLUME    300 
....................  
....................  
.................... #define INACTIVITY_TIME_LIMIT   30               //5 minutes time limit for inactivity 
.................... #define MAXIMUM_NUMBER_OF_RECORDS 24 
....................  
.................... #define FIVE_MINUTES    300000 
.................... #define FOUR_MINUTES    240000 
.................... #define THREE_MINUTES   180000 
.................... #define TWO_MINUTES     120000 
.................... #define ONE_MINUTE      60000 
.................... #define THIRTY_SECONDS  30000 
.................... #define FIFTEEN_SECONDS 15000 
.................... #define TEN_SECONDS     10000 
.................... #define FIVE_SECONDS     5000 
.................... #define FOUR_SECONDS     4000 
.................... #define THREE_SECONDS    3000 
.................... #define TWO_SECONDS      2000 
.................... #define ONE_SECOND       1000 
....................  
.................... #define BLE_MODULE_ID_SIZE 6 
....................  
.................... const char bad_resp[] = "Bad "; 
.................... const char cartridge_resp[] = "Cartridge "; 
.................... const char bright730_resp[] = "Bright730 "; 
.................... const char bright588_resp[] = "Bright588 "; 
.................... const char bright475_resp[] = "Bright475 "; 
.................... const char brightness_resp[] = "Brightness "; 
.................... const char calibrated_resp[] = "Calibrated "; 
.................... const char cartridge_wetting_check_resp[] = "Cartridge Wetting Check "; 
.................... const char colon_resp[] = ": "; 
.................... const char darkness_resp[] = "Darkness "; 
.................... const char dash_resp[] = "- "; 
.................... const char detected_resp[] = "Detected "; 
.................... const char fail_resp[] = "Fail "; 
.................... const char hardware_check_resp[] = "Hardware Checked "; 
.................... const char insert_new_cartridge_resp[] = "Insert new cartridge "; 
.................... const char led_resp[] = "LED "; 
.................... const char max_power_setting_exceeded_resp[] = "Exceeded maximum power limit allowed "; 
.................... const char new_line_resp[] = "\r\n"; 
.................... const char new_resp[] = "New "; 
....................  
.................... const char not_resp[] = "Not "; 
.................... const char pass_resp[] = "Pass "; 
.................... const char please_wait_resp[] = "Please wait....."; 
.................... const char set_resp[] = "Set "; 
.................... const char test_started_resp[] = "test started "; 
.................... const char time_limit_exceeded[] = "Time limit exceeded"; 
.................... const char two_new_lines_resp[] = "\r\n\r\n"; 
.................... const char used_resp[] = "Used "; 
.................... const char wet_resp[] = "Wet "; 
....................  
....................  
....................  
....................  
.................... enum BreathTestState 
.................... { 
....................     BREATH_TEST_NOT_RUN, 
....................     BREATH_TEST_STARTED, 
....................     BREATH_TEST_EXITING, 
....................     BREATH_TEST_COMPLETED, 
....................     BREATH_TEST_ENDED 
.................... }; 
....................  
.................... enum CatridgeState 
.................... { 
....................     CARTRIDGE_STATE_NEW, 
....................     CARTRIDGE_STATE_USED, 
....................     CARTRIDGE_STATE_JUST_WET, 
....................     CARTRIDGE_STATE_UNKNOWN     
.................... }; 
....................  
.................... enum iosRequests 
.................... { 
....................    IOS_REQUEST_START_KETONE_TEST= 1, 
....................    IOS_REQUEST_START_AMMONIA_TEST, 
....................    IOS_REQUEST_RESET_USE_COUNTER, 
....................    IOS_REQUEST_RESET_READINGS, 
....................    IOS_REQUEST_RESET_STATE_MACHINE = 0XFA, 
....................    IOS_REQUEST_START_FIRMWARE_UPDATE = 0xFF, 
.................... }; 
....................  
.................... enum I50StepState 
.................... { 
....................    HARDWARE_CHECK = 0, 
....................    TEST_STARTED = 1, 
....................    INSERT_CARTRIDGE = 10, 
....................    BLOW = 20, 
....................    WET = 30, 
....................    ANALYZE_BREATH_SAMPLE = 35, 
....................    REMOVE_CARTRIDGE = 40, 
....................    TEST_COMPLETED = 50, 
....................    SEND_RESULTS = 60, 
....................    ERROR_TERMINATION = 70, 
....................  
....................    FULLTEST_UNKNOWN = 0xFFFF 
.................... }; 
....................  
.................... enum I50ErrorCode 
.................... { 
....................    NO_ERROR = 0, 
....................    HARDWARE_FAIL = 1, 
....................    BAD_CATRIDGE = 2, 
....................    BAD_BLOW_VOLUME = 4, 
....................    BAD_BLOW_PRESSURE = 8, 
....................    BAD_SCORE = 10, 
....................    NO_WETTING = 20, 
....................    CARTRIDGE_NOT_REMOVED = 40, 
....................    CARTRIDGE_REMOVED_DURING_ANALYSIS = 80, 
....................    TIME_OUT = 100, 
.................... }; 
....................  
.................... enum opCodeCmd 
.................... { 
....................    START_TEST = 0,  
....................    INIT_FIRMWARE_UPDATE = 1 
.................... }; 
....................  
.................... struct testResultPara 
.................... { 
....................    int16    testMode; 
....................    uint32   totalTestTime; 
....................    int32    score; 
....................    uint8    status; 
....................    uint8    stepID; 
.................... }; 
....................  
.................... struct timePara 
.................... { 
....................    uint8   hour; 
....................    uint8   minute; 
....................    uint8   second; 
....................    uint8   day; 
....................    uint8   month; 
....................    uint8   year; 
.................... }; 
....................  
.................... struct commandPara 
.................... { 
....................    uint8             opCode; 
....................    uint16            volume; 
....................    struct timePara   time; 
.................... }; 
....................  
.................... struct statusPara 
.................... { 
....................    uint32 cartridgeInsertionTime; 
....................    uint32 blowTime; 
....................    uint32 wettingTime; 
....................    uint32 removeCartridgeTime; 
.................... }; 
....................  
.................... struct deviceInfoPara 
.................... { 
....................    uint16 fwMajor; 
....................    uint16 fwMinor; 
....................    uint16 fwRevision; 
....................    uint16 batteryLevel;    
....................    uint16 useCount; 
....................    uint8  bleModuleId[6]; 
.................... }; 
....................  
.................... struct testInfoPara 
.................... { 
....................    int32  temperature; 
....................    uint32 pressure; 
....................    uint16 volume; 
....................    uint16 humidity; 
....................    uint16 numOfBlowAttempts; 
.................... }; 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "bme680_defs.h" 
.................... /** 
....................  * @brief       bme680_defs.h 
....................  * @details     Low power gas, pressure, temperature & humidity sensor. 
....................  *              Header file. 
....................  * 
....................  * 
....................  * @return      N/A 
....................  * 
....................  * @author      Manuel Caballero 
....................  * @date        21/July/2018 
....................  * @version     21/July/2018    The ORIGIN 
....................  * @pre         This is just a port from Bosh driver to mBed ( c++ ) 
....................  * @warning     N/A 
....................  * @pre         This code belongs to Nimbus Centre ( http://www.nimbus.cit.ie ). 
....................  */ 
....................  /** 
....................  * Copyright (C) 2017 - 2018 Bosch Sensortec GmbH 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  * Redistributions of source code must retain the above copyright 
....................  * notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * Redistributions in binary form must reproduce the above copyright 
....................  * notice, this list of conditions and the following disclaimer in the 
....................  * documentation and/or other materials provided with the distribution. 
....................  * 
....................  * Neither the name of the copyright holder nor the names of the 
....................  * contributors may be used to endorse or promote products derived from 
....................  * this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
....................  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
....................  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER 
....................  * OR CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
....................  * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
....................  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
....................  * ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE 
....................  * 
....................  * The information provided is believed to be accurate and reliable. 
....................  * The copyright holder assumes no responsibility 
....................  * for the consequences of use 
....................  * of such information nor for any infringement of patents or 
....................  * other rights of third parties which may result from its use. 
....................  * No license is granted by implication or otherwise under any patent or 
....................  * patent rights of the copyright holder. 
....................  * 
....................  * @file    bme680_defs.h 
....................  * @date    19 Jun 2018 
....................  * @version 3.5.9 
....................  * @brief 
....................  * 
....................  */ 
....................   
.................... /*! @file bme680_defs.h 
....................  @brief Sensor driver for BME680 sensor */ 
.................... /*! 
....................  * @defgroup BME680 SENSOR API 
....................  * @brief 
....................  * @{*/ 
.................... #ifndef BME680_DEFS_H_ 
.................... #define BME680_DEFS_H_ 
....................   
.................... /********************************************************/ 
.................... /* header includes */ 
.................... //#ifdef __KERNEL__ 
.................... //#include <linux/types.h> 
.................... //#include <linux/kernel.h> 
.................... //#else 
.................... #include <stdint.h> 
.................... #include <stddef.h> 
.................... //#endif 
....................   
.................... /******************************************************************************/ 
.................... /*! @name       Common macros                         */ 
.................... /******************************************************************************/ 
....................   
....................   
.................... #include <.\Drivers\stdlib.h> 
.................... #include <.\Drivers\math.h> 
.................... #include <.\Drivers\stdio.h> 
.................... #include <.\Drivers\string.h> 
.................... #include <.\Drivers\ieeefloat.c> 
....................  
.................... //////////////////////////////////////// 
....................  
.................... //#define STREAM_SERIAL_INPUT STDOUT 
.................... //#include <.\Drivers\input.c> 
....................  
.................... //////////////////////////////////////// 
.................... /* 
.................... typedef int8 int8_t; 
.................... typedef int16 int16_t; 
.................... typedef int32 int32_t; 
.................... typedef long long int64_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef unsigned int32 uint32_t; 
.................... typedef unsigned long long uint64_t; 
.................... */ 
....................  
.................... /* 
.................... typedef (int8_t) (int8); 
.................... typedef (int16) INT16_C; 
.................... typedef (int32) (int32); 
.................... typedef (unsigned int8) (unsigned int8); 
.................... typedef (unsigned int16) (unsigned int16); 
.................... typedef (unsigned int32) U(int32); 
.................... */ 
....................   
.................... /* 
.................... #if !defined(UINT8_C) && !defined(INT8_C) 
.................... #define INT8_C(x)       int8_t(x) 
.................... #define UINT8_C(x)      uint8_t(x) 
.................... #endif 
....................   
.................... #if !defined(UINT16_C) && !defined(INT16_C) 
.................... #define INT16_C(x)      int16_t(x) 
.................... #define UINT16_C(x)     uint16_t(x) 
.................... #endif 
....................   
.................... #if !defined(INT32_C) && !defined(UINT32_C) 
.................... #define INT32_C(x)      int32_t(x) 
.................... #define UINT32_C(x)     uint32_t(x) 
.................... #endif 
....................   
.................... #if !defined(INT64_C) && !defined(UINT64_C) 
.................... #define INT64_C(x)      int64_t(x) 
.................... #define UINT64_C(x)     uint64_t(x) 
.................... #endif 
....................  */ 
....................   
.................... /**@}*/ 
....................   
.................... /**\name C standard macros */ 
.................... #ifndef NULL 
.................... #ifdef __cplusplus 
.................... #define NULL   0 
.................... #else 
.................... #define NULL   ((void *) 0) 
.................... #endif 
.................... #endif 
....................   
.................... /** BME680 configuration macros */ 
.................... /** Enable or un-comment the macro to provide floating point data output */ 
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
.................... // #define BME680_FLOAT_POINT_COMPENSATION */ 
.................... #endif 
....................   
.................... /** BME680 General config */ 
.................... #define BME680_POLL_PERIOD_MS             (unsigned int8)(10) 
....................   
.................... /** BME680 I2C addresses */ 
.................... //  T. Luu Check this address shifting compatibility!!!!! 
.................... #define BME680_I2C_ADDR_PRIMARY           (unsigned int8)( 0x76 )        // [MANUAL] Address compatible with mBed 
.................... #define BME680_I2C_ADDR_SECONDARY         (unsigned int8)( 0x77 )        // [MANUAL] Address compatible with mBed 
....................   
.................... #define BME680_I2C_Read_addr            ((BME680_I2C_ADDR_PRIMARY << 1) | 0x01) 
.................... #define BME680_I2C_Write_addr           ((BME680_I2C_ADDR_PRIMARY << 1) & 0xFE) 
....................  
.................... /** BME680 unique chip identifier */ 
.................... #define BME680_CHIP_ID                    (unsigned int8)(0x61) 
....................  
....................  
.................... /** BME680 coefficients related defines */ 
.................... #define BME680_COEFF_SIZE                 (unsigned int8)(41) 
.................... #define BME680_COEFF_ADDR1_LEN            (unsigned int8)(25) 
.................... #define BME680_COEFF_ADDR2_LEN            (unsigned int8)(16) 
....................   
.................... /** BME680 field_x related defines */ 
.................... #define BME680_FIELD_LENGTH               (unsigned int8)(15) 
.................... #define BME680_FIELD_ADDR_OFFSET          (unsigned int8)(17) 
....................   
.................... /** Soft reset command */ 
.................... #define BME680_SOFT_RESET_CMD             (unsigned int8)(0xb6) 
....................   
.................... /** Error code definitions */ 
.................... #define BME680_OK                         (unsigned int8)(0)//(int8)(0) 
....................  
.................... /* Errors */ 
.................... #define BME680_E_NULL_PTR                 (unsigned int8)(1) 
.................... #define BME680_E_COM_FAIL                 (unsigned int8)(2) 
.................... #define BME680_E_DEV_NOT_FOUND            (unsigned int8)(4) 
.................... #define BME680_E_INVALID_LENGTH           (unsigned int8)(8) 
.................... #define BME680_E_SET_MEM_PAGE_FAIL        (unsigned int8)(16) 
.................... #define BME680_E_XXXX_FAIL                (unsigned int8)(32) 
.................... #define BME680_E_XXXX1_FAIL               (unsigned int8)(64) 
.................... #define BME680_E_XXXX2_FAIL               (unsigned int8)(128) 
....................   
.................... /* Warnings */ 
.................... #define BME680_W_DEFINE_PWR_MODE          (int8)(1) 
.................... #define BME680_W_NO_NEW_DATA              (int8)(2) 
....................   
.................... /* Info's */ 
.................... #define BME680_I_MIN_CORRECTION           (unsigned int8)(1) 
.................... #define BME680_I_MAX_CORRECTION           (unsigned int8)(2) 
....................   
.................... /** Register map */ 
.................... /** Other coefficient's address */ 
.................... #define BME680_ADDR_RES_HEAT_VAL_ADDR     (unsigned int8)(0x00) 
.................... #define BME680_ADDR_RES_HEAT_RANGE_ADDR   (unsigned int8)(0x02) 
.................... #define BME680_ADDR_RANGE_SW_ERR_ADDR     (unsigned int8)(0x04) 
.................... #define BME680_ADDR_SENS_CONF_START       (unsigned int8)(0x5A) 
.................... #define BME680_ADDR_GAS_CONF_START        (unsigned int8)(0x64) 
....................   
.................... /** Field settings */ 
.................... #define BME680_FIELD0_ADDR                (unsigned int8)(0x1d) 
....................   
.................... /** Heater settings */ 
.................... #define BME680_RES_HEAT0_ADDR             (unsigned int8)(0x5a) 
.................... #define BME680_GAS_WAIT0_ADDR             (unsigned int8)(0x64) 
....................   
.................... /** Sensor configuration registers */ 
.................... #define BME680_CONF_HEAT_CTRL_ADDR        (unsigned int8)(0x70) 
.................... #define BME680_CONF_ODR_RUN_GAS_NBC_ADDR  (unsigned int8)(0x71) 
.................... #define BME680_CONF_OS_H_ADDR             (unsigned int8)(0x72) 
.................... #define BME680_MEM_PAGE_ADDR              (unsigned int8)(0x73) 
.................... #define BME680_CONF_T_P_MODE_ADDR         (unsigned int8)(0x74) 
.................... #define BME680_CONF_ODR_FILT_ADDR         (unsigned int8)(0x75) 
....................   
.................... /** Coefficient's address */ 
.................... #define BME680_COEFF_ADDR1                (unsigned int8)(0x89) 
.................... #define BME680_COEFF_ADDR2                (unsigned int8)(0xe1) 
....................   
.................... /** Chip identifier */ 
.................... #define BME680_I2CCHIP_ID_ADDR            (unsigned int8)(0xd0) 
.................... #define BME680_SPI_CHIP_ID_ADDR           (unsigned int8)(0x50)  
....................  
.................... /** Soft reset register */ 
.................... #define BME680_I2C_SOFT_RESET_ADDR        (unsigned int8)(0xe0) 
.................... #define BME680_SPI_SOFT_RESET_ADDR        (unsigned int8)(0x60)  
....................  
.................... /** Heater control settings */ 
.................... #define BME680_ENABLE_HEATER              (unsigned int8)(0x00) 
.................... #define BME680_DISABLE_HEATER             (unsigned int8)(0x08) 
....................   
.................... /** Gas measurement settings */ 
.................... #define BME680_DISABLE_GAS_MEAS           (unsigned int8)(0x00) 
.................... #define BME680_ENABLE_GAS_MEAS            (unsigned int8)(0x01) 
....................   
.................... /** Over-sampling settings */ 
.................... #define BME680_OS_NONE                    (unsigned int8)(0) 
.................... #define BME680_OS_1X                      (unsigned int8)(1) 
.................... #define BME680_OS_2X                      (unsigned int8)(2) 
.................... #define BME680_OS_4X                      (unsigned int8)(3) 
.................... #define BME680_OS_8X                      (unsigned int8)(4) 
.................... #define BME680_OS_16X                     (unsigned int8)(5) 
....................   
.................... /** IIR filter settings */ 
.................... #define BME680_FILTER_SIZE_0              (unsigned int8)(0) 
.................... #define BME680_FILTER_SIZE_1              (unsigned int8)(1) 
.................... #define BME680_FILTER_SIZE_3              (unsigned int8)(2) 
.................... #define BME680_FILTER_SIZE_7              (unsigned int8)(3) 
.................... #define BME680_FILTER_SIZE_15             (unsigned int8)(4) 
.................... #define BME680_FILTER_SIZE_31             (unsigned int8)(5) 
.................... #define BME680_FILTER_SIZE_63             (unsigned int8)(6) 
.................... #define BME680_FILTER_SIZE_127            (unsigned int8)(7) 
....................   
.................... /** Power mode settings */ 
.................... #define BME680_SLEEP_MODE                 (unsigned int8)(0) 
.................... #define BME680_FORCED_MODE                (unsigned int8)(1) 
....................   
.................... /** Delay related macro declaration */ 
.................... //#define BME680_RESET_PERIOD               (unsigned int32)(int32)(10) 
.................... #define BME680_RESET_PERIOD               (unsigned int32)(10)  
....................  
.................... /** SPI memory page settings */ 
.................... #define BME680_MEM_PAGE0                  (unsigned int8)(0x0) 
.................... #define BME680_MEM_PAGE1                  (unsigned int8)(0x2) 
....................  
.................... /** SPI register settings */ 
.................... #define BME680_SPI_STATUS                (unsigned int8)(0x73) 
.................... #define BME680_SPI_RESET                 (unsigned int8)(0x60) 
.................... #define BME680_SPI_DEVICE_ID             (unsigned int8)(0x50) 
.................... #define BME680_SPI_CONFIG                (unsigned int8)(0x75) 
.................... #define BME680_SPI_CTRL                  (unsigned int8)(0x74) 
.................... #define BME680_SPI_CTRL_HUM              (unsigned int8)(0x72) 
.................... #define BME680_SPI_CTRL_GAS_1            (unsigned int8)(0x71) 
.................... #define BME680_SPI_CTRL_GAS_0            (unsigned int8)(0x70) 
.................... #define BME680_SPI_GAS_WAIT              (unsigned int8)(0x64)  
.................... #define BME680_SPI_RES_HEAT_X            (unsigned int8)(0x5a) 
.................... #define BME680_SPI_IDAC_HEAT_X           (unsigned int8)(0x50) 
.................... #define BME680_SPI_GAS_R_LSB             (unsigned int8)(0x2b) 
.................... #define BME680_SPI_GAS_R_MSB             (unsigned int8)(0x2a)  
.................... #define BME680_SPI_HUM_LSB               (unsigned int8)(0x26) 
.................... #define BME680_SPI_HUM_MSB               (unsigned int8)(0x25) 
.................... #define BME680_SPI_TEMP_XLSB             (unsigned int8)(0x24) 
.................... #define BME680_SPI_TEMP_LSB              (unsigned int8)(0x23) 
.................... #define BME680_SPI_TEMP_MSB              (unsigned int8)(0x22) 
.................... #define BME680_SPI_PRESS_XLSB            (unsigned int8)(0x21) 
.................... #define BME680_SPI_PRESS_LSB             (unsigned int8)(0x20) 
.................... #define BME680_SPI_PRESS_MSB             (unsigned int8)(0x1f) 
.................... #define BME680_SPI_EAS_STATUS_0          (unsigned int8)(0x1d) 
....................   
.................... #define SLEEP_MODE      (unsigned int8)0X0 
.................... #define FORCED_MODE     (unsigned int8)0X1 
....................  
.................... #define PORTC           (unsigned int8)0XF82 
.................... #define LATC            (unsigned int8)0xF8B 
.................... #define ANSELC          (unsigned int8)0xF3A 
.................... #define TRISC           (unsigned int8)0xF94 
.................... #define SSP1CON1        (unsigned int8)0XFC6 
.................... #define SSP1STAT        (unsigned int8)0XFC7 
....................  
.................... #define TMP_HUM_ADDR    (unsigned int8)0X25 
.................... #define TMP_MSB_ADDR    (unsigned int8)0X22 
.................... #define PRESS_MSB_ADDR  (unsigned int8)0X1F 
.................... #define IDAX_HEAT_X     (unsigned int8)0X50 
.................... #define RES_WAIT_X      (unsigned int8)0X5A 
.................... #define GAS_WAIT_X      (unsigned int8)0X64 
.................... #define CTRL_GAS_1      (unsigned int8)0X71 
....................  
.................... #define BME680_W_SELF_TEST_FAILED 3 
....................  
.................... #define MIN_TEMPERATURE (uint16)(0)      /* 0 degree Celsius */ 
.................... #define MAX_TEMPERATURE (uint16)(6000)    /* 60 degree Celsius */ 
....................  
.................... #define MIN_PRESSURE (uint32)(90000)   /* 900 hecto Pascals */ 
.................... #define MAX_PRESSURE (uint32)(110000)    /* 1100 hecto Pascals */ 
....................  
.................... #define MIN_HUMIDITY (uint32)(20000)   /* 20% relative humidity */ 
.................... #define MAX_HUMIDITY (uint32)(80000)    /* 80% relative humidity*/ 
....................  
.................... #define HEATR_DUR          2000 
.................... #define N_MEAS             6 
.................... #define LOW_TEMP           150 
.................... #define HIGH_TEMP          350 
....................   
....................   
.................... /** Ambient humidity shift value for compensation */ 
.................... #define BME680_HUM_REG_SHIFT_VAL          (unsigned int8)(4) 
....................   
.................... /** Run gas enable and disable settings */ 
.................... #define BME680_RUN_GAS_DISABLE            (unsigned int8)(0) 
.................... #define BME680_RUN_GAS_ENABLE             (unsigned int8)(1) 
....................   
.................... /** Buffer length macro declaration */ 
.................... #define BME680_TMP_BUFFER_LENGTH          (unsigned int8)(40) 
.................... #define BME680_REG_BUFFER_LENGTH          (unsigned int8)(6) 
.................... #define BME680_FIELD_DATA_LENGTH          (unsigned int8)(3) 
.................... #define BME680_GAS_REG_BUF_LENGTH         (unsigned int8)(20) 
....................   
.................... /** Settings selector */ 
.................... #define BME680_OST_SEL                    (unsigned int16)(1) 
.................... #define BME680_OSP_SEL                    (unsigned int16)(2) 
.................... #define BME680_OSH_SEL                    (unsigned int16)(4) 
.................... #define BME680_GAS_MEAS_SEL               (unsigned int16)(8) 
.................... #define BME680_FILTER_SEL                 (unsigned int16)(16) 
.................... #define BME680_HCNTRL_SEL                 (unsigned int16)(32) 
.................... #define BME680_RUN_GAS_SEL                (unsigned int16)(64) 
.................... #define BME680_NBCONV_SEL                 (unsigned int16)(128) 
.................... #define BME680_GAS_SENSOR_SEL             (BME680_GAS_MEAS_SEL | BME680_RUN_GAS_SEL | BME680_NBCONV_SEL) 
....................   
.................... /** Number of conversion settings*/ 
.................... #define BME680_NBCONV_MIN        (unsigned int8)(0) 
.................... #define BME680_NBCONV_MAX        (unsigned int8)(10) 
....................   
.................... /** Mask definitions */ 
.................... #define BME680_GAS_MEAS_MSK      (unsigned int8)(0x30) 
.................... #define BME680_NBCONV_MSK        (unsigned int8)(0X0F) 
.................... #define BME680_FILTER_MSK        (unsigned int8)(0X1C) 
.................... #define BME680_OST_MSK           (unsigned int8)(0XE0) 
.................... #define BME680_OSP_MSK           (unsigned int8)(0X1C) 
.................... #define BME680_OSH_MSK           (unsigned int8)(0X07) 
.................... #define BME680_HCTRL_MSK         (unsigned int8)(0x08) 
.................... #define BME680_RUN_GAS_MSK       (unsigned int8)(0x10) 
.................... #define BME680_MODE_MSK          (unsigned int8)(0x03) 
.................... #define BME680_RHRANGE_MSK       (unsigned int8)(0x30) 
.................... #define BME680_RSERROR_MSK       (unsigned int8)(0xf0) 
.................... #define BME680_NEW_DATA_MSK      (unsigned int8)(0x80) 
.................... #define BME680_GAS_INDEX_MSK     (unsigned int8)(0x0f) 
.................... #define BME680_GAS_RANGE_MSK     (unsigned int8)(0x0f) 
.................... #define BME680_GASM_VALID_MSK    (unsigned int8)(0x20) 
.................... #define BME680_HEAT_STAB_MSK     (unsigned int8)(0x10) 
.................... #define BME680_MEM_PAGE_MSK      (unsigned int8)(0x10) 
.................... #define BME680_SPI_RD_MSK        (unsigned int8)(0x80) 
.................... #define BME680_SPI_WR_MSK        (unsigned int8)(0x7f) 
.................... #define BME680_BIT_H1_DATA_MSK   (unsigned int8)(0x0F) 
....................   
.................... /** Bit position definitions for sensor settings */ 
.................... #define BME680_GAS_MEAS_POS      (unsigned int8)(4) 
.................... #define BME680_FILTER_POS        (unsigned int8)(2) 
.................... #define BME680_OST_POS           (unsigned int8)(5) 
.................... #define BME680_OSP_POS           (unsigned int8)(2) 
.................... #define BME680_RUN_GAS_POS       (unsigned int8)(4) 
....................   
.................... /** Array Index to Field data mapping for Calibration Data*/ 
.................... #define BME680_T2_LSB_REG   (1) 
.................... #define BME680_T2_MSB_REG   (2) 
.................... #define BME680_T3_REG       (3) 
.................... #define BME680_P1_LSB_REG   (5) 
.................... #define BME680_P1_MSB_REG   (6) 
.................... #define BME680_P2_LSB_REG   (7) 
.................... #define BME680_P2_MSB_REG   (8) 
.................... #define BME680_P3_REG       (9) 
.................... #define BME680_P4_LSB_REG   (11) 
.................... #define BME680_P4_MSB_REG   (12) 
.................... #define BME680_P5_LSB_REG   (13) 
.................... #define BME680_P5_MSB_REG   (14) 
.................... #define BME680_P7_REG       (15) 
.................... #define BME680_P6_REG       (16) 
.................... #define BME680_P8_LSB_REG   (19) 
.................... #define BME680_P8_MSB_REG   (20) 
.................... #define BME680_P9_LSB_REG   (21) 
.................... #define BME680_P9_MSB_REG   (22) 
.................... #define BME680_P10_REG      (23) 
.................... #define BME680_H2_MSB_REG   (25) 
.................... #define BME680_H2_LSB_REG   (26) 
.................... #define BME680_H1_LSB_REG   (26) 
.................... #define BME680_H1_MSB_REG   (27) 
.................... #define BME680_H3_REG       (28) 
.................... #define BME680_H4_REG       (29) 
.................... #define BME680_H5_REG       (30) 
.................... #define BME680_H6_REG       (31) 
.................... #define BME680_H7_REG       (32) 
.................... #define BME680_T1_LSB_REG   (33) 
.................... #define BME680_T1_MSB_REG   (34) 
.................... #define BME680_GH2_LSB_REG  (35) 
.................... #define BME680_GH2_MSB_REG  (36) 
.................... #define BME680_GH1_REG      (37) 
.................... #define BME680_GH3_REG      (38) 
....................   
.................... /** BME680 register buffer index settings*/ 
.................... #define BME680_REG_FILTER_INDEX        (unsigned int8)(5) 
.................... #define BME680_REG_TEMP_INDEX          (unsigned int8)(4) 
.................... #define BME680_REG_PRES_INDEX          (unsigned int8)(4) 
.................... #define BME680_REG_HUM_INDEX           (unsigned int8)(2) 
.................... #define BME680_REG_NBCONV_INDEX        (unsigned int8)(1) 
.................... #define BME680_REG_RUN_GAS_INDEX       (unsigned int8)(1) 
.................... #define BME680_REG_HCTRL_INDEX         (unsigned int8)(0) 
....................   
.................... /** BME680 pressure calculation macros */ 
.................... /*! This max value is used to provide precedence to multiplication or division 
....................  * in pressure compensation equation to achieve least loss of precision and 
....................  * avoiding overflows. 
....................  * i.e Comparing value, BME680_MAX_OVERFLOW_VAL = (int32)(1 << 30) 
....................  */ 
.................... #define BME680_MAX_OVERFLOW_VAL      (int32)(0x40000000) 
....................   
.................... /** Macro to combine two 8 bit data's to form a 16 bit data */ 
.................... #define BME680_CONCAT_BYTES(msb, lsb)   (((uint16_t)msb << 8) | (uint16_t)lsb) 
....................   
.................... /** Macro to SET and GET BITS of a register */ 
.................... #define BME680_SET_BITS(reg_data, bitname, data) \ 
....................         ((reg_data & ~(bitname##_MSK)) | \ 
....................         ((data << bitname##_POS) & bitname##_MSK)) 
.................... #define BME680_GET_BITS(reg_data, bitname)  ((reg_data & (bitname##_MSK)) >> \ 
....................     (bitname##_POS)) 
....................   
.................... /** Macro variant to handle the bitname position if it is zero */ 
.................... #define BME680_SET_BITS_POS_0(reg_data, bitname, data) \ 
....................                 ((reg_data & ~(bitname##_MSK)) | \ 
....................                 (data & bitname##_MSK)) 
.................... #define BME680_GET_BITS_POS_0(reg_data, bitname)  (reg_data & (bitname##_MSK)) 
....................   
.................... /** Type definitions */ 
.................... /*! 
....................  * Generic communication function pointer 
....................  * @param[in] dev_id: Place holder to store the id of the device structure 
....................  *                    Can be used to store the index of the Chip select or 
....................  *                    I2C address of the device. 
....................  * @param[in] reg_addr: Used to select the register the where data needs to 
....................  *                      be read from or written to. 
....................  * @param[in/out] reg_data: Data array to read/write 
....................  * @param[in] len: Length of the data array 
....................  */ 
.................... typedef int8_t (*bme680_com_fptr_t)(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len); 
....................   
.................... /*! 
....................  * Delay function pointer 
....................  * @param[in] period: Time period in milliseconds 
....................  */ 
.................... typedef void (*bme680_delay_fptr_t)(uint32_t period); 
....................   
.................... /*! 
....................  * @brief Interface selection Enumerations 
....................  */ 
.................... enum bme680_intf { 
....................     /*! SPI interface */ 
....................     BME680_SPI_INTF, 
....................     /*! I2C interface */ 
....................     BME680_I2C_INTF 
.................... }; 
....................   
.................... /* structure definitions */ 
.................... /*! 
....................  * @brief Sensor field data structure 
....................  */ 
.................... struct  bme680_field_data { 
....................     /*! Contains new_data, gasm_valid & heat_stab */ 
....................     uint8_t status; 
....................     /*! The index of the heater profile used */ 
....................     uint8_t gas_index; 
....................     /*! Measurement index to track order */ 
....................     uint8_t meas_index; 
....................   
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
....................     /*! Temperature in degree celsius x100 */ 
....................     int16_t temperature; 
....................     /*! Pressure in Pascal */ 
....................     uint32_t pressure; 
....................     /*! Humidity in % relative humidity x1000 */ 
....................     uint32_t humidity; 
....................     /*! Gas resistance in Ohms */ 
....................     uint32_t gas_resistance; 
.................... #else 
....................     /*! Temperature in degree celsius */ 
....................     float temperature; 
....................     /*! Pressure in Pascal */ 
....................     float pressure; 
....................     /*! Humidity in % relative humidity x1000 */ 
....................     float humidity; 
....................     /*! Gas resistance in Ohms */ 
....................     float gas_resistance; 
....................   
.................... #endif 
....................   
.................... }; 
....................   
.................... /*! 
....................  * @brief Structure to hold the Calibration data 
....................  */ 
.................... struct  bme680_calib_data { 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint16_t par_h1; 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint16_t par_h2; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h3; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h4; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h5; 
....................     /*! Variable to store calibrated humidity data */ 
....................     uint8_t par_h6; 
....................     /*! Variable to store calibrated humidity data */ 
....................     int8_t par_h7; 
....................     /*! Variable to store calibrated gas data */ 
....................     int8_t par_gh1; 
....................     /*! Variable to store calibrated gas data */ 
....................     int16_t par_gh2; 
....................     /*! Variable to store calibrated gas data */ 
....................     int8_t par_gh3; 
....................     /*! Variable to store calibrated temperature data */ 
....................     uint16_t par_t1; 
....................     /*! Variable to store calibrated temperature data */ 
....................     int16_t par_t2; 
....................     /*! Variable to store calibrated temperature data */ 
....................     int8_t par_t3; 
....................     /*! Variable to store calibrated pressure data */ 
....................     uint16_t par_p1; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p2; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p3; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p4; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p5; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p6; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int8_t par_p7; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p8; 
....................     /*! Variable to store calibrated pressure data */ 
....................     int16_t par_p9; 
....................     /*! Variable to store calibrated pressure data */ 
....................     uint8_t par_p10; 
....................   
.................... #ifndef BME680_FLOAT_POINT_COMPENSATION 
....................     /*! Variable to store t_fine size */ 
....................     int32_t t_fine; 
.................... #else 
....................     /*! Variable to store t_fine size */ 
....................     float t_fine; 
.................... #endif 
....................     /*! Variable to store heater resistance range */ 
....................     uint8_t res_heat_range; 
....................     /*! Variable to store heater resistance value */ 
....................     int8_t res_heat_val; 
....................     /*! Variable to store error range */ 
....................     int8_t range_sw_err; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 sensor settings structure which comprises of ODR, 
....................  * over-sampling and filter settings. 
....................  */ 
.................... struct  bme680_tph_sett { 
....................     /*! Humidity oversampling */ 
....................     uint8_t os_hum; 
....................     /*! Temperature oversampling */ 
....................     uint8_t os_temp; 
....................     /*! Pressure oversampling */ 
....................     uint8_t os_pres; 
....................     /*! Filter coefficient */ 
....................     uint8_t filter; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 gas sensor which comprises of gas settings 
....................  *  and status parameters 
....................  */ 
.................... struct  bme680_gas_sett { 
....................     /*! Variable to store nb conversion */ 
....................     uint8_t nb_conv; 
....................     /*! Variable to store heater control */ 
....................     uint8_t heatr_ctrl; 
....................     /*! Run gas enable value */ 
....................     uint8_t run_gas; 
....................     /*! Heater temperature value */ 
....................     uint16_t heatr_temp; 
....................     /*! Duration profile value */ 
....................     uint16_t heatr_dur; 
.................... }; 
....................   
.................... /*! 
....................  * @brief BME680 device structure 
....................  */ 
.................... struct  bme680_dev { 
....................     /*! Chip Id */ 
....................     uint8_t chip_id; 
....................     /*! Device Id */ 
....................     uint8_t dev_id; 
....................     /*! SPI/I2C interface */ 
....................     enum bme680_intf intf; 
....................     /*! Memory page used */ 
....................     uint8_t mem_page; 
....................     /*! Ambient temperature in Degree C */ 
....................     int8_t amb_temp; 
....................     /*! Sensor calibration data */ 
....................     struct bme680_calib_data calib; 
....................     /*! Sensor settings */ 
....................     struct bme680_tph_sett tph_sett; 
....................     /*! Gas Sensor settings */ 
....................     struct bme680_gas_sett gas_sett; 
....................     /*! Sensor power modes */ 
....................     uint8_t power_mode; 
....................     /*! New sensor fields */ 
....................     uint8_t new_fields; 
....................     /*! Store the info messages */ 
....................     uint8_t info_msg; 
....................     /*! Bus read function pointer */ 
....................     bme680_com_fptr_t read; 
....................     /*! Bus write function pointer */ 
....................     bme680_com_fptr_t write; 
....................     /*! delay function pointer */ 
....................     bme680_delay_fptr_t delay_ms; 
....................     /*! Communication function result */ 
....................     int8_t com_rslt; 
.................... }; 
.................... #endif /* BME680_DEFS_H_ */ 
....................  
....................  
....................  
.................... #include "ErrorCodes.h" 
.................... #ifndef __ERROR_CODES__ 
.................... #define __ERROR_CODES__ 
....................  
.................... #include "datatype.h" 
....................  
....................  
....................  
.................... enum ErrorBitsDefinition 
.................... { 
.................... //   LIS3DH_MALFUNCTION = 0, 
....................    BME680_MALFUNCTION = 0, 
....................    EEPROM_MALFUNCTON, 
....................    LED_MALFUNCTION, 
....................     
....................    ERROR_UNKNOWN = 0XFF 
.................... }; 
....................  
.................... //Result Errors Code 
.................... #define MYSTATUS_OK              0x0 
.................... #define LOW_PRESSURE_BREATH      0X3 
....................  
.................... /* Device Errors Code*/ 
.................... //#define LIS3DH_FAIL                       2 
.................... #define BLE_FAIL                          4 
.................... #define EEPROM_FAIL                       8 
.................... #define BME680_SENSOR_FAIL                16 
.................... #define LED_FAIL                          32 
.................... #define XXXXX_FAIL                        64 
.................... #define NULL_POINTER_DETECTED             128 
....................  
.................... extern int8 ErrorBits; 
.................... extern int8 LastErrorBits; 
....................  
.................... #endif 
....................  
....................  
.................... #include "Events.c" 
.................... #ifdef BASE_40 
.................... enum Events { 
....................    SOLENOID_EJECTS_TRAY = 1, 
....................    TEST_COMPLETE_TRAY_SWITCH_DETECTED = 2 
.................... }; 
....................  
....................  
.................... void bleNotifyEvent(uint16 event) 
.................... { 
....................    static uint16 lastEvent = 0; 
....................     
....................    if (event != lastEvent) { 
....................       lastEvent = event; 
....................       int32 ts = time_get(); 
....................       char b[6]; 
....................       int i; 
....................       char *p= &ts; 
....................       for(i=0; i< 4; i++) 
....................       { 
....................          b[i] = p[i]; 
....................       } 
....................       p=&event; 
....................       b[i++] = p[0]; 
....................       b[i] = p[1]; 
....................       ble_cmd_attributes_write(BLE_HANDLE_EVENTS, 0, 6, b); 
....................       while(!ble_log_process()); 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include "reading.h" 
.................... #ifndef __READING__ 
.................... #define __READING__ 
....................  
.................... #include "datatype.h" 
....................  
.................... #define READING_ERROR_NONE                   0 
.................... #define READING_ERROR_TRAY_OPENED            1 
.................... #define READING_ERROR_CARTRIDGE_REMOVED      2 
.................... #define READING_ERROR_BOTTLE_DOOR_OPENED     3 
.................... #define READING_ERROR_CARTRIDGE_FORGOTTEN    4 
.................... #define READING_ERROR_MODULE_NOT_STRAIGHT    5 
.................... #define READING_ERROR_BAD_TEMPERATURE        6 
.................... #define READING_ERROR_BAD_ORIENTATION        7 
.................... #define READING_ERROR_BAD_READING            8 
....................  
.................... #ifdef BASE_40 
.................... // Total Size: 12 
.................... struct reading  
.................... { 
....................   uint32 timestamp; 
....................  
....................   // NOTE: WARNING. This is actually a float. 
....................   // However the PIC processor does not use IEEE-754 floats 
....................   // so we have to convert manually. 
....................   int32 value; 
....................   uint16 status; 
....................   uint16 FullTestStepID; 
.................... }; 
....................  
.................... void reading_save(uint32 timestamp, float32 value, uint16 status, uint16 fullTestStepID); 
.................... #endif 
....................  
.................... // Total Size: 18 
.................... struct reading  
.................... { 
....................    struct testResultPara   testResult; 
....................    struct timePara         time; 
....................    // NOTE: WARNING. This is actually a float. 
....................    // However the PIC processor does not use IEEE-754 floats 
....................    // so we have to convert manually. 
....................  
.................... }; 
....................  
.................... void readings_reset(); 
.................... uint16 reading_index_start(); 
.................... uint16 reading_index_stop(); 
.................... struct reading reading_fetch(uint16 index); 
.................... void reading_save(struct testResultPara *testResult, struct timePara *timestamp); 
.................... void reading_simulate(); 
....................  
.................... uint16 SetFullTestStepID(uint16 stepID); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... //////////////////////////////////////// 
....................  
.................... static uint16 myStatus; 
.................... //static struct BreathTest myTestResult; 
....................  
.................... static struct bme680_dev gas_sensor; 
....................  
....................  
.................... static struct commandPara     cmdReceived; 
.................... static struct testResultPara  testResult; 
.................... static struct statusPara      testTime; 
.................... static struct deviceInfoPara  deviceStat; 
.................... static struct testInfoPara    testStat; 
....................  
.................... uint8   cartridgeDetected; 
.................... uint8   cartridgeState; 
.................... uint8   brightnessChecked; 
.................... uint8   calibrationStatus; 
.................... uint8   ledBrightnessCalibrated; 
....................  
.................... uint8   bluetoothState; 
.................... uint16  breathVolume; 
.................... uint16  powerDownTimeCtr; 
....................  
....................  
.................... //uint32  timestamp = 0X0; 
.................... //char    string_resp[50]; 
....................  
.................... //uint8   stepSequences[MAXIMUM_NUMBER_OF_RECORDS]; 
.................... //uint8   errorCode[MAXIMUM_NUMBER_OF_RECORDS]; 
....................  
....................  
....................  
....................  
.................... //////////////////////////////////////// 
....................  
.................... struct LightProperties { 
....................    uint8 LevelBrightness730; 
....................    uint8 LevelBrightness588; 
....................    uint8 LevelBrightness475; 
....................     
....................    uint16 DarkReading730; 
....................    uint16 DarkReading588; 
....................    uint16 DarkReading475; 
.................... }; 
....................  
.................... struct LightMeasurements { 
....................    float32 Light730; 
....................    float32 Light588; 
....................    float32 Light475; 
.................... }; 
....................  
.................... struct LedReadings { 
....................    uint16 Raw730; 
....................    uint16 Raw588; 
....................    uint16 Raw475; 
.................... }; 
....................  
.................... //////////////////////////////////////// 
.................... void initBME ( void ) 
.................... { 
.................... #ifdef BME_SPI_MODE 
....................    uint8    *addrPtr = NULL; 
....................    uint8    tmpValue = 0x0; 
....................    gas_sensor.intf = BME680_SPI_INTF; 
....................     
.................... #else  
....................    gas_sensor.intf = BME680_I2C_INTF; 
*
0313E:  MOVLB  4
03140:  BSF    xC5.0
....................     
.................... #endif 
....................  
....................    //Init gas sensor structure 
....................    gas_sensor.write = Write; 
03142:  MOVLW  05
03144:  MOVWF  FEA
03146:  MOVLW  01
03148:  MOVWF  FE9
0314A:  MOVLW  02
0314C:  MOVWF  03
0314E:  MOVLW  6C
03150:  MOVWF  FEF
03152:  MOVFF  03,FEC
....................    gas_sensor.read = Read; 
03156:  MOVLW  04
03158:  MOVWF  FEA
0315A:  SETF   FE9
0315C:  MOVLW  33
0315E:  MOVWF  03
03160:  MOVLW  C6
03162:  MOVWF  FEF
03164:  MOVFF  03,FEC
....................    gas_sensor.delay_ms = NULL; 
03168:  MOVLW  05
0316A:  MOVWF  FEA
0316C:  MOVLW  03
0316E:  MOVWF  FE9
03170:  CLRF   FEC
03172:  MOVF   FED,F
03174:  CLRF   FEF
....................  
.................... #ifdef USE_BME_SPI_MODE 
03176:  MOVLB  0
03178:  GOTO   48C8 (RETURN)
....................    //Clear Port C 
....................    addrPtr = PORTC; 
....................    *addrPtr = 0x0; 
....................     
....................    //Clear data latches 
....................    addrPtr = LATC; 
....................    *addrPtr = 0x0; 
....................     
....................    //Init PORTC - C3 & C4 Direction (TRISC) 
....................    tmpValue = get_tris_c(); 
....................     
....................    //Set C3 to output and C4 to input  
....................    //tmpValue &= 0xF7;       //b1111 0111 
....................    tmpValue &= 0xE7;         //b1110 0111 
....................    set_tris_c(tmpValue); 
....................     
....................    //Set C3 and C4 to digital I/O 
....................    //C3 and C4 located on bit 4 and 5 respectively.  0 - digital, 1 - analog 
....................    addrPtr = ANSELC; 
....................    tmpValue = *addrPtr; 
....................    tmpValue &= 0xE4;       //b1110 0100 
....................    *addrPtr = tmpValue; 
....................     
....................    addrPtr = NULL; 
.................... #endif 
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void shutDown () 
.................... { 
....................    DisableBleModule(); 
*
0462E:  BRA    45CC
....................     
....................    fprintf(STDOUT, "\r\nShutdown external devices...\r\n"); 
04630:  MOVLW  F8
04632:  MOVWF  FF6
04634:  MOVLW  1B
04636:  MOVWF  FF7
04638:  CALL   2CA0
....................    output_low(PIN_C1); 
0463C:  BCF    F94.1
0463E:  BCF    F8B.1
....................    output_low(PIN_C2); 
04640:  BCF    F94.2
04642:  BCF    F8B.2
....................     
....................    fprintf(STDOUT, "\r\nShutdown processor...\r\n"); 
04644:  MOVLW  1A
04646:  MOVWF  FF6
04648:  MOVLW  1C
0464A:  MOVWF  FF7
0464C:  CALL   2CA0
....................    sleep(SLEEP_FULL); 
04650:  MOVFF  FD3,00
04654:  BCF    FD3.7
04656:  SLEEP 
04658:  MOVFF  00,FD3
0465C:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void hardwareFailure() 
0465E:  MOVLB  7
04660:  CLRF   x1D
04662:  CLRF   x1C
04664:  CLRF   x1B
04666:  CLRF   x1A
04668:  CLRF   x1E
.................... { 
....................    uint32   timer_current = 0; 
....................    uint8_t  tmpCtr = 0; 
....................     
....................    while( myStatus ) 
0466A:  MOVLB  4
0466C:  MOVF   xC1,W
0466E:  IORWF  xC2,W
04670:  BTFSC  FD8.2
04672:  BRA    4762
....................    { 
....................       illumination_brightness( 90 ); 
04674:  MOVLW  5A
04676:  MOVLB  8
04678:  MOVWF  x12
0467A:  MOVLB  0
0467C:  RCALL  42F2
....................       illumination_use(ILLUMINATION_730); 
0467E:  MOVLW  7C
04680:  MOVLB  8
04682:  MOVWF  x13
04684:  MOVLW  05
04686:  MOVWF  x12
04688:  MOVLB  0
0468A:  RCALL  4394
....................       ble_wait(100); 
0468C:  MOVLB  7
0468E:  CLRF   x58
04690:  CLRF   x57
04692:  CLRF   x56
04694:  MOVLW  64
04696:  MOVWF  x55
04698:  MOVLB  0
0469A:  RCALL  43F6
....................       output_low(ILLUMINATION_730); 
0469C:  BCF    F92.5
0469E:  BCF    F89.5
....................       ble_wait(50); 
046A0:  MOVLB  7
046A2:  CLRF   x58
046A4:  CLRF   x57
046A6:  CLRF   x56
046A8:  MOVLW  32
046AA:  MOVWF  x55
046AC:  MOVLB  0
046AE:  RCALL  43F6
....................             
....................       play_error(); 
046B0:  RCALL  4538
....................       delay_ms(100); 
046B2:  MOVLW  64
046B4:  MOVLB  8
046B6:  MOVWF  x18
046B8:  MOVLB  0
046BA:  CALL   2D2E
....................  
....................       timer_current = get_ticks(); 
046BE:  RCALL  43C2
046C0:  MOVFF  03,71D
046C4:  MOVFF  02,71C
046C8:  MOVFF  01,71B
046CC:  MOVFF  00,71A
....................       if( timer_current >= TEN_SECONDS ) 
046D0:  MOVLB  7
046D2:  MOVF   x1D,F
046D4:  BNZ   46EA
046D6:  MOVF   x1C,F
046D8:  BNZ   46EA
046DA:  MOVF   x1B,W
046DC:  SUBLW  26
046DE:  BC    4746
046E0:  XORLW  FF
046E2:  BNZ   46EA
046E4:  MOVF   x1A,W
046E6:  SUBLW  0F
046E8:  BC    4746
....................       { 
....................          tmpCtr++; 
046EA:  INCF   x1E,F
....................          set_ticks(0x0); 
046EC:  CLRF   x34
046EE:  CLRF   x33
046F0:  CLRF   x32
046F2:  CLRF   x31
046F4:  MOVLB  0
046F6:  RCALL  45A2
....................          fprintf(STDOUT, "Hardware failure code %lu\r\n", myStatus); 
046F8:  MOVLW  34
046FA:  MOVWF  FF6
046FC:  MOVLW  1C
046FE:  MOVWF  FF7
04700:  CLRF   19
04702:  BTFSC  FF2.7
04704:  BSF    19.7
04706:  BCF    FF2.7
04708:  MOVLW  16
0470A:  MOVLB  9
0470C:  MOVWF  x66
0470E:  MOVLB  0
04710:  CALL   0AAC
04714:  BTFSC  19.7
04716:  BSF    FF2.7
04718:  MOVLW  10
0471A:  MOVWF  FE9
0471C:  CLRF   19
0471E:  BTFSC  FF2.7
04720:  BSF    19.7
04722:  BCF    FF2.7
04724:  MOVFF  4C2,967
04728:  MOVFF  4C1,966
0472C:  CALL   0AD6
04730:  BTFSC  19.7
04732:  BSF    FF2.7
04734:  MOVLW  0D
04736:  BTFSS  FA4.4
04738:  BRA    4736
0473A:  MOVWF  F73
0473C:  MOVLW  0A
0473E:  BTFSS  FA4.4
04740:  BRA    473E
04742:  MOVWF  F73
04744:  MOVLB  7
....................       } 
....................        
....................       if( tmpCtr >= 3 ) 
04746:  MOVF   x1E,W
04748:  SUBLW  02
0474A:  BC    475E
....................       { 
....................          fprintf(STDOUT, "Hardware failure, unit is shutting down\r\n"); 
0474C:  MOVLW  50
0474E:  MOVWF  FF6
04750:  MOVLW  1C
04752:  MOVWF  FF7
04754:  MOVLB  0
04756:  CALL   2CA0
....................          shutDown(); 
0475A:  RCALL  462E
0475C:  MOVLB  7
....................       } 
0475E:  BRA    466A
04760:  MOVLB  4
....................    } 
04762:  MOVLB  0
04764:  GOTO   4CF2 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... struct LightProperties LedProperties; 
.................... struct LedReadings CartridgeRawDataSet1[9]; 
.................... struct LedReadings CartridgeRawDataSet2[7]; 
.................... struct LightMeasurements whitebalances; 
....................  
.................... //////////////////////////////////////// 
.................... struct LedReadings MeasureLEDs() { 
....................    struct LedReadings x; 
....................  
....................    illumination_brightness(LedProperties.LevelBrightness730); 
*
0618A:  MOVFF  50D,812
0618E:  CALL   42F2
....................    illumination_use(ILLUMINATION_730); 
06192:  MOVLW  7C
06194:  MOVLB  8
06196:  MOVWF  x13
06198:  MOVLW  05
0619A:  MOVWF  x12
0619C:  MOVLB  0
0619E:  CALL   4394
....................    ble_wait(45); 
061A2:  MOVLB  7
061A4:  CLRF   x58
061A6:  CLRF   x57
061A8:  CLRF   x56
061AA:  MOVLW  2D
061AC:  MOVWF  x55
061AE:  MOVLB  0
061B0:  CALL   43F6
....................    x.Raw730 = photodiode(); 
061B4:  CALL   4FFC
061B8:  MOVFF  02,750
061BC:  MOVFF  01,74F
....................    //illumination_all_off(); 
....................    ble_wait(5); 
061C0:  MOVLB  7
061C2:  CLRF   x58
061C4:  CLRF   x57
061C6:  CLRF   x56
061C8:  MOVLW  05
061CA:  MOVWF  x55
061CC:  MOVLB  0
061CE:  CALL   43F6
....................     
....................    illumination_brightness(LedProperties.LevelBrightness588); 
061D2:  MOVFF  50E,812
061D6:  CALL   42F2
....................    illumination_use(ILLUMINATION_588); 
061DA:  MOVLW  7C
061DC:  MOVLB  8
061DE:  MOVWF  x13
061E0:  MOVLW  10
061E2:  MOVWF  x12
061E4:  MOVLB  0
061E6:  CALL   4394
....................    ble_wait(45); 
061EA:  MOVLB  7
061EC:  CLRF   x58
061EE:  CLRF   x57
061F0:  CLRF   x56
061F2:  MOVLW  2D
061F4:  MOVWF  x55
061F6:  MOVLB  0
061F8:  CALL   43F6
....................    x.Raw588 = photodiode(); 
061FC:  CALL   4FFC
06200:  MOVFF  02,752
06204:  MOVFF  01,751
....................    //illumination_all_off(); 
....................    ble_wait(5); 
06208:  MOVLB  7
0620A:  CLRF   x58
0620C:  CLRF   x57
0620E:  CLRF   x56
06210:  MOVLW  05
06212:  MOVWF  x55
06214:  MOVLB  0
06216:  CALL   43F6
....................     
....................    illumination_brightness(LedProperties.LevelBrightness475); 
0621A:  MOVFF  50F,812
0621E:  CALL   42F2
....................    illumination_use(ILLUMINATION_475); 
06222:  MOVLW  7C
06224:  MOVLB  8
06226:  MOVWF  x13
06228:  MOVLW  04
0622A:  MOVWF  x12
0622C:  MOVLB  0
0622E:  CALL   4394
....................    ble_wait(45); 
06232:  MOVLB  7
06234:  CLRF   x58
06236:  CLRF   x57
06238:  CLRF   x56
0623A:  MOVLW  2D
0623C:  MOVWF  x55
0623E:  MOVLB  0
06240:  CALL   43F6
....................    x.Raw475 = photodiode(); 
06244:  CALL   4FFC
06248:  MOVFF  02,754
0624C:  MOVFF  01,753
....................    ble_wait(5);   
06250:  MOVLB  7
06252:  CLRF   x58
06254:  CLRF   x57
06256:  CLRF   x56
06258:  MOVLW  05
0625A:  MOVWF  x55
0625C:  MOVLB  0
0625E:  CALL   43F6
....................  
....................    illumination_all_off(); 
06262:  CALL   4344
....................    return x; 
06266:  MOVLW  4F
06268:  MOVWF  01
0626A:  MOVLW  07
0626C:  MOVWF  02
0626E:  GOTO   63D2 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... #ifdef BASE_40 
.................... uint8 check_LEDs_below(uint16 value)  
.................... { 
....................    struct LedReadings x; 
....................     
....................    x = MeasureLEDs(); 
....................     
....................    fprintf(STDOUT, "LEDs Check (<%lu):\r\n730nm, 588nm, 475nm\r%lu, %lu, %lu\r\n", value, x.Raw730, x.Raw588, x.Raw475); 
....................    if (TestMode == 0)  
....................    { 
....................       if (x.Raw730 < value || x.Raw588 < value || x.Raw475 < value)  
....................          return 1; 
....................        
....................       else  
....................          return 0; 
....................    } 
....................     
....................    else  
....................       return 0; // TEST MODE 
.................... } 
.................... #endif 
.................... //////////////////////////////////////// 
.................... uint8 check_wet_cartridge( )  
.................... { 
....................    uint16 Raw588; 
....................     
....................    illumination_all_off(); 
*
06722:  CALL   4344
....................    ble_wait(5); 
06726:  MOVLB  7
06728:  CLRF   x58
0672A:  CLRF   x57
0672C:  CLRF   x56
0672E:  MOVLW  05
06730:  MOVWF  x55
06732:  MOVLB  0
06734:  CALL   43F6
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, cartridge_wetting_check_resp, new_line_resp); 
.................... #endif 
....................  
....................    illumination_brightness(LedProperties.LevelBrightness588); 
06738:  MOVFF  50E,812
0673C:  CALL   42F2
....................    illumination_use(ILLUMINATION_588); 
06740:  MOVLW  7C
06742:  MOVLB  8
06744:  MOVWF  x13
06746:  MOVLW  10
06748:  MOVWF  x12
0674A:  MOVLB  0
0674C:  CALL   4394
....................    ble_wait(45); 
06750:  MOVLB  7
06752:  CLRF   x58
06754:  CLRF   x57
06756:  CLRF   x56
06758:  MOVLW  2D
0675A:  MOVWF  x55
0675C:  MOVLB  0
0675E:  CALL   43F6
....................    Raw588 = photodiode(); 
06762:  CALL   4FFC
06766:  MOVFF  02,732
0676A:  MOVFF  01,731
....................    ble_wait(5);  
0676E:  MOVLB  7
06770:  CLRF   x58
06772:  CLRF   x57
06774:  CLRF   x56
06776:  MOVLW  05
06778:  MOVWF  x55
0677A:  MOVLB  0
0677C:  CALL   43F6
....................    output_low(ILLUMINATION_588); 
06780:  BCF    F94.0
06782:  BCF    F8B.0
....................  
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, bright588_resp); 
....................    fprintf(STDOUT, colon_resp); 
....................    fprintf(STDOUT, "%lu", Raw588); 
....................    fprintf(STDOUT, new_line_resp); 
.................... #endif 
....................  
....................    if (TestMode == 0) 
06784:  MOVF   xD1,F
06786:  BNZ   6824
....................    { 
....................       //if ( Raw588 < JUST_WET_CARTRIDGE_MAX_588 && Raw588 > JUST_WET_CARTRIDGE_MIN_588 )  
....................       if ( Raw588 < JUST_WET_CARTRIDGE_MAX_588 && Raw588 > 75 )  
06788:  MOVLB  7
0678A:  MOVF   x32,W
0678C:  SUBLW  01
0678E:  BNC   67DE
06790:  BNZ   6798
06792:  MOVF   x31,W
06794:  SUBLW  99
06796:  BNC   67DE
06798:  MOVF   x32,F
0679A:  BNZ   67A2
0679C:  MOVF   x31,W
0679E:  SUBLW  4B
067A0:  BC    67DE
....................       { 
....................          fprintf(STDOUT, cartridge_wetting_check_resp); 
067A2:  MOVLW  01
067A4:  MOVWF  FEA
067A6:  MOVLW  1B
067A8:  MOVWF  FE9
067AA:  MOVLB  0
067AC:  CALL   2D08
....................          fprintf(STDOUT, dash_resp); 
067B0:  MOVLW  01
067B2:  MOVWF  FEA
067B4:  MOVLW  41
067B6:  MOVWF  FE9
067B8:  CALL   2D08
....................          fprintf(STDOUT, wet_resp); 
067BC:  MOVLW  01
067BE:  MOVWF  FEA
067C0:  MOVLW  FD
067C2:  MOVWF  FE9
067C4:  CALL   2D08
....................          fprintf(STDOUT, two_new_lines_resp); 
067C8:  MOVLW  01
067CA:  MOVWF  FEA
067CC:  MOVLW  F2
067CE:  MOVWF  FE9
067D0:  CALL   2D08
....................          return YES; 
067D4:  MOVLW  01
067D6:  MOVWF  01
067D8:  BRA    682E
....................       } 
067DA:  BRA    6822
067DC:  MOVLB  7
....................        
....................       else  
....................       { 
....................          fprintf(STDOUT, cartridge_wetting_check_resp); 
067DE:  MOVLW  01
067E0:  MOVWF  FEA
067E2:  MOVLW  1B
067E4:  MOVWF  FE9
067E6:  MOVLB  0
067E8:  CALL   2D08
....................          fprintf(STDOUT, dash_resp); 
067EC:  MOVLW  01
067EE:  MOVWF  FEA
067F0:  MOVLW  41
067F2:  MOVWF  FE9
067F4:  CALL   2D08
....................          fprintf(STDOUT, not_resp); 
067F8:  MOVLW  01
067FA:  MOVWF  FEA
067FC:  MOVLW  AF
067FE:  MOVWF  FE9
06800:  CALL   2D08
....................          fprintf(STDOUT, wet_resp); 
06804:  MOVLW  01
06806:  MOVWF  FEA
06808:  MOVLW  FD
0680A:  MOVWF  FE9
0680C:  CALL   2D08
....................          fprintf(STDOUT, two_new_lines_resp); 
06810:  MOVLW  01
06812:  MOVWF  FEA
06814:  MOVLW  F2
06816:  MOVWF  FE9
06818:  CALL   2D08
....................          return NO; 
0681C:  MOVLW  00
0681E:  MOVWF  01
06820:  BRA    682E
....................       } 
....................    } 
06822:  BRA    682A
....................     
....................    else  
....................    { 
.................... //      fprintf(STDOUT, "Cartridge Wetting Check: skipped test mode"); 
....................       return 0; // TEST MODE overwriting 
06824:  MOVLW  00
06826:  MOVWF  01
06828:  BRA    682E
....................    } 
....................     
....................    illumination_all_off(); 
0682A:  CALL   4344
0682E:  GOTO   8C8E (RETURN)
....................  
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void get_LED_Brightness(void ) 
.................... { 
....................    ledBrightnessCalibrated = ConfigReadByte(CONFIG_LED_BRIGHTNESS_CALIBRATED); 
*
0558A:  MOVLB  7
0558C:  CLRF   x53
0558E:  MOVLW  13
05590:  MOVWF  x52
05592:  MOVLB  0
05594:  CALL   429C
05598:  MOVFF  01,50A
....................     
....................    if( ledBrightnessCalibrated != UNIT_CALIBRATED ) 
0559C:  MOVLB  5
0559E:  MOVF   x0A,W
055A0:  SUBLW  AA
055A2:  BZ    55E6
....................       fprintf(STDOUT, "Brightness not calibrated - 0x%x\r\n", ledBrightnessCalibrated); 
055A4:  MOVLW  7A
055A6:  MOVWF  FF6
055A8:  MOVLW  1C
055AA:  MOVWF  FF7
055AC:  CLRF   19
055AE:  BTFSC  FF2.7
055B0:  BSF    19.7
055B2:  BCF    FF2.7
055B4:  MOVLW  1E
055B6:  MOVLB  9
055B8:  MOVWF  x66
055BA:  MOVLB  0
055BC:  CALL   0AAC
055C0:  BTFSC  19.7
055C2:  BSF    FF2.7
055C4:  MOVFF  50A,74B
055C8:  MOVLW  57
055CA:  MOVLB  7
055CC:  MOVWF  x4C
055CE:  MOVLB  0
055D0:  CALL   2CC2
055D4:  MOVLW  0D
055D6:  BTFSS  FA4.4
055D8:  BRA    55D6
055DA:  MOVWF  F73
055DC:  MOVLW  0A
055DE:  BTFSS  FA4.4
055E0:  BRA    55DE
055E2:  MOVWF  F73
055E4:  MOVLB  5
....................     
....................    fprintf(STDOUT, bright730_resp); 
055E6:  CLRF   FEA
055E8:  MOVLW  E2
055EA:  MOVWF  FE9
055EC:  MOVLB  0
055EE:  CALL   2D08
....................    fprintf(STDOUT, colon_resp); 
055F2:  MOVLW  01
055F4:  MOVWF  FEA
055F6:  MOVLW  34
055F8:  MOVWF  FE9
055FA:  CALL   2D08
....................    fprintf(STDOUT, "%u", ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS)); 
055FE:  MOVLB  7
05600:  CLRF   x53
05602:  CLRF   x52
05604:  MOVLB  0
05606:  CALL   429C
0560A:  MOVFF  01,74B
0560E:  MOVFF  01,813
05612:  MOVLW  1B
05614:  MOVLB  8
05616:  MOVWF  x14
05618:  MOVLB  0
0561A:  CALL   39DC
....................    fprintf(STDOUT, new_line_resp); 
0561E:  MOVLW  01
05620:  MOVWF  FEA
05622:  MOVLW  A7
05624:  MOVWF  FE9
05626:  CALL   2D08
....................     
....................  
....................    fprintf(STDOUT, bright588_resp); 
0562A:  CLRF   FEA
0562C:  MOVLW  ED
0562E:  MOVWF  FE9
05630:  CALL   2D08
....................    fprintf(STDOUT, colon_resp); 
05634:  MOVLW  01
05636:  MOVWF  FEA
05638:  MOVLW  34
0563A:  MOVWF  FE9
0563C:  CALL   2D08
....................    fprintf(STDOUT, "%u", ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS)); 
05640:  MOVLB  7
05642:  CLRF   x53
05644:  MOVLW  01
05646:  MOVWF  x52
05648:  MOVLB  0
0564A:  CALL   429C
0564E:  MOVFF  01,74B
05652:  MOVFF  01,813
05656:  MOVLW  1B
05658:  MOVLB  8
0565A:  MOVWF  x14
0565C:  MOVLB  0
0565E:  CALL   39DC
....................    fprintf(STDOUT, new_line_resp); 
05662:  MOVLW  01
05664:  MOVWF  FEA
05666:  MOVLW  A7
05668:  MOVWF  FE9
0566A:  CALL   2D08
....................  
....................  
....................    fprintf(STDOUT, bright475_resp); 
0566E:  CLRF   FEA
05670:  MOVLW  F8
05672:  MOVWF  FE9
05674:  CALL   2D08
....................    fprintf(STDOUT, colon_resp); 
05678:  MOVLW  01
0567A:  MOVWF  FEA
0567C:  MOVLW  34
0567E:  MOVWF  FE9
05680:  CALL   2D08
....................    fprintf(STDOUT, "%u", ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS)); 
05684:  MOVLB  7
05686:  CLRF   x53
05688:  MOVLW  02
0568A:  MOVWF  x52
0568C:  MOVLB  0
0568E:  CALL   429C
05692:  MOVFF  01,74B
05696:  MOVFF  01,813
0569A:  MOVLW  1B
0569C:  MOVLB  8
0569E:  MOVWF  x14
056A0:  MOVLB  0
056A2:  CALL   39DC
....................    fprintf(STDOUT, new_line_resp); 
056A6:  MOVLW  01
056A8:  MOVWF  FEA
056AA:  MOVLW  A7
056AC:  MOVWF  FE9
056AE:  CALL   2D08
056B2:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... int autoSetLEDBrightness(int16 bt730, int16 bt588, int16 bt475) 
056B4:  MOVLB  7
056B6:  CLRF   x37
056B8:  CLRF   x38
.................... { 
....................    uint8 status = FAIL; 
....................    uint8 ctr = 0; 
....................    int16 Led730, Led588, Led475; 
....................    int16 tmpLed730, tmpLed588, tmpLed475;                  
....................     
....................    Led730 = Led588 = Led475 = 0; 
056BA:  CLRF   x3E
056BC:  CLRF   x3D
056BE:  MOVFF  73E,73C
056C2:  MOVFF  73D,73B
056C6:  MOVFF  73C,73A
056CA:  MOVFF  73B,739
....................    status = FAIL; 
056CE:  CLRF   x37
....................     
....................    ledBrightnessCalibrated = ConfigReadByte(CONFIG_LED_BRIGHTNESS_CALIBRATED); 
056D0:  CLRF   x53
056D2:  MOVLW  13
056D4:  MOVWF  x52
056D6:  MOVLB  0
056D8:  CALL   429C
056DC:  MOVFF  01,50A
.................... //   fprintf(STDOUT, "Brightness calibration stat = %x\r\n", ledBrightnessCalibrated); 
....................     
....................    if( ledBrightnessCalibrated == UNIT_CALIBRATED ) 
056E0:  MOVLB  5
056E2:  MOVF   x0A,W
056E4:  SUBLW  AA
056E6:  BNZ   5782
....................    { 
....................       tmpLed730 = ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS); 
056E8:  MOVLB  7
056EA:  CLRF   x53
056EC:  CLRF   x52
056EE:  MOVLB  0
056F0:  CALL   429C
056F4:  CLRF   03
056F6:  MOVF   01,W
056F8:  BTFSC  FE8.7
056FA:  DECF   03,F
056FC:  MOVLB  7
056FE:  MOVWF  x3F
05700:  MOVFF  03,740
....................       tmpLed588 = ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS); 
05704:  CLRF   x53
05706:  MOVLW  01
05708:  MOVWF  x52
0570A:  MOVLB  0
0570C:  CALL   429C
05710:  CLRF   03
05712:  MOVF   01,W
05714:  BTFSC  FE8.7
05716:  DECF   03,F
05718:  MOVLB  7
0571A:  MOVWF  x41
0571C:  MOVFF  03,742
....................       tmpLed475 = ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS); 
05720:  CLRF   x53
05722:  MOVLW  02
05724:  MOVWF  x52
05726:  MOVLB  0
05728:  CALL   429C
0572C:  CLRF   03
0572E:  MOVF   01,W
05730:  BTFSC  FE8.7
05732:  DECF   03,F
05734:  MOVLB  7
05736:  MOVWF  x43
05738:  MOVFF  03,744
....................        
....................       if( tmpLed730 < LED_BRIGHTNESS_MINIMUM_SETTING ) 
0573C:  BTFSC  x40.7
0573E:  BRA    574A
05740:  MOVF   x40,F
05742:  BNZ   5752
05744:  MOVF   x3F,W
05746:  SUBLW  27
05748:  BNC   5752
....................          tmpLed730 = bt730; 
0574A:  MOVFF  732,740
0574E:  MOVFF  731,73F
....................           
....................       if( tmpLed588 < LED_BRIGHTNESS_MINIMUM_SETTING ) 
05752:  BTFSC  x42.7
05754:  BRA    5760
05756:  MOVF   x42,F
05758:  BNZ   5768
0575A:  MOVF   x41,W
0575C:  SUBLW  27
0575E:  BNC   5768
....................          tmpLed588 = bt588;          
05760:  MOVFF  734,742
05764:  MOVFF  733,741
....................           
....................       if( tmpLed475 < LED_BRIGHTNESS_MINIMUM_SETTING ) 
05768:  BTFSC  x44.7
0576A:  BRA    5776
0576C:  MOVF   x44,F
0576E:  BNZ   577E
05770:  MOVF   x43,W
05772:  SUBLW  27
05774:  BNC   577E
....................          tmpLed475 = bt475; 
05776:  MOVFF  736,744
0577A:  MOVFF  735,743
....................    } 
0577E:  BRA    579C
05780:  MOVLB  5
....................     
....................    else     //First time setting LED brightness 
....................    { 
....................       tmpLed730 = bt730;                  
05782:  MOVFF  732,740
05786:  MOVFF  731,73F
....................       tmpLed588 = bt588;               
0578A:  MOVFF  734,742
0578E:  MOVFF  733,741
....................       tmpLed475 = bt475; 
05792:  MOVFF  736,744
05796:  MOVFF  735,743
0579A:  MOVLB  7
....................    } 
....................                  
....................    //Get the LED brightness readinng 
....................    illumination_brightness(tmpLed730); 
0579C:  MOVFF  73F,812
057A0:  MOVLB  0
057A2:  CALL   42F2
....................    illumination_use(ILLUMINATION_730); 
057A6:  MOVLW  7C
057A8:  MOVLB  8
057AA:  MOVWF  x13
057AC:  MOVLW  05
057AE:  MOVWF  x12
057B0:  MOVLB  0
057B2:  CALL   4394
....................    ble_wait(45); 
057B6:  MOVLB  7
057B8:  CLRF   x58
057BA:  CLRF   x57
057BC:  CLRF   x56
057BE:  MOVLW  2D
057C0:  MOVWF  x55
057C2:  MOVLB  0
057C4:  CALL   43F6
....................    Led730 = photodiode(); 
057C8:  RCALL  4FFC
057CA:  MOVFF  02,73A
057CE:  MOVFF  01,739
....................    ble_wait(5); 
057D2:  MOVLB  7
057D4:  CLRF   x58
057D6:  CLRF   x57
057D8:  CLRF   x56
057DA:  MOVLW  05
057DC:  MOVWF  x55
057DE:  MOVLB  0
057E0:  CALL   43F6
....................    output_low(ILLUMINATION_730); 
057E4:  BCF    F92.5
057E6:  BCF    F89.5
....................     
....................    illumination_brightness(tmpLed588); 
057E8:  MOVFF  741,812
057EC:  CALL   42F2
....................    illumination_use(ILLUMINATION_588); 
057F0:  MOVLW  7C
057F2:  MOVLB  8
057F4:  MOVWF  x13
057F6:  MOVLW  10
057F8:  MOVWF  x12
057FA:  MOVLB  0
057FC:  CALL   4394
....................    ble_wait(45); 
05800:  MOVLB  7
05802:  CLRF   x58
05804:  CLRF   x57
05806:  CLRF   x56
05808:  MOVLW  2D
0580A:  MOVWF  x55
0580C:  MOVLB  0
0580E:  CALL   43F6
....................    Led588 = photodiode(); 
05812:  CALL   4FFC
05816:  MOVFF  02,73C
0581A:  MOVFF  01,73B
....................    ble_wait(5); 
0581E:  MOVLB  7
05820:  CLRF   x58
05822:  CLRF   x57
05824:  CLRF   x56
05826:  MOVLW  05
05828:  MOVWF  x55
0582A:  MOVLB  0
0582C:  CALL   43F6
....................    output_low(ILLUMINATION_588); 
05830:  BCF    F94.0
05832:  BCF    F8B.0
....................     
....................    illumination_brightness(tmpLed475); 
05834:  MOVFF  743,812
05838:  CALL   42F2
....................    illumination_use(ILLUMINATION_475); 
0583C:  MOVLW  7C
0583E:  MOVLB  8
05840:  MOVWF  x13
05842:  MOVLW  04
05844:  MOVWF  x12
05846:  MOVLB  0
05848:  CALL   4394
....................    ble_wait(45); 
0584C:  MOVLB  7
0584E:  CLRF   x58
05850:  CLRF   x57
05852:  CLRF   x56
05854:  MOVLW  2D
05856:  MOVWF  x55
05858:  MOVLB  0
0585A:  CALL   43F6
....................    Led475 = photodiode(); 
0585E:  CALL   4FFC
05862:  MOVFF  02,73E
05866:  MOVFF  01,73D
....................    ble_wait(5); 
0586A:  MOVLB  7
0586C:  CLRF   x58
0586E:  CLRF   x57
05870:  CLRF   x56
05872:  MOVLW  05
05874:  MOVWF  x55
05876:  MOVLB  0
05878:  CALL   43F6
....................    output_low(ILLUMINATION_475); 
0587C:  BCF    F92.4
0587E:  BCF    F89.4
....................  
....................    delay_ms(2850); 
05880:  MOVLW  0F
05882:  MOVLB  7
05884:  MOVWF  x4B
05886:  MOVLW  BE
05888:  MOVLB  8
0588A:  MOVWF  x18
0588C:  MOVLB  0
0588E:  CALL   2D2E
05892:  MOVLB  7
05894:  DECFSZ x4B,F
05896:  BRA    5886
....................                    
.................... //   if( Led588 < NEW_CARTRIDGE_MIN && tmpLed588 > 75 ) 
....................    if( Led730 < NEW_CARTRIDGE_MIN_730 && tmpLed730 > NO_CARTRIDGE ) 
05898:  BTFSC  x3A.7
0589A:  BRA    58AA
0589C:  MOVF   x3A,W
0589E:  SUBLW  02
058A0:  BNC   590C
058A2:  BNZ   58AA
058A4:  MOVF   x39,W
058A6:  SUBLW  1B
058A8:  BNC   590C
058AA:  BTFSC  x40.7
058AC:  BRA    590C
058AE:  MOVF   x40,F
058B0:  BNZ   58B8
058B2:  MOVF   x3F,W
058B4:  SUBLW  4B
058B6:  BC    590C
....................    {  
....................       cartridgeState = CARTRIDGE_STATE_USED; 
058B8:  MOVLW  01
058BA:  MOVLB  5
058BC:  MOVWF  x07
....................       bleNotifyErrorSet(BAD_CATRIDGE); 
058BE:  MOVLW  02
058C0:  MOVLB  8
058C2:  MOVWF  x12
058C4:  MOVLB  0
058C6:  CALL   3A78
....................       fprintf(STDOUT, bad_resp); 
058CA:  CLRF   FEA
058CC:  MOVLW  D2
058CE:  MOVWF  FE9
058D0:  CALL   2D08
....................       fprintf(STDOUT, cartridge_resp); 
058D4:  CLRF   FEA
058D6:  MOVLW  D7
058D8:  MOVWF  FE9
058DA:  CALL   2D08
....................       fprintf(STDOUT, detected_resp); 
058DE:  MOVLW  01
058E0:  MOVWF  FEA
058E2:  MOVLW  44
058E4:  MOVWF  FE9
058E6:  CALL   2D08
....................       fprintf(STDOUT, insert_new_cartridge_resp); 
058EA:  MOVLW  01
058EC:  MOVWF  FEA
058EE:  MOVLW  66
058F0:  MOVWF  FE9
058F2:  CALL   2D08
....................       fprintf(STDOUT, two_new_lines_resp); 
058F6:  MOVLW  01
058F8:  MOVWF  FEA
058FA:  MOVLW  F2
058FC:  MOVWF  FE9
058FE:  CALL   2D08
....................  
....................       return status; 
05902:  MOVLB  7
05904:  MOVFF  737,01
05908:  GOTO   6028
....................    } 
....................                    
....................    while( status != PASS ) 
0590C:  DECFSZ x37,W
0590E:  BRA    5914
05910:  GOTO   6024
....................    { 
....................       fprintf(STDOUT, bright730_resp); 
05914:  CLRF   FEA
05916:  MOVLW  E2
05918:  MOVWF  FE9
0591A:  MOVLB  0
0591C:  CALL   2D08
....................       fprintf(STDOUT, dash_resp);    
05920:  MOVLW  01
05922:  MOVWF  FEA
05924:  MOVLW  41
05926:  MOVWF  FE9
05928:  CALL   2D08
....................       fprintf(STDOUT, "%ld @ %ld", Led730, tmpLed730); 
0592C:  MOVLW  10
0592E:  MOVWF  FE9
05930:  MOVFF  73A,74C
05934:  MOVFF  739,74B
05938:  CALL   3C60
0593C:  MOVLW  A1
0593E:  MOVWF  FF6
05940:  MOVLW  1C
05942:  MOVWF  FF7
05944:  CLRF   19
05946:  BTFSC  FF2.7
05948:  BSF    19.7
0594A:  BCF    FF2.7
0594C:  MOVLW  03
0594E:  MOVLB  9
05950:  MOVWF  x66
05952:  MOVLB  0
05954:  CALL   0AAC
05958:  BTFSC  19.7
0595A:  BSF    FF2.7
0595C:  MOVLW  10
0595E:  MOVWF  FE9
05960:  MOVFF  740,74C
05964:  MOVFF  73F,74B
05968:  CALL   3C60
....................       fprintf(STDOUT, new_line_resp);    
0596C:  MOVLW  01
0596E:  MOVWF  FEA
05970:  MOVLW  A7
05972:  MOVWF  FE9
05974:  CALL   2D08
....................     
....................       fprintf(STDOUT, bright588_resp); 
05978:  CLRF   FEA
0597A:  MOVLW  ED
0597C:  MOVWF  FE9
0597E:  CALL   2D08
....................       fprintf(STDOUT, dash_resp);    
05982:  MOVLW  01
05984:  MOVWF  FEA
05986:  MOVLW  41
05988:  MOVWF  FE9
0598A:  CALL   2D08
....................       fprintf(STDOUT, "%ld @ %ld", Led588, tmpLed588);                      
0598E:  MOVLW  10
05990:  MOVWF  FE9
05992:  MOVFF  73C,74C
05996:  MOVFF  73B,74B
0599A:  CALL   3C60
0599E:  MOVLW  AB
059A0:  MOVWF  FF6
059A2:  MOVLW  1C
059A4:  MOVWF  FF7
059A6:  CLRF   19
059A8:  BTFSC  FF2.7
059AA:  BSF    19.7
059AC:  BCF    FF2.7
059AE:  MOVLW  03
059B0:  MOVLB  9
059B2:  MOVWF  x66
059B4:  MOVLB  0
059B6:  CALL   0AAC
059BA:  BTFSC  19.7
059BC:  BSF    FF2.7
059BE:  MOVLW  10
059C0:  MOVWF  FE9
059C2:  MOVFF  742,74C
059C6:  MOVFF  741,74B
059CA:  CALL   3C60
....................       fprintf(STDOUT, new_line_resp);    
059CE:  MOVLW  01
059D0:  MOVWF  FEA
059D2:  MOVLW  A7
059D4:  MOVWF  FE9
059D6:  CALL   2D08
....................        
....................       fprintf(STDOUT, bright475_resp); 
059DA:  CLRF   FEA
059DC:  MOVLW  F8
059DE:  MOVWF  FE9
059E0:  CALL   2D08
....................       fprintf(STDOUT, dash_resp);    
059E4:  MOVLW  01
059E6:  MOVWF  FEA
059E8:  MOVLW  41
059EA:  MOVWF  FE9
059EC:  CALL   2D08
....................       fprintf(STDOUT, "%ld @ %ld", Led475, tmpLed475); 
059F0:  MOVLW  10
059F2:  MOVWF  FE9
059F4:  MOVFF  73E,74C
059F8:  MOVFF  73D,74B
059FC:  CALL   3C60
05A00:  MOVLW  B5
05A02:  MOVWF  FF6
05A04:  MOVLW  1C
05A06:  MOVWF  FF7
05A08:  CLRF   19
05A0A:  BTFSC  FF2.7
05A0C:  BSF    19.7
05A0E:  BCF    FF2.7
05A10:  MOVLW  03
05A12:  MOVLB  9
05A14:  MOVWF  x66
05A16:  MOVLB  0
05A18:  CALL   0AAC
05A1C:  BTFSC  19.7
05A1E:  BSF    FF2.7
05A20:  MOVLW  10
05A22:  MOVWF  FE9
05A24:  MOVFF  744,74C
05A28:  MOVFF  743,74B
05A2C:  CALL   3C60
....................       fprintf(STDOUT, new_line_resp);    
05A30:  MOVLW  01
05A32:  MOVWF  FEA
05A34:  MOVLW  A7
05A36:  MOVWF  FE9
05A38:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp);    
05A3C:  MOVLW  01
05A3E:  MOVWF  FEA
05A40:  MOVLW  A7
05A42:  MOVWF  FE9
05A44:  CALL   2D08
....................  
....................       //Check for cartridge 
....................       if( Led730 < NO_CARTRIDGE || Led588 < NO_CARTRIDGE || Led475 < NO_CARTRIDGE ) 
05A48:  MOVLB  7
05A4A:  BTFSC  x3A.7
05A4C:  BRA    5A74
05A4E:  MOVF   x3A,F
05A50:  BNZ   5A58
05A52:  MOVF   x39,W
05A54:  SUBLW  4A
05A56:  BC    5A74
05A58:  BTFSC  x3C.7
05A5A:  BRA    5A74
05A5C:  MOVF   x3C,F
05A5E:  BNZ   5A66
05A60:  MOVF   x3B,W
05A62:  SUBLW  4A
05A64:  BC    5A74
05A66:  BTFSC  x3E.7
05A68:  BRA    5A74
05A6A:  MOVF   x3E,F
05A6C:  BNZ   5B20
05A6E:  MOVF   x3D,W
05A70:  SUBLW  4A
05A72:  BNC   5B20
....................       { 
....................          bleNotifyErrorSet(BAD_CATRIDGE); 
05A74:  MOVLW  02
05A76:  MOVLB  8
05A78:  MOVWF  x12
05A7A:  MOVLB  0
05A7C:  CALL   3A78
....................          fprintf(STDOUT, "%lu, %lu, %lu", Led730, Led588, Led475); 
05A80:  MOVLW  10
05A82:  MOVWF  FE9
05A84:  CLRF   19
05A86:  BTFSC  FF2.7
05A88:  BSF    19.7
05A8A:  BCF    FF2.7
05A8C:  MOVFF  73A,967
05A90:  MOVFF  739,966
05A94:  CALL   0AD6
05A98:  BTFSC  19.7
05A9A:  BSF    FF2.7
05A9C:  MOVLW  2C
05A9E:  BTFSS  FA4.4
05AA0:  BRA    5A9E
05AA2:  MOVWF  F73
05AA4:  MOVLW  20
05AA6:  BTFSS  FA4.4
05AA8:  BRA    5AA6
05AAA:  MOVWF  F73
05AAC:  MOVLW  10
05AAE:  MOVWF  FE9
05AB0:  CLRF   19
05AB2:  BTFSC  FF2.7
05AB4:  BSF    19.7
05AB6:  BCF    FF2.7
05AB8:  MOVFF  73C,967
05ABC:  MOVFF  73B,966
05AC0:  CALL   0AD6
05AC4:  BTFSC  19.7
05AC6:  BSF    FF2.7
05AC8:  MOVLW  2C
05ACA:  BTFSS  FA4.4
05ACC:  BRA    5ACA
05ACE:  MOVWF  F73
05AD0:  MOVLW  20
05AD2:  BTFSS  FA4.4
05AD4:  BRA    5AD2
05AD6:  MOVWF  F73
05AD8:  MOVLW  10
05ADA:  MOVWF  FE9
05ADC:  CLRF   19
05ADE:  BTFSC  FF2.7
05AE0:  BSF    19.7
05AE2:  BCF    FF2.7
05AE4:  MOVFF  73E,967
05AE8:  MOVFF  73D,966
05AEC:  CALL   0AD6
05AF0:  BTFSC  19.7
05AF2:  BSF    FF2.7
....................          fprintf(STDOUT, two_new_lines_resp); 
05AF4:  MOVLW  01
05AF6:  MOVWF  FEA
05AF8:  MOVLW  F2
05AFA:  MOVWF  FE9
05AFC:  CALL   2D08
....................          fprintf(STDOUT, insert_new_cartridge_resp); 
05B00:  MOVLW  01
05B02:  MOVWF  FEA
05B04:  MOVLW  66
05B06:  MOVWF  FE9
05B08:  CALL   2D08
....................          fprintf(STDOUT, new_line_resp); 
05B0C:  MOVLW  01
05B0E:  MOVWF  FEA
05B10:  MOVLW  A7
05B12:  MOVWF  FE9
05B14:  CALL   2D08
....................          return FAIL;                         
05B18:  MOVLW  00
05B1A:  MOVWF  01
05B1C:  MOVLB  7
05B1E:  BRA    6028
....................       } 
....................  
....................       if( tmpLed730 >= LED_BRIGHTNESS_MAXIMUM_SETTING || tmpLed588 >= LED_BRIGHTNESS_MAXIMUM_SETTING || tmpLed475 >= LED_BRIGHTNESS_MAXIMUM_SETTING )                     
05B20:  BTFSC  x40.7
05B22:  BRA    5B2E
05B24:  MOVF   x40,F
05B26:  BNZ   5B4A
05B28:  MOVF   x3F,W
05B2A:  SUBLW  63
05B2C:  BNC   5B4A
05B2E:  BTFSC  x42.7
05B30:  BRA    5B3C
05B32:  MOVF   x42,F
05B34:  BNZ   5B4A
05B36:  MOVF   x41,W
05B38:  SUBLW  63
05B3A:  BNC   5B4A
05B3C:  BTFSC  x44.7
05B3E:  BRA    5B84
05B40:  MOVF   x44,F
05B42:  BNZ   5B4A
05B44:  MOVF   x43,W
05B46:  SUBLW  63
05B48:  BC    5B84
....................       { 
....................          fprintf(STDOUT, new_line_resp); 
05B4A:  MOVLW  01
05B4C:  MOVWF  FEA
05B4E:  MOVLW  A7
05B50:  MOVWF  FE9
05B52:  MOVLB  0
05B54:  CALL   2D08
....................          fprintf(STDOUT, max_power_setting_exceeded_resp); 
05B58:  MOVLW  01
05B5A:  MOVWF  FEA
05B5C:  MOVLW  81
05B5E:  MOVWF  FE9
05B60:  CALL   2D08
....................          fprintf(STDOUT, new_line_resp); 
05B64:  MOVLW  01
05B66:  MOVWF  FEA
05B68:  MOVLW  A7
05B6A:  MOVWF  FE9
05B6C:  CALL   2D08
....................           
....................          bleNotifyErrorSet(HARDWARE_FAIL); 
05B70:  MOVLW  01
05B72:  MOVLB  8
05B74:  MOVWF  x12
05B76:  MOVLB  0
05B78:  CALL   3A78
....................          return FAIL;                         
05B7C:  MOVLW  00
05B7E:  MOVWF  01
05B80:  MOVLB  7
05B82:  BRA    6028
....................       } 
....................                      
....................       //Adjust the LED brightness 
....................       if( Led730 <= 590 || Led730 >= 610 ) 
05B84:  BTFSC  x3A.7
05B86:  BRA    5BAA
05B88:  MOVF   x3A,W
05B8A:  SUBLW  02
05B8C:  BNC   5B96
05B8E:  BNZ   5BAA
05B90:  MOVF   x39,W
05B92:  SUBLW  4E
05B94:  BC    5BAA
05B96:  BTFSC  x3A.7
05B98:  BRA    5C2C
05B9A:  MOVF   x3A,W
05B9C:  SUBLW  01
05B9E:  BC    5C2C
05BA0:  XORLW  FF
05BA2:  BNZ   5BAA
05BA4:  MOVF   x39,W
05BA6:  SUBLW  61
05BA8:  BC    5C2C
....................       { 
....................          int16 tmp_led730 = 600 - Led730; 
05BAA:  MOVLW  58
05BAC:  BSF    FD8.0
05BAE:  SUBFWB x39,W
05BB0:  MOVWF  x45
05BB2:  MOVLW  02
05BB4:  SUBFWB x3A,W
05BB6:  MOVWF  x46
....................                        
....................          if( tmp_led730 < 20  && tmp_led730 > 5 ) 
05BB8:  BTFSC  x46.7
05BBA:  BRA    5BC6
05BBC:  MOVF   x46,F
05BBE:  BNZ   5BDC
05BC0:  MOVF   x45,W
05BC2:  SUBLW  13
05BC4:  BNC   5BDC
05BC6:  BTFSC  x46.7
05BC8:  BRA    5BDC
05BCA:  MOVF   x46,F
05BCC:  BNZ   5BD4
05BCE:  MOVF   x45,W
05BD0:  SUBLW  05
05BD2:  BC    5BDC
....................             tmp_led730 = 1; 
05BD4:  CLRF   x46
05BD6:  MOVLW  01
05BD8:  MOVWF  x45
05BDA:  BRA    5C24
....................                          
....................          else if ( tmp_led730 > -20 && tmp_led730 < -5 ) 
05BDC:  BTFSS  x46.7
05BDE:  BRA    5BF0
05BE0:  MOVF   x46,W
05BE2:  SUBLW  FE
05BE4:  BC    5C08
05BE6:  XORLW  FF
05BE8:  BNZ   5BF0
05BEA:  MOVF   x45,W
05BEC:  SUBLW  EC
05BEE:  BC    5C08
05BF0:  BTFSS  x46.7
05BF2:  BRA    5C08
05BF4:  MOVF   x46,W
05BF6:  SUBLW  FF
05BF8:  BNC   5C08
05BFA:  BNZ   5C02
05BFC:  MOVF   x45,W
05BFE:  SUBLW  FA
05C00:  BNC   5C08
....................             tmp_led730 = -1; 
05C02:  SETF   x46
05C04:  SETF   x45
05C06:  BRA    5C24
....................                             
....................          else   
....................             tmp_led730 /= 20; 
05C08:  MOVFF  746,74C
05C0C:  MOVFF  745,74B
05C10:  CLRF   x4E
05C12:  MOVLW  14
05C14:  MOVWF  x4D
05C16:  MOVLB  0
05C18:  RCALL  54F4
05C1A:  MOVFF  02,746
05C1E:  MOVFF  01,745
05C22:  MOVLB  7
....................                             
....................          tmpLed730 += tmp_led730; 
05C24:  MOVF   x45,W
05C26:  ADDWF  x3F,F
05C28:  MOVF   x46,W
05C2A:  ADDWFC x40,F
....................       } 
....................                       
....................       if( Led588 <= 610 || Led588 >= 630 ) 
05C2C:  BTFSC  x3C.7
05C2E:  BRA    5C52
05C30:  MOVF   x3C,W
05C32:  SUBLW  02
05C34:  BNC   5C3E
05C36:  BNZ   5C52
05C38:  MOVF   x3B,W
05C3A:  SUBLW  62
05C3C:  BC    5C52
05C3E:  BTFSC  x3C.7
05C40:  BRA    5CD4
05C42:  MOVF   x3C,W
05C44:  SUBLW  01
05C46:  BC    5CD4
05C48:  XORLW  FF
05C4A:  BNZ   5C52
05C4C:  MOVF   x3B,W
05C4E:  SUBLW  75
05C50:  BC    5CD4
....................       { 
....................          int16 tmp_led588 = 620 - Led588; 
05C52:  MOVLW  6C
05C54:  BSF    FD8.0
05C56:  SUBFWB x3B,W
05C58:  MOVWF  x47
05C5A:  MOVLW  02
05C5C:  SUBFWB x3C,W
05C5E:  MOVWF  x48
....................                          
....................          if( tmp_led588 < 20  && tmp_led588 > 5 ) 
05C60:  BTFSC  x48.7
05C62:  BRA    5C6E
05C64:  MOVF   x48,F
05C66:  BNZ   5C84
05C68:  MOVF   x47,W
05C6A:  SUBLW  13
05C6C:  BNC   5C84
05C6E:  BTFSC  x48.7
05C70:  BRA    5C84
05C72:  MOVF   x48,F
05C74:  BNZ   5C7C
05C76:  MOVF   x47,W
05C78:  SUBLW  05
05C7A:  BC    5C84
....................             tmp_led588 = 1; 
05C7C:  CLRF   x48
05C7E:  MOVLW  01
05C80:  MOVWF  x47
05C82:  BRA    5CCC
....................                         
....................          else if ( tmp_led588 > -20 && tmp_led588 < -5 ) 
05C84:  BTFSS  x48.7
05C86:  BRA    5C98
05C88:  MOVF   x48,W
05C8A:  SUBLW  FE
05C8C:  BC    5CB0
05C8E:  XORLW  FF
05C90:  BNZ   5C98
05C92:  MOVF   x47,W
05C94:  SUBLW  EC
05C96:  BC    5CB0
05C98:  BTFSS  x48.7
05C9A:  BRA    5CB0
05C9C:  MOVF   x48,W
05C9E:  SUBLW  FF
05CA0:  BNC   5CB0
05CA2:  BNZ   5CAA
05CA4:  MOVF   x47,W
05CA6:  SUBLW  FA
05CA8:  BNC   5CB0
....................             tmp_led588 = -1; 
05CAA:  SETF   x48
05CAC:  SETF   x47
05CAE:  BRA    5CCC
....................                             
....................          else   
....................             tmp_led588 /= 20; 
05CB0:  MOVFF  748,74C
05CB4:  MOVFF  747,74B
05CB8:  CLRF   x4E
05CBA:  MOVLW  14
05CBC:  MOVWF  x4D
05CBE:  MOVLB  0
05CC0:  RCALL  54F4
05CC2:  MOVFF  02,748
05CC6:  MOVFF  01,747
05CCA:  MOVLB  7
....................                          
....................          tmpLed588 += tmp_led588; 
05CCC:  MOVF   x47,W
05CCE:  ADDWF  x41,F
05CD0:  MOVF   x48,W
05CD2:  ADDWFC x42,F
....................       } 
....................                    
....................       if( Led475 <= 690 || Led475 >= 710 ) 
05CD4:  BTFSC  x3E.7
05CD6:  BRA    5CFA
05CD8:  MOVF   x3E,W
05CDA:  SUBLW  02
05CDC:  BNC   5CE6
05CDE:  BNZ   5CFA
05CE0:  MOVF   x3D,W
05CE2:  SUBLW  B2
05CE4:  BC    5CFA
05CE6:  BTFSC  x3E.7
05CE8:  BRA    5D7E
05CEA:  MOVF   x3E,W
05CEC:  SUBLW  01
05CEE:  BC    5D7E
05CF0:  XORLW  FF
05CF2:  BNZ   5CFA
05CF4:  MOVF   x3D,W
05CF6:  SUBLW  C5
05CF8:  BC    5D7E
....................       { 
....................          int16 tmp_led475 = 700 - Led475; 
05CFA:  MOVLW  BC
05CFC:  BSF    FD8.0
05CFE:  SUBFWB x3D,W
05D00:  MOVWF  x49
05D02:  MOVLW  02
05D04:  SUBFWB x3E,W
05D06:  MOVWF  x4A
....................                       
....................          if( tmp_led475 < 20  && tmp_led475 > 5 ) 
05D08:  BTFSC  x4A.7
05D0A:  BRA    5D16
05D0C:  MOVF   x4A,F
05D0E:  BNZ   5D2C
05D10:  MOVF   x49,W
05D12:  SUBLW  13
05D14:  BNC   5D2C
05D16:  BTFSC  x4A.7
05D18:  BRA    5D2C
05D1A:  MOVF   x4A,F
05D1C:  BNZ   5D24
05D1E:  MOVF   x49,W
05D20:  SUBLW  05
05D22:  BC    5D2C
....................             tmp_led475 = 1; 
05D24:  CLRF   x4A
05D26:  MOVLW  01
05D28:  MOVWF  x49
05D2A:  BRA    5D76
....................                          
....................          else if ( tmp_led475 > -20 && tmp_led475 < -5 ) 
05D2C:  BTFSS  x4A.7
05D2E:  BRA    5D40
05D30:  MOVF   x4A,W
05D32:  SUBLW  FE
05D34:  BC    5D58
05D36:  XORLW  FF
05D38:  BNZ   5D40
05D3A:  MOVF   x49,W
05D3C:  SUBLW  EC
05D3E:  BC    5D58
05D40:  BTFSS  x4A.7
05D42:  BRA    5D58
05D44:  MOVF   x4A,W
05D46:  SUBLW  FF
05D48:  BNC   5D58
05D4A:  BNZ   5D52
05D4C:  MOVF   x49,W
05D4E:  SUBLW  FA
05D50:  BNC   5D58
....................             tmp_led475 = -1; 
05D52:  SETF   x4A
05D54:  SETF   x49
05D56:  BRA    5D76
....................                             
....................          else   
....................             tmp_led475 /= 20; 
05D58:  MOVFF  74A,74C
05D5C:  MOVFF  749,74B
05D60:  CLRF   x4E
05D62:  MOVLW  14
05D64:  MOVWF  x4D
05D66:  MOVLB  0
05D68:  CALL   54F4
05D6C:  MOVFF  02,74A
05D70:  MOVFF  01,749
05D74:  MOVLB  7
....................                             
....................          tmpLed475 += tmp_led475; 
05D76:  MOVF   x49,W
05D78:  ADDWF  x43,F
05D7A:  MOVF   x4A,W
05D7C:  ADDWFC x44,F
....................       } 
....................                        
....................       if( Led730 < 620 && Led730 >= 590  
....................           && Led588 < 640 && Led588 >= 610 
....................           && Led475 < 720 && Led475 >= 690 ) 
05D7E:  BTFSC  x3A.7
05D80:  BRA    5D94
05D82:  MOVF   x3A,W
05D84:  SUBLW  02
05D86:  BTFSS  FD8.0
05D88:  BRA    5F04
05D8A:  BNZ   5D94
05D8C:  MOVF   x39,W
05D8E:  SUBLW  6B
05D90:  BTFSS  FD8.0
05D92:  BRA    5F04
05D94:  BTFSC  x3A.7
05D96:  BRA    5F04
05D98:  MOVF   x3A,W
05D9A:  SUBLW  01
05D9C:  BTFSC  FD8.0
05D9E:  BRA    5F04
05DA0:  XORLW  FF
05DA2:  BNZ   5DAC
05DA4:  MOVF   x39,W
05DA6:  SUBLW  4D
05DA8:  BTFSC  FD8.0
05DAA:  BRA    5F04
05DAC:  BTFSC  x3C.7
05DAE:  BRA    5DC2
05DB0:  MOVF   x3C,W
05DB2:  SUBLW  02
05DB4:  BTFSS  FD8.0
05DB6:  BRA    5F04
05DB8:  BNZ   5DC2
05DBA:  MOVF   x3B,W
05DBC:  SUBLW  7F
05DBE:  BTFSS  FD8.0
05DC0:  BRA    5F04
05DC2:  BTFSC  x3C.7
05DC4:  BRA    5F04
05DC6:  MOVF   x3C,W
05DC8:  SUBLW  01
05DCA:  BTFSC  FD8.0
05DCC:  BRA    5F04
05DCE:  XORLW  FF
05DD0:  BNZ   5DDA
05DD2:  MOVF   x3B,W
05DD4:  SUBLW  61
05DD6:  BTFSC  FD8.0
05DD8:  BRA    5F04
05DDA:  BTFSC  x3E.7
05DDC:  BRA    5DF0
05DDE:  MOVF   x3E,W
05DE0:  SUBLW  02
05DE2:  BTFSS  FD8.0
05DE4:  BRA    5F04
05DE6:  BNZ   5DF0
05DE8:  MOVF   x3D,W
05DEA:  SUBLW  CF
05DEC:  BTFSS  FD8.0
05DEE:  BRA    5F04
05DF0:  BTFSC  x3E.7
05DF2:  BRA    5F04
05DF4:  MOVF   x3E,W
05DF6:  SUBLW  01
05DF8:  BTFSC  FD8.0
05DFA:  BRA    5F04
05DFC:  XORLW  FF
05DFE:  BNZ   5E08
05E00:  MOVF   x3D,W
05E02:  SUBLW  B1
05E04:  BTFSC  FD8.0
05E06:  BRA    5F04
....................       { 
....................          ConfigWriteByte(CONFIG_LED475_BRIGHTNESS_ADDRESS, tmpLed475); 
05E08:  CLRF   x4C
05E0A:  MOVLW  02
05E0C:  MOVWF  x4B
05E0E:  MOVFF  743,74D
05E12:  MOVLB  0
05E14:  CALL   556C
....................          LedProperties.LevelBrightness475 = ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS); 
05E18:  MOVLB  7
05E1A:  CLRF   x53
05E1C:  MOVLW  02
05E1E:  MOVWF  x52
05E20:  MOVLB  0
05E22:  CALL   429C
05E26:  MOVFF  01,50F
....................                        
....................          ConfigWriteByte(CONFIG_LED588_BRIGHTNESS_ADDRESS, tmpLed588); 
05E2A:  MOVLB  7
05E2C:  CLRF   x4C
05E2E:  MOVLW  01
05E30:  MOVWF  x4B
05E32:  MOVFF  741,74D
05E36:  MOVLB  0
05E38:  CALL   556C
....................          LedProperties.LevelBrightness588 = ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS); 
05E3C:  MOVLB  7
05E3E:  CLRF   x53
05E40:  MOVLW  01
05E42:  MOVWF  x52
05E44:  MOVLB  0
05E46:  CALL   429C
05E4A:  MOVFF  01,50E
....................                          
....................          ConfigWriteByte(CONFIG_LED730_BRIGHTNESS_ADDRESS, tmpLed730); 
05E4E:  MOVLB  7
05E50:  CLRF   x4C
05E52:  CLRF   x4B
05E54:  MOVFF  73F,74D
05E58:  MOVLB  0
05E5A:  CALL   556C
....................          LedProperties.LevelBrightness730 = ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS); 
05E5E:  MOVLB  7
05E60:  CLRF   x53
05E62:  CLRF   x52
05E64:  MOVLB  0
05E66:  CALL   429C
05E6A:  MOVFF  01,50D
....................           
....................          status = PASS; 
05E6E:  MOVLW  01
05E70:  MOVLB  7
05E72:  MOVWF  x37
....................           
....................          ledBrightnessCalibrated = UNIT_CALIBRATED; 
05E74:  MOVLW  AA
05E76:  MOVLB  5
05E78:  MOVWF  x0A
....................          ConfigWriteByte(CONFIG_LED_BRIGHTNESS_CALIBRATED, ledBrightnessCalibrated); 
05E7A:  MOVLB  7
05E7C:  CLRF   x4C
05E7E:  MOVLW  13
05E80:  MOVWF  x4B
05E82:  MOVFF  50A,74D
05E86:  MOVLB  0
05E88:  CALL   556C
....................  
....................          if( ledBrightnessCalibrated == UNIT_CALIBRATED ) 
05E8C:  MOVLB  5
05E8E:  MOVF   x0A,W
05E90:  SUBLW  AA
05E92:  BNZ   5EBE
....................          { 
....................             fprintf(STDOUT, brightness_resp);    
05E94:  MOVLW  01
05E96:  MOVWF  FEA
05E98:  MOVLW  03
05E9A:  MOVWF  FE9
05E9C:  MOVLB  0
05E9E:  CALL   2D08
....................             fprintf(STDOUT, calibrated_resp);          
05EA2:  MOVLW  01
05EA4:  MOVWF  FEA
05EA6:  MOVLW  0F
05EA8:  MOVWF  FE9
05EAA:  CALL   2D08
....................             fprintf(STDOUT, new_line_resp);          
05EAE:  MOVLW  01
05EB0:  MOVWF  FEA
05EB2:  MOVLW  A7
05EB4:  MOVWF  FE9
05EB6:  CALL   2D08
....................          } 
05EBA:  BRA    5EF0
05EBC:  MOVLB  5
....................   
....................          else 
....................          { 
....................             fprintf(STDOUT, brightness_resp);          
05EBE:  MOVLW  01
05EC0:  MOVWF  FEA
05EC2:  MOVLW  03
05EC4:  MOVWF  FE9
05EC6:  MOVLB  0
05EC8:  CALL   2D08
....................             fprintf(STDOUT, not_resp);          
05ECC:  MOVLW  01
05ECE:  MOVWF  FEA
05ED0:  MOVLW  AF
05ED2:  MOVWF  FE9
05ED4:  CALL   2D08
....................             fprintf(STDOUT, calibrated_resp);          
05ED8:  MOVLW  01
05EDA:  MOVWF  FEA
05EDC:  MOVLW  0F
05EDE:  MOVWF  FE9
05EE0:  CALL   2D08
....................             fprintf(STDOUT, new_line_resp);          
05EE4:  MOVLW  01
05EE6:  MOVWF  FEA
05EE8:  MOVLW  A7
05EEA:  MOVWF  FE9
05EEC:  CALL   2D08
....................          } 
....................           
....................          get_LED_Brightness(); 
05EF0:  CALL   558A
....................          fprintf(STDOUT, new_line_resp); 
05EF4:  MOVLW  01
05EF6:  MOVWF  FEA
05EF8:  MOVLW  A7
05EFA:  MOVWF  FE9
05EFC:  CALL   2D08
....................       } 
05F00:  BRA    6004
05F02:  MOVLB  7
....................                       
....................       else 
....................       { 
....................          //Get the LED brightness readinng 
....................          illumination_brightness(tmpLed730); 
05F04:  MOVFF  73F,812
05F08:  MOVLB  0
05F0A:  CALL   42F2
....................          illumination_use(ILLUMINATION_730); 
05F0E:  MOVLW  7C
05F10:  MOVLB  8
05F12:  MOVWF  x13
05F14:  MOVLW  05
05F16:  MOVWF  x12
05F18:  MOVLB  0
05F1A:  CALL   4394
....................          ble_wait(45); 
05F1E:  MOVLB  7
05F20:  CLRF   x58
05F22:  CLRF   x57
05F24:  CLRF   x56
05F26:  MOVLW  2D
05F28:  MOVWF  x55
05F2A:  MOVLB  0
05F2C:  CALL   43F6
....................          Led730 = photodiode(); 
05F30:  CALL   4FFC
05F34:  MOVFF  02,73A
05F38:  MOVFF  01,739
....................          ble_wait(5); 
05F3C:  MOVLB  7
05F3E:  CLRF   x58
05F40:  CLRF   x57
05F42:  CLRF   x56
05F44:  MOVLW  05
05F46:  MOVWF  x55
05F48:  MOVLB  0
05F4A:  CALL   43F6
....................          output_low(ILLUMINATION_730); 
05F4E:  BCF    F92.5
05F50:  BCF    F89.5
....................     
....................          illumination_brightness(tmpLed588); 
05F52:  MOVFF  741,812
05F56:  CALL   42F2
....................          illumination_use(ILLUMINATION_588); 
05F5A:  MOVLW  7C
05F5C:  MOVLB  8
05F5E:  MOVWF  x13
05F60:  MOVLW  10
05F62:  MOVWF  x12
05F64:  MOVLB  0
05F66:  CALL   4394
....................          ble_wait(45); 
05F6A:  MOVLB  7
05F6C:  CLRF   x58
05F6E:  CLRF   x57
05F70:  CLRF   x56
05F72:  MOVLW  2D
05F74:  MOVWF  x55
05F76:  MOVLB  0
05F78:  CALL   43F6
....................          Led588 = photodiode(); 
05F7C:  CALL   4FFC
05F80:  MOVFF  02,73C
05F84:  MOVFF  01,73B
....................          ble_wait(5); 
05F88:  MOVLB  7
05F8A:  CLRF   x58
05F8C:  CLRF   x57
05F8E:  CLRF   x56
05F90:  MOVLW  05
05F92:  MOVWF  x55
05F94:  MOVLB  0
05F96:  CALL   43F6
....................          output_low(ILLUMINATION_588); 
05F9A:  BCF    F94.0
05F9C:  BCF    F8B.0
....................     
....................          illumination_brightness(tmpLed475); 
05F9E:  MOVFF  743,812
05FA2:  CALL   42F2
....................          illumination_use(ILLUMINATION_475); 
05FA6:  MOVLW  7C
05FA8:  MOVLB  8
05FAA:  MOVWF  x13
05FAC:  MOVLW  04
05FAE:  MOVWF  x12
05FB0:  MOVLB  0
05FB2:  CALL   4394
....................          ble_wait(45); 
05FB6:  MOVLB  7
05FB8:  CLRF   x58
05FBA:  CLRF   x57
05FBC:  CLRF   x56
05FBE:  MOVLW  2D
05FC0:  MOVWF  x55
05FC2:  MOVLB  0
05FC4:  CALL   43F6
....................          Led475 = photodiode(); 
05FC8:  CALL   4FFC
05FCC:  MOVFF  02,73E
05FD0:  MOVFF  01,73D
....................          ble_wait(5); 
05FD4:  MOVLB  7
05FD6:  CLRF   x58
05FD8:  CLRF   x57
05FDA:  CLRF   x56
05FDC:  MOVLW  05
05FDE:  MOVWF  x55
05FE0:  MOVLB  0
05FE2:  CALL   43F6
....................          output_low(ILLUMINATION_475); 
05FE6:  BCF    F92.4
05FE8:  BCF    F89.4
....................          delay_ms(2850); 
05FEA:  MOVLW  0F
05FEC:  MOVLB  7
05FEE:  MOVWF  x4B
05FF0:  MOVLW  BE
05FF2:  MOVLB  8
05FF4:  MOVWF  x18
05FF6:  MOVLB  0
05FF8:  CALL   2D2E
05FFC:  MOVLB  7
05FFE:  DECFSZ x4B,F
06000:  BRA    5FF0
06002:  MOVLB  0
....................       } 
....................        
....................       ctr++; 
06004:  MOVLB  7
06006:  INCF   x38,F
....................       if( ctr > 15 )       //Try 15 times to set  
06008:  MOVF   x38,W
0600A:  SUBLW  0F
0600C:  BC    6022
....................       { 
....................          bleNotifyErrorSet(BAD_CATRIDGE); 
0600E:  MOVLW  02
06010:  MOVLB  8
06012:  MOVWF  x12
06014:  MOVLB  0
06016:  CALL   3A78
....................          return FAIL; 
0601A:  MOVLW  00
0601C:  MOVWF  01
0601E:  MOVLB  7
06020:  BRA    6028
....................       } 
06022:  BRA    590C
....................    } 
....................     
.................... //   fprintf(STDOUT, "Brightness calibration stat = %x\r\n", ledBrightnessCalibrated); 
....................    return status; 
06024:  MOVFF  737,01
06028:  MOVLB  0
0602A:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void check_bad_or_used_cartridge( )  
*
0501C:  MOVLB  7
0501E:  CLRF   x51
.................... { 
.................... #ifdef 588 
....................    uint32   Raw588[3], tmpRaw588; 
.................... #else 
....................    uint32   Raw730[3], tmpRaw730; 
....................    uint32   Raw475[3], tmpRaw475; 
.................... #endif 
....................  
....................    uint8    ctr = 0; 
....................     
....................    cartridgeDetected = YES; 
05020:  MOVLW  01
05022:  MOVLB  5
05024:  MOVWF  x06
....................                   
....................    if( !( ConfigReadByte (CONFIG_LED_BRIGHTNESS_CALIBRATED) ) ) 
05026:  MOVLB  7
05028:  CLRF   x53
0502A:  MOVLW  13
0502C:  MOVWF  x52
0502E:  MOVLB  0
05030:  CALL   429C
05034:  MOVF   01,F
05036:  BNZ   5066
....................    { 
....................       fprintf(STDOUT, brightness_resp); 
05038:  MOVLW  01
0503A:  MOVWF  FEA
0503C:  MOVLW  03
0503E:  MOVWF  FE9
05040:  CALL   2D08
....................       fprintf(STDOUT, not_resp); 
05044:  MOVLW  01
05046:  MOVWF  FEA
05048:  MOVLW  AF
0504A:  MOVWF  FE9
0504C:  CALL   2D08
....................       fprintf(STDOUT, set_resp); 
05050:  MOVLW  01
05052:  MOVWF  FEA
05054:  MOVLW  CB
05056:  MOVWF  FE9
05058:  CALL   2D08
....................       cartridgeState = CARTRIDGE_STATE_UNKNOWN; 
0505C:  MOVLW  03
0505E:  MOVLB  5
05060:  MOVWF  x07
....................       return; 
05062:  BRA    54B0
05064:  MOVLB  0
....................    } 
....................  
....................    fprintf(STDOUT, cartridge_wetting_check_resp); 
05066:  MOVLW  01
05068:  MOVWF  FEA
0506A:  MOVLW  1B
0506C:  MOVWF  FE9
0506E:  CALL   2D08
....................    fprintf(STDOUT, new_line_resp); 
05072:  MOVLW  01
05074:  MOVWF  FEA
05076:  MOVLW  A7
05078:  MOVWF  FE9
0507A:  CALL   2D08
....................    fprintf(STDOUT, please_wait_resp); 
0507E:  MOVLW  01
05080:  MOVWF  FEA
05082:  MOVLW  BA
05084:  MOVWF  FE9
05086:  CALL   2D08
....................    fprintf(STDOUT, new_line_resp); 
0508A:  MOVLW  01
0508C:  MOVWF  FEA
0508E:  MOVLW  A7
05090:  MOVWF  FE9
05092:  CALL   2D08
....................  
....................    while ( ctr++ < 3 ) 
05096:  MOVLB  7
05098:  MOVF   x51,W
0509A:  INCF   x51,F
0509C:  SUBLW  02
0509E:  BTFSS  FD8.0
050A0:  BRA    519E
....................    { 
.................... #ifdef 588    
....................       illumination_brightness(LedProperties.LevelBrightness588); 
....................       illumination_use(ILLUMINATION_588); 
....................       ble_wait(45); 
....................       Raw588[ctr] = photodiode(); 
....................       output_low(ILLUMINATION_588); 
....................       delay_ms( ONE_SECOND ); 
....................        
....................       fprintf(STDOUT, new_line_resp); 
....................       fprintf(STDOUT, bright588_resp); 
....................       fprintf(STDOUT, dash_resp); 
....................       fprintf(STDOUT, "%lu", Raw588[ctr]); 
....................       fprintf(STDOUT, new_line_resp); 
.................... #else       
....................  
....................       illumination_brightness(LedProperties.LevelBrightness730); 
050A2:  MOVFF  50D,812
050A6:  MOVLB  0
050A8:  CALL   42F2
....................       illumination_use(ILLUMINATION_730); 
050AC:  MOVLW  7C
050AE:  MOVLB  8
050B0:  MOVWF  x13
050B2:  MOVLW  05
050B4:  MOVWF  x12
050B6:  MOVLB  0
050B8:  CALL   4394
....................       ble_wait(45); 
050BC:  MOVLB  7
050BE:  CLRF   x58
050C0:  CLRF   x57
050C2:  CLRF   x56
050C4:  MOVLW  2D
050C6:  MOVWF  x55
050C8:  MOVLB  0
050CA:  CALL   43F6
....................       Raw730[ctr] = photodiode(); 
050CE:  MOVLB  7
050D0:  MOVF   x51,W
050D2:  MULLW  04
050D4:  MOVF   FF3,W
050D6:  CLRF   03
050D8:  ADDLW  31
050DA:  MOVWF  01
050DC:  MOVLW  07
050DE:  ADDWFC 03,F
050E0:  MOVFF  01,752
050E4:  MOVFF  03,753
050E8:  MOVLB  0
050EA:  RCALL  4FFC
050EC:  MOVFF  01,00
050F0:  MOVFF  02,01
050F4:  CLRF   02
050F6:  CLRF   03
050F8:  MOVFF  753,FEA
050FC:  MOVFF  752,FE9
05100:  MOVFF  00,FEF
05104:  MOVFF  01,FEC
05108:  MOVFF  02,FEC
0510C:  MOVFF  03,FEC
....................       output_low(ILLUMINATION_730); 
05110:  BCF    F92.5
05112:  BCF    F89.5
....................              
....................       illumination_brightness(LedProperties.LevelBrightness475); 
05114:  MOVFF  50F,812
05118:  CALL   42F2
....................       illumination_use(ILLUMINATION_475); 
0511C:  MOVLW  7C
0511E:  MOVLB  8
05120:  MOVWF  x13
05122:  MOVLW  04
05124:  MOVWF  x12
05126:  MOVLB  0
05128:  CALL   4394
....................       ble_wait(45); 
0512C:  MOVLB  7
0512E:  CLRF   x58
05130:  CLRF   x57
05132:  CLRF   x56
05134:  MOVLW  2D
05136:  MOVWF  x55
05138:  MOVLB  0
0513A:  CALL   43F6
....................       Raw475[ctr] = photodiode(); 
0513E:  MOVLB  7
05140:  MOVF   x51,W
05142:  MULLW  04
05144:  MOVF   FF3,W
05146:  CLRF   03
05148:  ADDLW  41
0514A:  MOVWF  01
0514C:  MOVLW  07
0514E:  ADDWFC 03,F
05150:  MOVFF  01,752
05154:  MOVFF  03,753
05158:  MOVLB  0
0515A:  RCALL  4FFC
0515C:  MOVFF  01,00
05160:  MOVFF  02,01
05164:  CLRF   02
05166:  CLRF   03
05168:  MOVFF  753,FEA
0516C:  MOVFF  752,FE9
05170:  MOVFF  00,FEF
05174:  MOVFF  01,FEC
05178:  MOVFF  02,FEC
0517C:  MOVFF  03,FEC
....................       output_low(ILLUMINATION_475); 
05180:  BCF    F92.4
05182:  BCF    F89.4
....................        
....................       delay_ms( 500 ); 
05184:  MOVLW  02
05186:  MOVLB  7
05188:  MOVWF  x52
0518A:  MOVLW  FA
0518C:  MOVLB  8
0518E:  MOVWF  x18
05190:  MOVLB  0
05192:  CALL   2D2E
05196:  MOVLB  7
05198:  DECFSZ x52,F
0519A:  BRA    518A
....................        
.................... #ifdef DEBUG       
....................       fprintf(STDOUT, new_line_resp); 
....................       fprintf(STDOUT, bright730_resp); 
....................       fprintf(STDOUT, dash_resp); 
....................       fprintf(STDOUT, "%lu", Raw730[ctr]); 
....................       fprintf(STDOUT, new_line_resp); 
....................  
....................       fprintf(STDOUT, bright475_resp); 
....................       fprintf(STDOUT, dash_resp); 
....................       fprintf(STDOUT, "%lu", Raw475[ctr]); 
....................       fprintf(STDOUT, new_line_resp); 
.................... #endif 
....................  
.................... #endif 
0519C:  BRA    5098
....................    } 
....................  
.................... #ifdef 588   
....................    if( Raw588[2] < NO_CARTRIDGE ) 
.................... #else    
....................    if( Raw730[2] < NO_CARTRIDGE || Raw475[2] < NO_CARTRIDGE ) 
0519E:  MOVF   x3C,F
051A0:  BNZ   51B0
051A2:  MOVF   x3B,F
051A4:  BNZ   51B0
051A6:  MOVF   x3A,F
051A8:  BNZ   51B0
051AA:  MOVF   x39,W
051AC:  SUBLW  4A
051AE:  BC    51C2
051B0:  MOVF   x4C,F
051B2:  BNZ   520C
051B4:  MOVF   x4B,F
051B6:  BNZ   520C
051B8:  MOVF   x4A,F
051BA:  BNZ   520C
051BC:  MOVF   x49,W
051BE:  SUBLW  4A
051C0:  BNC   520C
.................... #endif    
....................    { 
....................       cartridgeState = CARTRIDGE_STATE_UNKNOWN; 
051C2:  MOVLW  03
051C4:  MOVLB  5
051C6:  MOVWF  x07
....................       //bleNotifyErrorSet(BAD_CATRIDGE); 
....................        
....................       fprintf(STDOUT, new_line_resp); 
051C8:  MOVLW  01
051CA:  MOVWF  FEA
051CC:  MOVLW  A7
051CE:  MOVWF  FE9
051D0:  MOVLB  0
051D2:  CALL   2D08
....................       fprintf(STDOUT, cartridge_resp); 
051D6:  CLRF   FEA
051D8:  MOVLW  D7
051DA:  MOVWF  FE9
051DC:  CALL   2D08
....................       fprintf(STDOUT, not_resp); 
051E0:  MOVLW  01
051E2:  MOVWF  FEA
051E4:  MOVLW  AF
051E6:  MOVWF  FE9
051E8:  CALL   2D08
....................       fprintf(STDOUT, detected_resp); 
051EC:  MOVLW  01
051EE:  MOVWF  FEA
051F0:  MOVLW  44
051F2:  MOVWF  FE9
051F4:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
051F8:  MOVLW  01
051FA:  MOVWF  FEA
051FC:  MOVLW  A7
051FE:  MOVWF  FE9
05200:  CALL   2D08
....................        
....................       cartridgeDetected = NO; 
05204:  MOVLB  5
05206:  CLRF   x06
....................       return; 
05208:  BRA    54B0
0520A:  MOVLB  7
....................    } 
....................     
.................... #ifdef DEBUG 
....................    fprintf(STDOUT, "temp 730 %lu", tmpRaw730); 
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "temp 475 %lu", tmpRaw475); 
....................    fprintf(STDOUT, new_line_resp); 
.................... #endif 
....................  
....................  
.................... #ifdef 588    
....................    if( Raw588[2] > NEW_CARTRIDGE_MIN && Raw588[2] < NEW_CARTRIDGE_MAX ) 
.................... #else 
....................  
....................    if( Raw730[2] > NEW_CARTRIDGE_MIN_730  &&  
....................        Raw475[2] > NEW_CARTRIDGE_MIN_475  &&  
....................        Raw730[2] < Raw475[2] ) 
0520C:  MOVF   x3C,F
0520E:  BNZ   5224
05210:  MOVF   x3B,F
05212:  BNZ   5224
05214:  MOVF   x3A,W
05216:  SUBLW  01
05218:  BC    52A6
0521A:  XORLW  FF
0521C:  BNZ   5224
0521E:  MOVF   x39,W
05220:  SUBLW  1C
05222:  BC    52A6
05224:  MOVF   x4C,F
05226:  BNZ   523C
05228:  MOVF   x4B,F
0522A:  BNZ   523C
0522C:  MOVF   x4A,W
0522E:  SUBLW  01
05230:  BC    52A6
05232:  XORLW  FF
05234:  BNZ   523C
05236:  MOVF   x49,W
05238:  SUBLW  76
0523A:  BC    52A6
0523C:  MOVF   x3C,W
0523E:  SUBWF  x4C,W
05240:  BNC   52A6
05242:  BNZ   525A
05244:  MOVF   x3B,W
05246:  SUBWF  x4B,W
05248:  BNC   52A6
0524A:  BNZ   525A
0524C:  MOVF   x3A,W
0524E:  SUBWF  x4A,W
05250:  BNC   52A6
05252:  BNZ   525A
05254:  MOVF   x49,W
05256:  SUBWF  x39,W
05258:  BC    52A6
....................         
.................... #endif    
....................    {  
....................       cartridgeState = CARTRIDGE_STATE_NEW; 
0525A:  MOVLB  5
0525C:  CLRF   x07
....................       bleNotifyErrorSet(NO_ERROR); 
0525E:  MOVLB  8
05260:  CLRF   x12
05262:  MOVLB  0
05264:  CALL   3A78
....................        
....................       fprintf(STDOUT, new_line_resp); 
05268:  MOVLW  01
0526A:  MOVWF  FEA
0526C:  MOVLW  A7
0526E:  MOVWF  FE9
05270:  CALL   2D08
....................       fprintf(STDOUT, new_resp); 
05274:  MOVLW  01
05276:  MOVWF  FEA
05278:  MOVLW  AA
0527A:  MOVWF  FE9
0527C:  CALL   2D08
....................       fprintf(STDOUT, cartridge_resp); 
05280:  CLRF   FEA
05282:  MOVLW  D7
05284:  MOVWF  FE9
05286:  CALL   2D08
....................       fprintf(STDOUT, detected_resp); 
0528A:  MOVLW  01
0528C:  MOVWF  FEA
0528E:  MOVLW  44
05290:  MOVWF  FE9
05292:  CALL   2D08
....................       fprintf(STDOUT, two_new_lines_resp); 
05296:  MOVLW  01
05298:  MOVWF  FEA
0529A:  MOVLW  F2
0529C:  MOVWF  FE9
0529E:  CALL   2D08
....................    } 
052A2:  BRA    54AE
052A4:  MOVLB  7
....................  
....................    //Determined if it is used or just wet 
....................    else 
....................    { 
....................       //Wait for 3 seconds to see if the catridge color changes 
....................       delay_ms(THREE_SECONDS); 
052A6:  MOVLW  0C
052A8:  MOVWF  x52
052AA:  MOVLW  FA
052AC:  MOVLB  8
052AE:  MOVWF  x18
052B0:  MOVLB  0
052B2:  CALL   2D2E
052B6:  MOVLB  7
052B8:  DECFSZ x52,F
052BA:  BRA    52AA
.................... #ifdef 588       
....................       illumination_brightness(LedProperties.LevelBrightness588); 
....................       illumination_use(ILLUMINATION_588); 
....................       ble_wait(45); 
....................       tmpRaw588 = photodiode(); 
....................       fprintf(STDOUT, "temp 588 %lu", tmpRaw588); 
....................       output_low(ILLUMINATION_588); 
....................  
....................       if( tmpRaw588 != Raw588[2] ) 
.................... #else       
....................       illumination_brightness(LedProperties.LevelBrightness730); 
052BC:  MOVFF  50D,812
052C0:  MOVLB  0
052C2:  CALL   42F2
....................       illumination_use(ILLUMINATION_730); 
052C6:  MOVLW  7C
052C8:  MOVLB  8
052CA:  MOVWF  x13
052CC:  MOVLW  05
052CE:  MOVWF  x12
052D0:  MOVLB  0
052D2:  CALL   4394
....................       ble_wait(45); 
052D6:  MOVLB  7
052D8:  CLRF   x58
052DA:  CLRF   x57
052DC:  CLRF   x56
052DE:  MOVLW  2D
052E0:  MOVWF  x55
052E2:  MOVLB  0
052E4:  CALL   43F6
....................       tmpRaw730 = photodiode(); 
052E8:  RCALL  4FFC
052EA:  MOVFF  01,73D
052EE:  MOVFF  02,73E
052F2:  CLRF   02
052F4:  CLRF   03
052F6:  MOVFF  03,740
052FA:  MOVFF  02,73F
....................       output_low(ILLUMINATION_730); 
052FE:  BCF    F92.5
05300:  BCF    F89.5
....................        
....................       fprintf(STDOUT, new_line_resp); 
05302:  MOVLW  01
05304:  MOVWF  FEA
05306:  MOVLW  A7
05308:  MOVWF  FE9
0530A:  CALL   2D08
....................       illumination_brightness(LedProperties.LevelBrightness475); 
0530E:  MOVFF  50F,812
05312:  CALL   42F2
....................       illumination_use(ILLUMINATION_475); 
05316:  MOVLW  7C
05318:  MOVLB  8
0531A:  MOVWF  x13
0531C:  MOVLW  04
0531E:  MOVWF  x12
05320:  MOVLB  0
05322:  CALL   4394
....................       ble_wait(45); 
05326:  MOVLB  7
05328:  CLRF   x58
0532A:  CLRF   x57
0532C:  CLRF   x56
0532E:  MOVLW  2D
05330:  MOVWF  x55
05332:  MOVLB  0
05334:  CALL   43F6
....................       tmpRaw475 = photodiode(); 
05338:  RCALL  4FFC
0533A:  MOVFF  01,74D
0533E:  MOVFF  02,74E
05342:  CLRF   02
05344:  CLRF   03
05346:  MOVFF  03,750
0534A:  MOVFF  02,74F
....................       output_low(ILLUMINATION_475); 
0534E:  BCF    F92.4
05350:  BCF    F89.4
....................  
....................  
....................       if( ( tmpRaw730 <= Raw730[2] + 1 && tmpRaw730 >= Raw730[2] - 1 ) ||  
....................           ( tmpRaw475 <= Raw475[2] + 1 && tmpRaw475 >= Raw475[2] - 1 ) ) 
05352:  MOVLW  01
05354:  MOVLB  7
05356:  ADDWF  x39,W
05358:  MOVWF  00
0535A:  MOVLW  00
0535C:  ADDWFC x3A,W
0535E:  MOVWF  01
05360:  MOVLW  00
05362:  ADDWFC x3B,W
05364:  MOVWF  02
05366:  MOVLW  00
05368:  ADDWFC x3C,W
0536A:  MOVWF  03
0536C:  MOVF   x40,W
0536E:  SUBWF  03,W
05370:  BNC   53BE
05372:  BNZ   538A
05374:  MOVF   x3F,W
05376:  SUBWF  02,W
05378:  BNC   53BE
0537A:  BNZ   538A
0537C:  MOVF   x3E,W
0537E:  SUBWF  01,W
05380:  BNC   53BE
05382:  BNZ   538A
05384:  MOVF   x3D,W
05386:  SUBWF  00,W
05388:  BNC   53BE
0538A:  MOVLW  01
0538C:  SUBWF  x39,W
0538E:  MOVWF  00
05390:  MOVLW  00
05392:  SUBWFB x3A,W
05394:  MOVWF  01
05396:  MOVLW  00
05398:  SUBWFB x3B,W
0539A:  MOVWF  02
0539C:  MOVLW  00
0539E:  SUBWFB x3C,W
053A0:  MOVWF  03
053A2:  SUBWF  x40,W
053A4:  BNC   53BE
053A6:  BNZ   5428
053A8:  MOVF   02,W
053AA:  SUBWF  x3F,W
053AC:  BNC   53BE
053AE:  BNZ   5428
053B0:  MOVF   01,W
053B2:  SUBWF  x3E,W
053B4:  BNC   53BE
053B6:  BNZ   5428
053B8:  MOVF   00,W
053BA:  SUBWF  x3D,W
053BC:  BC    5428
053BE:  MOVLW  01
053C0:  ADDWF  x49,W
053C2:  MOVWF  00
053C4:  MOVLW  00
053C6:  ADDWFC x4A,W
053C8:  MOVWF  01
053CA:  MOVLW  00
053CC:  ADDWFC x4B,W
053CE:  MOVWF  02
053D0:  MOVLW  00
053D2:  ADDWFC x4C,W
053D4:  MOVWF  03
053D6:  MOVF   x50,W
053D8:  SUBWF  03,W
053DA:  BNC   5460
053DC:  BNZ   53F4
053DE:  MOVF   x4F,W
053E0:  SUBWF  02,W
053E2:  BNC   5460
053E4:  BNZ   53F4
053E6:  MOVF   x4E,W
053E8:  SUBWF  01,W
053EA:  BNC   5460
053EC:  BNZ   53F4
053EE:  MOVF   x4D,W
053F0:  SUBWF  00,W
053F2:  BNC   5460
053F4:  MOVLW  01
053F6:  SUBWF  x49,W
053F8:  MOVWF  00
053FA:  MOVLW  00
053FC:  SUBWFB x4A,W
053FE:  MOVWF  01
05400:  MOVLW  00
05402:  SUBWFB x4B,W
05404:  MOVWF  02
05406:  MOVLW  00
05408:  SUBWFB x4C,W
0540A:  MOVWF  03
0540C:  SUBWF  x50,W
0540E:  BNC   5460
05410:  BNZ   5428
05412:  MOVF   02,W
05414:  SUBWF  x4F,W
05416:  BNC   5460
05418:  BNZ   5428
0541A:  MOVF   01,W
0541C:  SUBWF  x4E,W
0541E:  BNC   5460
05420:  BNZ   5428
05422:  MOVF   00,W
05424:  SUBWF  x4D,W
05426:  BNC   5460
.................... #endif       
....................       { 
....................          cartridgeState = CARTRIDGE_STATE_USED; 
05428:  MOVLW  01
0542A:  MOVLB  5
0542C:  MOVWF  x07
....................          fprintf(STDOUT, used_resp); 
0542E:  MOVWF  FEA
05430:  MOVLW  F7
05432:  MOVWF  FE9
05434:  MOVLB  0
05436:  CALL   2D08
....................          fprintf(STDOUT, cartridge_resp); 
0543A:  CLRF   FEA
0543C:  MOVLW  D7
0543E:  MOVWF  FE9
05440:  CALL   2D08
....................          fprintf(STDOUT, detected_resp); 
05444:  MOVLW  01
05446:  MOVWF  FEA
05448:  MOVLW  44
0544A:  MOVWF  FE9
0544C:  CALL   2D08
....................          fprintf(STDOUT, new_line_resp); 
05450:  MOVLW  01
05452:  MOVWF  FEA
05454:  MOVLW  A7
05456:  MOVWF  FE9
05458:  CALL   2D08
....................       } 
0545C:  BRA    5496
0545E:  MOVLB  7
....................                       
....................       else 
....................       { 
....................          cartridgeState = CARTRIDGE_STATE_JUST_WET; 
05460:  MOVLW  02
05462:  MOVLB  5
05464:  MOVWF  x07
....................          fprintf(STDOUT, wet_resp); 
05466:  MOVLW  01
05468:  MOVWF  FEA
0546A:  MOVLW  FD
0546C:  MOVWF  FE9
0546E:  MOVLB  0
05470:  CALL   2D08
....................          fprintf(STDOUT, cartridge_resp); 
05474:  CLRF   FEA
05476:  MOVLW  D7
05478:  MOVWF  FE9
0547A:  CALL   2D08
....................          fprintf(STDOUT, detected_resp); 
0547E:  MOVLW  01
05480:  MOVWF  FEA
05482:  MOVLW  44
05484:  MOVWF  FE9
05486:  CALL   2D08
....................          fprintf(STDOUT, two_new_lines_resp); 
0548A:  MOVLW  01
0548C:  MOVWF  FEA
0548E:  MOVLW  F2
05490:  MOVWF  FE9
05492:  CALL   2D08
....................       } 
....................        
....................       bleNotifyErrorSet(BAD_CATRIDGE); 
05496:  MOVLW  02
05498:  MOVLB  8
0549A:  MOVWF  x12
0549C:  MOVLB  0
0549E:  CALL   3A78
....................       fprintf(STDOUT, new_line_resp); 
054A2:  MOVLW  01
054A4:  MOVWF  FEA
054A6:  MOVLW  A7
054A8:  MOVWF  FE9
054AA:  CALL   2D08
054AE:  MOVLB  5
....................    } 
054B0:  MOVLB  0
054B2:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... void MeasureDarkness()  
.................... { 
....................    struct LedReadings x; 
....................   
....................    illumination_all_off(); 
*
0602C:  CALL   4344
....................    ble_wait(45); 
06030:  MOVLB  7
06032:  CLRF   x58
06034:  CLRF   x57
06036:  CLRF   x56
06038:  MOVLW  2D
0603A:  MOVWF  x55
0603C:  MOVLB  0
0603E:  CALL   43F6
....................    x.Raw730 = photodiode(); 
06042:  CALL   4FFC
06046:  MOVFF  02,732
0604A:  MOVFF  01,731
....................    ble_wait(5); 
0604E:  MOVLB  7
06050:  CLRF   x58
06052:  CLRF   x57
06054:  CLRF   x56
06056:  MOVLW  05
06058:  MOVWF  x55
0605A:  MOVLB  0
0605C:  CALL   43F6
....................    x.Raw588 = photodiode(); 
06060:  CALL   4FFC
06064:  MOVFF  02,734
06068:  MOVFF  01,733
....................    ble_wait(5); 
0606C:  MOVLB  7
0606E:  CLRF   x58
06070:  CLRF   x57
06072:  CLRF   x56
06074:  MOVLW  05
06076:  MOVWF  x55
06078:  MOVLB  0
0607A:  CALL   43F6
....................    x.Raw475 = photodiode(); 
0607E:  CALL   4FFC
06082:  MOVFF  02,736
06086:  MOVFF  01,735
....................    ble_wait(5); 
0608A:  MOVLB  7
0608C:  CLRF   x58
0608E:  CLRF   x57
06090:  CLRF   x56
06092:  MOVLW  05
06094:  MOVWF  x55
06096:  MOVLB  0
06098:  CALL   43F6
....................     
....................    LedProperties.DarkReading730 = x.Raw730; 
0609C:  MOVFF  732,511
060A0:  MOVFF  731,510
....................    LedProperties.DarkReading588 = x.Raw588; 
060A4:  MOVFF  734,513
060A8:  MOVFF  733,512
....................    LedProperties.DarkReading475 = x.Raw475; 
060AC:  MOVFF  736,515
060B0:  MOVFF  735,514
....................     
....................    fprintf(STDOUT, darkness_resp); 
060B4:  MOVLW  01
060B6:  MOVWF  FEA
060B8:  MOVLW  37
060BA:  MOVWF  FE9
060BC:  CALL   2D08
....................    fprintf(STDOUT, new_line_resp); 
060C0:  MOVLW  01
060C2:  MOVWF  FEA
060C4:  MOVLW  A7
060C6:  MOVWF  FE9
060C8:  CALL   2D08
....................    fprintf(STDOUT, bright730_resp); 
060CC:  CLRF   FEA
060CE:  MOVLW  E2
060D0:  MOVWF  FE9
060D2:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
060D6:  MOVLW  01
060D8:  MOVWF  FEA
060DA:  MOVLW  41
060DC:  MOVWF  FE9
060DE:  CALL   2D08
....................    fprintf(STDOUT, "%lu", x.Raw730); 
060E2:  MOVLW  10
060E4:  MOVWF  FE9
060E6:  CLRF   19
060E8:  BTFSC  FF2.7
060EA:  BSF    19.7
060EC:  BCF    FF2.7
060EE:  MOVFF  732,967
060F2:  MOVFF  731,966
060F6:  CALL   0AD6
060FA:  BTFSC  19.7
060FC:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
060FE:  MOVLW  01
06100:  MOVWF  FEA
06102:  MOVLW  A7
06104:  MOVWF  FE9
06106:  CALL   2D08
....................    fprintf(STDOUT, bright588_resp); 
0610A:  CLRF   FEA
0610C:  MOVLW  ED
0610E:  MOVWF  FE9
06110:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06114:  MOVLW  01
06116:  MOVWF  FEA
06118:  MOVLW  41
0611A:  MOVWF  FE9
0611C:  CALL   2D08
....................    fprintf(STDOUT, "%lu", x.Raw588); 
06120:  MOVLW  10
06122:  MOVWF  FE9
06124:  CLRF   19
06126:  BTFSC  FF2.7
06128:  BSF    19.7
0612A:  BCF    FF2.7
0612C:  MOVFF  734,967
06130:  MOVFF  733,966
06134:  CALL   0AD6
06138:  BTFSC  19.7
0613A:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
0613C:  MOVLW  01
0613E:  MOVWF  FEA
06140:  MOVLW  A7
06142:  MOVWF  FE9
06144:  CALL   2D08
....................    fprintf(STDOUT, bright475_resp); 
06148:  CLRF   FEA
0614A:  MOVLW  F8
0614C:  MOVWF  FE9
0614E:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06152:  MOVLW  01
06154:  MOVWF  FEA
06156:  MOVLW  41
06158:  MOVWF  FE9
0615A:  CALL   2D08
....................    fprintf(STDOUT, "%lu", x.Raw475); 
0615E:  MOVLW  10
06160:  MOVWF  FE9
06162:  CLRF   19
06164:  BTFSC  FF2.7
06166:  BSF    19.7
06168:  BCF    FF2.7
0616A:  MOVFF  736,967
0616E:  MOVFF  735,966
06172:  CALL   0AD6
06176:  BTFSC  19.7
06178:  BSF    FF2.7
....................     
....................    fprintf(STDOUT, new_line_resp); 
0617A:  MOVLW  01
0617C:  MOVWF  FEA
0617E:  MOVLW  A7
06180:  MOVWF  FE9
06182:  CALL   2D08
06186:  GOTO   8A2E (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... struct LightMeasurements Whitebalances()  
.................... { 
....................    struct LightMeasurements x; 
....................    struct LedReadings y; 
....................    
....................    y = MeasureLEDs(); 
*
063D0:  BRA    618A
063D2:  MOVFF  02,03
063D6:  MOVFF  01,FE1
063DA:  MOVFF  02,FE2
063DE:  MOVLW  07
063E0:  MOVWF  FEA
063E2:  MOVLW  43
063E4:  MOVWF  FE9
063E6:  MOVLW  06
063E8:  MOVWF  01
063EA:  MOVFF  FE6,FEE
063EE:  DECFSZ 01,F
063F0:  BRA    63EA
....................    fprintf(STDOUT, "Whitebalance: "); 
063F2:  MOVLW  BC
063F4:  MOVWF  FF6
063F6:  MOVLW  1C
063F8:  MOVWF  FF7
063FA:  CALL   2CA0
....................     
....................    fprintf(STDOUT, new_line_resp); 
063FE:  MOVLW  01
06400:  MOVWF  FEA
06402:  MOVLW  A7
06404:  MOVWF  FE9
06406:  CALL   2D08
....................    fprintf(STDOUT, bright730_resp); 
0640A:  CLRF   FEA
0640C:  MOVLW  E2
0640E:  MOVWF  FE9
06410:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06414:  MOVLW  01
06416:  MOVWF  FEA
06418:  MOVLW  41
0641A:  MOVWF  FE9
0641C:  CALL   2D08
....................    fprintf(STDOUT, "%lu", y.Raw730); 
06420:  MOVLW  10
06422:  MOVWF  FE9
06424:  CLRF   19
06426:  BTFSC  FF2.7
06428:  BSF    19.7
0642A:  BCF    FF2.7
0642C:  MOVFF  744,967
06430:  MOVFF  743,966
06434:  CALL   0AD6
06438:  BTFSC  19.7
0643A:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
0643C:  MOVLW  01
0643E:  MOVWF  FEA
06440:  MOVLW  A7
06442:  MOVWF  FE9
06444:  CALL   2D08
....................    fprintf(STDOUT, bright588_resp); 
06448:  CLRF   FEA
0644A:  MOVLW  ED
0644C:  MOVWF  FE9
0644E:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06452:  MOVLW  01
06454:  MOVWF  FEA
06456:  MOVLW  41
06458:  MOVWF  FE9
0645A:  CALL   2D08
....................    fprintf(STDOUT, "%lu", y.Raw588); 
0645E:  MOVLW  10
06460:  MOVWF  FE9
06462:  CLRF   19
06464:  BTFSC  FF2.7
06466:  BSF    19.7
06468:  BCF    FF2.7
0646A:  MOVFF  746,967
0646E:  MOVFF  745,966
06472:  CALL   0AD6
06476:  BTFSC  19.7
06478:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
0647A:  MOVLW  01
0647C:  MOVWF  FEA
0647E:  MOVLW  A7
06480:  MOVWF  FE9
06482:  CALL   2D08
....................    fprintf(STDOUT, bright475_resp); 
06486:  CLRF   FEA
06488:  MOVLW  F8
0648A:  MOVWF  FE9
0648C:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06490:  MOVLW  01
06492:  MOVWF  FEA
06494:  MOVLW  41
06496:  MOVWF  FE9
06498:  CALL   2D08
....................    fprintf(STDOUT, "%lu", y.Raw475); 
0649C:  MOVLW  10
0649E:  MOVWF  FE9
064A0:  CLRF   19
064A2:  BTFSC  FF2.7
064A4:  BSF    19.7
064A6:  BCF    FF2.7
064A8:  MOVFF  748,967
064AC:  MOVFF  747,966
064B0:  CALL   0AD6
064B4:  BTFSC  19.7
064B6:  BSF    FF2.7
....................    fprintf(STDOUT, new_line_resp); 
064B8:  MOVLW  01
064BA:  MOVWF  FEA
064BC:  MOVLW  A7
064BE:  MOVWF  FE9
064C0:  CALL   2D08
....................     
....................    x.Light730 = 62.0729508196721 / (float32)(y.Raw730 - LedProperties.DarkReading730); 
064C4:  MOVLB  5
064C6:  MOVF   x10,W
064C8:  MOVLB  7
064CA:  SUBWF  x43,W
064CC:  MOVWF  00
064CE:  MOVLB  5
064D0:  MOVF   x11,W
064D2:  MOVLB  7
064D4:  SUBWFB x44,W
064D6:  MOVWF  03
064D8:  MOVF   00,W
064DA:  CLRF   19
064DC:  BTFSC  FF2.7
064DE:  BSF    19.7
064E0:  BCF    FF2.7
064E2:  MOVLB  9
064E4:  MOVWF  x66
064E6:  MOVFF  03,967
064EA:  MOVLB  0
064EC:  CALL   099A
064F0:  BTFSC  19.7
064F2:  BSF    FF2.7
064F4:  MOVLW  B4
064F6:  MOVLB  8
064F8:  MOVWF  x19
064FA:  MOVLW  4A
064FC:  MOVWF  x18
064FE:  MOVLW  78
06500:  MOVWF  x17
06502:  MOVLW  84
06504:  MOVWF  x16
06506:  MOVFF  03,81D
0650A:  MOVFF  02,81C
0650E:  MOVFF  01,81B
06512:  MOVFF  00,81A
06516:  MOVLB  0
06518:  RCALL  6272
0651A:  MOVFF  03,73A
0651E:  MOVFF  02,739
06522:  MOVFF  01,738
06526:  MOVFF  00,737
....................    x.Light588 = 62.413275862069 / (float32)(y.Raw588 - LedProperties.DarkReading588); 
0652A:  MOVLB  5
0652C:  MOVF   x12,W
0652E:  MOVLB  7
06530:  SUBWF  x45,W
06532:  MOVWF  00
06534:  MOVLB  5
06536:  MOVF   x13,W
06538:  MOVLB  7
0653A:  SUBWFB x46,W
0653C:  MOVWF  03
0653E:  MOVF   00,W
06540:  CLRF   19
06542:  BTFSC  FF2.7
06544:  BSF    19.7
06546:  BCF    FF2.7
06548:  MOVLB  9
0654A:  MOVWF  x66
0654C:  MOVFF  03,967
06550:  MOVLB  0
06552:  CALL   099A
06556:  BTFSC  19.7
06558:  BSF    FF2.7
0655A:  MOVLW  32
0655C:  MOVLB  8
0655E:  MOVWF  x19
06560:  MOVLW  A7
06562:  MOVWF  x18
06564:  MOVLW  79
06566:  MOVWF  x17
06568:  MOVLW  84
0656A:  MOVWF  x16
0656C:  MOVFF  03,81D
06570:  MOVFF  02,81C
06574:  MOVFF  01,81B
06578:  MOVFF  00,81A
0657C:  MOVLB  0
0657E:  RCALL  6272
06580:  MOVFF  03,73E
06584:  MOVFF  02,73D
06588:  MOVFF  01,73C
0658C:  MOVFF  00,73B
....................    x.Light475 = 60.92125 / (float32)(y.Raw475 - LedProperties.DarkReading475); 
06590:  MOVLB  5
06592:  MOVF   x14,W
06594:  MOVLB  7
06596:  SUBWF  x47,W
06598:  MOVWF  00
0659A:  MOVLB  5
0659C:  MOVF   x15,W
0659E:  MOVLB  7
065A0:  SUBWFB x48,W
065A2:  MOVWF  03
065A4:  MOVF   00,W
065A6:  CLRF   19
065A8:  BTFSC  FF2.7
065AA:  BSF    19.7
065AC:  BCF    FF2.7
065AE:  MOVLB  9
065B0:  MOVWF  x66
065B2:  MOVFF  03,967
065B6:  MOVLB  0
065B8:  CALL   099A
065BC:  BTFSC  19.7
065BE:  BSF    FF2.7
065C0:  MOVLW  5C
065C2:  MOVLB  8
065C4:  MOVWF  x19
065C6:  MOVLW  AF
065C8:  MOVWF  x18
065CA:  MOVLW  73
065CC:  MOVWF  x17
065CE:  MOVLW  84
065D0:  MOVWF  x16
065D2:  MOVFF  03,81D
065D6:  MOVFF  02,81C
065DA:  MOVFF  01,81B
065DE:  MOVFF  00,81A
065E2:  MOVLB  0
065E4:  RCALL  6272
065E6:  MOVFF  03,742
065EA:  MOVFF  02,741
065EE:  MOVFF  01,740
065F2:  MOVFF  00,73F
....................     
....................    fprintf(STDOUT, "WB Coeffficients: "); 
065F6:  MOVLW  CC
065F8:  MOVWF  FF6
065FA:  MOVLW  1C
065FC:  MOVWF  FF7
065FE:  CALL   2CA0
....................    fprintf(STDOUT, new_line_resp); 
06602:  MOVLW  01
06604:  MOVWF  FEA
06606:  MOVLW  A7
06608:  MOVWF  FE9
0660A:  CALL   2D08
....................    fprintf(STDOUT, bright730_resp); 
0660E:  CLRF   FEA
06610:  MOVLW  E2
06612:  MOVWF  FE9
06614:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
06618:  MOVLW  01
0661A:  MOVWF  FEA
0661C:  MOVLW  41
0661E:  MOVWF  FE9
06620:  CALL   2D08
....................    fprintf(STDOUT, "%.4f", x.Light730); 
06624:  MOVLW  89
06626:  MOVWF  FE9
06628:  MOVFF  73A,815
0662C:  MOVFF  739,814
06630:  MOVFF  738,813
06634:  MOVFF  737,812
06638:  MOVLW  04
0663A:  MOVLB  8
0663C:  MOVWF  x16
0663E:  MOVLB  0
06640:  CALL   40FE
....................    fprintf(STDOUT, new_line_resp); 
06644:  MOVLW  01
06646:  MOVWF  FEA
06648:  MOVLW  A7
0664A:  MOVWF  FE9
0664C:  CALL   2D08
....................    fprintf(STDOUT, bright588_resp); 
06650:  CLRF   FEA
06652:  MOVLW  ED
06654:  MOVWF  FE9
06656:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
0665A:  MOVLW  01
0665C:  MOVWF  FEA
0665E:  MOVLW  41
06660:  MOVWF  FE9
06662:  CALL   2D08
....................    fprintf(STDOUT, "%.4f", x.Light588); 
06666:  MOVLW  89
06668:  MOVWF  FE9
0666A:  MOVFF  73E,815
0666E:  MOVFF  73D,814
06672:  MOVFF  73C,813
06676:  MOVFF  73B,812
0667A:  MOVLW  04
0667C:  MOVLB  8
0667E:  MOVWF  x16
06680:  MOVLB  0
06682:  CALL   40FE
....................    fprintf(STDOUT, new_line_resp); 
06686:  MOVLW  01
06688:  MOVWF  FEA
0668A:  MOVLW  A7
0668C:  MOVWF  FE9
0668E:  CALL   2D08
....................    fprintf(STDOUT, bright475_resp); 
06692:  CLRF   FEA
06694:  MOVLW  F8
06696:  MOVWF  FE9
06698:  CALL   2D08
....................    fprintf(STDOUT, dash_resp); 
0669C:  MOVLW  01
0669E:  MOVWF  FEA
066A0:  MOVLW  41
066A2:  MOVWF  FE9
066A4:  CALL   2D08
....................    fprintf(STDOUT, "%.4f", x.Light475); 
066A8:  MOVLW  89
066AA:  MOVWF  FE9
066AC:  MOVFF  742,815
066B0:  MOVFF  741,814
066B4:  MOVFF  740,813
066B8:  MOVFF  73F,812
066BC:  MOVLW  04
066BE:  MOVLB  8
066C0:  MOVWF  x16
066C2:  MOVLB  0
066C4:  CALL   40FE
....................    fprintf(STDOUT, new_line_resp); 
066C8:  MOVLW  01
066CA:  MOVWF  FEA
066CC:  MOVLW  A7
066CE:  MOVWF  FE9
066D0:  CALL   2D08
....................     
....................    return x; 
066D4:  MOVLW  37
066D6:  MOVWF  01
066D8:  MOVLW  07
066DA:  MOVWF  02
066DC:  GOTO   8A32 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 AnalyzeBreathSample(float32* AD2, float32* AD_Final) 
*
06AF8:  MOVLB  7
06AFA:  CLRF   x58
06AFC:  CLRF   x57
06AFE:  CLRF   x59
06B00:  CLRF   x5A
06B02:  CLRF   x78
06B04:  CLRF   x77
06B06:  CLRF   x76
06B08:  CLRF   x75
06B0A:  CLRF   x7C
06B0C:  CLRF   x7B
06B0E:  CLRF   x7A
06B10:  CLRF   x79
06B12:  CLRF   x80
06B14:  CLRF   x7F
06B16:  CLRF   x7E
06B18:  CLRF   x7D
.................... {    
....................    uint16 status = READING_ERROR_NONE; 
....................    int i1=0; 
....................    int i2=0; 
....................    struct LedReadings RawReadings; 
....................    struct LightMeasurements x; 
....................    float32 r475o588; 
....................    float32 r588o730; 
....................    float32 Diff1 = 0.0; 
....................    float32 Diff2 = 0.0; 
....................    float32 Diff3 = 0.0; 
....................        
....................    fprintf(STDOUT, "Measuring breath sample...\r\nTime(s), Red 730, Orange 588, Blue 475\r\n"); 
06B1A:  MOVLW  E0
06B1C:  MOVWF  FF6
06B1E:  MOVLW  1C
06B20:  MOVWF  FF7
06B22:  MOVLB  0
06B24:  CALL   2CA0
....................    testResult.stepID = ANALYZE_BREATH_SAMPLE; 
06B28:  MOVLW  23
06B2A:  MOVLB  2
06B2C:  MOVWF  x19
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
06B2E:  MOVLB  8
06B30:  CLRF   x14
06B32:  MOVLW  3B
06B34:  MOVWF  x13
06B36:  CLRF   x15
06B38:  MOVLW  01
06B3A:  MOVWF  x16
06B3C:  MOVLW  02
06B3E:  MOVWF  x18
06B40:  MOVLW  19
06B42:  MOVWF  x17
06B44:  MOVLB  0
06B46:  CALL   2E2E
.................... //   SetFullTestStepID(ANALYZE_BREATH_SAMPLE); 
....................  
....................    for( int16 i = 2; i <= 40; i++ ) 
06B4A:  MOVLB  7
06B4C:  CLRF   x82
06B4E:  MOVLW  02
06B50:  MOVWF  x81
06B52:  BTFSC  x82.7
06B54:  BRA    6B64
06B56:  MOVF   x82,F
06B58:  BTFSS  FD8.2
06B5A:  BRA    6E3C
06B5C:  MOVF   x81,W
06B5E:  SUBLW  28
06B60:  BTFSS  FD8.0
06B62:  BRA    6E3C
....................    { 
....................       illumination_brightness(LedProperties.LevelBrightness730); 
06B64:  MOVFF  50D,812
06B68:  MOVLB  0
06B6A:  CALL   42F2
....................       illumination_use(ILLUMINATION_730); 
06B6E:  MOVLW  7C
06B70:  MOVLB  8
06B72:  MOVWF  x13
06B74:  MOVLW  05
06B76:  MOVWF  x12
06B78:  MOVLB  0
06B7A:  CALL   4394
....................  
....................       delay_ms(45); 
06B7E:  MOVLW  2D
06B80:  MOVLB  8
06B82:  MOVWF  x18
06B84:  MOVLB  0
06B86:  CALL   2D2E
....................       RawReadings.Raw730 = photodiode(); 
06B8A:  CALL   4FFC
06B8E:  MOVFF  02,75C
06B92:  MOVFF  01,75B
....................        
....................       delay_ms(5); 
06B96:  MOVLW  05
06B98:  MOVLB  8
06B9A:  MOVWF  x18
06B9C:  MOVLB  0
06B9E:  CALL   2D2E
....................       illumination_brightness(LedProperties.LevelBrightness588); 
06BA2:  MOVFF  50E,812
06BA6:  CALL   42F2
....................       illumination_use(ILLUMINATION_588); 
06BAA:  MOVLW  7C
06BAC:  MOVLB  8
06BAE:  MOVWF  x13
06BB0:  MOVLW  10
06BB2:  MOVWF  x12
06BB4:  MOVLB  0
06BB6:  CALL   4394
....................        
....................       delay_ms(45); 
06BBA:  MOVLW  2D
06BBC:  MOVLB  8
06BBE:  MOVWF  x18
06BC0:  MOVLB  0
06BC2:  CALL   2D2E
....................       RawReadings.Raw588 = photodiode(); 
06BC6:  CALL   4FFC
06BCA:  MOVFF  02,75E
06BCE:  MOVFF  01,75D
....................  
....................       delay_ms(5); 
06BD2:  MOVLW  05
06BD4:  MOVLB  8
06BD6:  MOVWF  x18
06BD8:  MOVLB  0
06BDA:  CALL   2D2E
....................       illumination_brightness(LedProperties.LevelBrightness475); 
06BDE:  MOVFF  50F,812
06BE2:  CALL   42F2
....................       illumination_use(ILLUMINATION_475); 
06BE6:  MOVLW  7C
06BE8:  MOVLB  8
06BEA:  MOVWF  x13
06BEC:  MOVLW  04
06BEE:  MOVWF  x12
06BF0:  MOVLB  0
06BF2:  CALL   4394
....................  
....................       delay_ms(45); 
06BF6:  MOVLW  2D
06BF8:  MOVLB  8
06BFA:  MOVWF  x18
06BFC:  MOVLB  0
06BFE:  CALL   2D2E
....................       RawReadings.Raw475 = photodiode(); 
06C02:  CALL   4FFC
06C06:  MOVFF  02,760
06C0A:  MOVFF  01,75F
....................       illumination_all_off(); 
06C0E:  CALL   4344
....................  
....................       if( RawReadings.Raw730 < NO_CARTRIDGE || 
....................           RawReadings.Raw588 < NO_CARTRIDGE || 
....................           RawReadings.Raw475 < NO_CARTRIDGE ) 
06C12:  MOVLB  7
06C14:  MOVF   x5C,F
06C16:  BNZ   6C1E
06C18:  MOVF   x5B,W
06C1A:  SUBLW  4A
06C1C:  BC    6C32
06C1E:  MOVF   x5E,F
06C20:  BNZ   6C28
06C22:  MOVF   x5D,W
06C24:  SUBLW  4A
06C26:  BC    6C32
06C28:  MOVF   x60,F
06C2A:  BNZ   6C94
06C2C:  MOVF   x5F,W
06C2E:  SUBLW  4A
06C30:  BNC   6C94
....................       { 
....................          fprintf(STDOUT, "\r\n\r\n*****Cartridge removed during reading*****\r\n\r\n"); 
06C32:  MOVLW  26
06C34:  MOVWF  FF6
06C36:  MOVLW  1D
06C38:  MOVWF  FF7
06C3A:  MOVLB  0
06C3C:  CALL   2CA0
....................          for( i = 0; i < 5; i++ ) 
06C40:  MOVLB  7
06C42:  CLRF   x82
06C44:  CLRF   x81
06C46:  BTFSC  x82.7
06C48:  BRA    6C54
06C4A:  MOVF   x82,F
06C4C:  BNZ   6C7A
06C4E:  MOVF   x81,W
06C50:  SUBLW  04
06C52:  BNC   6C7A
....................          { 
....................             play_error(); 
06C54:  MOVLB  0
06C56:  CALL   4538
....................             delay_ms( ONE_SECOND ); 
06C5A:  MOVLW  04
06C5C:  MOVLB  7
06C5E:  MOVWF  x87
06C60:  MOVLW  FA
06C62:  MOVLB  8
06C64:  MOVWF  x18
06C66:  MOVLB  0
06C68:  CALL   2D2E
06C6C:  MOVLB  7
06C6E:  DECFSZ x87,F
06C70:  BRA    6C60
06C72:  INCF   x81,F
06C74:  BTFSC  FD8.2
06C76:  INCF   x82,F
06C78:  BRA    6C46
....................          } 
....................           
....................          bleNotifyErrorSet(CARTRIDGE_REMOVED_DURING_ANALYSIS); 
06C7A:  MOVLW  50
06C7C:  MOVLB  8
06C7E:  MOVWF  x12
06C80:  MOVLB  0
06C82:  CALL   3A78
....................          return CARTRIDGE_REMOVED_DURING_ANALYSIS; 
06C86:  MOVLW  50
06C88:  MOVWF  01
06C8A:  MOVLW  00
06C8C:  MOVWF  02
06C8E:  GOTO   7B62
06C92:  MOVLB  7
06C94:  CLRF   19
06C96:  BTFSC  FF2.7
06C98:  BSF    19.7
06C9A:  BCF    FF2.7
....................       } 
....................  
....................       fprintf(STDOUT, "%lu, %lu, %lu, %lu\r\n", i*3, RawReadings.Raw730, RawReadings.Raw588, RawReadings.Raw475); 
06C9C:  MOVFF  782,96B
06CA0:  MOVFF  781,96A
06CA4:  MOVLB  9
06CA6:  CLRF   x6D
06CA8:  MOVLW  03
06CAA:  MOVWF  x6C
06CAC:  MOVLB  0
06CAE:  CALL   0C48
06CB2:  BTFSC  19.7
06CB4:  BSF    FF2.7
06CB6:  MOVFF  02,788
06CBA:  MOVFF  01,787
06CBE:  MOVLW  10
06CC0:  MOVWF  FE9
06CC2:  CLRF   19
06CC4:  BTFSC  FF2.7
06CC6:  BSF    19.7
06CC8:  BCF    FF2.7
06CCA:  MOVFF  02,967
06CCE:  MOVFF  01,966
06CD2:  CALL   0AD6
06CD6:  BTFSC  19.7
06CD8:  BSF    FF2.7
06CDA:  MOVLW  2C
06CDC:  BTFSS  FA4.4
06CDE:  BRA    6CDC
06CE0:  MOVWF  F73
06CE2:  MOVLW  20
06CE4:  BTFSS  FA4.4
06CE6:  BRA    6CE4
06CE8:  MOVWF  F73
06CEA:  MOVLW  10
06CEC:  MOVWF  FE9
06CEE:  CLRF   19
06CF0:  BTFSC  FF2.7
06CF2:  BSF    19.7
06CF4:  BCF    FF2.7
06CF6:  MOVFF  75C,967
06CFA:  MOVFF  75B,966
06CFE:  CALL   0AD6
06D02:  BTFSC  19.7
06D04:  BSF    FF2.7
06D06:  MOVLW  2C
06D08:  BTFSS  FA4.4
06D0A:  BRA    6D08
06D0C:  MOVWF  F73
06D0E:  MOVLW  20
06D10:  BTFSS  FA4.4
06D12:  BRA    6D10
06D14:  MOVWF  F73
06D16:  MOVLW  10
06D18:  MOVWF  FE9
06D1A:  CLRF   19
06D1C:  BTFSC  FF2.7
06D1E:  BSF    19.7
06D20:  BCF    FF2.7
06D22:  MOVFF  75E,967
06D26:  MOVFF  75D,966
06D2A:  CALL   0AD6
06D2E:  BTFSC  19.7
06D30:  BSF    FF2.7
06D32:  MOVLW  2C
06D34:  BTFSS  FA4.4
06D36:  BRA    6D34
06D38:  MOVWF  F73
06D3A:  MOVLW  20
06D3C:  BTFSS  FA4.4
06D3E:  BRA    6D3C
06D40:  MOVWF  F73
06D42:  MOVLW  10
06D44:  MOVWF  FE9
06D46:  CLRF   19
06D48:  BTFSC  FF2.7
06D4A:  BSF    19.7
06D4C:  BCF    FF2.7
06D4E:  MOVFF  760,967
06D52:  MOVFF  75F,966
06D56:  CALL   0AD6
06D5A:  BTFSC  19.7
06D5C:  BSF    FF2.7
06D5E:  MOVLW  0D
06D60:  BTFSS  FA4.4
06D62:  BRA    6D60
06D64:  MOVWF  F73
06D66:  MOVLW  0A
06D68:  BTFSS  FA4.4
06D6A:  BRA    6D68
06D6C:  MOVWF  F73
....................        
....................       if (i < 11)  
06D6E:  MOVLB  7
06D70:  BTFSC  x82.7
06D72:  BRA    6D7E
06D74:  MOVF   x82,F
06D76:  BNZ   6DB4
06D78:  MOVF   x81,W
06D7A:  SUBLW  0A
06D7C:  BNC   6DB4
....................          CartridgeRawDataSet1[ i1++ ] = RawReadings; 
06D7E:  MOVF   x59,W
06D80:  INCF   x59,F
06D82:  MOVWF  x88
06D84:  MOVWF  x89
06D86:  MOVLW  06
06D88:  MOVWF  x8A
06D8A:  MOVLB  0
06D8C:  RCALL  6832
06D8E:  MOVF   01,W
06D90:  CLRF   03
06D92:  ADDLW  16
06D94:  MOVWF  FE9
06D96:  MOVLW  05
06D98:  ADDWFC 03,W
06D9A:  MOVWF  FEA
06D9C:  MOVLW  07
06D9E:  MOVWF  FE2
06DA0:  MOVLW  5B
06DA2:  MOVWF  FE1
06DA4:  MOVLW  06
06DA6:  MOVWF  01
06DA8:  MOVFF  FE6,FEE
06DAC:  DECFSZ 01,F
06DAE:  BRA    6DA8
06DB0:  BRA    6E02
06DB2:  MOVLB  7
....................        
....................       else if (i > 33 && i <= 40)  
06DB4:  BTFSC  x82.7
06DB6:  BRA    6E04
06DB8:  MOVF   x82,F
06DBA:  BNZ   6DC2
06DBC:  MOVF   x81,W
06DBE:  SUBLW  21
06DC0:  BC    6E04
06DC2:  BTFSC  x82.7
06DC4:  BRA    6DD0
06DC6:  MOVF   x82,F
06DC8:  BNZ   6E04
06DCA:  MOVF   x81,W
06DCC:  SUBLW  28
06DCE:  BNC   6E04
....................          CartridgeRawDataSet2[ i2++ ] = RawReadings; 
06DD0:  MOVF   x5A,W
06DD2:  INCF   x5A,F
06DD4:  MOVWF  x88
06DD6:  MOVWF  x89
06DD8:  MOVLW  06
06DDA:  MOVWF  x8A
06DDC:  MOVLB  0
06DDE:  RCALL  6832
06DE0:  MOVF   01,W
06DE2:  CLRF   03
06DE4:  ADDLW  4C
06DE6:  MOVWF  FE9
06DE8:  MOVLW  05
06DEA:  ADDWFC 03,W
06DEC:  MOVWF  FEA
06DEE:  MOVLW  07
06DF0:  MOVWF  FE2
06DF2:  MOVLW  5B
06DF4:  MOVWF  FE1
06DF6:  MOVLW  06
06DF8:  MOVWF  01
06DFA:  MOVFF  FE6,FEE
06DFE:  DECFSZ 01,F
06E00:  BRA    6DFA
06E02:  MOVLB  7
....................  
....................       delay_ms(5); 
06E04:  MOVLW  05
06E06:  MOVLB  8
06E08:  MOVWF  x18
06E0A:  MOVLB  0
06E0C:  CALL   2D2E
....................       if (i == 40) 
06E10:  MOVLB  7
06E12:  MOVF   x81,W
06E14:  SUBLW  28
06E16:  BNZ   6E1E
06E18:  MOVF   x82,F
06E1A:  BNZ   6E1E
....................          break; 
06E1C:  BRA    6E3C
....................  
....................       delay_ms(2850); 
06E1E:  MOVLW  0F
06E20:  MOVWF  x87
06E22:  MOVLW  BE
06E24:  MOVLB  8
06E26:  MOVWF  x18
06E28:  MOVLB  0
06E2A:  CALL   2D2E
06E2E:  MOVLB  7
06E30:  DECFSZ x87,F
06E32:  BRA    6E22
06E34:  INCF   x81,F
06E36:  BTFSC  FD8.2
06E38:  INCF   x82,F
06E3A:  BRA    6B52
....................    } 
....................    
....................    illumination_all_off(); 
06E3C:  MOVLB  0
06E3E:  CALL   4344
....................     
....................    if(!status)  
06E42:  MOVLB  7
06E44:  MOVF   x57,W
06E46:  IORWF  x58,W
06E48:  BTFSS  FD8.2
06E4A:  GOTO   7B50
....................    { 
....................       fprintf(STDOUT, "\r\nAnalyzing wet cartridge...\r\nTime(s), Red 730, Orange 588, Blue 475\r\n"); 
06E4E:  MOVLW  5A
06E50:  MOVWF  FF6
06E52:  MOVLW  1D
06E54:  MOVWF  FF7
06E56:  MOVLB  0
06E58:  CALL   2CA0
....................       r475o588 = 0.0; 
06E5C:  MOVLB  7
06E5E:  CLRF   x70
06E60:  CLRF   x6F
06E62:  CLRF   x6E
06E64:  CLRF   x6D
....................       r588o730 = 0.0; 
06E66:  CLRF   x74
06E68:  CLRF   x73
06E6A:  CLRF   x72
06E6C:  CLRF   x71
....................       for( i1=0, i2=2; i1<4; i1++, i2++ )  
06E6E:  CLRF   x59
06E70:  MOVLW  02
06E72:  MOVWF  x5A
06E74:  BTFSC  x59.7
06E76:  BRA    6E80
06E78:  MOVF   x59,W
06E7A:  SUBLW  03
06E7C:  BTFSS  FD8.0
06E7E:  BRA    7142
....................       { 
....................          RawReadings = CartridgeRawDataSet1[i1]; 
06E80:  MOVFF  759,789
06E84:  MOVLW  06
06E86:  MOVWF  x8A
06E88:  MOVLB  0
06E8A:  RCALL  6832
06E8C:  MOVF   01,W
06E8E:  CLRF   03
06E90:  ADDLW  16
06E92:  MOVWF  FE1
06E94:  MOVLW  05
06E96:  ADDWFC 03,W
06E98:  MOVWF  FE2
06E9A:  MOVLW  07
06E9C:  MOVWF  FEA
06E9E:  MOVLW  5B
06EA0:  MOVWF  FE9
06EA2:  MOVLW  06
06EA4:  MOVWF  01
06EA6:  MOVFF  FE6,FEE
06EAA:  DECFSZ 01,F
06EAC:  BRA    6EA6
06EAE:  CLRF   19
06EB0:  BTFSC  FF2.7
06EB2:  BSF    19.7
06EB4:  BCF    FF2.7
....................           
....................          x.Light730 = (float32)RawReadings.Raw730 * whitebalances.Light730; 
06EB6:  MOVFF  75C,967
06EBA:  MOVFF  75B,966
06EBE:  CALL   099A
06EC2:  BTFSC  19.7
06EC4:  BSF    FF2.7
06EC6:  MOVFF  03,78A
06ECA:  MOVFF  02,789
06ECE:  MOVFF  01,788
06ED2:  MOVFF  00,787
06ED6:  MOVFF  03,835
06EDA:  MOVFF  02,834
06EDE:  MOVFF  01,833
06EE2:  MOVFF  00,832
06EE6:  MOVFF  579,839
06EEA:  MOVFF  578,838
06EEE:  MOVFF  577,837
06EF2:  MOVFF  576,836
06EF6:  CALL   3F30
06EFA:  MOVFF  03,764
06EFE:  MOVFF  02,763
06F02:  MOVFF  01,762
06F06:  MOVFF  00,761
06F0A:  CLRF   19
06F0C:  BTFSC  FF2.7
06F0E:  BSF    19.7
06F10:  BCF    FF2.7
....................          x.Light588 = (float32)RawReadings.Raw588 * whitebalances.Light588; 
06F12:  MOVFF  75E,967
06F16:  MOVFF  75D,966
06F1A:  CALL   099A
06F1E:  BTFSC  19.7
06F20:  BSF    FF2.7
06F22:  MOVFF  03,78A
06F26:  MOVFF  02,789
06F2A:  MOVFF  01,788
06F2E:  MOVFF  00,787
06F32:  MOVFF  03,835
06F36:  MOVFF  02,834
06F3A:  MOVFF  01,833
06F3E:  MOVFF  00,832
06F42:  MOVFF  57D,839
06F46:  MOVFF  57C,838
06F4A:  MOVFF  57B,837
06F4E:  MOVFF  57A,836
06F52:  CALL   3F30
06F56:  MOVFF  03,768
06F5A:  MOVFF  02,767
06F5E:  MOVFF  01,766
06F62:  MOVFF  00,765
06F66:  CLRF   19
06F68:  BTFSC  FF2.7
06F6A:  BSF    19.7
06F6C:  BCF    FF2.7
....................          x.Light475 = (float32)RawReadings.Raw475 * whitebalances.Light475; 
06F6E:  MOVFF  760,967
06F72:  MOVFF  75F,966
06F76:  CALL   099A
06F7A:  BTFSC  19.7
06F7C:  BSF    FF2.7
06F7E:  MOVFF  03,78A
06F82:  MOVFF  02,789
06F86:  MOVFF  01,788
06F8A:  MOVFF  00,787
06F8E:  MOVFF  03,835
06F92:  MOVFF  02,834
06F96:  MOVFF  01,833
06F9A:  MOVFF  00,832
06F9E:  MOVFF  581,839
06FA2:  MOVFF  580,838
06FA6:  MOVFF  57F,837
06FAA:  MOVFF  57E,836
06FAE:  CALL   3F30
06FB2:  MOVFF  03,76C
06FB6:  MOVFF  02,76B
06FBA:  MOVFF  01,76A
06FBE:  MOVFF  00,769
....................           
....................          fprintf(STDOUT, "%u, %.4f, %.4f, %.4f\r\n", i2*3, x.Light730, x.Light588, x.Light475); 
06FC2:  MOVFF  75A,789
06FC6:  MOVLW  03
06FC8:  MOVLB  7
06FCA:  MOVWF  x8A
06FCC:  MOVLB  0
06FCE:  RCALL  6832
06FD0:  MOVFF  01,787
06FD4:  MOVFF  01,813
06FD8:  MOVLW  1B
06FDA:  MOVLB  8
06FDC:  MOVWF  x14
06FDE:  MOVLB  0
06FE0:  CALL   39DC
06FE4:  MOVLW  2C
06FE6:  BTFSS  FA4.4
06FE8:  BRA    6FE6
06FEA:  MOVWF  F73
06FEC:  MOVLW  20
06FEE:  BTFSS  FA4.4
06FF0:  BRA    6FEE
06FF2:  MOVWF  F73
06FF4:  MOVLW  89
06FF6:  MOVWF  FE9
06FF8:  MOVFF  764,815
06FFC:  MOVFF  763,814
07000:  MOVFF  762,813
07004:  MOVFF  761,812
07008:  MOVLW  04
0700A:  MOVLB  8
0700C:  MOVWF  x16
0700E:  MOVLB  0
07010:  CALL   40FE
07014:  MOVLW  2C
07016:  BTFSS  FA4.4
07018:  BRA    7016
0701A:  MOVWF  F73
0701C:  MOVLW  20
0701E:  BTFSS  FA4.4
07020:  BRA    701E
07022:  MOVWF  F73
07024:  MOVLW  89
07026:  MOVWF  FE9
07028:  MOVFF  768,815
0702C:  MOVFF  767,814
07030:  MOVFF  766,813
07034:  MOVFF  765,812
07038:  MOVLW  04
0703A:  MOVLB  8
0703C:  MOVWF  x16
0703E:  MOVLB  0
07040:  CALL   40FE
07044:  MOVLW  2C
07046:  BTFSS  FA4.4
07048:  BRA    7046
0704A:  MOVWF  F73
0704C:  MOVLW  20
0704E:  BTFSS  FA4.4
07050:  BRA    704E
07052:  MOVWF  F73
07054:  MOVLW  89
07056:  MOVWF  FE9
07058:  MOVFF  76C,815
0705C:  MOVFF  76B,814
07060:  MOVFF  76A,813
07064:  MOVFF  769,812
07068:  MOVLW  04
0706A:  MOVLB  8
0706C:  MOVWF  x16
0706E:  MOVLB  0
07070:  CALL   40FE
07074:  MOVLW  0D
07076:  BTFSS  FA4.4
07078:  BRA    7076
0707A:  MOVWF  F73
0707C:  MOVLW  0A
0707E:  BTFSS  FA4.4
07080:  BRA    707E
07082:  MOVWF  F73
....................          r475o588 += (x.Light475 / x.Light588); 
07084:  MOVFF  76C,819
07088:  MOVFF  76B,818
0708C:  MOVFF  76A,817
07090:  MOVFF  769,816
07094:  MOVFF  768,81D
07098:  MOVFF  767,81C
0709C:  MOVFF  766,81B
070A0:  MOVFF  765,81A
070A4:  CALL   6272
070A8:  BCF    FD8.1
070AA:  MOVFF  770,835
070AE:  MOVFF  76F,834
070B2:  MOVFF  76E,833
070B6:  MOVFF  76D,832
070BA:  MOVFF  03,839
070BE:  MOVFF  02,838
070C2:  MOVFF  01,837
070C6:  MOVFF  00,836
070CA:  CALL   6880
070CE:  MOVFF  03,770
070D2:  MOVFF  02,76F
070D6:  MOVFF  01,76E
070DA:  MOVFF  00,76D
....................          r588o730 += (x.Light588 / x.Light730); 
070DE:  MOVFF  768,819
070E2:  MOVFF  767,818
070E6:  MOVFF  766,817
070EA:  MOVFF  765,816
070EE:  MOVFF  764,81D
070F2:  MOVFF  763,81C
070F6:  MOVFF  762,81B
070FA:  MOVFF  761,81A
070FE:  CALL   6272
07102:  BCF    FD8.1
07104:  MOVFF  774,835
07108:  MOVFF  773,834
0710C:  MOVFF  772,833
07110:  MOVFF  771,832
07114:  MOVFF  03,839
07118:  MOVFF  02,838
0711C:  MOVFF  01,837
07120:  MOVFF  00,836
07124:  CALL   6880
07128:  MOVFF  03,774
0712C:  MOVFF  02,773
07130:  MOVFF  01,772
07134:  MOVFF  00,771
07138:  MOVLB  7
0713A:  MOVF   x59,W
0713C:  INCF   x59,F
0713E:  INCF   x5A,F
07140:  BRA    6E74
....................       } 
....................        
....................       Diff1 = (r475o588 - r588o730) / 4.0; 
07142:  BSF    FD8.1
07144:  MOVFF  770,835
07148:  MOVFF  76F,834
0714C:  MOVFF  76E,833
07150:  MOVFF  76D,832
07154:  MOVFF  774,839
07158:  MOVFF  773,838
0715C:  MOVFF  772,837
07160:  MOVFF  771,836
07164:  MOVLB  0
07166:  CALL   6880
0716A:  MOVFF  03,78A
0716E:  MOVFF  02,789
07172:  MOVFF  01,788
07176:  MOVFF  00,787
0717A:  MOVFF  03,819
0717E:  MOVFF  02,818
07182:  MOVFF  01,817
07186:  MOVFF  00,816
0718A:  MOVLB  8
0718C:  CLRF   x1D
0718E:  CLRF   x1C
07190:  CLRF   x1B
07192:  MOVLW  81
07194:  MOVWF  x1A
07196:  MOVLB  0
07198:  CALL   6272
0719C:  MOVFF  03,778
071A0:  MOVFF  02,777
071A4:  MOVFF  01,776
071A8:  MOVFF  00,775
....................       fprintf(STDOUT, "Diff1= %.4f\r\n", Diff1); 
071AC:  MOVLW  A2
071AE:  MOVWF  FF6
071B0:  MOVLW  1D
071B2:  MOVWF  FF7
071B4:  CLRF   19
071B6:  BTFSC  FF2.7
071B8:  BSF    19.7
071BA:  BCF    FF2.7
071BC:  MOVLW  07
071BE:  MOVLB  9
071C0:  MOVWF  x66
071C2:  MOVLB  0
071C4:  CALL   0AAC
071C8:  BTFSC  19.7
071CA:  BSF    FF2.7
071CC:  MOVLW  89
071CE:  MOVWF  FE9
071D0:  MOVFF  778,815
071D4:  MOVFF  777,814
071D8:  MOVFF  776,813
071DC:  MOVFF  775,812
071E0:  MOVLW  04
071E2:  MOVLB  8
071E4:  MOVWF  x16
071E6:  MOVLB  0
071E8:  CALL   40FE
071EC:  MOVLW  0D
071EE:  BTFSS  FA4.4
071F0:  BRA    71EE
071F2:  MOVWF  F73
071F4:  MOVLW  0A
071F6:  BTFSS  FA4.4
071F8:  BRA    71F6
071FA:  MOVWF  F73
....................        
....................       fprintf(STDOUT, "\r\nAnalyzing initial cartridge...\r\nTime(s), Red 730, Orange 588, Blue 475\r\n"); 
071FC:  MOVLW  B0
071FE:  MOVWF  FF6
07200:  MOVLW  1D
07202:  MOVWF  FF7
07204:  CALL   2CA0
....................       r475o588 = 0.0; 
07208:  MOVLB  7
0720A:  CLRF   x70
0720C:  CLRF   x6F
0720E:  CLRF   x6E
07210:  CLRF   x6D
....................       r588o730 = 0.0; 
07212:  CLRF   x74
07214:  CLRF   x73
07216:  CLRF   x72
07218:  CLRF   x71
....................       for(i1=1, i2=3; i1<9; i1++, i2++)  
0721A:  MOVLW  01
0721C:  MOVWF  x59
0721E:  MOVLW  03
07220:  MOVWF  x5A
07222:  BTFSC  x59.7
07224:  BRA    722E
07226:  MOVF   x59,W
07228:  SUBLW  08
0722A:  BTFSS  FD8.0
0722C:  BRA    74F4
....................       { 
....................          RawReadings = CartridgeRawDataSet1[i1]; 
0722E:  MOVFF  759,789
07232:  MOVLW  06
07234:  MOVWF  x8A
07236:  MOVLB  0
07238:  CALL   6832
0723C:  MOVF   01,W
0723E:  CLRF   03
07240:  ADDLW  16
07242:  MOVWF  FE1
07244:  MOVLW  05
07246:  ADDWFC 03,W
07248:  MOVWF  FE2
0724A:  MOVLW  07
0724C:  MOVWF  FEA
0724E:  MOVLW  5B
07250:  MOVWF  FE9
07252:  MOVLW  06
07254:  MOVWF  01
07256:  MOVFF  FE6,FEE
0725A:  DECFSZ 01,F
0725C:  BRA    7256
0725E:  CLRF   19
07260:  BTFSC  FF2.7
07262:  BSF    19.7
07264:  BCF    FF2.7
....................           
....................          x.Light730 = (float32)RawReadings.Raw730 * whitebalances.Light730; 
07266:  MOVFF  75C,967
0726A:  MOVFF  75B,966
0726E:  CALL   099A
07272:  BTFSC  19.7
07274:  BSF    FF2.7
07276:  MOVFF  03,78A
0727A:  MOVFF  02,789
0727E:  MOVFF  01,788
07282:  MOVFF  00,787
07286:  MOVFF  03,835
0728A:  MOVFF  02,834
0728E:  MOVFF  01,833
07292:  MOVFF  00,832
07296:  MOVFF  579,839
0729A:  MOVFF  578,838
0729E:  MOVFF  577,837
072A2:  MOVFF  576,836
072A6:  CALL   3F30
072AA:  MOVFF  03,764
072AE:  MOVFF  02,763
072B2:  MOVFF  01,762
072B6:  MOVFF  00,761
072BA:  CLRF   19
072BC:  BTFSC  FF2.7
072BE:  BSF    19.7
072C0:  BCF    FF2.7
....................          x.Light588 = (float32)RawReadings.Raw588 * whitebalances.Light588; 
072C2:  MOVFF  75E,967
072C6:  MOVFF  75D,966
072CA:  CALL   099A
072CE:  BTFSC  19.7
072D0:  BSF    FF2.7
072D2:  MOVFF  03,78A
072D6:  MOVFF  02,789
072DA:  MOVFF  01,788
072DE:  MOVFF  00,787
072E2:  MOVFF  03,835
072E6:  MOVFF  02,834
072EA:  MOVFF  01,833
072EE:  MOVFF  00,832
072F2:  MOVFF  57D,839
072F6:  MOVFF  57C,838
072FA:  MOVFF  57B,837
072FE:  MOVFF  57A,836
07302:  CALL   3F30
07306:  MOVFF  03,768
0730A:  MOVFF  02,767
0730E:  MOVFF  01,766
07312:  MOVFF  00,765
07316:  CLRF   19
07318:  BTFSC  FF2.7
0731A:  BSF    19.7
0731C:  BCF    FF2.7
....................          x.Light475 = (float32)RawReadings.Raw475 * whitebalances.Light475; 
0731E:  MOVFF  760,967
07322:  MOVFF  75F,966
07326:  CALL   099A
0732A:  BTFSC  19.7
0732C:  BSF    FF2.7
0732E:  MOVFF  03,78A
07332:  MOVFF  02,789
07336:  MOVFF  01,788
0733A:  MOVFF  00,787
0733E:  MOVFF  03,835
07342:  MOVFF  02,834
07346:  MOVFF  01,833
0734A:  MOVFF  00,832
0734E:  MOVFF  581,839
07352:  MOVFF  580,838
07356:  MOVFF  57F,837
0735A:  MOVFF  57E,836
0735E:  CALL   3F30
07362:  MOVFF  03,76C
07366:  MOVFF  02,76B
0736A:  MOVFF  01,76A
0736E:  MOVFF  00,769
....................           
....................          fprintf(STDOUT, "%u, %.4f, %.4f, %.4f\r\n", i2*3, x.Light730, x.Light588, x.Light475); 
07372:  MOVFF  75A,789
07376:  MOVLW  03
07378:  MOVLB  7
0737A:  MOVWF  x8A
0737C:  MOVLB  0
0737E:  CALL   6832
07382:  MOVFF  01,787
07386:  MOVFF  01,813
0738A:  MOVLW  1B
0738C:  MOVLB  8
0738E:  MOVWF  x14
07390:  MOVLB  0
07392:  CALL   39DC
07396:  MOVLW  2C
07398:  BTFSS  FA4.4
0739A:  BRA    7398
0739C:  MOVWF  F73
0739E:  MOVLW  20
073A0:  BTFSS  FA4.4
073A2:  BRA    73A0
073A4:  MOVWF  F73
073A6:  MOVLW  89
073A8:  MOVWF  FE9
073AA:  MOVFF  764,815
073AE:  MOVFF  763,814
073B2:  MOVFF  762,813
073B6:  MOVFF  761,812
073BA:  MOVLW  04
073BC:  MOVLB  8
073BE:  MOVWF  x16
073C0:  MOVLB  0
073C2:  CALL   40FE
073C6:  MOVLW  2C
073C8:  BTFSS  FA4.4
073CA:  BRA    73C8
073CC:  MOVWF  F73
073CE:  MOVLW  20
073D0:  BTFSS  FA4.4
073D2:  BRA    73D0
073D4:  MOVWF  F73
073D6:  MOVLW  89
073D8:  MOVWF  FE9
073DA:  MOVFF  768,815
073DE:  MOVFF  767,814
073E2:  MOVFF  766,813
073E6:  MOVFF  765,812
073EA:  MOVLW  04
073EC:  MOVLB  8
073EE:  MOVWF  x16
073F0:  MOVLB  0
073F2:  CALL   40FE
073F6:  MOVLW  2C
073F8:  BTFSS  FA4.4
073FA:  BRA    73F8
073FC:  MOVWF  F73
073FE:  MOVLW  20
07400:  BTFSS  FA4.4
07402:  BRA    7400
07404:  MOVWF  F73
07406:  MOVLW  89
07408:  MOVWF  FE9
0740A:  MOVFF  76C,815
0740E:  MOVFF  76B,814
07412:  MOVFF  76A,813
07416:  MOVFF  769,812
0741A:  MOVLW  04
0741C:  MOVLB  8
0741E:  MOVWF  x16
07420:  MOVLB  0
07422:  CALL   40FE
07426:  MOVLW  0D
07428:  BTFSS  FA4.4
0742A:  BRA    7428
0742C:  MOVWF  F73
0742E:  MOVLW  0A
07430:  BTFSS  FA4.4
07432:  BRA    7430
07434:  MOVWF  F73
....................          r475o588 += (x.Light475 / x.Light588); 
07436:  MOVFF  76C,819
0743A:  MOVFF  76B,818
0743E:  MOVFF  76A,817
07442:  MOVFF  769,816
07446:  MOVFF  768,81D
0744A:  MOVFF  767,81C
0744E:  MOVFF  766,81B
07452:  MOVFF  765,81A
07456:  CALL   6272
0745A:  BCF    FD8.1
0745C:  MOVFF  770,835
07460:  MOVFF  76F,834
07464:  MOVFF  76E,833
07468:  MOVFF  76D,832
0746C:  MOVFF  03,839
07470:  MOVFF  02,838
07474:  MOVFF  01,837
07478:  MOVFF  00,836
0747C:  CALL   6880
07480:  MOVFF  03,770
07484:  MOVFF  02,76F
07488:  MOVFF  01,76E
0748C:  MOVFF  00,76D
....................          r588o730 += (x.Light588 / x.Light730); 
07490:  MOVFF  768,819
07494:  MOVFF  767,818
07498:  MOVFF  766,817
0749C:  MOVFF  765,816
074A0:  MOVFF  764,81D
074A4:  MOVFF  763,81C
074A8:  MOVFF  762,81B
074AC:  MOVFF  761,81A
074B0:  CALL   6272
074B4:  BCF    FD8.1
074B6:  MOVFF  774,835
074BA:  MOVFF  773,834
074BE:  MOVFF  772,833
074C2:  MOVFF  771,832
074C6:  MOVFF  03,839
074CA:  MOVFF  02,838
074CE:  MOVFF  01,837
074D2:  MOVFF  00,836
074D6:  CALL   6880
074DA:  MOVFF  03,774
074DE:  MOVFF  02,773
074E2:  MOVFF  01,772
074E6:  MOVFF  00,771
074EA:  MOVLB  7
074EC:  MOVF   x59,W
074EE:  INCF   x59,F
074F0:  INCF   x5A,F
074F2:  BRA    7222
....................       } 
....................        
....................       Diff2 = (r475o588 - r588o730) / 8.0; 
074F4:  BSF    FD8.1
074F6:  MOVFF  770,835
074FA:  MOVFF  76F,834
074FE:  MOVFF  76E,833
07502:  MOVFF  76D,832
07506:  MOVFF  774,839
0750A:  MOVFF  773,838
0750E:  MOVFF  772,837
07512:  MOVFF  771,836
07516:  MOVLB  0
07518:  CALL   6880
0751C:  MOVFF  03,78A
07520:  MOVFF  02,789
07524:  MOVFF  01,788
07528:  MOVFF  00,787
0752C:  MOVFF  03,819
07530:  MOVFF  02,818
07534:  MOVFF  01,817
07538:  MOVFF  00,816
0753C:  MOVLB  8
0753E:  CLRF   x1D
07540:  CLRF   x1C
07542:  CLRF   x1B
07544:  MOVLW  82
07546:  MOVWF  x1A
07548:  MOVLB  0
0754A:  CALL   6272
0754E:  MOVFF  03,77C
07552:  MOVFF  02,77B
07556:  MOVFF  01,77A
0755A:  MOVFF  00,779
....................       fprintf(STDOUT, "Diff2= %.4f\r\n", Diff2); 
0755E:  MOVLW  FC
07560:  MOVWF  FF6
07562:  MOVLW  1D
07564:  MOVWF  FF7
07566:  CLRF   19
07568:  BTFSC  FF2.7
0756A:  BSF    19.7
0756C:  BCF    FF2.7
0756E:  MOVLW  07
07570:  MOVLB  9
07572:  MOVWF  x66
07574:  MOVLB  0
07576:  CALL   0AAC
0757A:  BTFSC  19.7
0757C:  BSF    FF2.7
0757E:  MOVLW  89
07580:  MOVWF  FE9
07582:  MOVFF  77C,815
07586:  MOVFF  77B,814
0758A:  MOVFF  77A,813
0758E:  MOVFF  779,812
07592:  MOVLW  04
07594:  MOVLB  8
07596:  MOVWF  x16
07598:  MOVLB  0
0759A:  CALL   40FE
0759E:  MOVLW  0D
075A0:  BTFSS  FA4.4
075A2:  BRA    75A0
075A4:  MOVWF  F73
075A6:  MOVLW  0A
075A8:  BTFSS  FA4.4
075AA:  BRA    75A8
075AC:  MOVWF  F73
....................        
....................       fprintf(STDOUT, "\r\nAnalyzing final cartridge...\r\nTime(s), Red 730, Orange 588, Blue 475\r\n"); 
075AE:  MOVLW  0A
075B0:  MOVWF  FF6
075B2:  MOVLW  1E
075B4:  MOVWF  FF7
075B6:  CALL   2CA0
....................       r475o588 = 0.0; 
075BA:  MOVLB  7
075BC:  CLRF   x70
075BE:  CLRF   x6F
075C0:  CLRF   x6E
075C2:  CLRF   x6D
....................       r588o730 = 0.0; 
075C4:  CLRF   x74
075C6:  CLRF   x73
075C8:  CLRF   x72
075CA:  CLRF   x71
....................       for(i1=0, i2=34; i1<7; i1++, i2++)  
075CC:  CLRF   x59
075CE:  MOVLW  22
075D0:  MOVWF  x5A
075D2:  BTFSC  x59.7
075D4:  BRA    75DE
075D6:  MOVF   x59,W
075D8:  SUBLW  06
075DA:  BTFSS  FD8.0
075DC:  BRA    78A4
....................       { 
....................          RawReadings = CartridgeRawDataSet2[i1]; 
075DE:  MOVFF  759,789
075E2:  MOVLW  06
075E4:  MOVWF  x8A
075E6:  MOVLB  0
075E8:  CALL   6832
075EC:  MOVF   01,W
075EE:  CLRF   03
075F0:  ADDLW  4C
075F2:  MOVWF  FE1
075F4:  MOVLW  05
075F6:  ADDWFC 03,W
075F8:  MOVWF  FE2
075FA:  MOVLW  07
075FC:  MOVWF  FEA
075FE:  MOVLW  5B
07600:  MOVWF  FE9
07602:  MOVLW  06
07604:  MOVWF  01
07606:  MOVFF  FE6,FEE
0760A:  DECFSZ 01,F
0760C:  BRA    7606
0760E:  CLRF   19
07610:  BTFSC  FF2.7
07612:  BSF    19.7
07614:  BCF    FF2.7
....................           
....................          x.Light730 = (float32)RawReadings.Raw730 * whitebalances.Light730; 
07616:  MOVFF  75C,967
0761A:  MOVFF  75B,966
0761E:  CALL   099A
07622:  BTFSC  19.7
07624:  BSF    FF2.7
07626:  MOVFF  03,78A
0762A:  MOVFF  02,789
0762E:  MOVFF  01,788
07632:  MOVFF  00,787
07636:  MOVFF  03,835
0763A:  MOVFF  02,834
0763E:  MOVFF  01,833
07642:  MOVFF  00,832
07646:  MOVFF  579,839
0764A:  MOVFF  578,838
0764E:  MOVFF  577,837
07652:  MOVFF  576,836
07656:  CALL   3F30
0765A:  MOVFF  03,764
0765E:  MOVFF  02,763
07662:  MOVFF  01,762
07666:  MOVFF  00,761
0766A:  CLRF   19
0766C:  BTFSC  FF2.7
0766E:  BSF    19.7
07670:  BCF    FF2.7
....................          x.Light588 = (float32)RawReadings.Raw588 * whitebalances.Light588; 
07672:  MOVFF  75E,967
07676:  MOVFF  75D,966
0767A:  CALL   099A
0767E:  BTFSC  19.7
07680:  BSF    FF2.7
07682:  MOVFF  03,78A
07686:  MOVFF  02,789
0768A:  MOVFF  01,788
0768E:  MOVFF  00,787
07692:  MOVFF  03,835
07696:  MOVFF  02,834
0769A:  MOVFF  01,833
0769E:  MOVFF  00,832
076A2:  MOVFF  57D,839
076A6:  MOVFF  57C,838
076AA:  MOVFF  57B,837
076AE:  MOVFF  57A,836
076B2:  CALL   3F30
076B6:  MOVFF  03,768
076BA:  MOVFF  02,767
076BE:  MOVFF  01,766
076C2:  MOVFF  00,765
076C6:  CLRF   19
076C8:  BTFSC  FF2.7
076CA:  BSF    19.7
076CC:  BCF    FF2.7
....................          x.Light475 = (float32)RawReadings.Raw475 * whitebalances.Light475; 
076CE:  MOVFF  760,967
076D2:  MOVFF  75F,966
076D6:  CALL   099A
076DA:  BTFSC  19.7
076DC:  BSF    FF2.7
076DE:  MOVFF  03,78A
076E2:  MOVFF  02,789
076E6:  MOVFF  01,788
076EA:  MOVFF  00,787
076EE:  MOVFF  03,835
076F2:  MOVFF  02,834
076F6:  MOVFF  01,833
076FA:  MOVFF  00,832
076FE:  MOVFF  581,839
07702:  MOVFF  580,838
07706:  MOVFF  57F,837
0770A:  MOVFF  57E,836
0770E:  CALL   3F30
07712:  MOVFF  03,76C
07716:  MOVFF  02,76B
0771A:  MOVFF  01,76A
0771E:  MOVFF  00,769
....................           
....................          fprintf(STDOUT, "%u, %.4f, %.4f, %.4f\r\n", i2*3, x.Light730, x.Light588, x.Light475); 
07722:  MOVFF  75A,789
07726:  MOVLW  03
07728:  MOVLB  7
0772A:  MOVWF  x8A
0772C:  MOVLB  0
0772E:  CALL   6832
07732:  MOVFF  01,787
07736:  MOVFF  01,813
0773A:  MOVLW  1B
0773C:  MOVLB  8
0773E:  MOVWF  x14
07740:  MOVLB  0
07742:  CALL   39DC
07746:  MOVLW  2C
07748:  BTFSS  FA4.4
0774A:  BRA    7748
0774C:  MOVWF  F73
0774E:  MOVLW  20
07750:  BTFSS  FA4.4
07752:  BRA    7750
07754:  MOVWF  F73
07756:  MOVLW  89
07758:  MOVWF  FE9
0775A:  MOVFF  764,815
0775E:  MOVFF  763,814
07762:  MOVFF  762,813
07766:  MOVFF  761,812
0776A:  MOVLW  04
0776C:  MOVLB  8
0776E:  MOVWF  x16
07770:  MOVLB  0
07772:  CALL   40FE
07776:  MOVLW  2C
07778:  BTFSS  FA4.4
0777A:  BRA    7778
0777C:  MOVWF  F73
0777E:  MOVLW  20
07780:  BTFSS  FA4.4
07782:  BRA    7780
07784:  MOVWF  F73
07786:  MOVLW  89
07788:  MOVWF  FE9
0778A:  MOVFF  768,815
0778E:  MOVFF  767,814
07792:  MOVFF  766,813
07796:  MOVFF  765,812
0779A:  MOVLW  04
0779C:  MOVLB  8
0779E:  MOVWF  x16
077A0:  MOVLB  0
077A2:  CALL   40FE
077A6:  MOVLW  2C
077A8:  BTFSS  FA4.4
077AA:  BRA    77A8
077AC:  MOVWF  F73
077AE:  MOVLW  20
077B0:  BTFSS  FA4.4
077B2:  BRA    77B0
077B4:  MOVWF  F73
077B6:  MOVLW  89
077B8:  MOVWF  FE9
077BA:  MOVFF  76C,815
077BE:  MOVFF  76B,814
077C2:  MOVFF  76A,813
077C6:  MOVFF  769,812
077CA:  MOVLW  04
077CC:  MOVLB  8
077CE:  MOVWF  x16
077D0:  MOVLB  0
077D2:  CALL   40FE
077D6:  MOVLW  0D
077D8:  BTFSS  FA4.4
077DA:  BRA    77D8
077DC:  MOVWF  F73
077DE:  MOVLW  0A
077E0:  BTFSS  FA4.4
077E2:  BRA    77E0
077E4:  MOVWF  F73
....................          r475o588 += (x.Light475 / x.Light588); 
077E6:  MOVFF  76C,819
077EA:  MOVFF  76B,818
077EE:  MOVFF  76A,817
077F2:  MOVFF  769,816
077F6:  MOVFF  768,81D
077FA:  MOVFF  767,81C
077FE:  MOVFF  766,81B
07802:  MOVFF  765,81A
07806:  CALL   6272
0780A:  BCF    FD8.1
0780C:  MOVFF  770,835
07810:  MOVFF  76F,834
07814:  MOVFF  76E,833
07818:  MOVFF  76D,832
0781C:  MOVFF  03,839
07820:  MOVFF  02,838
07824:  MOVFF  01,837
07828:  MOVFF  00,836
0782C:  CALL   6880
07830:  MOVFF  03,770
07834:  MOVFF  02,76F
07838:  MOVFF  01,76E
0783C:  MOVFF  00,76D
....................          r588o730 += (x.Light588 / x.Light730); 
07840:  MOVFF  768,819
07844:  MOVFF  767,818
07848:  MOVFF  766,817
0784C:  MOVFF  765,816
07850:  MOVFF  764,81D
07854:  MOVFF  763,81C
07858:  MOVFF  762,81B
0785C:  MOVFF  761,81A
07860:  CALL   6272
07864:  BCF    FD8.1
07866:  MOVFF  774,835
0786A:  MOVFF  773,834
0786E:  MOVFF  772,833
07872:  MOVFF  771,832
07876:  MOVFF  03,839
0787A:  MOVFF  02,838
0787E:  MOVFF  01,837
07882:  MOVFF  00,836
07886:  CALL   6880
0788A:  MOVFF  03,774
0788E:  MOVFF  02,773
07892:  MOVFF  01,772
07896:  MOVFF  00,771
0789A:  MOVLB  7
0789C:  MOVF   x59,W
0789E:  INCF   x59,F
078A0:  INCF   x5A,F
078A2:  BRA    75D2
....................       } 
....................        
....................       Diff3 = (r475o588 - r588o730) / 7.0; 
078A4:  BSF    FD8.1
078A6:  MOVFF  770,835
078AA:  MOVFF  76F,834
078AE:  MOVFF  76E,833
078B2:  MOVFF  76D,832
078B6:  MOVFF  774,839
078BA:  MOVFF  773,838
078BE:  MOVFF  772,837
078C2:  MOVFF  771,836
078C6:  MOVLB  0
078C8:  CALL   6880
078CC:  MOVFF  03,78A
078D0:  MOVFF  02,789
078D4:  MOVFF  01,788
078D8:  MOVFF  00,787
078DC:  MOVFF  03,819
078E0:  MOVFF  02,818
078E4:  MOVFF  01,817
078E8:  MOVFF  00,816
078EC:  MOVLB  8
078EE:  CLRF   x1D
078F0:  CLRF   x1C
078F2:  MOVLW  60
078F4:  MOVWF  x1B
078F6:  MOVLW  81
078F8:  MOVWF  x1A
078FA:  MOVLB  0
078FC:  CALL   6272
07900:  MOVFF  03,780
07904:  MOVFF  02,77F
07908:  MOVFF  01,77E
0790C:  MOVFF  00,77D
....................       fprintf(STDOUT, "Diff3= %.4f\r\n", Diff3); 
07910:  MOVLW  54
07912:  MOVWF  FF6
07914:  MOVLW  1E
07916:  MOVWF  FF7
07918:  CLRF   19
0791A:  BTFSC  FF2.7
0791C:  BSF    19.7
0791E:  BCF    FF2.7
07920:  MOVLW  07
07922:  MOVLB  9
07924:  MOVWF  x66
07926:  MOVLB  0
07928:  CALL   0AAC
0792C:  BTFSC  19.7
0792E:  BSF    FF2.7
07930:  MOVLW  89
07932:  MOVWF  FE9
07934:  MOVFF  780,815
07938:  MOVFF  77F,814
0793C:  MOVFF  77E,813
07940:  MOVFF  77D,812
07944:  MOVLW  04
07946:  MOVLB  8
07948:  MOVWF  x16
0794A:  MOVLB  0
0794C:  CALL   40FE
07950:  MOVLW  0D
07952:  BTFSS  FA4.4
07954:  BRA    7952
07956:  MOVWF  F73
07958:  MOVLW  0A
0795A:  BTFSS  FA4.4
0795C:  BRA    795A
0795E:  MOVWF  F73
....................        
....................       float32 AD1 = Diff3 - Diff2; 
07960:  BSF    FD8.1
07962:  MOVFF  780,835
07966:  MOVFF  77F,834
0796A:  MOVFF  77E,833
0796E:  MOVFF  77D,832
07972:  MOVFF  77C,839
07976:  MOVFF  77B,838
0797A:  MOVFF  77A,837
0797E:  MOVFF  779,836
07982:  CALL   6880
07986:  MOVFF  03,786
0798A:  MOVFF  02,785
0798E:  MOVFF  01,784
07992:  MOVFF  00,783
....................       *AD2 = Diff3 - Diff1; 
07996:  MOVFF  754,03
0799A:  MOVLB  7
0799C:  MOVFF  753,FE9
079A0:  MOVFF  03,FEA
079A4:  MOVFF  FEA,78A
079A8:  MOVFF  FE9,789
079AC:  BSF    FD8.1
079AE:  MOVFF  780,835
079B2:  MOVFF  77F,834
079B6:  MOVFF  77E,833
079BA:  MOVFF  77D,832
079BE:  MOVFF  778,839
079C2:  MOVFF  777,838
079C6:  MOVFF  776,837
079CA:  MOVFF  775,836
079CE:  MOVLB  0
079D0:  CALL   6880
079D4:  MOVFF  78A,FEA
079D8:  MOVFF  789,FE9
079DC:  MOVFF  00,FEF
079E0:  MOVFF  01,FEC
079E4:  MOVFF  02,FEC
079E8:  MOVFF  03,FEC
....................       *AD_Final = *AD2 - AD1; 
079EC:  MOVFF  756,788
079F0:  MOVLB  7
079F2:  MOVFF  755,787
079F6:  MOVFF  754,03
079FA:  MOVFF  753,FE9
079FE:  MOVFF  03,FEA
07A02:  MOVFF  FEF,832
07A06:  MOVFF  FEC,833
07A0A:  MOVFF  FEC,834
07A0E:  MOVFF  FEC,835
07A12:  BSF    FD8.1
07A14:  MOVFF  786,839
07A18:  MOVFF  785,838
07A1C:  MOVFF  784,837
07A20:  MOVFF  783,836
07A24:  MOVLB  0
07A26:  CALL   6880
07A2A:  MOVFF  788,FEA
07A2E:  MOVFF  787,FE9
07A32:  MOVFF  00,FEF
07A36:  MOVFF  01,FEC
07A3A:  MOVFF  02,FEC
07A3E:  MOVFF  03,FEC
....................       fprintf(STDOUT, "\rAD1=%.4f, AD2=%.4f, AD_Final=%.4f\r\n", AD1, *AD2, *AD_Final); 
07A42:  MOVFF  754,03
07A46:  MOVLB  7
07A48:  MOVFF  753,FE9
07A4C:  MOVFF  03,FEA
07A50:  MOVFF  FEF,787
07A54:  MOVFF  FEC,788
07A58:  MOVFF  FEC,789
07A5C:  MOVFF  FEC,78A
07A60:  MOVFF  756,03
07A64:  MOVFF  755,FE9
07A68:  MOVFF  03,FEA
07A6C:  MOVFF  FEF,78B
07A70:  MOVFF  FEC,78C
07A74:  MOVFF  FEC,78D
07A78:  MOVFF  FEC,78E
07A7C:  MOVLW  62
07A7E:  MOVWF  FF6
07A80:  MOVLW  1E
07A82:  MOVWF  FF7
07A84:  CLRF   19
07A86:  BTFSC  FF2.7
07A88:  BSF    19.7
07A8A:  BCF    FF2.7
07A8C:  MOVLW  05
07A8E:  MOVLB  9
07A90:  MOVWF  x66
07A92:  MOVLB  0
07A94:  CALL   0AAC
07A98:  BTFSC  19.7
07A9A:  BSF    FF2.7
07A9C:  MOVLW  89
07A9E:  MOVWF  FE9
07AA0:  MOVFF  786,815
07AA4:  MOVFF  785,814
07AA8:  MOVFF  784,813
07AAC:  MOVFF  783,812
07AB0:  MOVLW  04
07AB2:  MOVLB  8
07AB4:  MOVWF  x16
07AB6:  MOVLB  0
07AB8:  CALL   40FE
07ABC:  MOVLW  6B
07ABE:  MOVWF  FF6
07AC0:  MOVLW  1E
07AC2:  MOVWF  FF7
07AC4:  CLRF   19
07AC6:  BTFSC  FF2.7
07AC8:  BSF    19.7
07ACA:  BCF    FF2.7
07ACC:  MOVLW  06
07ACE:  MOVLB  9
07AD0:  MOVWF  x66
07AD2:  MOVLB  0
07AD4:  CALL   0AAC
07AD8:  BTFSC  19.7
07ADA:  BSF    FF2.7
07ADC:  MOVLW  89
07ADE:  MOVWF  FE9
07AE0:  MOVFF  78A,815
07AE4:  MOVFF  789,814
07AE8:  MOVFF  788,813
07AEC:  MOVFF  787,812
07AF0:  MOVLW  04
07AF2:  MOVLB  8
07AF4:  MOVWF  x16
07AF6:  MOVLB  0
07AF8:  CALL   40FE
07AFC:  MOVLW  75
07AFE:  MOVWF  FF6
07B00:  MOVLW  1E
07B02:  MOVWF  FF7
07B04:  CLRF   19
07B06:  BTFSC  FF2.7
07B08:  BSF    19.7
07B0A:  BCF    FF2.7
07B0C:  MOVLW  0B
07B0E:  MOVLB  9
07B10:  MOVWF  x66
07B12:  MOVLB  0
07B14:  CALL   0AAC
07B18:  BTFSC  19.7
07B1A:  BSF    FF2.7
07B1C:  MOVLW  89
07B1E:  MOVWF  FE9
07B20:  MOVFF  78E,815
07B24:  MOVFF  78D,814
07B28:  MOVFF  78C,813
07B2C:  MOVFF  78B,812
07B30:  MOVLW  04
07B32:  MOVLB  8
07B34:  MOVWF  x16
07B36:  MOVLB  0
07B38:  CALL   40FE
07B3C:  MOVLW  0D
07B3E:  BTFSS  FA4.4
07B40:  BRA    7B3E
07B42:  MOVWF  F73
07B44:  MOVLW  0A
07B46:  BTFSS  FA4.4
07B48:  BRA    7B46
07B4A:  MOVWF  F73
....................       
....................    }  
07B4C:  BRA    7B56
07B4E:  MOVLB  7
....................     
....................    else  
....................       play_error(); 
07B50:  MOVLB  0
07B52:  CALL   4538
....................     
....................    return status; 
07B56:  MOVLB  7
07B58:  MOVFF  757,01
07B5C:  MOVFF  758,02
07B60:  MOVLB  0
07B62:  RETURN 0
.................... } 
.................... //////////////////////////////////////// 
.................... float32 EvaluateConcentration( float32 x, float32 AD_Final)  
.................... { 
....................    if ((x < 1.5 && AD_Final < 0.0) || x < 0.0)  
07B64:  MOVFF  758,815
07B68:  MOVFF  757,814
07B6C:  MOVFF  756,813
07B70:  MOVFF  755,812
07B74:  MOVLB  8
07B76:  CLRF   x19
07B78:  CLRF   x18
07B7A:  MOVLW  40
07B7C:  MOVWF  x17
07B7E:  MOVLW  7F
07B80:  MOVWF  x16
07B82:  MOVLB  0
07B84:  CALL   3EB6
07B88:  BNC   7BAC
07B8A:  MOVFF  75C,815
07B8E:  MOVFF  75B,814
07B92:  MOVFF  75A,813
07B96:  MOVFF  759,812
07B9A:  MOVLB  8
07B9C:  CLRF   x19
07B9E:  CLRF   x18
07BA0:  CLRF   x17
07BA2:  CLRF   x16
07BA4:  MOVLB  0
07BA6:  CALL   3EB6
07BAA:  BC    7BCE
07BAC:  MOVFF  758,815
07BB0:  MOVFF  757,814
07BB4:  MOVFF  756,813
07BB8:  MOVFF  755,812
07BBC:  MOVLB  8
07BBE:  CLRF   x19
07BC0:  CLRF   x18
07BC2:  CLRF   x17
07BC4:  CLRF   x16
07BC6:  MOVLB  0
07BC8:  CALL   3EB6
07BCC:  BNC   7BD8
....................       return 0.0; 
07BCE:  CLRF   00
07BD0:  CLRF   01
07BD2:  CLRF   02
07BD4:  CLRF   03
07BD6:  BRA    7BE8
....................    return x; 
07BD8:  MOVFF  755,00
07BDC:  MOVFF  756,01
07BE0:  MOVFF  757,02
07BE4:  MOVFF  758,03
07BE8:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 Calibrate()  
*
07E5E:  MOVLW  07
07E60:  MOVLB  7
07E62:  MOVWF  x54
07E64:  MOVLW  37
07E66:  MOVWF  x53
07E68:  MOVLW  07
07E6A:  MOVWF  x56
07E6C:  MOVLW  3B
07E6E:  MOVWF  x55
07E70:  MOVLB  0
07E72:  CALL   6AF8
07E76:  MOVFF  02,740
07E7A:  MOVFF  01,73F
.................... { 
....................    float32 AD2; 
....................    float32 AD_Final; 
....................    uint16 status = AnalyzeBreathSample(&AD2, &AD_Final); 
....................     
....................    if ( status == CARTRIDGE_REMOVED_DURING_ANALYSIS ) 
07E7E:  MOVLB  7
07E80:  MOVF   x3F,W
07E82:  SUBLW  50
07E84:  BNZ   7E94
07E86:  MOVF   x40,F
07E88:  BNZ   7E94
....................       return status; 
07E8A:  MOVFF  73F,01
07E8E:  MOVFF  740,02
07E92:  BRA    8242
....................        
....................    if (!status)  
07E94:  MOVF   x3F,W
07E96:  IORWF  x40,W
07E98:  BTFSS  FD8.2
07E9A:  BRA    823A
....................    { 
....................       float32 Conc1 = (AD2-0.0300)/0.0200; 
....................       float32 Conc2 = (AD2-0.0500)/0.0200; 
....................       float32 Conc3 = (AD2-0.0900)/0.0200; 
....................       float32 Conc; 
07E9C:  BSF    FD8.1
07E9E:  MOVFF  73A,835
07EA2:  MOVFF  739,834
07EA6:  MOVFF  738,833
07EAA:  MOVFF  737,832
07EAE:  MOVLW  8F
07EB0:  MOVLB  8
07EB2:  MOVWF  x39
07EB4:  MOVLW  C2
07EB6:  MOVWF  x38
07EB8:  MOVLW  75
07EBA:  MOVWF  x37
07EBC:  MOVLW  79
07EBE:  MOVWF  x36
07EC0:  MOVLB  0
07EC2:  CALL   6880
07EC6:  MOVFF  03,754
07ECA:  MOVFF  02,753
07ECE:  MOVFF  01,752
07ED2:  MOVFF  00,751
07ED6:  MOVFF  03,819
07EDA:  MOVFF  02,818
07EDE:  MOVFF  01,817
07EE2:  MOVFF  00,816
07EE6:  MOVLW  0A
07EE8:  MOVLB  8
07EEA:  MOVWF  x1D
07EEC:  MOVLW  D7
07EEE:  MOVWF  x1C
07EF0:  MOVLW  23
07EF2:  MOVWF  x1B
07EF4:  MOVLW  79
07EF6:  MOVWF  x1A
07EF8:  MOVLB  0
07EFA:  CALL   6272
07EFE:  MOVFF  03,744
07F02:  MOVFF  02,743
07F06:  MOVFF  01,742
07F0A:  MOVFF  00,741
07F0E:  BSF    FD8.1
07F10:  MOVFF  73A,835
07F14:  MOVFF  739,834
07F18:  MOVFF  738,833
07F1C:  MOVFF  737,832
07F20:  MOVLW  CD
07F22:  MOVLB  8
07F24:  MOVWF  x39
07F26:  MOVLW  CC
07F28:  MOVWF  x38
07F2A:  MOVLW  4C
07F2C:  MOVWF  x37
07F2E:  MOVLW  7A
07F30:  MOVWF  x36
07F32:  MOVLB  0
07F34:  CALL   6880
07F38:  MOVFF  03,754
07F3C:  MOVFF  02,753
07F40:  MOVFF  01,752
07F44:  MOVFF  00,751
07F48:  MOVFF  03,819
07F4C:  MOVFF  02,818
07F50:  MOVFF  01,817
07F54:  MOVFF  00,816
07F58:  MOVLW  0A
07F5A:  MOVLB  8
07F5C:  MOVWF  x1D
07F5E:  MOVLW  D7
07F60:  MOVWF  x1C
07F62:  MOVLW  23
07F64:  MOVWF  x1B
07F66:  MOVLW  79
07F68:  MOVWF  x1A
07F6A:  MOVLB  0
07F6C:  CALL   6272
07F70:  MOVFF  03,748
07F74:  MOVFF  02,747
07F78:  MOVFF  01,746
07F7C:  MOVFF  00,745
07F80:  BSF    FD8.1
07F82:  MOVFF  73A,835
07F86:  MOVFF  739,834
07F8A:  MOVFF  738,833
07F8E:  MOVFF  737,832
07F92:  MOVLW  EC
07F94:  MOVLB  8
07F96:  MOVWF  x39
07F98:  MOVLW  51
07F9A:  MOVWF  x38
07F9C:  MOVLW  38
07F9E:  MOVWF  x37
07FA0:  MOVLW  7B
07FA2:  MOVWF  x36
07FA4:  MOVLB  0
07FA6:  CALL   6880
07FAA:  MOVFF  03,754
07FAE:  MOVFF  02,753
07FB2:  MOVFF  01,752
07FB6:  MOVFF  00,751
07FBA:  MOVFF  03,819
07FBE:  MOVFF  02,818
07FC2:  MOVFF  01,817
07FC6:  MOVFF  00,816
07FCA:  MOVLW  0A
07FCC:  MOVLB  8
07FCE:  MOVWF  x1D
07FD0:  MOVLW  D7
07FD2:  MOVWF  x1C
07FD4:  MOVLW  23
07FD6:  MOVWF  x1B
07FD8:  MOVLW  79
07FDA:  MOVWF  x1A
07FDC:  MOVLB  0
07FDE:  CALL   6272
07FE2:  MOVFF  03,74C
07FE6:  MOVFF  02,74B
07FEA:  MOVFF  01,74A
07FEE:  MOVFF  00,749
....................        
....................       Conc = EvaluateConcentration(Conc1, AD_Final); 
07FF2:  MOVFF  744,758
07FF6:  MOVFF  743,757
07FFA:  MOVFF  742,756
07FFE:  MOVFF  741,755
08002:  MOVFF  73E,75C
08006:  MOVFF  73D,75B
0800A:  MOVFF  73C,75A
0800E:  MOVFF  73B,759
08012:  RCALL  7B64
08014:  MOVFF  03,750
08018:  MOVFF  02,74F
0801C:  MOVFF  01,74E
08020:  MOVFF  00,74D
....................       fprintf(STDOUT, "Conc1 = (AD2 - 0.03) / 0.02 = %.4f => Concentration= %.4f\r\n", Conc1, Conc); 
08024:  MOVLW  88
08026:  MOVWF  FF6
08028:  MOVLW  1E
0802A:  MOVWF  FF7
0802C:  CLRF   19
0802E:  BTFSC  FF2.7
08030:  BSF    19.7
08032:  BCF    FF2.7
08034:  MOVLW  1E
08036:  MOVLB  9
08038:  MOVWF  x66
0803A:  MOVLB  0
0803C:  CALL   0AAC
08040:  BTFSC  19.7
08042:  BSF    FF2.7
08044:  MOVLW  89
08046:  MOVWF  FE9
08048:  MOVFF  744,815
0804C:  MOVFF  743,814
08050:  MOVFF  742,813
08054:  MOVFF  741,812
08058:  MOVLW  04
0805A:  MOVLB  8
0805C:  MOVWF  x16
0805E:  MOVLB  0
08060:  CALL   40FE
08064:  MOVLW  AA
08066:  MOVWF  FF6
08068:  MOVLW  1E
0806A:  MOVWF  FF7
0806C:  CLRF   19
0806E:  BTFSC  FF2.7
08070:  BSF    19.7
08072:  BCF    FF2.7
08074:  MOVLW  13
08076:  MOVLB  9
08078:  MOVWF  x66
0807A:  MOVLB  0
0807C:  CALL   0AAC
08080:  BTFSC  19.7
08082:  BSF    FF2.7
08084:  MOVLW  89
08086:  MOVWF  FE9
08088:  MOVFF  750,815
0808C:  MOVFF  74F,814
08090:  MOVFF  74E,813
08094:  MOVFF  74D,812
08098:  MOVLW  04
0809A:  MOVLB  8
0809C:  MOVWF  x16
0809E:  MOVLB  0
080A0:  CALL   40FE
080A4:  MOVLW  0D
080A6:  BTFSS  FA4.4
080A8:  BRA    80A6
080AA:  MOVWF  F73
080AC:  MOVLW  0A
080AE:  BTFSS  FA4.4
080B0:  BRA    80AE
080B2:  MOVWF  F73
....................        
....................       Conc = EvaluateConcentration(Conc2, AD_Final); 
080B4:  MOVFF  748,758
080B8:  MOVFF  747,757
080BC:  MOVFF  746,756
080C0:  MOVFF  745,755
080C4:  MOVFF  73E,75C
080C8:  MOVFF  73D,75B
080CC:  MOVFF  73C,75A
080D0:  MOVFF  73B,759
080D4:  RCALL  7B64
080D6:  MOVFF  03,750
080DA:  MOVFF  02,74F
080DE:  MOVFF  01,74E
080E2:  MOVFF  00,74D
....................       fprintf(STDOUT, "Conc2 = (AD2 - 0.05) / 0.02 = %.4f => Concentration= %.4f\r\n", Conc2, Conc); 
080E6:  MOVLW  C4
080E8:  MOVWF  FF6
080EA:  MOVLW  1E
080EC:  MOVWF  FF7
080EE:  CLRF   19
080F0:  BTFSC  FF2.7
080F2:  BSF    19.7
080F4:  BCF    FF2.7
080F6:  MOVLW  1E
080F8:  MOVLB  9
080FA:  MOVWF  x66
080FC:  MOVLB  0
080FE:  CALL   0AAC
08102:  BTFSC  19.7
08104:  BSF    FF2.7
08106:  MOVLW  89
08108:  MOVWF  FE9
0810A:  MOVFF  748,815
0810E:  MOVFF  747,814
08112:  MOVFF  746,813
08116:  MOVFF  745,812
0811A:  MOVLW  04
0811C:  MOVLB  8
0811E:  MOVWF  x16
08120:  MOVLB  0
08122:  CALL   40FE
08126:  MOVLW  E6
08128:  MOVWF  FF6
0812A:  MOVLW  1E
0812C:  MOVWF  FF7
0812E:  CLRF   19
08130:  BTFSC  FF2.7
08132:  BSF    19.7
08134:  BCF    FF2.7
08136:  MOVLW  13
08138:  MOVLB  9
0813A:  MOVWF  x66
0813C:  MOVLB  0
0813E:  CALL   0AAC
08142:  BTFSC  19.7
08144:  BSF    FF2.7
08146:  MOVLW  89
08148:  MOVWF  FE9
0814A:  MOVFF  750,815
0814E:  MOVFF  74F,814
08152:  MOVFF  74E,813
08156:  MOVFF  74D,812
0815A:  MOVLW  04
0815C:  MOVLB  8
0815E:  MOVWF  x16
08160:  MOVLB  0
08162:  CALL   40FE
08166:  MOVLW  0D
08168:  BTFSS  FA4.4
0816A:  BRA    8168
0816C:  MOVWF  F73
0816E:  MOVLW  0A
08170:  BTFSS  FA4.4
08172:  BRA    8170
08174:  MOVWF  F73
....................        
....................       Conc = EvaluateConcentration(Conc3, AD_Final); 
08176:  MOVFF  74C,758
0817A:  MOVFF  74B,757
0817E:  MOVFF  74A,756
08182:  MOVFF  749,755
08186:  MOVFF  73E,75C
0818A:  MOVFF  73D,75B
0818E:  MOVFF  73C,75A
08192:  MOVFF  73B,759
08196:  RCALL  7B64
08198:  MOVFF  03,750
0819C:  MOVFF  02,74F
081A0:  MOVFF  01,74E
081A4:  MOVFF  00,74D
....................       fprintf(STDOUT, "Conc3 = (AD2 - 0.09) / 0.02 = %.4f => Concentration= %.4f\r\n", Conc3, Conc); 
081A8:  MOVLW  00
081AA:  MOVWF  FF6
081AC:  MOVLW  1F
081AE:  MOVWF  FF7
081B0:  CLRF   19
081B2:  BTFSC  FF2.7
081B4:  BSF    19.7
081B6:  BCF    FF2.7
081B8:  MOVLW  1E
081BA:  MOVLB  9
081BC:  MOVWF  x66
081BE:  MOVLB  0
081C0:  CALL   0AAC
081C4:  BTFSC  19.7
081C6:  BSF    FF2.7
081C8:  MOVLW  89
081CA:  MOVWF  FE9
081CC:  MOVFF  74C,815
081D0:  MOVFF  74B,814
081D4:  MOVFF  74A,813
081D8:  MOVFF  749,812
081DC:  MOVLW  04
081DE:  MOVLB  8
081E0:  MOVWF  x16
081E2:  MOVLB  0
081E4:  CALL   40FE
081E8:  MOVLW  22
081EA:  MOVWF  FF6
081EC:  MOVLW  1F
081EE:  MOVWF  FF7
081F0:  CLRF   19
081F2:  BTFSC  FF2.7
081F4:  BSF    19.7
081F6:  BCF    FF2.7
081F8:  MOVLW  13
081FA:  MOVLB  9
081FC:  MOVWF  x66
081FE:  MOVLB  0
08200:  CALL   0AAC
08204:  BTFSC  19.7
08206:  BSF    FF2.7
08208:  MOVLW  89
0820A:  MOVWF  FE9
0820C:  MOVFF  750,815
08210:  MOVFF  74F,814
08214:  MOVFF  74E,813
08218:  MOVFF  74D,812
0821C:  MOVLW  04
0821E:  MOVLB  8
08220:  MOVWF  x16
08222:  MOVLB  0
08224:  CALL   40FE
08228:  MOVLW  0D
0822A:  BTFSS  FA4.4
0822C:  BRA    822A
0822E:  MOVWF  F73
08230:  MOVLW  0A
08232:  BTFSS  FA4.4
08234:  BRA    8232
08236:  MOVWF  F73
08238:  MOVLB  7
....................    } 
....................     
....................    return status; 
0823A:  MOVFF  73F,01
0823E:  MOVFF  740,02
08242:  MOVLB  0
08244:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint16 readings_csv(float32* concentration) 
*
07BEA:  MOVLW  07
07BEC:  MOVLB  7
07BEE:  MOVWF  x54
07BF0:  MOVLW  39
07BF2:  MOVWF  x53
07BF4:  MOVLW  07
07BF6:  MOVWF  x56
07BF8:  MOVLW  3D
07BFA:  MOVWF  x55
07BFC:  MOVLB  0
07BFE:  CALL   6AF8
07C02:  MOVFF  02,742
07C06:  MOVFF  01,741
.................... {    
....................    float32 AD2; 
....................    float32 AD_Final; 
....................    uint16 status = AnalyzeBreathSample(&AD2, &AD_Final); 
....................     
....................    if ( status == CARTRIDGE_REMOVED_DURING_ANALYSIS ) 
07C0A:  MOVLB  7
07C0C:  MOVF   x41,W
07C0E:  SUBLW  50
07C10:  BNZ   7C20
07C12:  MOVF   x42,F
07C14:  BNZ   7C20
....................       return status; 
07C16:  MOVFF  741,01
07C1A:  MOVFF  742,02
07C1E:  BRA    7E5A
....................        
....................    if ( !status )  
07C20:  MOVF   x41,W
07C22:  IORWF  x42,W
07C24:  BTFSS  FD8.2
07C26:  BRA    7E3E
....................    { 
....................       float32 slope = ConfigReadFloat(CONFIG_SLOPE); 
....................       float32 intercept = ConfigReadFloat(CONFIG_INTERCEPT); 
....................       float32 x = (AD2-intercept)/slope;      
....................       float32 conc = EvaluateConcentration(x, AD_Final); 
07C28:  CLRF   x54
07C2A:  MOVLW  0A
07C2C:  MOVWF  x53
07C2E:  MOVLB  0
07C30:  CALL   3B00
07C34:  MOVFF  03,746
07C38:  MOVFF  02,745
07C3C:  MOVFF  01,744
07C40:  MOVFF  00,743
07C44:  MOVLB  7
07C46:  CLRF   x54
07C48:  MOVLW  0E
07C4A:  MOVWF  x53
07C4C:  MOVLB  0
07C4E:  CALL   3B00
07C52:  MOVFF  03,74A
07C56:  MOVFF  02,749
07C5A:  MOVFF  01,748
07C5E:  MOVFF  00,747
07C62:  MOVFF  FEA,754
07C66:  MOVFF  FE9,753
07C6A:  BSF    FD8.1
07C6C:  MOVFF  73C,835
07C70:  MOVFF  73B,834
07C74:  MOVFF  73A,833
07C78:  MOVFF  739,832
07C7C:  MOVFF  74A,839
07C80:  MOVFF  749,838
07C84:  MOVFF  748,837
07C88:  MOVFF  747,836
07C8C:  CALL   6880
07C90:  MOVFF  754,FEA
07C94:  MOVFF  753,FE9
07C98:  MOVFF  03,758
07C9C:  MOVFF  02,757
07CA0:  MOVFF  01,756
07CA4:  MOVFF  00,755
07CA8:  MOVFF  03,819
07CAC:  MOVFF  02,818
07CB0:  MOVFF  01,817
07CB4:  MOVFF  00,816
07CB8:  MOVFF  746,81D
07CBC:  MOVFF  745,81C
07CC0:  MOVFF  744,81B
07CC4:  MOVFF  743,81A
07CC8:  CALL   6272
07CCC:  MOVFF  03,74E
07CD0:  MOVFF  02,74D
07CD4:  MOVFF  01,74C
07CD8:  MOVFF  00,74B
07CDC:  MOVFF  74E,758
07CE0:  MOVFF  74D,757
07CE4:  MOVFF  74C,756
07CE8:  MOVFF  74B,755
07CEC:  MOVFF  740,75C
07CF0:  MOVFF  73F,75B
07CF4:  MOVFF  73E,75A
07CF8:  MOVFF  73D,759
07CFC:  RCALL  7B64
07CFE:  MOVFF  03,752
07D02:  MOVFF  02,751
07D06:  MOVFF  01,750
07D0A:  MOVFF  00,74F
....................        
....................       fprintf(STDOUT, "Conc = (AD2 - %.4f) / %.4f = %.4f => Concentration= %f\r\n", intercept, slope, x, conc); 
07D0E:  MOVLW  3C
07D10:  MOVWF  FF6
07D12:  MOVLW  1F
07D14:  MOVWF  FF7
07D16:  CLRF   19
07D18:  BTFSC  FF2.7
07D1A:  BSF    19.7
07D1C:  BCF    FF2.7
07D1E:  MOVLW  0E
07D20:  MOVLB  9
07D22:  MOVWF  x66
07D24:  MOVLB  0
07D26:  CALL   0AAC
07D2A:  BTFSC  19.7
07D2C:  BSF    FF2.7
07D2E:  MOVLW  89
07D30:  MOVWF  FE9
07D32:  MOVFF  74A,815
07D36:  MOVFF  749,814
07D3A:  MOVFF  748,813
07D3E:  MOVFF  747,812
07D42:  MOVLW  04
07D44:  MOVLB  8
07D46:  MOVWF  x16
07D48:  MOVLB  0
07D4A:  CALL   40FE
07D4E:  MOVLW  4E
07D50:  MOVWF  FF6
07D52:  MOVLW  1F
07D54:  MOVWF  FF7
07D56:  CLRF   19
07D58:  BTFSC  FF2.7
07D5A:  BSF    19.7
07D5C:  BCF    FF2.7
07D5E:  MOVLW  04
07D60:  MOVLB  9
07D62:  MOVWF  x66
07D64:  MOVLB  0
07D66:  CALL   0AAC
07D6A:  BTFSC  19.7
07D6C:  BSF    FF2.7
07D6E:  MOVLW  89
07D70:  MOVWF  FE9
07D72:  MOVFF  746,815
07D76:  MOVFF  745,814
07D7A:  MOVFF  744,813
07D7E:  MOVFF  743,812
07D82:  MOVLW  04
07D84:  MOVLB  8
07D86:  MOVWF  x16
07D88:  MOVLB  0
07D8A:  CALL   40FE
07D8E:  MOVLW  56
07D90:  MOVWF  FF6
07D92:  MOVLW  1F
07D94:  MOVWF  FF7
07D96:  CLRF   19
07D98:  BTFSC  FF2.7
07D9A:  BSF    19.7
07D9C:  BCF    FF2.7
07D9E:  MOVLW  03
07DA0:  MOVLB  9
07DA2:  MOVWF  x66
07DA4:  MOVLB  0
07DA6:  CALL   0AAC
07DAA:  BTFSC  19.7
07DAC:  BSF    FF2.7
07DAE:  MOVLW  89
07DB0:  MOVWF  FE9
07DB2:  MOVFF  74E,815
07DB6:  MOVFF  74D,814
07DBA:  MOVFF  74C,813
07DBE:  MOVFF  74B,812
07DC2:  MOVLW  04
07DC4:  MOVLB  8
07DC6:  MOVWF  x16
07DC8:  MOVLB  0
07DCA:  CALL   40FE
07DCE:  MOVLW  5D
07DD0:  MOVWF  FF6
07DD2:  MOVLW  1F
07DD4:  MOVWF  FF7
07DD6:  CLRF   19
07DD8:  BTFSC  FF2.7
07DDA:  BSF    19.7
07DDC:  BCF    FF2.7
07DDE:  MOVLW  13
07DE0:  MOVLB  9
07DE2:  MOVWF  x66
07DE4:  MOVLB  0
07DE6:  CALL   0AAC
07DEA:  BTFSC  19.7
07DEC:  BSF    FF2.7
07DEE:  MOVLW  89
07DF0:  MOVWF  FE9
07DF2:  MOVFF  752,815
07DF6:  MOVFF  751,814
07DFA:  MOVFF  750,813
07DFE:  MOVFF  74F,812
07E02:  MOVLW  02
07E04:  MOVLB  8
07E06:  MOVWF  x16
07E08:  MOVLB  0
07E0A:  CALL   40FE
07E0E:  MOVLW  0D
07E10:  BTFSS  FA4.4
07E12:  BRA    7E10
07E14:  MOVWF  F73
07E16:  MOVLW  0A
07E18:  BTFSS  FA4.4
07E1A:  BRA    7E18
07E1C:  MOVWF  F73
....................       *concentration = conc; 
07E1E:  MOVFF  738,03
07E22:  MOVLB  7
07E24:  MOVFF  737,FE9
07E28:  MOVFF  03,FEA
07E2C:  MOVFF  74F,FEF
07E30:  MOVFF  750,FEC
07E34:  MOVFF  751,FEC
07E38:  MOVFF  752,FEC
....................    } 
07E3C:  BRA    7E52
....................     
....................    else  
....................       *concentration = 0.0; 
07E3E:  MOVFF  738,03
07E42:  MOVFF  737,FE9
07E46:  MOVFF  03,FEA
07E4A:  CLRF   FEF
07E4C:  CLRF   FEC
07E4E:  CLRF   FEC
07E50:  CLRF   FEC
....................     
....................    return status; 
07E52:  MOVFF  741,01
07E56:  MOVF   x42,W
07E58:  MOVWF  02
07E5A:  MOVLB  0
07E5C:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... uint8_t checkForCartridge() 
.................... { 
....................    //check for cartridge 
....................    fprintf(STDOUT, "\r\n**** Check for cartridge ****\r\n"); 
*
054B4:  MOVLW  76
054B6:  MOVWF  FF6
054B8:  MOVLW  1F
054BA:  MOVWF  FF7
054BC:  CALL   2CA0
....................  
....................    check_bad_or_used_cartridge( ); 
054C0:  RCALL  501C
....................     
....................    if( !cartridgeDetected ) 
054C2:  MOVLB  5
054C4:  MOVF   x06,F
054C6:  BNZ   54D0
....................       return FAIL; 
054C8:  MOVLW  00
054CA:  MOVWF  01
054CC:  BRA    54EE
054CE:  BRA    54EE
....................     
....................    else 
....................    { 
....................       delay_ms( ONE_SECOND ); 
054D0:  MOVLW  04
054D2:  MOVLB  7
054D4:  MOVWF  x31
054D6:  MOVLW  FA
054D8:  MOVLB  8
054DA:  MOVWF  x18
054DC:  MOVLB  0
054DE:  CALL   2D2E
054E2:  MOVLB  7
054E4:  DECFSZ x31,F
054E6:  BRA    54D6
....................       return PASS; 
054E8:  MOVLW  01
054EA:  MOVWF  01
054EC:  MOVLB  5
....................    } 
054EE:  MOVLB  0
054F0:  GOTO   8882 (RETURN)
.................... } 
.................... //////////////////////////////////////// 
.................... void full_test( int mode ) 
.................... { 
....................    int                status; 
....................    float32            concentration; 
....................     
....................    if( mode == KETONE_TEST )  
*
08246:  MOVLB  7
08248:  MOVF   x31,W
0824A:  SUBLW  02
0824C:  BNZ   832E
....................    { 
....................       status = readings_csv( &concentration ); 
0824E:  MOVLW  07
08250:  MOVWF  x38
08252:  MOVLW  33
08254:  MOVWF  x37
08256:  MOVLB  0
08258:  RCALL  7BEA
0825A:  MOVFF  01,732
....................        
....................       if ( status == CARTRIDGE_REMOVED_DURING_ANALYSIS ) 
0825E:  MOVLB  7
08260:  MOVF   x32,W
08262:  SUBLW  50
08264:  BNZ   827E
....................       { 
....................          bleNotifyErrorSet(CARTRIDGE_REMOVED_DURING_ANALYSIS); 
08266:  MOVLW  50
08268:  MOVLB  8
0826A:  MOVWF  x12
0826C:  MOVLB  0
0826E:  CALL   3A78
....................          testResult.status = CARTRIDGE_REMOVED_DURING_ANALYSIS; 
08272:  MOVLW  50
08274:  MOVLB  2
08276:  MOVWF  x18
....................          goto FullTest_End; 
08278:  BRA    834E
....................       } 
0827A:  BRA    832A
0827C:  MOVLB  7
....................        
....................       else 
....................       { 
....................  
....................  
.................... #ifdef HIGH_SCORE_TEST 
....................          concentration = 55.55; 
....................          testResult.score = f_PICtoIEEE(concentration); 
.................... #else 
....................          testResult.score = f_PICtoIEEE(concentration); 
0827E:  MOVFF  736,23
08282:  MOVFF  735,22
08286:  MOVFF  734,21
0828A:  MOVFF  733,20
0828E:  MOVLB  0
08290:  CALL   66E0
08294:  MOVFF  03,217
08298:  MOVFF  02,216
0829C:  MOVFF  01,215
082A0:  MOVFF  00,214
.................... #endif 
....................       
....................          if( concentration > 20 ) 
082A4:  MOVLB  8
082A6:  CLRF   x15
082A8:  CLRF   x14
082AA:  MOVLW  20
082AC:  MOVWF  x13
082AE:  MOVLW  83
082B0:  MOVWF  x12
082B2:  MOVFF  736,819
082B6:  MOVFF  735,818
082BA:  MOVFF  734,817
082BE:  MOVFF  733,816
082C2:  MOVLB  0
082C4:  CALL   3EB6
082C8:  BNC   82FE
....................          { 
....................             fprintf(STDOUT, "Ketone reading error, replace catridge and retest.\r\n"); 
082CA:  MOVLW  98
082CC:  MOVWF  FF6
082CE:  MOVLW  1F
082D0:  MOVWF  FF7
082D2:  CALL   2CA0
....................             bleNotifyErrorSet(BAD_SCORE); 
082D6:  MOVLW  0A
082D8:  MOVLB  8
082DA:  MOVWF  x12
082DC:  MOVLB  0
082DE:  CALL   3A78
....................             testResult.status = BAD_SCORE; 
082E2:  MOVLW  0A
082E4:  MOVLB  2
082E6:  MOVWF  x18
....................             testResult.totalTestTime = get_ticks(); 
082E8:  MOVLB  0
082EA:  CALL   43C2
082EE:  MOVFF  03,213
082F2:  MOVFF  02,212
082F6:  MOVFF  01,211
082FA:  MOVFF  00,210
....................          } 
....................        
....................          if( status == READING_ERROR_NONE ) 
082FE:  MOVLB  7
08300:  MOVF   x32,F
08302:  BNZ   832C
....................          { 
....................             fprintf(STDOUT, "FullTest finished successfully.\r\n"); 
08304:  MOVLW  CE
08306:  MOVWF  FF6
08308:  MOVLW  1F
0830A:  MOVWF  FF7
0830C:  MOVLB  0
0830E:  CALL   2CA0
....................             testResult.totalTestTime = get_ticks(); 
08312:  CALL   43C2
08316:  MOVFF  03,213
0831A:  MOVFF  02,212
0831E:  MOVFF  01,211
08322:  MOVFF  00,210
....................             testResult.status = NO_ERROR; 
08326:  MOVLB  2
08328:  CLRF   x18
0832A:  MOVLB  7
....................          } 
....................       } 
....................    } 
0832C:  BRA    834C
....................     
....................    else  
....................    { 
....................       status = Calibrate(); 
0832E:  MOVLB  0
08330:  RCALL  7E5E
08332:  MOVFF  01,732
....................  
....................       if( status == READING_ERROR_NONE ) 
08336:  MOVLB  7
08338:  MOVF   x32,F
0833A:  BNZ   834C
....................          fprintf(STDOUT, "Calibration finished successfully.\r\n"); 
0833C:  MOVLW  F0
0833E:  MOVWF  FF6
08340:  MOVLW  1F
08342:  MOVWF  FF7
08344:  MOVLB  0
08346:  CALL   2CA0
0834A:  MOVLB  7
0834C:  MOVLB  2
....................    } 
....................  
.................... FullTest_End:   
....................  
.................... #ifdef SOFTWARE_DEBUG 
....................    fprintf(STDOUT, "Test Mode %ld.\r\n", testResult.testMode); 
....................    fprintf(STDOUT, "Test Score %ld.\r\n", testResult.score); 
....................    fprintf(STDOUT, "Test Time %ld.\r\n", testResult.totalTestTime); 
....................    fprintf(STDOUT, "Test Status %d.\r\n", testResult.status); 
....................    fprintf(STDOUT, "Test ID %d.\r\n", testResult.stepID);    
.................... #endif 
....................  
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
0834E:  MOVLB  8
08350:  CLRF   x14
08352:  MOVLW  3B
08354:  MOVWF  x13
08356:  CLRF   x15
08358:  MOVLW  01
0835A:  MOVWF  x16
0835C:  MOVLW  02
0835E:  MOVWF  x18
08360:  MOVLW  19
08362:  MOVWF  x17
08364:  MOVLB  0
08366:  CALL   2E2E
0836A:  GOTO   8E24 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int8 performBreathTest( int testMode ) 
*
086CC:  MOVLB  7
086CE:  CLRF   x05
086D0:  CLRF   x06
086D2:  CLRF   x1A
086D4:  CLRF   x19
086D6:  CLRF   x18
086D8:  CLRF   x17
.................... { 
....................    struct   timePara   *time; 
....................    int8     ctr, rslt = FAIL; 
....................    int8     errorTerminated = NO; 
.................... //   uint8    tmpStepID = HARDWARE_CHECK; 
....................    uint32   saveTimer, setTimer, currentTime, previousTime; 
....................    uint32   timeCounter = 0; 
....................    uint32   Raw730; 
....................     
....................    time = &cmdReceived.time; 
086DA:  MOVLW  02
086DC:  MOVWF  x03
086DE:  MOVLW  08
086E0:  MOVWF  x02
....................    testResult.testMode = testMode;    
086E2:  CLRF   03
086E4:  MOVF   x01,W
086E6:  BTFSC  FE8.7
086E8:  DECF   03,F
086EA:  MOVLB  2
086EC:  MOVWF  x0E
086EE:  MOVFF  03,20F
....................    brightnessChecked = NO; 
086F2:  MOVLB  5
086F4:  CLRF   x08
....................     
....................    fprintf(STDOUT, new_line_resp); 
086F6:  MOVLW  01
086F8:  MOVWF  FEA
086FA:  MOVLW  A7
086FC:  MOVWF  FE9
086FE:  MOVLB  0
08700:  CALL   2D08
....................    ShowPrompt(); 
08704:  CALL   4E82
....................    fprintf(STDOUT, "Breath test started\r\n"); 
08708:  MOVLW  16
0870A:  MOVWF  FF6
0870C:  MOVLW  20
0870E:  MOVWF  FF7
08710:  CALL   2CA0
....................    fprintf(STDOUT, new_line_resp); 
08714:  MOVLW  01
08716:  MOVWF  FEA
08718:  MOVLW  A7
0871A:  MOVWF  FE9
0871C:  CALL   2D08
....................     
....................    //Save the current timer count 
....................    saveTimer = get_ticks(); 
08720:  CALL   43C2
08724:  MOVFF  03,70A
08728:  MOVFF  02,709
0872C:  MOVFF  01,708
08730:  MOVFF  00,707
....................    setTimer = 0x0; 
08734:  MOVLB  7
08736:  CLRF   x0E
08738:  CLRF   x0D
0873A:  CLRF   x0C
0873C:  CLRF   x0B
....................    previousTime = 0x0; 
0873E:  CLRF   x16
08740:  CLRF   x15
08742:  CLRF   x14
08744:  CLRF   x13
....................    set_ticks( setTimer ); 
08746:  MOVFF  70E,734
0874A:  MOVFF  70D,733
0874E:  MOVFF  70C,732
08752:  MOVFF  70B,731
08756:  MOVLB  0
08758:  CALL   45A2
....................     
....................     
....................    //Set the busy flag, no interruption from BLE from this point on 
....................    FullTestRunning = 1; 
0875C:  MOVLW  01
0875E:  MOVLB  4
08760:  MOVWF  x54
....................     
....................    //Update the breathVolume 
....................    breathVolume = ConfigReadFloat(CONFIG_BREATH_VOLUME); 
08762:  MOVLB  7
08764:  CLRF   x54
08766:  MOVLW  1A
08768:  MOVWF  x53
0876A:  MOVLB  0
0876C:  CALL   3B00
08770:  MOVFF  03,815
08774:  MOVFF  02,814
08778:  MOVFF  01,813
0877C:  MOVFF  00,812
08780:  CALL   3B6C
08784:  MOVFF  02,204
08788:  MOVFF  01,203
....................     
....................    // Reset previously set error bits. 
....................    bleNotifyErrorResetErrorBits(); 
0878C:  CALL   4768
....................     
....................    fprintf(STDOUT, "Initial Light-Conditions:"); 
08790:  MOVLW  2C
08792:  MOVWF  FF6
08794:  MOVLW  20
08796:  MOVWF  FF7
08798:  CALL   2CA0
....................    fprintf(STDOUT, new_line_resp); 
0879C:  MOVLW  01
0879E:  MOVWF  FEA
087A0:  MOVLW  A7
087A2:  MOVWF  FE9
087A4:  CALL   2D08
....................     
....................    LedProperties.LevelBrightness730 = ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS); 
087A8:  MOVLB  7
087AA:  CLRF   x53
087AC:  CLRF   x52
087AE:  MOVLB  0
087B0:  CALL   429C
087B4:  MOVFF  01,50D
....................    LedProperties.LevelBrightness588 = ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS); 
087B8:  MOVLB  7
087BA:  CLRF   x53
087BC:  MOVLW  01
087BE:  MOVWF  x52
087C0:  MOVLB  0
087C2:  CALL   429C
087C6:  MOVFF  01,50E
....................    LedProperties.LevelBrightness475 = ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS); 
087CA:  MOVLB  7
087CC:  CLRF   x53
087CE:  MOVLW  02
087D0:  MOVWF  x52
087D2:  MOVLB  0
087D4:  CALL   429C
087D8:  MOVFF  01,50F
....................     
....................    fprintf(STDOUT, "Brightness levels:\r\n730nm, 588nm, 475nm\r%u, %u, %u\r\n", LedProperties.LevelBrightness730, LedProperties.LevelBrightness588, LedProperties.LevelBrightness475); 
087DC:  MOVLW  46
087DE:  MOVWF  FF6
087E0:  MOVLW  20
087E2:  MOVWF  FF7
087E4:  CLRF   19
087E6:  BTFSC  FF2.7
087E8:  BSF    19.7
087EA:  BCF    FF2.7
087EC:  MOVLW  28
087EE:  MOVLB  9
087F0:  MOVWF  x66
087F2:  MOVLB  0
087F4:  CALL   0AAC
087F8:  BTFSC  19.7
087FA:  BSF    FF2.7
087FC:  MOVFF  50D,813
08800:  MOVLW  1B
08802:  MOVLB  8
08804:  MOVWF  x14
08806:  MOVLB  0
08808:  CALL   39DC
0880C:  MOVLW  2C
0880E:  BTFSS  FA4.4
08810:  BRA    880E
08812:  MOVWF  F73
08814:  MOVLW  20
08816:  BTFSS  FA4.4
08818:  BRA    8816
0881A:  MOVWF  F73
0881C:  MOVFF  50E,813
08820:  MOVLW  1B
08822:  MOVLB  8
08824:  MOVWF  x14
08826:  MOVLB  0
08828:  CALL   39DC
0882C:  MOVLW  2C
0882E:  BTFSS  FA4.4
08830:  BRA    882E
08832:  MOVWF  F73
08834:  MOVLW  20
08836:  BTFSS  FA4.4
08838:  BRA    8836
0883A:  MOVWF  F73
0883C:  MOVFF  50F,813
08840:  MOVLW  1B
08842:  MOVLB  8
08844:  MOVWF  x14
08846:  MOVLB  0
08848:  CALL   39DC
0884C:  MOVLW  0D
0884E:  BTFSS  FA4.4
08850:  BRA    884E
08852:  MOVWF  F73
08854:  MOVLW  0A
08856:  BTFSS  FA4.4
08858:  BRA    8856
0885A:  MOVWF  F73
....................     
....................    testResult.stepID = INSERT_CARTRIDGE; 
0885C:  MOVLW  0A
0885E:  MOVLB  2
08860:  MOVWF  x19
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08862:  MOVLB  8
08864:  CLRF   x14
08866:  MOVLW  3B
08868:  MOVWF  x13
0886A:  CLRF   x15
0886C:  MOVLW  01
0886E:  MOVWF  x16
08870:  MOVLW  02
08872:  MOVWF  x18
08874:  MOVLW  19
08876:  MOVWF  x17
08878:  MOVLB  0
0887A:  CALL   2E2E
....................     
....................    //Check and verify cartridge condition prior to test 
....................    while( TRUE ) 
....................    { 
....................       rslt = checkForCartridge();    
0887E:  GOTO   54B4
08882:  MOVFF  01,705
....................  
....................       if ( cartridgeState != CARTRIDGE_STATE_NEW ) 
08886:  MOVLB  5
08888:  MOVF   x07,F
0888A:  BZ    88DA
....................       { 
....................          fprintf(STDOUT, new_line_resp); 
0888C:  MOVLW  01
0888E:  MOVWF  FEA
08890:  MOVLW  A7
08892:  MOVWF  FE9
08894:  MOVLB  0
08896:  CALL   2D08
....................          fprintf(STDOUT, insert_new_cartridge_resp); 
0889A:  MOVLW  01
0889C:  MOVWF  FEA
0889E:  MOVLW  66
088A0:  MOVWF  FE9
088A2:  CALL   2D08
....................          fprintf(STDOUT, new_line_resp); 
088A6:  MOVLW  01
088A8:  MOVWF  FEA
088AA:  MOVLW  A7
088AC:  MOVWF  FE9
088AE:  CALL   2D08
....................           
....................          delay_ms(FIVE_SECONDS); 
088B2:  MOVLW  14
088B4:  MOVLB  7
088B6:  MOVWF  x31
088B8:  MOVLW  FA
088BA:  MOVLB  8
088BC:  MOVWF  x18
088BE:  MOVLB  0
088C0:  CALL   2D2E
088C4:  MOVLB  7
088C6:  DECFSZ x31,F
088C8:  BRA    88B8
....................          timeCounter += FIVE_SECONDS; 
088CA:  MOVLW  88
088CC:  ADDWF  x17,F
088CE:  MOVLW  13
088D0:  ADDWFC x18,F
088D2:  MOVLW  00
088D4:  ADDWFC x19,F
088D6:  ADDWFC x1A,F
088D8:  MOVLB  5
....................       } 
....................  
.................... #ifdef TURN_OFF_BRIGHTNESS_CHECK   
....................  
....................       if( cartridgeState == CARTRIDGE_STATE_NEW ) 
....................       { 
....................          cartridgeDetected = YES; 
....................          brightnessChecked = YES; 
....................          break; 
....................       } 
....................  
.................... #else 
....................  
....................       if( (cartridgeState == CARTRIDGE_STATE_NEW) && !brightnessChecked ) 
088DA:  MOVF   x07,F
088DC:  BNZ   8944
088DE:  MOVF   x08,F
088E0:  BNZ   8944
....................       { 
....................          rslt = autoSetLEDBrightness( 65, 65, 65 ); 
088E2:  MOVLB  7
088E4:  CLRF   x32
088E6:  MOVLW  41
088E8:  MOVWF  x31
088EA:  CLRF   x34
088EC:  MOVWF  x33
088EE:  CLRF   x36
088F0:  MOVWF  x35
088F2:  MOVLB  0
088F4:  CALL   56B4
088F8:  MOVFF  01,705
....................             
....................          if( rslt != PASS ) 
088FC:  MOVLB  7
088FE:  DECFSZ x05,W
08900:  BRA    8904
08902:  BRA    893A
....................          { 
....................             fprintf(STDOUT, "***** LED brightness setting failed *****\r\n"); 
08904:  MOVLW  7C
08906:  MOVWF  FF6
08908:  MOVLW  20
0890A:  MOVWF  FF7
0890C:  MOVLB  0
0890E:  CALL   2CA0
....................             fprintf(STDOUT, two_new_lines_resp); 
08912:  MOVLW  01
08914:  MOVWF  FEA
08916:  MOVLW  F2
08918:  MOVWF  FE9
0891A:  CALL   2D08
....................             fprintf(STDOUT, insert_new_cartridge_resp); 
0891E:  MOVLW  01
08920:  MOVWF  FEA
08922:  MOVLW  66
08924:  MOVWF  FE9
08926:  CALL   2D08
....................             fprintf(STDOUT, new_line_resp); 
0892A:  MOVLW  01
0892C:  MOVWF  FEA
0892E:  MOVLW  A7
08930:  MOVWF  FE9
08932:  CALL   2D08
....................          } 
08936:  BRA    8946
08938:  MOVLB  7
....................           
....................          else  
....................          { 
....................             brightnessChecked = YES; 
0893A:  MOVLW  01
0893C:  MOVLB  5
0893E:  MOVWF  x08
....................             cartridgeDetected = YES; 
08940:  MOVWF  x06
....................             break; 
08942:  BRA    89DA
08944:  MOVLB  0
....................          } 
....................       } 
....................        
.................... #endif 
....................  
....................       if( timeCounter >= FOUR_MINUTES ) 
08946:  MOVLB  7
08948:  MOVF   x1A,F
0894A:  BNZ   8966
0894C:  MOVF   x19,W
0894E:  SUBLW  02
08950:  BC    89D4
08952:  XORLW  FF
08954:  BNZ   8966
08956:  MOVF   x18,W
08958:  SUBLW  A8
0895A:  BC    89D4
0895C:  XORLW  FF
0895E:  BNZ   8966
08960:  MOVF   x17,W
08962:  SUBLW  7F
08964:  BC    89D4
....................       { 
....................          testResult.totalTestTime = get_ticks(); 
08966:  MOVLB  0
08968:  CALL   43C2
0896C:  MOVFF  03,213
08970:  MOVFF  02,212
08974:  MOVFF  01,211
08978:  MOVFF  00,210
....................          testResult.status = TIME_OUT; 
0897C:  MOVLW  64
0897E:  MOVLB  2
08980:  MOVWF  x18
....................           
....................          bleNotifyErrorSet( TIME_OUT ); 
08982:  MOVLB  8
08984:  MOVWF  x12
08986:  MOVLB  0
08988:  CALL   3A78
....................          delay_ms(ONE_MINUTE); 
0898C:  MOVLW  F0
0898E:  MOVLB  7
08990:  MOVWF  x31
08992:  MOVLW  FA
08994:  MOVLB  8
08996:  MOVWF  x18
08998:  MOVLB  0
0899A:  CALL   2D2E
0899E:  MOVLB  7
089A0:  DECFSZ x31,F
089A2:  BRA    8992
....................           
....................          fprintf(STDOUT, new_line_resp); 
089A4:  MOVLW  01
089A6:  MOVWF  FEA
089A8:  MOVLW  A7
089AA:  MOVWF  FE9
089AC:  MOVLB  0
089AE:  CALL   2D08
....................          fprintf(STDOUT, time_limit_exceeded); 
089B2:  MOVLW  01
089B4:  MOVWF  FEA
089B6:  MOVLW  DE
089B8:  MOVWF  FE9
089BA:  CALL   2D08
....................          fprintf(STDOUT, new_line_resp); 
089BE:  MOVLW  01
089C0:  MOVWF  FEA
089C2:  MOVLW  A7
089C4:  MOVWF  FE9
089C6:  CALL   2D08
....................          rslt = FAIL; 
089CA:  MOVLB  7
089CC:  CLRF   x05
....................          errorTerminated = YES; 
089CE:  MOVLW  01
089D0:  MOVWF  x06
....................          goto FullTestEnd; 
089D2:  BRA    8E46
....................       } 
089D4:  MOVLB  0
089D6:  BRA    887E
089D8:  MOVLB  5
....................    }    
....................     
....................    currentTime = get_ticks(); 
089DA:  MOVLB  0
089DC:  CALL   43C2
089E0:  MOVFF  03,712
089E4:  MOVFF  02,711
089E8:  MOVFF  01,710
089EC:  MOVFF  00,70F
....................    testTime.cartridgeInsertionTime = currentTime - previousTime; 
089F0:  MOVLB  7
089F2:  MOVF   x13,W
089F4:  SUBWF  x0F,W
089F6:  MOVLB  2
089F8:  MOVWF  x1A
089FA:  MOVLB  7
089FC:  MOVF   x14,W
089FE:  SUBWFB x10,W
08A00:  MOVLB  2
08A02:  MOVWF  x1B
08A04:  MOVLB  7
08A06:  MOVF   x15,W
08A08:  SUBWFB x11,W
08A0A:  MOVLB  2
08A0C:  MOVWF  x1C
08A0E:  MOVLB  7
08A10:  MOVF   x16,W
08A12:  SUBWFB x12,W
08A14:  MOVLB  2
08A16:  MOVWF  x1D
....................    previousTime = currentTime; 
08A18:  MOVFF  712,716
08A1C:  MOVFF  711,715
08A20:  MOVFF  710,714
08A24:  MOVFF  70F,713
....................     
....................    MeasureDarkness(); 
08A28:  MOVLB  0
08A2A:  GOTO   602C
....................    whitebalances = Whitebalances();            
08A2E:  GOTO   63D0
08A32:  MOVFF  02,03
08A36:  MOVFF  01,FE1
08A3A:  MOVFF  02,FE2
08A3E:  MOVLW  05
08A40:  MOVWF  FEA
08A42:  MOVLW  76
08A44:  MOVWF  FE9
08A46:  MOVLW  0C
08A48:  MOVWF  01
08A4A:  MOVFF  FE6,FEE
08A4E:  DECFSZ 01,F
08A50:  BRA    8A4A
....................     
....................    // Reset previously set error bits. 
....................    bleNotifyErrorResetErrorBits(); 
08A52:  CALL   4768
....................     
....................    switch( testMode ) 
08A56:  MOVLB  7
08A58:  MOVF   x01,W
08A5A:  XORLW  02
08A5C:  MOVLB  0
08A5E:  BZ    8A66
08A60:  XORLW  01
08A62:  BZ    8A74
08A64:  BRA    8A82
....................    { 
....................       case KETONE_TEST: 
....................          fprintf(STDOUT, "Ketone "); 
08A66:  MOVLW  A8
08A68:  MOVWF  FF6
08A6A:  MOVLW  20
08A6C:  MOVWF  FF7
08A6E:  CALL   2CA0
....................          break; 
08A72:  BRA    8A8E
....................           
....................       case AMMONIA_TEST: 
....................          fprintf(STDOUT, "Ammonia "); 
08A74:  MOVLW  B0
08A76:  MOVWF  FF6
08A78:  MOVLW  20
08A7A:  MOVWF  FF7
08A7C:  CALL   2CA0
....................          break; 
08A80:  BRA    8A8E
....................           
....................       default: 
....................          fprintf(STDOUT, "Calibration "); 
08A82:  MOVLW  BA
08A84:  MOVWF  FF6
08A86:  MOVLW  20
08A88:  MOVWF  FF7
08A8A:  CALL   2CA0
....................  
....................    } 
....................  
....................    fprintf(STDOUT, test_started_resp); 
08A8E:  MOVLW  01
08A90:  MOVWF  FEA
08A92:  MOVLW  D0
08A94:  MOVWF  FE9
08A96:  CALL   2D08
....................    fprintf(STDOUT, new_line_resp); 
08A9A:  MOVLW  01
08A9C:  MOVWF  FEA
08A9E:  MOVLW  A7
08AA0:  MOVWF  FE9
08AA2:  CALL   2D08
....................     
....................     
.................... //************* Need to set the stepcode and errorcode here ************** 
....................  
....................    if( testMode != CALIBRATION_TEST ) 
08AA6:  MOVLB  7
08AA8:  DECFSZ x01,W
08AAA:  BRA    8AAE
08AAC:  BRA    8BD2
....................    { 
....................       illumination_brightness( 30 ); 
08AAE:  MOVLW  1E
08AB0:  MOVLB  8
08AB2:  MOVWF  x12
08AB4:  MOVLB  0
08AB6:  CALL   42F2
....................       illumination_use(ILLUMINATION_588); 
08ABA:  MOVLW  7C
08ABC:  MOVLB  8
08ABE:  MOVWF  x13
08AC0:  MOVLW  10
08AC2:  MOVWF  x12
08AC4:  MOVLB  0
08AC6:  CALL   4394
....................       //output_high(ILLUMINATION_588); 
....................  
....................       testResult.stepID = BLOW; 
08ACA:  MOVLW  14
08ACC:  MOVLB  2
08ACE:  MOVWF  x19
....................       ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08AD0:  MOVLB  8
08AD2:  CLRF   x14
08AD4:  MOVLW  3B
08AD6:  MOVWF  x13
08AD8:  CLRF   x15
08ADA:  MOVLW  01
08ADC:  MOVWF  x16
08ADE:  MOVLW  02
08AE0:  MOVWF  x18
08AE2:  MOVLW  19
08AE4:  MOVWF  x17
08AE6:  MOVLB  0
08AE8:  CALL   2E2E
....................        
....................       fprintf(STDOUT, "....Start breathing into the mouth piece...\r\n"); 
08AEC:  MOVLW  C8
08AEE:  MOVWF  FF6
08AF0:  MOVLW  20
08AF2:  MOVWF  FF7
08AF4:  CALL   2CA0
....................  
....................  
.................... #ifdef BYPASS_BREATH_COLLECTION 
....................     
....................       testStat.pressure = 110000; 
08AF8:  MOVLB  2
08AFA:  CLRF   x41
08AFC:  MOVLW  01
08AFE:  MOVWF  x40
08B00:  MOVLW  AD
08B02:  MOVWF  x3F
08B04:  MOVLW  B0
08B06:  MOVWF  x3E
....................       testStat.temperature = f_PICtoIEEE(89.5); 
08B08:  CLRF   23
08B0A:  CLRF   22
08B0C:  MOVLW  33
08B0E:  MOVWF  21
08B10:  MOVLW  85
08B12:  MOVWF  20
08B14:  MOVLB  0
08B16:  CALL   66E0
08B1A:  MOVFF  03,23D
08B1E:  MOVFF  02,23C
08B22:  MOVFF  01,23B
08B26:  MOVFF  00,23A
....................       testStat.volume = 600; 
08B2A:  MOVLW  02
08B2C:  MOVLB  2
08B2E:  MOVWF  x43
08B30:  MOVLW  58
08B32:  MOVWF  x42
....................       testStat.numOfBlowAttempts = 3; 
08B34:  CLRF   x47
08B36:  MOVLW  03
08B38:  MOVWF  x46
....................       bleNotifyErrorSet(NO_ERROR); 
08B3A:  MOVLB  8
08B3C:  CLRF   x12
08B3E:  MOVLB  0
08B40:  CALL   3A78
....................       rslt = PASS; 
08B44:  MOVLW  01
08B46:  MOVLB  7
08B48:  MOVWF  x05
....................       fprintf(STDOUT, "Breath volume settings %lu\r\n", breathVolume);    
08B4A:  MOVLW  F6
08B4C:  MOVWF  FF6
08B4E:  MOVLW  20
08B50:  MOVWF  FF7
08B52:  CLRF   19
08B54:  BTFSC  FF2.7
08B56:  BSF    19.7
08B58:  BCF    FF2.7
08B5A:  MOVLW  17
08B5C:  MOVLB  9
08B5E:  MOVWF  x66
08B60:  MOVLB  0
08B62:  CALL   0AAC
08B66:  BTFSC  19.7
08B68:  BSF    FF2.7
08B6A:  MOVLW  10
08B6C:  MOVWF  FE9
08B6E:  CLRF   19
08B70:  BTFSC  FF2.7
08B72:  BSF    19.7
08B74:  BCF    FF2.7
08B76:  MOVFF  204,967
08B7A:  MOVFF  203,966
08B7E:  CALL   0AD6
08B82:  BTFSC  19.7
08B84:  BSF    FF2.7
08B86:  MOVLW  0D
08B88:  BTFSS  FA4.4
08B8A:  BRA    8B88
08B8C:  MOVWF  F73
08B8E:  MOVLW  0A
08B90:  BTFSS  FA4.4
08B92:  BRA    8B90
08B94:  MOVWF  F73
.................... #else 
....................  
....................       //Get breath sample 
....................       rslt = Compute_Breath_Volume(&gas_sensor); 
....................        
....................       if( testResult.status == TIME_OUT ) 
....................       { 
....................          errorTerminated = YES; 
....................          testResult.totalTestTime = get_ticks(); //update the Test Report BLE 
....................          goto FullTestEnd; 
....................       } 
....................  
.................... #endif 
....................  
....................       if( rslt != PASS ) 
08B96:  MOVLB  7
08B98:  DECFSZ x05,W
08B9A:  BRA    8B9E
08B9C:  BRA    8BD0
....................       { 
....................          fprintf(STDOUT, "***** Insufficient breath volume *****\r\n"); 
08B9E:  MOVLW  14
08BA0:  MOVWF  FF6
08BA2:  MOVLW  21
08BA4:  MOVWF  FF7
08BA6:  MOVLB  0
08BA8:  CALL   2CA0
....................          bleNotifyErrorSet(BAD_BLOW_VOLUME); 
08BAC:  MOVLW  04
08BAE:  MOVLB  8
08BB0:  MOVWF  x12
08BB2:  MOVLB  0
08BB4:  CALL   3A78
....................          testResult.totalTestTime = get_ticks(); //update the Test Report BLE 
08BB8:  CALL   43C2
08BBC:  MOVFF  03,213
08BC0:  MOVFF  02,212
08BC4:  MOVFF  01,211
08BC8:  MOVFF  00,210
....................          goto FullTestEnd; 
08BCC:  MOVLB  7
08BCE:  BRA    8E46
....................       } 
....................    }       
08BD0:  BRA    8BE2
....................      
....................    else 
....................       fprintf(STDOUT, "Insert catridge with known gas samples for calibration into unit when done\r\n"); 
08BD2:  MOVLW  3E
08BD4:  MOVWF  FF6
08BD6:  MOVLW  21
08BD8:  MOVWF  FF7
08BDA:  MOVLB  0
08BDC:  CALL   2CA0
08BE0:  MOVLB  7
....................  
....................    currentTime = get_ticks(); 
08BE2:  MOVLB  0
08BE4:  CALL   43C2
08BE8:  MOVFF  03,712
08BEC:  MOVFF  02,711
08BF0:  MOVFF  01,710
08BF4:  MOVFF  00,70F
....................    testTime.blowTime = currentTime - previousTime; 
08BF8:  MOVLB  7
08BFA:  MOVF   x13,W
08BFC:  SUBWF  x0F,W
08BFE:  MOVLB  2
08C00:  MOVWF  x1E
08C02:  MOVLB  7
08C04:  MOVF   x14,W
08C06:  SUBWFB x10,W
08C08:  MOVLB  2
08C0A:  MOVWF  x1F
08C0C:  MOVLB  7
08C0E:  MOVF   x15,W
08C10:  SUBWFB x11,W
08C12:  MOVLB  2
08C14:  MOVWF  x20
08C16:  MOVLB  7
08C18:  MOVF   x16,W
08C1A:  SUBWFB x12,W
08C1C:  MOVLB  2
08C1E:  MOVWF  x21
....................    previousTime = currentTime; 
08C20:  MOVFF  712,716
08C24:  MOVFF  711,715
08C28:  MOVFF  710,714
08C2C:  MOVFF  70F,713
....................     
....................    //reset flag to fail 
....................    rslt = FAIL; 
08C30:  MOVLB  7
08C32:  CLRF   x05
....................    timeCounter = 0; 
08C34:  CLRF   x1A
08C36:  CLRF   x19
08C38:  CLRF   x18
08C3A:  CLRF   x17
....................        
.................... #ifndef SKIP_WETCARTRIDGE_CHECK       
....................    //Check for wet cartridge once every 5 seconds for the next 5 minutes 
....................    while( !rslt && timeCounter <= 48 )  //5 minutes time limit to wet the cartridge 
08C3C:  MOVF   x05,F
08C3E:  BNZ   8CFC
08C40:  MOVF   x1A,F
08C42:  BNZ   8CFC
08C44:  MOVF   x19,F
08C46:  BNZ   8CFC
08C48:  MOVF   x18,F
08C4A:  BNZ   8CFC
08C4C:  MOVF   x17,W
08C4E:  SUBLW  30
08C50:  BNC   8CFC
....................    { 
....................       delay_ms( FIVE_SECONDS ); 
08C52:  MOVLW  14
08C54:  MOVWF  x31
08C56:  MOVLW  FA
08C58:  MOVLB  8
08C5A:  MOVWF  x18
08C5C:  MOVLB  0
08C5E:  CALL   2D2E
08C62:  MOVLB  7
08C64:  DECFSZ x31,F
08C66:  BRA    8C56
....................       testResult.stepID = WET; 
08C68:  MOVLW  1E
08C6A:  MOVLB  2
08C6C:  MOVWF  x19
....................       ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08C6E:  MOVLB  8
08C70:  CLRF   x14
08C72:  MOVLW  3B
08C74:  MOVWF  x13
08C76:  CLRF   x15
08C78:  MOVLW  01
08C7A:  MOVWF  x16
08C7C:  MOVLW  02
08C7E:  MOVWF  x18
08C80:  MOVLW  19
08C82:  MOVWF  x17
08C84:  MOVLB  0
08C86:  CALL   2E2E
....................        
....................       rslt = check_wet_cartridge(); 
08C8A:  GOTO   6722
08C8E:  MOVFF  01,705
....................           
....................       if( rslt != YES ) 
08C92:  MOVLB  7
08C94:  DECFSZ x05,W
08C96:  BRA    8C9A
08C98:  BRA    8CEA
....................       { 
....................          illumination_brightness(ONE_HUNDRED); 
08C9A:  MOVLW  64
08C9C:  MOVLB  8
08C9E:  MOVWF  x12
08CA0:  MOVLB  0
08CA2:  CALL   42F2
....................          illumination_use(ILLUMINATION_475); 
08CA6:  MOVLW  7C
08CA8:  MOVLB  8
08CAA:  MOVWF  x13
08CAC:  MOVLW  04
08CAE:  MOVWF  x12
08CB0:  MOVLB  0
08CB2:  CALL   4394
....................           
....................          if( timeCounter == 6 )              //Wait for 30 seconds before notify BLE 
08CB6:  MOVLB  7
08CB8:  MOVF   x17,W
08CBA:  SUBLW  06
08CBC:  BNZ   8CEA
08CBE:  MOVF   x18,F
08CC0:  BNZ   8CEA
08CC2:  MOVF   x19,F
08CC4:  BNZ   8CEA
08CC6:  MOVF   x1A,F
08CC8:  BNZ   8CEA
....................          { 
....................             bleNotifyErrorSet(NO_WETTING); 
08CCA:  MOVLW  14
08CCC:  MOVLB  8
08CCE:  MOVWF  x12
08CD0:  MOVLB  0
08CD2:  CALL   3A78
....................             ble_wait(75); 
08CD6:  MOVLB  7
08CD8:  CLRF   x58
08CDA:  CLRF   x57
08CDC:  CLRF   x56
08CDE:  MOVLW  4B
08CE0:  MOVWF  x55
08CE2:  MOVLB  0
08CE4:  CALL   43F6
08CE8:  MOVLB  7
....................          } 
....................       } 
....................           
....................       timeCounter++; 
08CEA:  MOVLW  01
08CEC:  ADDWF  x17,F
08CEE:  BTFSC  FD8.0
08CF0:  INCF   x18,F
08CF2:  BTFSC  FD8.2
08CF4:  INCF   x19,F
08CF6:  BTFSC  FD8.2
08CF8:  INCF   x1A,F
08CFA:  BRA    8C3C
....................    } 
....................    
....................    if( rslt != PASS ) 
08CFC:  DECFSZ x05,W
08CFE:  BRA    8D02
08D00:  BRA    8D48
....................    { 
....................       bleNotifyErrorSet(TIME_OUT); 
08D02:  MOVLW  64
08D04:  MOVLB  8
08D06:  MOVWF  x12
08D08:  MOVLB  0
08D0A:  CALL   3A78
....................       testResult.totalTestTime = get_ticks(); 
08D0E:  CALL   43C2
08D12:  MOVFF  03,213
08D16:  MOVFF  02,212
08D1A:  MOVFF  01,211
08D1E:  MOVFF  00,210
....................       testResult.status = TIME_OUT; 
08D22:  MOVLW  64
08D24:  MOVLB  2
08D26:  MOVWF  x18
....................       errorTerminated = YES; 
08D28:  MOVLW  01
08D2A:  MOVLB  7
08D2C:  MOVWF  x06
....................  
.................... #ifdef DEBUG 
....................       fprintf(STDOUT, "\r\n\r\n***** Cartridge not wet *****\r\n"); 
.................... #endif 
....................  
....................       delay_ms( ONE_MINUTE ); 
08D2E:  MOVLW  F0
08D30:  MOVWF  x31
08D32:  MOVLW  FA
08D34:  MOVLB  8
08D36:  MOVWF  x18
08D38:  MOVLB  0
08D3A:  CALL   2D2E
08D3E:  MOVLB  7
08D40:  DECFSZ x31,F
08D42:  BRA    8D32
....................       goto FullTestEnd; 
08D44:  BRA    8E46
....................    } 
08D46:  BRA    8E3A
....................                 
....................    else      
.................... #endif    
....................    { 
....................       for( ctr = 7; ctr > 0; ctr-- ) 
08D48:  MOVLW  07
08D4A:  MOVWF  x04
08D4C:  BTFSC  x04.7
08D4E:  BRA    8DA2
08D50:  MOVF   x04,W
08D52:  SUBLW  00
08D54:  BC    8DA2
....................       { 
....................          fprintf(STDOUT, "%d seconds to ketone analysis\r\n", ctr); 
08D56:  MOVFF  704,812
08D5A:  MOVLW  18
08D5C:  MOVLB  8
08D5E:  MOVWF  x13
08D60:  MOVLB  0
08D62:  CALL   2AEC
08D66:  MOVLW  8E
08D68:  MOVWF  FF6
08D6A:  MOVLW  21
08D6C:  MOVWF  FF7
08D6E:  CLRF   19
08D70:  BTFSC  FF2.7
08D72:  BSF    19.7
08D74:  BCF    FF2.7
08D76:  MOVLW  1D
08D78:  MOVLB  9
08D7A:  MOVWF  x66
08D7C:  MOVLB  0
08D7E:  CALL   0AAC
08D82:  BTFSC  19.7
08D84:  BSF    FF2.7
....................          delay_ms( ONE_SECOND ); 
08D86:  MOVLW  04
08D88:  MOVLB  7
08D8A:  MOVWF  x31
08D8C:  MOVLW  FA
08D8E:  MOVLB  8
08D90:  MOVWF  x18
08D92:  MOVLB  0
08D94:  CALL   2D2E
08D98:  MOVLB  7
08D9A:  DECFSZ x31,F
08D9C:  BRA    8D8C
08D9E:  DECF   x04,F
08DA0:  BRA    8D4C
....................       } 
....................        
....................       currentTime = get_ticks(); 
08DA2:  MOVLB  0
08DA4:  CALL   43C2
08DA8:  MOVFF  03,712
08DAC:  MOVFF  02,711
08DB0:  MOVFF  01,710
08DB4:  MOVFF  00,70F
....................       testTime.wettingTime = currentTime - previousTime; 
08DB8:  MOVLB  7
08DBA:  MOVF   x13,W
08DBC:  SUBWF  x0F,W
08DBE:  MOVLB  2
08DC0:  MOVWF  x22
08DC2:  MOVLB  7
08DC4:  MOVF   x14,W
08DC6:  SUBWFB x10,W
08DC8:  MOVLB  2
08DCA:  MOVWF  x23
08DCC:  MOVLB  7
08DCE:  MOVF   x15,W
08DD0:  SUBWFB x11,W
08DD2:  MOVLB  2
08DD4:  MOVWF  x24
08DD6:  MOVLB  7
08DD8:  MOVF   x16,W
08DDA:  SUBWFB x12,W
08DDC:  MOVLB  2
08DDE:  MOVWF  x25
....................       previousTime = currentTime; 
08DE0:  MOVFF  712,716
08DE4:  MOVFF  711,715
08DE8:  MOVFF  710,714
08DEC:  MOVFF  70F,713
....................        
....................       bleNotifyErrorSet(NO_ERROR); 
08DF0:  MOVLB  8
08DF2:  CLRF   x12
08DF4:  MOVLB  0
08DF6:  CALL   3A78
....................       testResult.stepID = ANALYZE_BREATH_SAMPLE;       
08DFA:  MOVLW  23
08DFC:  MOVLB  2
08DFE:  MOVWF  x19
....................       ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08E00:  MOVLB  8
08E02:  CLRF   x14
08E04:  MOVLW  3B
08E06:  MOVWF  x13
08E08:  CLRF   x15
08E0A:  MOVLW  01
08E0C:  MOVWF  x16
08E0E:  MOVLW  02
08E10:  MOVWF  x18
08E12:  MOVLW  19
08E14:  MOVWF  x17
08E16:  MOVLB  0
08E18:  CALL   2E2E
....................       full_test( testMode ); 
08E1C:  MOVFF  701,731
08E20:  GOTO   8246
....................        
....................       if( testResult.status == CARTRIDGE_REMOVED_DURING_ANALYSIS ) 
08E24:  MOVLB  2
08E26:  MOVF   x18,W
08E28:  SUBLW  50
08E2A:  BNZ   8E3C
....................       { 
....................          cartridgeDetected = NO; 
08E2C:  MOVLB  5
08E2E:  CLRF   x06
....................          rslt = FAIL; 
08E30:  MOVLB  7
08E32:  CLRF   x05
....................          errorTerminated = YES; 
08E34:  MOVLW  01
08E36:  MOVWF  x06
....................          goto FullTestEnd; 
08E38:  BRA    8E46
08E3A:  MOVLB  2
....................       } 
....................    } 
....................     
....................    timeCounter = 0; 
08E3C:  MOVLB  7
08E3E:  CLRF   x1A
08E40:  CLRF   x19
08E42:  CLRF   x18
08E44:  CLRF   x17
....................     
.................... FullTestEnd: 
....................     
....................    fprintf(STDOUT, "Update the BLE info\r\n"); 
08E46:  MOVLW  AC
08E48:  MOVWF  FF6
08E4A:  MOVLW  21
08E4C:  MOVWF  FF7
08E4E:  MOVLB  0
08E50:  CALL   2CA0
....................     
....................    testResult.stepID = SEND_RESULTS; 
08E54:  MOVLW  3C
08E56:  MOVLB  2
08E58:  MOVWF  x19
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08E5A:  MOVLB  8
08E5C:  CLRF   x14
08E5E:  MOVLW  3B
08E60:  MOVWF  x13
08E62:  CLRF   x15
08E64:  MOVLW  01
08E66:  MOVWF  x16
08E68:  MOVLW  02
08E6A:  MOVWF  x18
08E6C:  MOVLW  19
08E6E:  MOVWF  x17
08E70:  MOVLB  0
08E72:  CALL   2E2E
....................     
....................    ble_wait( 150 ); 
08E76:  MOVLB  7
08E78:  CLRF   x58
08E7A:  CLRF   x57
08E7C:  CLRF   x56
08E7E:  MOVLW  96
08E80:  MOVWF  x55
08E82:  MOVLB  0
08E84:  CALL   43F6
....................     
....................    //update the Test result to BLE 
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_REPORT, 0, sizeof(testResult), (uint8*)&testResult); 
08E88:  MOVLW  02
08E8A:  MOVLB  7
08E8C:  MOVWF  x32
08E8E:  MOVLW  0E
08E90:  MOVWF  x31
08E92:  MOVLB  8
08E94:  CLRF   x14
08E96:  MOVLW  21
08E98:  MOVWF  x13
08E9A:  CLRF   x15
08E9C:  MOVLW  0C
08E9E:  MOVWF  x16
08EA0:  MOVFF  732,818
08EA4:  MOVFF  731,817
08EA8:  MOVLB  0
08EAA:  CALL   2E2E
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_REPORT, sizeof(testResult), sizeof(struct timePara), (uint8*)time); 
08EAE:  MOVLB  8
08EB0:  CLRF   x14
08EB2:  MOVLW  21
08EB4:  MOVWF  x13
08EB6:  MOVLW  0C
08EB8:  MOVWF  x15
08EBA:  MOVLW  06
08EBC:  MOVWF  x16
08EBE:  MOVFF  703,818
08EC2:  MOVFF  702,817
08EC6:  MOVLB  0
08EC8:  CALL   2E2E
....................    ble_wait( 150 ); 
08ECC:  MOVLB  7
08ECE:  CLRF   x58
08ED0:  CLRF   x57
08ED2:  CLRF   x56
08ED4:  MOVLW  96
08ED6:  MOVWF  x55
08ED8:  MOVLB  0
08EDA:  CALL   43F6
....................     
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_STAT, 0, sizeof(testStat), (uint8*)&testStat); 
08EDE:  MOVLW  02
08EE0:  MOVLB  7
08EE2:  MOVWF  x32
08EE4:  MOVLW  3A
08EE6:  MOVWF  x31
08EE8:  MOVLB  8
08EEA:  CLRF   x14
08EEC:  MOVLW  1D
08EEE:  MOVWF  x13
08EF0:  CLRF   x15
08EF2:  MOVLW  0E
08EF4:  MOVWF  x16
08EF6:  MOVFF  732,818
08EFA:  MOVFF  731,817
08EFE:  MOVLB  0
08F00:  CALL   2E2E
....................    ble_wait( 150 ); 
08F04:  MOVLB  7
08F06:  CLRF   x58
08F08:  CLRF   x57
08F0A:  CLRF   x56
08F0C:  MOVLW  96
08F0E:  MOVWF  x55
08F10:  MOVLB  0
08F12:  CALL   43F6
....................     
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_STAGE, 0, sizeof(testTime), (uint8*)&testTime); 
08F16:  MOVLW  02
08F18:  MOVLB  7
08F1A:  MOVWF  x32
08F1C:  MOVLW  1A
08F1E:  MOVWF  x31
08F20:  MOVLB  8
08F22:  CLRF   x14
08F24:  MOVLW  19
08F26:  MOVWF  x13
08F28:  CLRF   x15
08F2A:  MOVLW  10
08F2C:  MOVWF  x16
08F2E:  MOVFF  732,818
08F32:  MOVFF  731,817
08F36:  MOVLB  0
08F38:  CALL   2E2E
....................    ble_wait( 150 ); 
08F3C:  MOVLB  7
08F3E:  CLRF   x58
08F40:  CLRF   x57
08F42:  CLRF   x56
08F44:  MOVLW  96
08F46:  MOVWF  x55
08F48:  MOVLB  0
08F4A:  CALL   43F6
....................  
....................    fprintf(STDOUT, "BLE info updated\r\n"); 
08F4E:  MOVLW  C2
08F50:  MOVWF  FF6
08F52:  MOVLW  21
08F54:  MOVWF  FF7
08F56:  CALL   2CA0
....................  
....................    //calculated time test finished 
....................    testResult.totalTestTime = get_ticks(); 
08F5A:  CALL   43C2
08F5E:  MOVFF  03,213
08F62:  MOVFF  02,212
08F66:  MOVFF  01,211
08F6A:  MOVFF  00,210
....................     
....................    if( testResult.status != TIME_OUT ) 
08F6E:  MOVLB  2
08F70:  MOVF   x18,W
08F72:  SUBLW  64
08F74:  BTFSC  FD8.2
08F76:  BRA    9166
....................    { 
....................       testResult.stepID = REMOVE_CARTRIDGE; 
08F78:  MOVLW  28
08F7A:  MOVWF  x19
....................       ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
08F7C:  MOVLB  8
08F7E:  CLRF   x14
08F80:  MOVLW  3B
08F82:  MOVWF  x13
08F84:  CLRF   x15
08F86:  MOVLW  01
08F88:  MOVWF  x16
08F8A:  MOVLW  02
08F8C:  MOVWF  x18
08F8E:  MOVLW  19
08F90:  MOVWF  x17
08F92:  MOVLB  0
08F94:  CALL   2E2E
....................    
.................... //      fprintf(STDOUT, "cartridge present - %d\r\n", cartridgeDetected); 
....................  
....................       while( cartridgeDetected ) 
08F98:  MOVLB  5
08F9A:  MOVF   x06,F
08F9C:  BTFSC  FD8.2
08F9E:  BRA    9164
....................       { 
....................  
.................... #ifdef DEBUG 
....................          //check for cartridge 
....................          fprintf(STDOUT, "\r\n**** Check for cartridge ****\r\n"); 
.................... #endif             
....................          illumination_brightness(LedProperties.LevelBrightness730); 
08FA0:  MOVFF  50D,812
08FA4:  MOVLB  0
08FA6:  CALL   42F2
....................          illumination_use(ILLUMINATION_730); 
08FAA:  MOVLW  7C
08FAC:  MOVLB  8
08FAE:  MOVWF  x13
08FB0:  MOVLW  05
08FB2:  MOVWF  x12
08FB4:  MOVLB  0
08FB6:  CALL   4394
....................          ble_wait(45); 
08FBA:  MOVLB  7
08FBC:  CLRF   x58
08FBE:  CLRF   x57
08FC0:  CLRF   x56
08FC2:  MOVLW  2D
08FC4:  MOVWF  x55
08FC6:  MOVLB  0
08FC8:  CALL   43F6
....................          Raw730 = photodiode(); 
08FCC:  CALL   4FFC
08FD0:  MOVFF  01,71B
08FD4:  MOVFF  02,71C
08FD8:  CLRF   02
08FDA:  CLRF   03
08FDC:  MOVFF  03,71E
08FE0:  MOVFF  02,71D
....................          output_low(ILLUMINATION_730); 
08FE4:  BCF    F92.5
08FE6:  BCF    F89.5
....................          ble_wait(50); 
08FE8:  MOVLB  7
08FEA:  CLRF   x58
08FEC:  CLRF   x57
08FEE:  CLRF   x56
08FF0:  MOVLW  32
08FF2:  MOVWF  x55
08FF4:  MOVLB  0
08FF6:  CALL   43F6
....................  
.................... #ifdef DEBUG 
....................          fprintf(STDOUT, "\r\nRaw 730 reading - %lu \r\n", Raw730); 
.................... #endif   
....................  
.................... //         if( Raw730 < 550 && Raw730 > 75 ) 
....................          if( Raw730 > 75 ) 
08FFA:  MOVLB  7
08FFC:  MOVF   x1E,F
08FFE:  BNZ   900E
09000:  MOVF   x1D,F
09002:  BNZ   900E
09004:  MOVF   x1C,F
09006:  BNZ   900E
09008:  MOVF   x1B,W
0900A:  SUBLW  4B
0900C:  BC    90AC
....................          { 
....................             cartridgeDetected = YES; 
0900E:  MOVLW  01
09010:  MOVLB  5
09012:  MOVWF  x06
....................              
....................             if( timeCounter == THIRTY_SECONDS ) 
09014:  MOVLB  7
09016:  MOVF   x17,W
09018:  SUBLW  30
0901A:  BNZ   9038
0901C:  MOVF   x18,W
0901E:  SUBLW  75
09020:  BNZ   9038
09022:  MOVF   x19,F
09024:  BNZ   9038
09026:  MOVF   x1A,F
09028:  BNZ   9038
....................                bleNotifyErrorSet(CARTRIDGE_NOT_REMOVED); 
0902A:  MOVLW  28
0902C:  MOVLB  8
0902E:  MOVWF  x12
09030:  MOVLB  0
09032:  CALL   3A78
09036:  MOVLB  7
....................              
....................             fprintf(STDOUT, "****Please removes cartridge****\r\n"); 
09038:  MOVLW  D6
0903A:  MOVWF  FF6
0903C:  MOVLW  21
0903E:  MOVWF  FF7
09040:  MOVLB  0
09042:  CALL   2CA0
....................             illumination_brightness( ONE_HUNDRED ); 
09046:  MOVLW  64
09048:  MOVLB  8
0904A:  MOVWF  x12
0904C:  MOVLB  0
0904E:  CALL   42F2
....................             illumination_use(ILLUMINATION_475); 
09052:  MOVLW  7C
09054:  MOVLB  8
09056:  MOVWF  x13
09058:  MOVLW  04
0905A:  MOVWF  x12
0905C:  MOVLB  0
0905E:  CALL   4394
....................             ble_wait(ONE_HUNDRED); 
09062:  MOVLB  7
09064:  CLRF   x58
09066:  CLRF   x57
09068:  CLRF   x56
0906A:  MOVLW  64
0906C:  MOVWF  x55
0906E:  MOVLB  0
09070:  CALL   43F6
....................          
....................             delay_ms( FIVE_SECONDS ); 
09074:  MOVLW  14
09076:  MOVLB  7
09078:  MOVWF  x31
0907A:  MOVLW  FA
0907C:  MOVLB  8
0907E:  MOVWF  x18
09080:  MOVLB  0
09082:  CALL   2D2E
09086:  MOVLB  7
09088:  DECFSZ x31,F
0908A:  BRA    907A
....................             timeCounter += FIVE_SECONDS; 
0908C:  MOVLW  88
0908E:  ADDWF  x17,F
09090:  MOVLW  13
09092:  ADDWFC x18,F
09094:  MOVLW  00
09096:  ADDWFC x19,F
09098:  ADDWFC x1A,F
....................             play_error(); 
0909A:  MOVLB  0
0909C:  CALL   4538
....................             illumination_all_off(); 
090A0:  CALL   4344
....................             ShowPrompt(); 
090A4:  CALL   4E82
....................          } 
090A8:  BRA    9112
090AA:  MOVLB  7
....................           
....................          else 
....................          { 
....................             currentTime = get_ticks(); 
090AC:  MOVLB  0
090AE:  CALL   43C2
090B2:  MOVFF  03,712
090B6:  MOVFF  02,711
090BA:  MOVFF  01,710
090BE:  MOVFF  00,70F
....................             testTime.removeCartridgeTime = currentTime - previousTime; 
090C2:  MOVLB  7
090C4:  MOVF   x13,W
090C6:  SUBWF  x0F,W
090C8:  MOVLB  2
090CA:  MOVWF  x26
090CC:  MOVLB  7
090CE:  MOVF   x14,W
090D0:  SUBWFB x10,W
090D2:  MOVLB  2
090D4:  MOVWF  x27
090D6:  MOVLB  7
090D8:  MOVF   x15,W
090DA:  SUBWFB x11,W
090DC:  MOVLB  2
090DE:  MOVWF  x28
090E0:  MOVLB  7
090E2:  MOVF   x16,W
090E4:  SUBWFB x12,W
090E6:  MOVLB  2
090E8:  MOVWF  x29
....................             previousTime = currentTime; 
090EA:  MOVFF  712,716
090EE:  MOVFF  711,715
090F2:  MOVFF  710,714
090F6:  MOVFF  70F,713
....................             bleNotifyErrorSet(NO_ERROR); 
090FA:  MOVLB  8
090FC:  CLRF   x12
090FE:  MOVLB  0
09100:  CALL   3A78
....................             rslt = PASS; 
09104:  MOVLW  01
09106:  MOVLB  7
09108:  MOVWF  x05
....................             cartridgeDetected = NO; 
0910A:  MOVLB  5
0910C:  CLRF   x06
....................             brightnessChecked = NO; 
0910E:  CLRF   x08
09110:  MOVLB  0
....................          } 
....................        
....................          if( timeCounter > FOUR_MINUTES )            //5 minutes is up 
09112:  MOVLB  7
09114:  MOVF   x1A,F
09116:  BNZ   9132
09118:  MOVF   x19,W
0911A:  SUBLW  02
0911C:  BC    915E
0911E:  XORLW  FF
09120:  BNZ   9132
09122:  MOVF   x18,W
09124:  SUBLW  A8
09126:  BC    915E
09128:  XORLW  FF
0912A:  BNZ   9132
0912C:  MOVF   x17,W
0912E:  SUBLW  80
09130:  BC    915E
....................          {   
....................             bleNotifyErrorSet(TIME_OUT); 
09132:  MOVLW  64
09134:  MOVLB  8
09136:  MOVWF  x12
09138:  MOVLB  0
0913A:  CALL   3A78
....................             errorTerminated = YES; 
0913E:  MOVLW  01
09140:  MOVLB  7
09142:  MOVWF  x06
....................             delay_ms( ONE_MINUTE ); 
09144:  MOVLW  F0
09146:  MOVWF  x31
09148:  MOVLW  FA
0914A:  MOVLB  8
0914C:  MOVWF  x18
0914E:  MOVLB  0
09150:  CALL   2D2E
09154:  MOVLB  7
09156:  DECFSZ x31,F
09158:  BRA    9148
....................             break; 
0915A:  MOVLB  5
0915C:  BRA    9164
....................          } 
0915E:  MOVLB  0
09160:  BRA    8F98
09162:  MOVLB  5
09164:  MOVLB  2
....................       } 
....................    } 
....................     
....................    currentTime = get_ticks(); 
09166:  MOVLB  0
09168:  CALL   43C2
0916C:  MOVFF  03,712
09170:  MOVFF  02,711
09174:  MOVFF  01,710
09178:  MOVFF  00,70F
....................    if( errorTerminated == YES || testResult.status == TIME_OUT ) 
0917C:  MOVLB  7
0917E:  DECFSZ x06,W
09180:  BRA    9184
09182:  BRA    918E
09184:  MOVLB  2
09186:  MOVF   x18,W
09188:  SUBLW  64
0918A:  BNZ   9196
0918C:  MOVLB  7
....................       testResult.stepID = ERROR_TERMINATION; 
0918E:  MOVLW  46
09190:  MOVLB  2
09192:  MOVWF  x19
09194:  BRA    91B4
....................        
....................    else 
....................    { 
....................       testResult.stepID = TEST_COMPLETED; 
09196:  MOVLW  32
09198:  MOVWF  x19
....................       bleNotifyErrorResetErrorBits(); 
0919A:  MOVLB  0
0919C:  CALL   4768
....................       ble_wait( 150 ); 
091A0:  MOVLB  7
091A2:  CLRF   x58
091A4:  CLRF   x57
091A6:  CLRF   x56
091A8:  MOVLW  96
091AA:  MOVWF  x55
091AC:  MOVLB  0
091AE:  CALL   43F6
091B2:  MOVLB  2
....................     
.................... #ifdef CONNIE_STUDY 
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Number of blow attempt - %ld", testStat.numOfBlowAttempts); 
....................  
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Cartridge insertion time - %ld", testTime.cartridgeInsertionTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Breath exhale time - %ld", testTime.blowTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Wetting time - %ld", testTime.wettingTime); 
....................    fprintf(STDOUT, new_line_resp); 
.................... #endif 
....................        
....................    } 
....................     
.................... //   fprintf(STDOUT, "StepID - %d", testResult.stepID); 
....................     
....................    FullTestRunning = 0; 
091B4:  MOVLB  4
091B6:  CLRF   x54
....................    reading_save( &testResult, time );    
091B8:  MOVLW  02
091BA:  MOVLB  7
091BC:  MOVWF  x32
091BE:  MOVLW  0E
091C0:  MOVWF  x31
091C2:  MOVFF  703,734
091C6:  MOVFF  702,733
091CA:  MOVLB  0
091CC:  CALL   836E
....................     
.................... //   ble_cmd_attributes_write(BLE_HANDLE_TEST_STAGE, 0, sizeof(testTime), (uint8*)&testTime); 
.................... //   ble_wait( 150 ); 
....................     
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
091D0:  MOVLB  8
091D2:  CLRF   x14
091D4:  MOVLW  3B
091D6:  MOVWF  x13
091D8:  CLRF   x15
091DA:  MOVLW  01
091DC:  MOVWF  x16
091DE:  MOVLW  02
091E0:  MOVWF  x18
091E2:  MOVLW  19
091E4:  MOVWF  x17
091E6:  MOVLB  0
091E8:  CALL   2E2E
....................    ble_wait(ONE_SECOND); 
091EC:  MOVLB  7
091EE:  CLRF   x58
091F0:  CLRF   x57
091F2:  MOVLW  03
091F4:  MOVWF  x56
091F6:  MOVLW  E8
091F8:  MOVWF  x55
091FA:  MOVLB  0
091FC:  CALL   43F6
....................    fprintf(STDOUT, new_line_resp); 
09200:  MOVLW  01
09202:  MOVWF  FEA
09204:  MOVLW  A7
09206:  MOVWF  FE9
09208:  CALL   2D08
....................     
....................    if( testResult.status == TIME_OUT ) 
0920C:  MOVLB  2
0920E:  MOVF   x18,W
09210:  SUBLW  64
09212:  BNZ   921E
....................       shutDown (); 
09214:  MOVLB  0
09216:  CALL   462E
0921A:  BRA    92B6
0921C:  MOVLB  2
....................        
....................    else 
....................    { 
....................       struct reading r; 
....................        
....................       for( ctr = 0; ctr < 10; ctr++ ) 
0921E:  MOVLB  7
09220:  CLRF   x04
09222:  BTFSC  x04.7
09224:  BRA    922C
09226:  MOVF   x04,W
09228:  SUBLW  09
0922A:  BNC   9296
....................       { 
....................          r = reading_fetch( ctr ); 
0922C:  CLRF   x38
0922E:  MOVFF  704,737
09232:  MOVLB  0
09234:  CALL   4F64
09238:  MOVFF  02,03
0923C:  MOVFF  01,FE1
09240:  MOVFF  02,FE2
09244:  MOVLW  07
09246:  MOVWF  FEA
09248:  MOVLW  1F
0924A:  MOVWF  FE9
0924C:  MOVLW  12
0924E:  MOVWF  01
09250:  MOVFF  FE6,FEE
09254:  DECFSZ 01,F
09256:  BRA    9250
....................              
....................          ble_cmd_attributes_write( BLE_HANDLE_READING, 0, sizeof(struct reading), (uint8 *)&r );   
09258:  MOVLW  07
0925A:  MOVLB  7
0925C:  MOVWF  x32
0925E:  MOVLW  1F
09260:  MOVWF  x31
09262:  MOVLB  8
09264:  CLRF   x14
09266:  MOVLW  30
09268:  MOVWF  x13
0926A:  CLRF   x15
0926C:  MOVLW  12
0926E:  MOVWF  x16
09270:  MOVFF  732,818
09274:  MOVFF  731,817
09278:  MOVLB  0
0927A:  CALL   2E2E
....................          ble_wait( 150 ); 
0927E:  MOVLB  7
09280:  CLRF   x58
09282:  CLRF   x57
09284:  CLRF   x56
09286:  MOVLW  96
09288:  MOVWF  x55
0928A:  MOVLB  0
0928C:  CALL   43F6
09290:  MOVLB  7
09292:  INCF   x04,F
09294:  BRA    9222
....................       } 
....................  
....................       //put the timer back the way it was 
....................       set_ticks ( saveTimer ); 
09296:  MOVFF  70A,734
0929A:  MOVFF  709,733
0929E:  MOVFF  708,732
092A2:  MOVFF  707,731
092A6:  MOVLB  0
092A8:  CALL   45A2
....................       powerDownTimeCtr = INACTIVITY_TIME_LIMIT; 
092AC:  MOVLB  5
092AE:  CLRF   x0C
092B0:  MOVLW  1E
092B2:  MOVWF  x0B
092B4:  MOVLB  0
....................    } 
....................        
....................    return rslt; 
092B6:  MOVLB  7
092B8:  MOVFF  705,01
092BC:  MOVLB  0
092BE:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 setBreathVolume( uint16 volume ) 
*
03BA8:  MOVLB  7
03BAA:  CLRF   x1C
.................... { 
....................    uint8_t  rslt = FAIL; 
....................     
....................    if( volume < MININUM_BREATH_VOLUME || volume > MAXINUM_BREATH_VOLUME ) 
03BAC:  MOVF   x1B,W
03BAE:  SUBLW  01
03BB0:  BNC   3BBA
03BB2:  BNZ   3BCA
03BB4:  MOVF   x1A,W
03BB6:  SUBLW  2B
03BB8:  BC    3BCA
03BBA:  MOVF   x1B,W
03BBC:  SUBLW  06
03BBE:  BC    3BE0
03BC0:  XORLW  FF
03BC2:  BNZ   3BCA
03BC4:  MOVF   x1A,W
03BC6:  SUBLW  D0
03BC8:  BC    3BE0
....................    { 
....................       fprintf(STDOUT, "\r\nBreath volume must be between 300-1000 ml\r\n"); 
03BCA:  MOVLW  FA
03BCC:  MOVWF  FF6
03BCE:  MOVLW  21
03BD0:  MOVWF  FF7
03BD2:  MOVLB  0
03BD4:  CALL   2CA0
....................       return rslt; 
03BD8:  MOVLB  7
03BDA:  MOVFF  71C,01
03BDE:  BRA    3C5C
03BE0:  CLRF   19
03BE2:  BTFSC  FF2.7
03BE4:  BSF    19.7
03BE6:  BCF    FF2.7
....................    } 
....................  
....................    ConfigWriteFloat(CONFIG_BREATH_VOLUME, volume); 
03BE8:  MOVFF  71B,967
03BEC:  MOVFF  71A,966
03BF0:  MOVLB  0
03BF2:  CALL   099A
03BF6:  BTFSC  19.7
03BF8:  BSF    FF2.7
03BFA:  MOVFF  03,720
03BFE:  MOVFF  02,71F
03C02:  MOVFF  01,71E
03C06:  MOVFF  00,71D
03C0A:  CLRF   19
03C0C:  BTFSC  FF2.7
03C0E:  BSF    19.7
03C10:  BCF    FF2.7
03C12:  MOVLB  9
03C14:  CLRF   x6B
03C16:  MOVLW  1A
03C18:  MOVWF  x6A
03C1A:  MOVFF  03,96F
03C1E:  MOVFF  02,96E
03C22:  MOVFF  01,96D
03C26:  MOVFF  00,96C
03C2A:  MOVLB  0
03C2C:  CALL   0A60
03C30:  BTFSC  19.7
03C32:  BSF    FF2.7
....................     
....................    //update breath volume setting 
....................    breathVolume = ConfigReadFloat(CONFIG_BREATH_VOLUME); 
03C34:  MOVLB  7
03C36:  CLRF   x54
03C38:  MOVLW  1A
03C3A:  MOVWF  x53
03C3C:  MOVLB  0
03C3E:  RCALL  3B00
03C40:  MOVFF  03,815
03C44:  MOVFF  02,814
03C48:  MOVFF  01,813
03C4C:  MOVFF  00,812
03C50:  RCALL  3B6C
03C52:  MOVFF  02,204
03C56:  MOVFF  01,203
03C5A:  MOVLB  7
03C5C:  MOVLB  0
03C5E:  RETURN 0
.................... //   fprintf(STDOUT, "**Breath Volume Setting : %lu ml \r\n\r\n", breathVolume); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef SOFTWARE_DEBUG 
.................... void testStage() 
.................... { 
....................    testTime.blowTime = 8200; 
....................    testTime.cartridgeInsertionTime = 12000; 
....................    testTime.removeCartridgeTime = 24150; 
....................    testTime.wettingTime = 18550;  
....................     
....................    //update the Teststage BLE 
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_STAGE, 0, sizeof(testTime), (uint8*)&testTime); 
....................    while(!ble_log_process()); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Cartridge insertion Time - %lx", testTime.cartridgeInsertionTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Blow Time - %lx", testTime.blowTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Wetting Time - %lx", testTime.wettingTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Removed Cartridge Time - %lx", testTime.removeCartridgeTime); 
....................    fprintf(STDOUT, new_line_resp); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void testStats() 
.................... { 
....................  
....................    testStat.temperature = f_PICtoIEEE(90.25); 
....................    testStat.pressure = 115000; 
....................    testStat.volume = 612; 
....................    testStat.humidity = 80; 
....................    testStat.numOfBlowAttempts = 12; 
....................     
....................     
....................    //update the Teststat BLE 
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_STAT, 0, sizeof(testStat), (uint8*)&testStat); 
....................    while(!ble_log_process()); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Temperature - %lx", testStat.temperature); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Pressure - %lx", testStat.pressure); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Volume - %lx", testStat.volume); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Humidity - %lx", testStat.humidity); 
....................  
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Number of attempts - %lx", testStat.numOfBlowAttempts); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void testReport() 
.................... { 
....................    uint8   ctr, *tmpPtr; 
.................... #define TEST_VECTOR    
.................... #ifdef TEST_VECTOR 
....................     
....................    testResult.testMode = 0XFF; 
....................    testResult.totalTestTime = 123456; 
....................    testResult.score = f_PICtoIEEE(11); 
....................    testResult.status = NO_ERROR; 
....................    testResult.stepID = REMOVE_CARTRIDGE; 
....................     
....................    cmdReceived.time.hour = 0XAA; 
....................    cmdReceived.time.minute = 0XBB; 
....................    cmdReceived.time.second = 0XCC; 
....................    cmdReceived.time.day = 0XDD; 
....................    cmdReceived.time.month = 0XEE; 
....................    cmdReceived.time.year = 19; 
....................     
.................... #else 
....................  
....................    tmpPtr = (uint8* )&testResult; 
....................    for( ctr = 0; ctr < sizeof(testResult); ctr++ ) 
....................       *tmpPtr++ = 0; 
....................        
....................    tmpPtr = (uint8* )&cmdReceived.time; 
....................    for( ctr = 0; ctr < sizeof(struct timePara); ctr++ ) 
....................       *tmpPtr++ = 0; 
....................  
.................... #endif 
....................     
....................    //update the Teststat BLE 
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_REPORT, 0, sizeof(testResult), (uint8*)&testResult); 
....................    ble_cmd_attributes_write(BLE_HANDLE_TEST_REPORT, sizeof(testResult), sizeof(struct timePara), (uint8*)&cmdReceived.time); 
....................    while(!ble_log_process()); 
....................  
....................    ble_cmd_attributes_write(BLE_HANDLE_READING, 0, sizeof(testResult), (uint8*)&testResult); 
....................    ble_cmd_attributes_write(BLE_HANDLE_READING, sizeof(testResult), sizeof(struct timePara), (uint8*)&cmdReceived.time); 
....................    while(!ble_log_process()); 
....................    
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "testMode - %x", testResult.testMode); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "totalTestTime - %lu", testResult.totalTestTime); 
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "totalTestTime - 0x%lx", testResult.totalTestTime); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Score - 0x%lx", testResult.score); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Status - %x", testResult.status); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "stepID - %x", testResult.stepID); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Hour - %x", cmdReceived.time.hour); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Minute - %x", cmdReceived.time.minute); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Second - %x", cmdReceived.time.second); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Date - %x", cmdReceived.time.day); 
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Month - %x", cmdReceived.time.month); 
....................    fprintf(STDOUT, new_line_resp); 
....................    fprintf(STDOUT, "Year - %x", cmdReceived.time.year); 
....................     
....................    fprintf(STDOUT, new_line_resp); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void selfTest() 
*
047AE:  MOVLB  7
047B0:  CLRF   x02
047B2:  CLRF   x10
047B4:  CLRF   x0F
047B6:  CLRF   x0E
047B8:  CLRF   x0D
047BA:  CLRF   x19
.................... { 
....................    uint8_t  tmpCtr, rslt = FAIL; 
....................    uint16   tmpBreathVolume; 
....................    uint32   tmpTime, previousTimer, tmp = 0; 
....................    float    temp_float, temp_float_1;    
....................     
....................    int opCode = HARDWARE_CHECK; 
....................    myStatus = MYSTATUS_OK; 
047BC:  MOVLB  4
047BE:  CLRF   xC2
047C0:  CLRF   xC1
....................     
....................    ConstructBatteryModule(); 
047C2:  MOVLB  0
047C4:  GOTO   2BCA
....................     
....................    deviceStat.fwMajor = FIRMWARE_VERSION_MAJOR; 
047C8:  MOVLB  2
047CA:  CLRF   x2B
047CC:  CLRF   x2A
....................    deviceStat.fwMinor = FIRMWARE_VERSION_MINOR; 
047CE:  CLRF   x2D
047D0:  MOVLW  41
047D2:  MOVWF  x2C
....................    deviceStat.fwRevision = FIRMWARE_VERSION_REVISION; 
047D4:  CLRF   x2F
047D6:  MOVLW  02
047D8:  MOVWF  x2E
....................    deviceStat.useCount = read_ext_eeprom(CONFIG_MOUTHPIECE_USES); 
047DA:  MOVLB  7
047DC:  CLRF   x5F
047DE:  MOVLW  1C
047E0:  MOVWF  x5E
047E2:  MOVLB  0
047E4:  CALL   2C1A
047E8:  CLRF   03
047EA:  MOVFF  01,232
047EE:  MOVLB  2
047F0:  MOVFF  03,233
....................  
....................  
....................    fprintf(STDOUT, "\r\nBLE ID : 0x"); 
047F4:  MOVLW  28
047F6:  MOVWF  FF6
047F8:  MOVLW  22
047FA:  MOVWF  FF7
047FC:  MOVLB  0
047FE:  CALL   2CA0
....................     
....................    //Updtate the BLE ID 
....................    for( tmpCtr = 0; tmpCtr < BLE_MODULE_ID_SIZE; tmpCtr++ ) 
04802:  MOVLB  7
04804:  CLRF   x01
04806:  MOVF   x01,W
04808:  SUBLW  05
0480A:  BNC   485C
....................    { 
....................       deviceStat.bleModuleId[tmpCtr] = BleModuleId[tmpCtr]; 
0480C:  CLRF   03
0480E:  MOVF   x01,W
04810:  ADDLW  34
04812:  MOVWF  01
04814:  MOVLW  02
04816:  ADDWFC 03,F
04818:  MOVFF  03,71B
0481C:  CLRF   03
0481E:  MOVF   x01,W
04820:  ADDLW  4A
04822:  MOVWF  FE9
04824:  MOVLW  03
04826:  ADDWFC 03,W
04828:  MOVWF  FEA
0482A:  MOVFF  FEF,71C
0482E:  MOVFF  71B,FEA
04832:  MOVFF  01,FE9
04836:  MOVFF  71C,FEF
....................       fprintf(STDOUT, "%2X", deviceStat.bleModuleId[tmpCtr]);       
0483A:  CLRF   03
0483C:  MOVF   x01,W
0483E:  ADDLW  34
04840:  MOVWF  FE9
04842:  MOVLW  02
04844:  ADDWFC 03,W
04846:  MOVWF  FEA
04848:  MOVFF  FEF,74B
0484C:  MOVLW  37
0484E:  MOVWF  x4C
04850:  MOVLB  0
04852:  CALL   2CC2
04856:  MOVLB  7
04858:  INCF   x01,F
0485A:  BRA    4806
....................    } 
....................  
....................     
....................    fprintf(STDOUT, new_line_resp); 
0485C:  MOVLW  01
0485E:  MOVWF  FEA
04860:  MOVLW  A7
04862:  MOVWF  FE9
04864:  MOVLB  0
04866:  CALL   2D08
....................    ble_configure(); 
0486A:  CALL   2F72
....................  
....................    //We are here, bluetooth works 
....................    fprintf(STDOUT, "BLE "); 
0486E:  MOVLW  36
04870:  MOVWF  FF6
04872:  MOVLW  22
04874:  MOVWF  FF7
04876:  CALL   2CA0
....................    fprintf(STDOUT, dash_resp); 
0487A:  MOVLW  01
0487C:  MOVWF  FEA
0487E:  MOVLW  41
04880:  MOVWF  FE9
04882:  CALL   2D08
....................    fprintf(STDOUT, pass_resp); 
04886:  MOVLW  01
04888:  MOVWF  FEA
0488A:  MOVLW  B4
0488C:  MOVWF  FE9
0488E:  CALL   2D08
....................    fprintf(STDOUT, new_line_resp); 
04892:  MOVLW  01
04894:  MOVWF  FEA
04896:  MOVLW  A7
04898:  MOVWF  FE9
0489A:  CALL   2D08
....................    
....................    
....................    //update bluetooth step code info 
....................    ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &opCode); 
0489E:  MOVLW  07
048A0:  MOVLB  7
048A2:  MOVWF  x1B
048A4:  MOVLW  19
048A6:  MOVWF  x1A
048A8:  MOVLB  8
048AA:  CLRF   x14
048AC:  MOVLW  3B
048AE:  MOVWF  x13
048B0:  CLRF   x15
048B2:  MOVLW  01
048B4:  MOVWF  x16
048B6:  MOVFF  71B,818
048BA:  MOVFF  71A,817
048BE:  MOVLB  0
048C0:  CALL   2E2E
....................  
.................... #ifdef LIS3DH_PRESENT      
....................    if (!LIS3DH_Present()) 
....................    { 
....................       fprintf(STDOUT, "LIS3DH "); 
....................       fprintf(STDOUT, dash_resp); 
....................       fprintf(STDOUT, fail_resp); 
....................       fprintf(STDOUT, new_line_resp); 
....................        
....................       bleNotifyErrorSet(HARDWARE_FAIL);    
....................       myStatus |= LIS3DH_MALFUNCTION; 
....................    } 
....................     
....................    else  
....................    { 
....................       LIS3DH_Configure(); 
....................       fprintf(STDOUT, "LIS3DH "); 
....................       fprintf(STDOUT, dash_resp); 
....................       fprintf(STDOUT, pass_resp); 
....................       fprintf(STDOUT, new_line_resp); 
....................    } 
.................... #endif 
....................  
....................    //Init Temp, Pressure, Humidity sensor 
....................    initBME();       
048C4:  GOTO   313E
....................    rslt = checkBMEPowerUp(&gas_sensor); 
048C8:  MOVLW  04
048CA:  MOVLB  7
048CC:  MOVWF  x1B
048CE:  MOVLW  C3
048D0:  MOVWF  x1A
048D2:  MOVLB  0
048D4:  GOTO   3906
048D8:  MOVFF  01,702
....................  
....................    if( rslt != BME680_OK ) 
048DC:  MOVLB  7
048DE:  MOVF   x02,F
048E0:  BZ    4924
....................    { 
....................       myStatus |= BME680_MALFUNCTION; 
....................       fprintf(STDOUT, "BME"); 
048E2:  MOVLW  3C
048E4:  MOVWF  FF6
048E6:  MOVLW  22
048E8:  MOVWF  FF7
048EA:  MOVLB  0
048EC:  CALL   2CA0
....................       fprintf(STDOUT, dash_resp); 
048F0:  MOVLW  01
048F2:  MOVWF  FEA
048F4:  MOVLW  41
048F6:  MOVWF  FE9
048F8:  CALL   2D08
....................       fprintf(STDOUT, fail_resp); 
048FC:  MOVLW  01
048FE:  MOVWF  FEA
04900:  MOVLW  4E
04902:  MOVWF  FE9
04904:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
04908:  MOVLW  01
0490A:  MOVWF  FEA
0490C:  MOVLW  A7
0490E:  MOVWF  FE9
04910:  CALL   2D08
....................       bleNotifyErrorSet(HARDWARE_FAIL); 
04914:  MOVLW  01
04916:  MOVLB  8
04918:  MOVWF  x12
0491A:  MOVLB  0
0491C:  CALL   3A78
....................    } 
04920:  BRA    4956
04922:  MOVLB  7
....................     
....................    else 
....................    { 
....................       fprintf(STDOUT, "BME"); 
04924:  MOVLW  40
04926:  MOVWF  FF6
04928:  MOVLW  22
0492A:  MOVWF  FF7
0492C:  MOVLB  0
0492E:  CALL   2CA0
....................       fprintf(STDOUT, dash_resp); 
04932:  MOVLW  01
04934:  MOVWF  FEA
04936:  MOVLW  41
04938:  MOVWF  FE9
0493A:  CALL   2D08
....................       fprintf(STDOUT, pass_resp); 
0493E:  MOVLW  01
04940:  MOVWF  FEA
04942:  MOVLW  B4
04944:  MOVWF  FE9
04946:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
0494A:  MOVLW  01
0494C:  MOVWF  FEA
0494E:  MOVLW  A7
04950:  MOVWF  FE9
04952:  CALL   2D08
....................    } 
....................  
....................    //Set breath volume 
....................    tmpBreathVolume = ConfigReadFloat(CONFIG_BREATH_VOLUME); 
04956:  MOVLB  7
04958:  CLRF   x54
0495A:  MOVLW  1A
0495C:  MOVWF  x53
0495E:  MOVLB  0
04960:  CALL   3B00
04964:  MOVFF  03,815
04968:  MOVFF  02,814
0496C:  MOVFF  01,813
04970:  MOVFF  00,812
04974:  CALL   3B6C
04978:  MOVFF  02,704
0497C:  MOVFF  01,703
....................    if( tmpBreathVolume < MININUM_BREATH_VOLUME || tmpBreathVolume > MAXINUM_BREATH_VOLUME ) 
04980:  MOVLB  7
04982:  MOVF   x04,W
04984:  SUBLW  01
04986:  BNC   4990
04988:  BNZ   49A0
0498A:  MOVF   x03,W
0498C:  SUBLW  2B
0498E:  BC    49A0
04990:  MOVF   x04,W
04992:  SUBLW  06
04994:  BC    49B2
04996:  XORLW  FF
04998:  BNZ   49A0
0499A:  MOVF   x03,W
0499C:  SUBLW  D0
0499E:  BC    49B2
....................       setBreathVolume( STANDARD_BREATH_VOLUME ); 
049A0:  MOVLW  02
049A2:  MOVWF  x1B
049A4:  MOVLW  58
049A6:  MOVWF  x1A
049A8:  MOVLB  0
049AA:  CALL   3BA8
049AE:  BRA    49BC
049B0:  MOVLB  7
....................        
....................    else  
....................       breathVolume = tmpBreathVolume; 
049B2:  MOVFF  704,204
049B6:  MOVFF  703,203
049BA:  MOVLB  0
....................     
....................    BatteryManagement(); 
049BC:  CALL   3D4C
....................    deviceStat.batteryLevel = BatteryCapacity(); 
049C0:  CALL   3E0C
049C4:  MOVLB  2
049C6:  CLRF   x31
049C8:  MOVFF  01,230
....................    fprintf(STDOUT, "Battery Level = %lu%%", deviceStat.batteryLevel); 
049CC:  MOVLW  44
049CE:  MOVWF  FF6
049D0:  MOVLW  22
049D2:  MOVWF  FF7
049D4:  CLRF   19
049D6:  BTFSC  FF2.7
049D8:  BSF    19.7
049DA:  BCF    FF2.7
049DC:  MOVLW  10
049DE:  MOVLB  9
049E0:  MOVWF  x66
049E2:  MOVLB  0
049E4:  CALL   0AAC
049E8:  BTFSC  19.7
049EA:  BSF    FF2.7
049EC:  MOVLW  10
049EE:  MOVWF  FE9
049F0:  CLRF   19
049F2:  BTFSC  FF2.7
049F4:  BSF    19.7
049F6:  BCF    FF2.7
049F8:  MOVFF  231,967
049FC:  MOVFF  230,966
04A00:  CALL   0AD6
04A04:  BTFSC  19.7
04A06:  BSF    FF2.7
04A08:  MOVLW  25
04A0A:  BTFSS  FA4.4
04A0C:  BRA    4A0A
04A0E:  MOVWF  F73
....................    fprintf(STDOUT, new_line_resp); 
04A10:  MOVLW  01
04A12:  MOVWF  FEA
04A14:  MOVLW  A7
04A16:  MOVWF  FE9
04A18:  CALL   2D08
....................     
....................    //Set slope to .020 
....................    temp_float = SLOPE; 
04A1C:  MOVLW  0A
04A1E:  MOVLB  7
04A20:  MOVWF  x14
04A22:  MOVLW  D7
04A24:  MOVWF  x13
04A26:  MOVLW  23
04A28:  MOVWF  x12
04A2A:  MOVLW  79
04A2C:  MOVWF  x11
04A2E:  CLRF   19
04A30:  BTFSC  FF2.7
04A32:  BSF    19.7
04A34:  BCF    FF2.7
....................    ConfigWriteFloat(CONFIG_SLOPE, temp_float); 
04A36:  MOVLB  9
04A38:  CLRF   x6B
04A3A:  MOVLW  0A
04A3C:  MOVWF  x6A
04A3E:  MOVFF  714,96F
04A42:  MOVFF  713,96E
04A46:  MOVFF  712,96D
04A4A:  MOVFF  711,96C
04A4E:  MOVLB  0
04A50:  CALL   0A60
04A54:  BTFSC  19.7
04A56:  BSF    FF2.7
....................     
....................    //Set intercept to .090 
....................    temp_float = INTERCEPT; 
04A58:  MOVLW  EC
04A5A:  MOVLB  7
04A5C:  MOVWF  x14
04A5E:  MOVLW  51
04A60:  MOVWF  x13
04A62:  MOVLW  38
04A64:  MOVWF  x12
04A66:  MOVLW  7B
04A68:  MOVWF  x11
04A6A:  CLRF   19
04A6C:  BTFSC  FF2.7
04A6E:  BSF    19.7
04A70:  BCF    FF2.7
....................    ConfigWriteFloat(CONFIG_INTERCEPT, temp_float); 
04A72:  MOVLB  9
04A74:  CLRF   x6B
04A76:  MOVLW  0E
04A78:  MOVWF  x6A
04A7A:  MOVFF  714,96F
04A7E:  MOVFF  713,96E
04A82:  MOVFF  712,96D
04A86:  MOVFF  711,96C
04A8A:  MOVLB  0
04A8C:  CALL   0A60
04A90:  BTFSC  19.7
04A92:  BSF    FF2.7
....................     
....................    //Read back and verify EEPROM 
....................    temp_float   = ConfigReadFloat(CONFIG_SLOPE); 
04A94:  MOVLB  7
04A96:  CLRF   x54
04A98:  MOVLW  0A
04A9A:  MOVWF  x53
04A9C:  MOVLB  0
04A9E:  CALL   3B00
04AA2:  MOVFF  03,714
04AA6:  MOVFF  02,713
04AAA:  MOVFF  01,712
04AAE:  MOVFF  00,711
....................    temp_float_1 = ConfigReadFloat(CONFIG_INTERCEPT); 
04AB2:  MOVLB  7
04AB4:  CLRF   x54
04AB6:  MOVLW  0E
04AB8:  MOVWF  x53
04ABA:  MOVLB  0
04ABC:  CALL   3B00
04AC0:  MOVFF  03,718
04AC4:  MOVFF  02,717
04AC8:  MOVFF  01,716
04ACC:  MOVFF  00,715
....................  
....................    if( temp_float != SLOPE || temp_float_1 != INTERCEPT ) 
04AD0:  MOVFF  714,815
04AD4:  MOVFF  713,814
04AD8:  MOVFF  712,813
04ADC:  MOVFF  711,812
04AE0:  MOVLW  0A
04AE2:  MOVLB  8
04AE4:  MOVWF  x19
04AE6:  MOVLW  D7
04AE8:  MOVWF  x18
04AEA:  MOVLW  23
04AEC:  MOVWF  x17
04AEE:  MOVLW  79
04AF0:  MOVWF  x16
04AF2:  MOVLB  0
04AF4:  CALL   3EB6
04AF8:  BNZ   4B24
04AFA:  MOVFF  718,815
04AFE:  MOVFF  717,814
04B02:  MOVFF  716,813
04B06:  MOVFF  715,812
04B0A:  MOVLW  EC
04B0C:  MOVLB  8
04B0E:  MOVWF  x19
04B10:  MOVLW  51
04B12:  MOVWF  x18
04B14:  MOVLW  38
04B16:  MOVWF  x17
04B18:  MOVLW  7B
04B1A:  MOVWF  x16
04B1C:  MOVLB  0
04B1E:  CALL   3EB6
04B22:  BZ    4B5C
....................    { 
....................       fprintf(STDOUT, "EEPROM "); 
04B24:  MOVLW  5A
04B26:  MOVWF  FF6
04B28:  MOVLW  22
04B2A:  MOVWF  FF7
04B2C:  CALL   2CA0
....................       fprintf(STDOUT, dash_resp); 
04B30:  MOVLW  01
04B32:  MOVWF  FEA
04B34:  MOVLW  41
04B36:  MOVWF  FE9
04B38:  CALL   2D08
....................       fprintf(STDOUT, fail_resp); 
04B3C:  MOVLW  01
04B3E:  MOVWF  FEA
04B40:  MOVLW  4E
04B42:  MOVWF  FE9
04B44:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
04B48:  MOVLW  01
04B4A:  MOVWF  FEA
04B4C:  MOVLW  A7
04B4E:  MOVWF  FE9
04B50:  CALL   2D08
....................       myStatus |= EEPROM_MALFUNCTON; 
04B54:  MOVLB  4
04B56:  BSF    xC1.0
....................    } 
04B58:  BRA    4C5A
04B5A:  MOVLB  0
....................  
....................    else 
....................    { 
....................       fprintf(STDOUT, "Slope: %.3f\r\n", temp_float); 
04B5C:  MOVLW  62
04B5E:  MOVWF  FF6
04B60:  MOVLW  22
04B62:  MOVWF  FF7
04B64:  CLRF   19
04B66:  BTFSC  FF2.7
04B68:  BSF    19.7
04B6A:  BCF    FF2.7
04B6C:  MOVLW  07
04B6E:  MOVLB  9
04B70:  MOVWF  x66
04B72:  MOVLB  0
04B74:  CALL   0AAC
04B78:  BTFSC  19.7
04B7A:  BSF    FF2.7
04B7C:  MOVLW  89
04B7E:  MOVWF  FE9
04B80:  MOVFF  714,815
04B84:  MOVFF  713,814
04B88:  MOVFF  712,813
04B8C:  MOVFF  711,812
04B90:  MOVLW  03
04B92:  MOVLB  8
04B94:  MOVWF  x16
04B96:  MOVLB  0
04B98:  CALL   40FE
04B9C:  MOVLW  0D
04B9E:  BTFSS  FA4.4
04BA0:  BRA    4B9E
04BA2:  MOVWF  F73
04BA4:  MOVLW  0A
04BA6:  BTFSS  FA4.4
04BA8:  BRA    4BA6
04BAA:  MOVWF  F73
....................       fprintf(STDOUT, "Intercept: %.3f\r\n", temp_float_1); 
04BAC:  MOVLW  70
04BAE:  MOVWF  FF6
04BB0:  MOVLW  22
04BB2:  MOVWF  FF7
04BB4:  CLRF   19
04BB6:  BTFSC  FF2.7
04BB8:  BSF    19.7
04BBA:  BCF    FF2.7
04BBC:  MOVLW  0B
04BBE:  MOVLB  9
04BC0:  MOVWF  x66
04BC2:  MOVLB  0
04BC4:  CALL   0AAC
04BC8:  BTFSC  19.7
04BCA:  BSF    FF2.7
04BCC:  MOVLW  89
04BCE:  MOVWF  FE9
04BD0:  MOVFF  718,815
04BD4:  MOVFF  717,814
04BD8:  MOVFF  716,813
04BDC:  MOVFF  715,812
04BE0:  MOVLW  03
04BE2:  MOVLB  8
04BE4:  MOVWF  x16
04BE6:  MOVLB  0
04BE8:  CALL   40FE
04BEC:  MOVLW  0D
04BEE:  BTFSS  FA4.4
04BF0:  BRA    4BEE
04BF2:  MOVWF  F73
04BF4:  MOVLW  0A
04BF6:  BTFSS  FA4.4
04BF8:  BRA    4BF6
04BFA:  MOVWF  F73
....................       fprintf(STDOUT, "Volume Settings : %lu ml \r\n\r\n", breathVolume); 
04BFC:  MOVLW  82
04BFE:  MOVWF  FF6
04C00:  MOVLW  22
04C02:  MOVWF  FF7
04C04:  CLRF   19
04C06:  BTFSC  FF2.7
04C08:  BSF    19.7
04C0A:  BCF    FF2.7
04C0C:  MOVLW  12
04C0E:  MOVLB  9
04C10:  MOVWF  x66
04C12:  MOVLB  0
04C14:  CALL   0AAC
04C18:  BTFSC  19.7
04C1A:  BSF    FF2.7
04C1C:  MOVLW  10
04C1E:  MOVWF  FE9
04C20:  CLRF   19
04C22:  BTFSC  FF2.7
04C24:  BSF    19.7
04C26:  BCF    FF2.7
04C28:  MOVFF  204,967
04C2C:  MOVFF  203,966
04C30:  CALL   0AD6
04C34:  BTFSC  19.7
04C36:  BSF    FF2.7
04C38:  MOVLW  97
04C3A:  MOVWF  FF6
04C3C:  MOVLW  22
04C3E:  MOVWF  FF7
04C40:  CLRF   19
04C42:  BTFSC  FF2.7
04C44:  BSF    19.7
04C46:  BCF    FF2.7
04C48:  MOVLW  08
04C4A:  MOVLB  9
04C4C:  MOVWF  x66
04C4E:  MOVLB  0
04C50:  CALL   0AAC
04C54:  BTFSC  19.7
04C56:  BSF    FF2.7
04C58:  MOVLB  4
....................    } 
....................     
....................    ledBrightnessCalibrated = ConfigReadByte(CONFIG_LED_BRIGHTNESS_CALIBRATED); 
04C5A:  MOVLB  7
04C5C:  CLRF   x53
04C5E:  MOVLW  13
04C60:  MOVWF  x52
04C62:  MOVLB  0
04C64:  CALL   429C
04C68:  MOVFF  01,50A
....................    fprintf(STDOUT, led_resp); 
04C6C:  MOVLW  01
04C6E:  MOVWF  FEA
04C70:  MOVLW  7C
04C72:  MOVWF  FE9
04C74:  CALL   2D08
....................     
....................    if( ledBrightnessCalibrated != UNIT_CALIBRATED ) 
04C78:  MOVLB  5
04C7A:  MOVF   x0A,W
04C7C:  SUBLW  AA
04C7E:  BZ    4CB6
....................    { 
....................       fprintf(STDOUT, brightness_resp); 
04C80:  MOVLW  01
04C82:  MOVWF  FEA
04C84:  MOVLW  03
04C86:  MOVWF  FE9
04C88:  MOVLB  0
04C8A:  CALL   2D08
....................       fprintf(STDOUT, not_resp); 
04C8E:  MOVLW  01
04C90:  MOVWF  FEA
04C92:  MOVLW  AF
04C94:  MOVWF  FE9
04C96:  CALL   2D08
....................       fprintf(STDOUT, calibrated_resp); 
04C9A:  MOVLW  01
04C9C:  MOVWF  FEA
04C9E:  MOVLW  0F
04CA0:  MOVWF  FE9
04CA2:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
04CA6:  MOVLW  01
04CA8:  MOVWF  FEA
04CAA:  MOVLW  A7
04CAC:  MOVWF  FE9
04CAE:  CALL   2D08
....................    } 
04CB2:  BRA    4CDC
04CB4:  MOVLB  5
....................     
....................    else 
....................    { 
....................       fprintf(STDOUT, brightness_resp); 
04CB6:  MOVLW  01
04CB8:  MOVWF  FEA
04CBA:  MOVLW  03
04CBC:  MOVWF  FE9
04CBE:  MOVLB  0
04CC0:  CALL   2D08
....................       fprintf(STDOUT, calibrated_resp); 
04CC4:  MOVLW  01
04CC6:  MOVWF  FEA
04CC8:  MOVLW  0F
04CCA:  MOVWF  FE9
04CCC:  CALL   2D08
....................       fprintf(STDOUT, new_line_resp); 
04CD0:  MOVLW  01
04CD2:  MOVWF  FEA
04CD4:  MOVLW  A7
04CD6:  MOVWF  FE9
04CD8:  CALL   2D08
....................    } 
....................     
....................    if( myStatus ) 
04CDC:  MOVLB  4
04CDE:  MOVF   xC1,W
04CE0:  IORWF  xC2,W
04CE2:  BZ    4CF6
....................    { 
....................       //update bluetooth error code info 
....................       bleNotifyErrorSet(HARDWARE_FAIL); 
04CE4:  MOVLW  01
04CE6:  MOVLB  8
04CE8:  MOVWF  x12
04CEA:  MOVLB  0
04CEC:  CALL   3A78
....................       hardwareFailure(); 
04CF0:  BRA    465E
....................    } 
04CF2:  BRA    4E46
04CF4:  MOVLB  4
....................     
....................    else 
....................    { 
....................       fprintf(STDOUT, new_line_resp); 
04CF6:  MOVLW  01
04CF8:  MOVWF  FEA
04CFA:  MOVLW  A7
04CFC:  MOVWF  FE9
04CFE:  MOVLB  0
04D00:  CALL   2D08
....................        
....................       fprintf(STDOUT, hardware_check_resp); 
04D04:  MOVLW  01
04D06:  MOVWF  FEA
04D08:  MOVLW  54
04D0A:  MOVWF  FE9
04D0C:  CALL   2D08
....................       fprintf(STDOUT, dash_resp); 
04D10:  MOVLW  01
04D12:  MOVWF  FEA
04D14:  MOVLW  41
04D16:  MOVWF  FE9
04D18:  CALL   2D08
....................       fprintf(STDOUT, pass_resp); 
04D1C:  MOVLW  01
04D1E:  MOVWF  FEA
04D20:  MOVLW  B4
04D22:  MOVWF  FE9
04D24:  CALL   2D08
....................       fprintf(STDOUT, two_new_lines_resp); 
04D28:  MOVLW  01
04D2A:  MOVWF  FEA
04D2C:  MOVLW  F2
04D2E:  MOVWF  FE9
04D30:  CALL   2D08
....................        
....................       previousTimer = get_ticks(); 
04D34:  CALL   43C2
04D38:  MOVFF  03,70C
04D3C:  MOVFF  02,70B
04D40:  MOVFF  01,70A
04D44:  MOVFF  00,709
....................       set_ticks(tmp); 
04D48:  MOVFF  710,734
04D4C:  MOVFF  70F,733
04D50:  MOVFF  70E,732
04D54:  MOVFF  70D,731
04D58:  RCALL  45A2
....................  
....................       //Unit pass hardware test 
....................       while( TRUE ) 
....................       { 
....................          illumination_brightness( 90 ); 
04D5A:  MOVLW  5A
04D5C:  MOVLB  8
04D5E:  MOVWF  x12
04D60:  MOVLB  0
04D62:  CALL   42F2
....................          illumination_use(ILLUMINATION_730); 
04D66:  MOVLW  7C
04D68:  MOVLB  8
04D6A:  MOVWF  x13
04D6C:  MOVLW  05
04D6E:  MOVWF  x12
04D70:  MOVLB  0
04D72:  CALL   4394
....................          ble_wait(ONE_HUNDRED); 
04D76:  MOVLB  7
04D78:  CLRF   x58
04D7A:  CLRF   x57
04D7C:  CLRF   x56
04D7E:  MOVLW  64
04D80:  MOVWF  x55
04D82:  MOVLB  0
04D84:  CALL   43F6
....................          output_low(ILLUMINATION_730); 
04D88:  BCF    F92.5
04D8A:  BCF    F89.5
....................          ble_wait(50); 
04D8C:  MOVLB  7
04D8E:  CLRF   x58
04D90:  CLRF   x57
04D92:  CLRF   x56
04D94:  MOVLW  32
04D96:  MOVWF  x55
04D98:  MOVLB  0
04D9A:  CALL   43F6
....................  
....................          illumination_use(ILLUMINATION_588); 
04D9E:  MOVLW  7C
04DA0:  MOVLB  8
04DA2:  MOVWF  x13
04DA4:  MOVLW  10
04DA6:  MOVWF  x12
04DA8:  MOVLB  0
04DAA:  CALL   4394
....................          ble_wait(ONE_HUNDRED); 
04DAE:  MOVLB  7
04DB0:  CLRF   x58
04DB2:  CLRF   x57
04DB4:  CLRF   x56
04DB6:  MOVLW  64
04DB8:  MOVWF  x55
04DBA:  MOVLB  0
04DBC:  CALL   43F6
....................          output_low(ILLUMINATION_588); 
04DC0:  BCF    F94.0
04DC2:  BCF    F8B.0
....................          ble_wait(50); 
04DC4:  MOVLB  7
04DC6:  CLRF   x58
04DC8:  CLRF   x57
04DCA:  CLRF   x56
04DCC:  MOVLW  32
04DCE:  MOVWF  x55
04DD0:  MOVLB  0
04DD2:  CALL   43F6
....................  
....................          illumination_use(ILLUMINATION_475); 
04DD6:  MOVLW  7C
04DD8:  MOVLB  8
04DDA:  MOVWF  x13
04DDC:  MOVLW  04
04DDE:  MOVWF  x12
04DE0:  MOVLB  0
04DE2:  CALL   4394
....................          ble_wait(ONE_HUNDRED); 
04DE6:  MOVLB  7
04DE8:  CLRF   x58
04DEA:  CLRF   x57
04DEC:  CLRF   x56
04DEE:  MOVLW  64
04DF0:  MOVWF  x55
04DF2:  MOVLB  0
04DF4:  CALL   43F6
....................          output_low(ILLUMINATION_475); 
04DF8:  BCF    F92.4
04DFA:  BCF    F89.4
....................          ble_wait(500); 
04DFC:  MOVLB  7
04DFE:  CLRF   x58
04E00:  CLRF   x57
04E02:  MOVLW  01
04E04:  MOVWF  x56
04E06:  MOVLW  F4
04E08:  MOVWF  x55
04E0A:  MOVLB  0
04E0C:  CALL   43F6
....................           
....................          bleNotifyErrorResetErrorBits(); 
04E10:  RCALL  4768
....................          tmpTime = get_ticks(); 
04E12:  CALL   43C2
04E16:  MOVFF  03,708
04E1A:  MOVFF  02,707
04E1E:  MOVFF  01,706
04E22:  MOVFF  00,705
....................          //fprintf(STDOUT, "\r\n %lu \r\n", tmpTime); 
....................          if( tmpTime > FIVE_SECONDS ) 
04E26:  MOVLB  7
04E28:  MOVF   x08,F
04E2A:  BNZ   4E40
04E2C:  MOVF   x07,F
04E2E:  BNZ   4E40
04E30:  MOVF   x06,W
04E32:  SUBLW  12
04E34:  BC    4E42
04E36:  XORLW  FF
04E38:  BNZ   4E40
04E3A:  MOVF   x05,W
04E3C:  SUBLW  88
04E3E:  BC    4E42
....................             break; 
04E40:  BRA    4E48
04E42:  MOVLB  0
04E44:  BRA    4D5A
04E46:  MOVLB  7
....................       } 
....................    } 
....................     
....................    ble_cmd_attributes_write(BLE_HANDLE_DEVICE_STAT, 0, sizeof(deviceStat), (uint8 *)&deviceStat); 
04E48:  MOVLW  02
04E4A:  MOVWF  x1B
04E4C:  MOVLW  2A
04E4E:  MOVWF  x1A
04E50:  MOVLB  8
04E52:  CLRF   x14
04E54:  MOVLW  15
04E56:  MOVWF  x13
04E58:  CLRF   x15
04E5A:  MOVLW  10
04E5C:  MOVWF  x16
04E5E:  MOVFF  71B,818
04E62:  MOVFF  71A,817
04E66:  MOVLB  0
04E68:  CALL   2E2E
....................    set_ticks(previousTimer); 
04E6C:  MOVFF  70C,734
04E70:  MOVFF  70B,733
04E74:  MOVFF  70A,732
04E78:  MOVFF  709,731
04E7C:  CALL   45A2
04E80:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void main() 
*
0CEBE:  CLRF   FF8
0CEC0:  BCF    FD0.7
0CEC2:  BSF    07.7
0CEC4:  MOVLW  1E
0CEC6:  MOVWF  00
0CEC8:  MOVLW  01
0CECA:  MOVWF  01
0CECC:  MOVLW  02
0CECE:  MOVWF  FE9
0CED0:  MOVLW  00
0CED2:  MOVWF  FEA
0CED4:  CLRF   FEE
0CED6:  CLRWDT
0CED8:  DECFSZ 00,F
0CEDA:  BRA    CED4
0CEDC:  DECFSZ 01,F
0CEDE:  BRA    CED4
0CEE0:  MOVLW  14
0CEE2:  MOVWF  00
0CEE4:  MOVLW  10
0CEE6:  MOVWF  01
0CEE8:  MOVLW  24
0CEEA:  MOVWF  FE9
0CEEC:  MOVLW  00
0CEEE:  MOVWF  FEA
0CEF0:  CLRF   FEE
0CEF2:  CLRWDT
0CEF4:  DECFSZ 00,F
0CEF6:  BRA    CEF0
0CEF8:  DECFSZ 01,F
0CEFA:  BRA    CEF0
0CEFC:  MOVLW  60
0CEFE:  MOVWF  FD3
0CF00:  BCF    F9B.6
0CF02:  BCF    F9B.7
0CF04:  CLRF   1A
0CF06:  BCF    FB8.3
0CF08:  MOVLW  0C
0CF0A:  MOVWF  FAF
0CF0C:  MOVLW  A2
0CF0E:  MOVWF  FAC
0CF10:  MOVLW  90
0CF12:  MOVWF  FAB
0CF14:  BSF    F70.3
0CF16:  MOVLW  10
0CF18:  MOVWF  F75
0CF1A:  MOVLW  00
0CF1C:  MOVWF  F76
0CF1E:  MOVLW  A6
0CF20:  MOVWF  F72
0CF22:  MOVLW  90
0CF24:  MOVWF  F71
0CF26:  CLRF   1B
0CF28:  CLRF   1C
0CF2A:  CLRF   1D
0CF2C:  CLRF   1B
0CF2E:  CLRF   1C
0CF30:  BSF    FA3.5
0CF32:  BSF    F94.3
0CF34:  BSF    F94.4
0CF36:  BCF    FCB.0
0CF38:  BCF    FCB.1
0CF3A:  BCF    FCB.3
0CF3C:  MOVLW  13
0CF3E:  MOVWF  FC8
0CF40:  MOVLW  28
0CF42:  MOVWF  FC6
0CF44:  BSF    FC7.7
0CF46:  BCF    FC7.6
0CF48:  BCF    F95.4
0CF4A:  BCF    F95.0
0CF4C:  BCF    F8C.0
0CF4E:  BCF    F95.3
0CF50:  BCF    F8C.3
0CF52:  MOVLB  F
0CF54:  BCF    x48.0
0CF56:  BCF    x49.1
0CF58:  SETF   FBB
0CF5A:  MOVLW  06
0CF5C:  MOVWF  FBA
0CF5E:  BCF    F95.1
0CF60:  MOVLW  80
0CF62:  MOVWF  x58
0CF64:  CLRF   x57
0CF66:  CLRF   59
0CF68:  CLRF   58
0CF6A:  CLRF   57
0CF6C:  CLRF   56
0CF6E:  MOVLW  37
0CF70:  MOVWF  FCD
0CF72:  CLRF   FCC
0CF74:  CLRF   FCF
0CF76:  CLRF   FCE
0CF78:  BCF    F9E.0
0CF7A:  BSF    F9D.0
0CF7C:  MOVLB  0
0CF7E:  CLRF   xCF
0CF80:  CLRF   xCE
0CF82:  CLRF   xD1
0CF84:  MOVLB  3
0CF86:  CLRF   x48
0CF88:  CLRF   x49
0CF8A:  CLRF   x50
0CF8C:  CLRF   x51
0CF8E:  MOVLB  4
0CF90:  CLRF   x52
0CF92:  CLRF   x53
0CF94:  MOVLB  0
0CF96:  CLRF   xD0
0CF98:  MOVLB  4
0CF9A:  CLRF   x54
0CF9C:  SETF   x56
0CF9E:  SETF   x55
0CFA0:  CLRF   x58
0CFA2:  MOVLW  3C
0CFA4:  MOVWF  x57
0CFA6:  CLRF   x5C
0CFA8:  CLRF   x5B
0CFAA:  CLRF   x5A
0CFAC:  CLRF   x59
0CFAE:  CLRF   x60
0CFB0:  CLRF   x5F
0CFB2:  CLRF   x5E
0CFB4:  CLRF   x5D
0CFB6:  CLRF   x68
0CFB8:  MOVLW  32
0CFBA:  MOVWF  x67
0CFBC:  CLRF   xC0
0CFBE:  CLRF   xBF
0CFC0:  MOVLB  F
0CFC2:  CLRF   x38
0CFC4:  CLRF   x39
0CFC6:  CLRF   x3A
0CFC8:  CLRF   x3B
0CFCA:  CLRF   x3C
0CFCC:  CLRF   F77
0CFCE:  CLRF   F78
0CFD0:  CLRF   F79
0CFD2:  BRA    D1D2
0CFD4:  DATA 1D,00
0CFD6:  DATA 5E,72
0CFD8:  DATA 59,88
0CFDA:  DATA 7C,75
0CFDC:  DATA 26,97
0CFDE:  DATA E0,78
0CFE0:  DATA 1E,1D
0CFE2:  DATA C4,7A
0CFE4:  DATA 63,50
0CFE6:  DATA 5E,7C
0CFE8:  DATA 75,FE
0CFEA:  DATA 1A,7E
0CFEC:  DATA 31,72
0CFEE:  DATA 18,7F
0CFF0:  DATA 8A,47
0CFF2:  DATA 99,80
0CFF4:  DATA 0B,C0
0CFF6:  DATA 00,08
0CFF8:  DATA 80,7B
0CFFA:  DATA 3A,F3
0CFFC:  DATA 4C,7E
0CFFE:  DATA DF,9D
0D000:  DATA 2B,08
0D002:  DATA C0,00
0D004:  DATA 38,80
0D006:  DATA 7D,7D
0D008:  DATA BF,37
0D00A:  DATA 81,93
0D00C:  DATA AA,3D
0D00E:  DATA 81,33
0D010:  DATA 50,EE
0D012:  DATA 7F,00
0D014:  DATA 00,00
0D016:  DATA 81,B1
0D018:  DATA 8D,0A
0D01A:  DATA 81,33
0D01C:  DATA 50,EE
0D01E:  DATA 7C,34
0D020:  DATA 89,0A
0D022:  DATA 81,35
0D024:  DATA 79,7C
0D026:  DATA 83,33
0D028:  DATA 02,3F
0D02A:  DATA 83,1E
0D02C:  DATA 8C,33
0D02E:  DATA 7F,00
0D030:  DATA 00,00
0D032:  DATA 82,35
0D034:  DATA E4,1B
0D036:  DATA 83,67
0D038:  DATA DB,A4
0D03A:  DATA 83,1E
0D03C:  DATA 8C,33
0D03E:  DATA F3,00
0D040:  DATA D2,42
0D042:  DATA 61,64
0D044:  DATA 20,00
0D046:  DATA 43,61
0D048:  DATA 72,74
0D04A:  DATA 72,69
0D04C:  DATA 64,67
0D04E:  DATA 65,20
0D050:  DATA 00,42
0D052:  DATA 72,69
0D054:  DATA 67,68
0D056:  DATA 74,37
0D058:  DATA 33,30
0D05A:  DATA 20,00
0D05C:  DATA 42,72
0D05E:  DATA 69,67
0D060:  DATA 68,74
0D062:  DATA 35,38
0D064:  DATA 38,20
0D066:  DATA 00,42
0D068:  DATA 72,69
0D06A:  DATA 67,68
0D06C:  DATA 74,34
0D06E:  DATA 37,35
0D070:  DATA 20,00
0D072:  DATA 42,72
0D074:  DATA 69,67
0D076:  DATA 68,74
0D078:  DATA 6E,65
0D07A:  DATA 73,73
0D07C:  DATA 20,00
0D07E:  DATA 43,61
0D080:  DATA 6C,69
0D082:  DATA 62,72
0D084:  DATA 61,74
0D086:  DATA 65,64
0D088:  DATA 20,00
0D08A:  DATA 43,61
0D08C:  DATA 72,74
0D08E:  DATA 72,69
0D090:  DATA 64,67
0D092:  DATA 65,20
0D094:  DATA 57,65
0D096:  DATA 74,74
0D098:  DATA 69,6E
0D09A:  DATA 67,20
0D09C:  DATA 43,68
0D09E:  DATA 65,63
0D0A0:  DATA 6B,20
0D0A2:  DATA 00,3A
0D0A4:  DATA 20,00
0D0A6:  DATA 44,61
0D0A8:  DATA 72,6B
0D0AA:  DATA 6E,65
0D0AC:  DATA 73,73
0D0AE:  DATA 20,00
0D0B0:  DATA 2D,20
0D0B2:  DATA 00,44
0D0B4:  DATA 65,74
0D0B6:  DATA 65,63
0D0B8:  DATA 74,65
0D0BA:  DATA 64,20
0D0BC:  DATA 00,46
0D0BE:  DATA 61,69
0D0C0:  DATA 6C,20
0D0C2:  DATA 00,48
0D0C4:  DATA 61,72
0D0C6:  DATA 64,77
0D0C8:  DATA 61,72
0D0CA:  DATA 65,20
0D0CC:  DATA 43,68
0D0CE:  DATA 65,63
0D0D0:  DATA 6B,65
0D0D2:  DATA 64,20
0D0D4:  DATA 00,49
0D0D6:  DATA 6E,73
0D0D8:  DATA 65,72
0D0DA:  DATA 74,20
0D0DC:  DATA 6E,65
0D0DE:  DATA 77,20
0D0E0:  DATA 63,61
0D0E2:  DATA 72,74
0D0E4:  DATA 72,69
0D0E6:  DATA 64,67
0D0E8:  DATA 65,20
0D0EA:  DATA 00,4C
0D0EC:  DATA 45,44
0D0EE:  DATA 20,00
0D0F0:  DATA 45,78
0D0F2:  DATA 63,65
0D0F4:  DATA 65,64
0D0F6:  DATA 65,64
0D0F8:  DATA 20,6D
0D0FA:  DATA 61,78
0D0FC:  DATA 69,6D
0D0FE:  DATA 75,6D
0D100:  DATA 20,70
0D102:  DATA 6F,77
0D104:  DATA 65,72
0D106:  DATA 20,6C
0D108:  DATA 69,6D
0D10A:  DATA 69,74
0D10C:  DATA 20,61
0D10E:  DATA 6C,6C
0D110:  DATA 6F,77
0D112:  DATA 65,64
0D114:  DATA 20,00
0D116:  DATA 0D,0A
0D118:  DATA 00,4E
0D11A:  DATA 65,77
0D11C:  DATA 20,00
0D11E:  DATA 4E,6F
0D120:  DATA 74,20
0D122:  DATA 00,50
0D124:  DATA 61,73
0D126:  DATA 73,20
0D128:  DATA 00,50
0D12A:  DATA 6C,65
0D12C:  DATA 61,73
0D12E:  DATA 65,20
0D130:  DATA 77,61
0D132:  DATA 69,74
0D134:  DATA 05,C0
0D136:  DATA 2E,38
0D138:  DATA 80,00
0D13A:  DATA 53,65
0D13C:  DATA 74,20
0D13E:  DATA 00,74
0D140:  DATA 65,73
0D142:  DATA 74,20
0D144:  DATA 73,74
0D146:  DATA 61,72
0D148:  DATA 74,65
0D14A:  DATA 64,20
0D14C:  DATA 00,54
0D14E:  DATA 69,6D
0D150:  DATA 65,20
0D152:  DATA 6C,69
0D154:  DATA 6D,69
0D156:  DATA 74,20
0D158:  DATA 65,78
0D15A:  DATA 63,65
0D15C:  DATA 65,64
0D15E:  DATA 65,64
0D160:  DATA 00,0D
0D162:  DATA 0A,0D
0D164:  DATA 0A,00
0D166:  DATA 55,73
0D168:  DATA 65,64
0D16A:  DATA 20,00
0D16C:  DATA 57,65
0D16E:  DATA 74,20
0D170:  DATA 00,06
0D172:  DATA 03,4A
0D174:  DATA 01,02
0D176:  DATA 0E,0C
0D178:  DATA 0A,0F
0D17A:  DATA 54,04
0D17C:  DATA 69,00
0D17E:  DATA 00,05
0D180:  DATA 00,0A
0D182:  DATA 00,0F
0D184:  DATA 00,14
0D186:  DATA 00,19
0D188:  DATA 00,1E
0D18A:  DATA 00,23
0D18C:  DATA 00,28
0D18E:  DATA 00,2D
0D190:  DATA 00,32
0D192:  DATA 00,37
0D194:  DATA 00,3C
0D196:  DATA 00,41
0D198:  DATA 00,46
0D19A:  DATA 00,4B
0D19C:  DATA 00,50
0D19E:  DATA 00,55
0D1A0:  DATA 00,5A
0D1A2:  DATA 00,5F
0D1A4:  DATA 00,64
0D1A6:  DATA 00,51
0D1A8:  DATA 03,5A
0D1AA:  DATA 03,70
0D1AC:  DATA 03,80
0D1AE:  DATA 03,8A
0D1B0:  DATA 03,91
0D1B2:  DATA 03,93
0D1B4:  DATA 03,96
0D1B6:  DATA 03,90
0D1B8:  DATA 03,95
0D1BA:  DATA 03,97
0D1BC:  DATA 03,9E
0D1BE:  DATA 03,A0
0D1C0:  DATA 03,A5
0D1C2:  DATA 03,AA
0D1C4:  DATA 03,BE
0D1C6:  DATA 03,5A
0D1C8:  DATA 03,5A
0D1CA:  DATA 03,C5
0D1CC:  DATA 03,C5
0D1CE:  DATA 03,C5
0D1D0:  DATA 03,00
0D1D2:  MOVLW  00
0D1D4:  MOVWF  FF8
0D1D6:  MOVLW  CF
0D1D8:  MOVWF  FF7
0D1DA:  MOVLW  D4
0D1DC:  MOVWF  FF6
0D1DE:  TBLRD*+
0D1E0:  MOVF   FF5,W
0D1E2:  MOVWF  00
0D1E4:  XORLW  00
0D1E6:  BZ    D20E
0D1E8:  TBLRD*+
0D1EA:  MOVF   FF5,W
0D1EC:  MOVWF  01
0D1EE:  BTFSC  FE8.7
0D1F0:  BRA    D1FC
0D1F2:  ANDLW  0F
0D1F4:  MOVWF  FEA
0D1F6:  TBLRD*+
0D1F8:  MOVFF  FF5,FE9
0D1FC:  BTFSC  01.6
0D1FE:  TBLRD*+
0D200:  BTFSS  01.6
0D202:  TBLRD*+
0D204:  MOVFF  FF5,FEE
0D208:  DCFSNZ 00,F
0D20A:  BRA    D1DE
0D20C:  BRA    D200
0D20E:  CLRF   FF8
0D210:  MOVLB  5
0D212:  CLRF   x89
0D214:  CLRF   x88
0D216:  CLRF   x87
0D218:  CLRF   x86
0D21A:  MOVLW  01
0D21C:  MOVWF  x8A
0D21E:  CLRF   x8D
0D220:  CLRF   x8E
0D222:  CLRF   x90
0D224:  CLRF   x8F
.................... { 
....................    uint32   tmpTimer, timer_current = 0; 
....................    char     status = PASS; 
....................    uint8_t  *tmpPtr, tmpCtr = 0, rslt = 0; 
....................    uint16   tmpValue = 0; 
....................     
....................    output_high(PIN_C1); 
0D226:  BCF    F94.1
0D228:  BSF    F8B.1
....................    output_high(PIN_C2); 
0D22A:  BCF    F94.2
0D22C:  BSF    F8B.2
....................     
....................    setup_oscillator(OSC_8MHZ|OSC_INTRC,OSC_STATE_STABLE); 
0D22E:  MOVLW  62
0D230:  MOVWF  FD3
0D232:  MOVLW  04
0D234:  MOVWF  F9B
....................    setup_adc_ports(sAN0|sAN1); 
0D236:  MOVF   FC1,W
0D238:  ANDLW  F0
0D23A:  MOVWF  FC1
0D23C:  MOVLW  03
0D23E:  MOVLB  F
0D240:  MOVWF  x38
0D242:  MOVLW  00
0D244:  MOVWF  x3C
0D246:  MOVWF  x39
0D248:  MOVWF  x3A
0D24A:  MOVWF  x3B
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
0D24C:  MOVF   FC0,W
0D24E:  ANDLW  C0
0D250:  IORLW  07
0D252:  MOVWF  FC0
0D254:  BSF    FC0.7
0D256:  BSF    FC2.0
....................  
....................    init_ext_eeprom(); 
0D258:  MOVLB  0
0D25A:  GOTO   2AE4
....................  
....................    enable_interrupts(GLOBAL); 
0D25E:  MOVLW  C0
0D260:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
0D262:  BSF    F9D.5
....................  
....................    fprintf(STDOUT, "\r\n"); 
0D264:  MOVLW  0D
0D266:  BTFSS  FA4.4
0D268:  BRA    D266
0D26A:  MOVWF  F73
0D26C:  MOVLW  0A
0D26E:  BTFSS  FA4.4
0D270:  BRA    D26E
0D272:  MOVWF  F73
....................    fprintf(STDOUT, "Invoy 5.0 Version Major %d. Minor %d. Revision %d\r\n\r\n", 
....................      FIRMWARE_VERSION_MAJOR, 
....................      FIRMWARE_VERSION_MINOR, 
....................      FIRMWARE_VERSION_REVISION); 
0D274:  MOVLW  A0
0D276:  MOVWF  FF6
0D278:  MOVLW  22
0D27A:  MOVWF  FF7
0D27C:  CLRF   19
0D27E:  BTFSC  FF2.7
0D280:  BSF    19.7
0D282:  BCF    FF2.7
0D284:  MOVLW  18
0D286:  MOVLB  9
0D288:  MOVWF  x66
0D28A:  MOVLB  0
0D28C:  CALL   0AAC
0D290:  BTFSC  19.7
0D292:  BSF    FF2.7
0D294:  MOVLB  8
0D296:  CLRF   x12
0D298:  MOVLW  18
0D29A:  MOVWF  x13
0D29C:  MOVLB  0
0D29E:  CALL   2AEC
0D2A2:  MOVLW  BA
0D2A4:  MOVWF  FF6
0D2A6:  MOVLW  22
0D2A8:  MOVWF  FF7
0D2AA:  CLRF   19
0D2AC:  BTFSC  FF2.7
0D2AE:  BSF    19.7
0D2B0:  BCF    FF2.7
0D2B2:  MOVLW  08
0D2B4:  MOVLB  9
0D2B6:  MOVWF  x66
0D2B8:  MOVLB  0
0D2BA:  CALL   0AAC
0D2BE:  BTFSC  19.7
0D2C0:  BSF    FF2.7
0D2C2:  MOVLW  41
0D2C4:  MOVLB  8
0D2C6:  MOVWF  x12
0D2C8:  MOVLW  18
0D2CA:  MOVWF  x13
0D2CC:  MOVLB  0
0D2CE:  CALL   2AEC
0D2D2:  MOVLW  C4
0D2D4:  MOVWF  FF6
0D2D6:  MOVLW  22
0D2D8:  MOVWF  FF7
0D2DA:  CLRF   19
0D2DC:  BTFSC  FF2.7
0D2DE:  BSF    19.7
0D2E0:  BCF    FF2.7
0D2E2:  MOVLW  0B
0D2E4:  MOVLB  9
0D2E6:  MOVWF  x66
0D2E8:  MOVLB  0
0D2EA:  CALL   0AAC
0D2EE:  BTFSC  19.7
0D2F0:  BSF    FF2.7
0D2F2:  MOVLW  02
0D2F4:  MOVLB  8
0D2F6:  MOVWF  x12
0D2F8:  MOVLW  18
0D2FA:  MOVWF  x13
0D2FC:  MOVLB  0
0D2FE:  CALL   2AEC
0D302:  MOVLW  D1
0D304:  MOVWF  FF6
0D306:  MOVLW  22
0D308:  MOVWF  FF7
0D30A:  CLRF   19
0D30C:  BTFSC  FF2.7
0D30E:  BSF    19.7
0D310:  BCF    FF2.7
0D312:  MOVLW  04
0D314:  MOVLB  9
0D316:  MOVWF  x66
0D318:  MOVLB  0
0D31A:  CALL   0AAC
0D31E:  BTFSC  19.7
0D320:  BSF    FF2.7
....................    
....................    selfTest(); 
0D322:  CALL   47AE
....................  
....................    TestMode = 0; 
0D326:  CLRF   xD1
....................    char buffer[256]; 
....................    uint8 buffer_index = 0; 
0D328:  MOVLB  6
0D32A:  CLRF   x91
....................     
....................    LedProperties.LevelBrightness730 = ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS); 
0D32C:  MOVLB  7
0D32E:  CLRF   x53
0D330:  CLRF   x52
0D332:  MOVLB  0
0D334:  CALL   429C
0D338:  MOVFF  01,50D
....................    LedProperties.LevelBrightness588 = ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS); 
0D33C:  MOVLB  7
0D33E:  CLRF   x53
0D340:  MOVLW  01
0D342:  MOVWF  x52
0D344:  MOVLB  0
0D346:  CALL   429C
0D34A:  MOVFF  01,50E
....................    LedProperties.LevelBrightness475 = ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS); 
0D34E:  MOVLB  7
0D350:  CLRF   x53
0D352:  MOVLW  02
0D354:  MOVWF  x52
0D356:  MOVLB  0
0D358:  CALL   429C
0D35C:  MOVFF  01,50F
....................     
....................    //Initializing  
....................    bluetoothState = NO; 
0D360:  MOVLB  2
0D362:  CLRF   x02
....................    cartridgeDetected = NO; 
0D364:  MOVLB  5
0D366:  CLRF   x06
....................    brightnessChecked = NO; 
0D368:  CLRF   x08
....................    calibrationStatus = NO; 
0D36A:  CLRF   x09
....................    cartridgeState = CARTRIDGE_STATE_UNKNOWN; 
0D36C:  MOVLW  03
0D36E:  MOVWF  x07
....................    powerDownTimeCtr = INACTIVITY_TIME_LIMIT;   
0D370:  CLRF   x0C
0D372:  MOVLW  1E
0D374:  MOVWF  x0B
....................     
....................    tmpPtr = &cmdReceived; 
0D376:  MOVLW  02
0D378:  MOVWF  x8C
0D37A:  MOVLW  05
0D37C:  MOVWF  x8B
....................  
....................    //clear the cmd structure 
....................    for( tmpCtr = 0; tmpCtr < sizeof( cmdReceived ); tmpCtr++ ) 
0D37E:  CLRF   x8D
0D380:  MOVF   x8D,W
0D382:  SUBLW  08
0D384:  BNC   D3A2
....................       *tmpPtr[tmpCtr] = 0x0; 
0D386:  MOVF   x8D,W
0D388:  ADDWF  x8B,W
0D38A:  MOVWF  FE9
0D38C:  MOVLW  00
0D38E:  ADDWFC x8C,W
0D390:  MOVWF  FEA
0D392:  MOVF   FEF,W
0D394:  CLRF   03
0D396:  MOVWF  FE9
0D398:  MOVFF  03,FEA
0D39C:  CLRF   FEF
0D39E:  INCF   x8D,F
0D3A0:  BRA    D380
....................  
....................    tmpPtr = NULL;    
0D3A2:  CLRF   x8C
0D3A4:  CLRF   x8B
....................    tmpCtr = 0; 
0D3A6:  CLRF   x8D
....................    tmpTimer = 0; 
0D3A8:  CLRF   x85
0D3AA:  CLRF   x84
0D3AC:  CLRF   x83
0D3AE:  CLRF   x82
....................    ShowPrompt(); 
0D3B0:  MOVLB  0
0D3B2:  CALL   4E82
....................     
....................    
....................    for(;;) 
....................    { 
....................       timer_current = get_ticks(); 
0D3B6:  CALL   43C2
0D3BA:  MOVFF  03,589
0D3BE:  MOVFF  02,588
0D3C2:  MOVFF  01,587
0D3C6:  MOVFF  00,586
....................       if( timer_current >= TEN_SECONDS ) 
0D3CA:  MOVLB  5
0D3CC:  MOVF   x89,F
0D3CE:  BNZ   D3E4
0D3D0:  MOVF   x88,F
0D3D2:  BNZ   D3E4
0D3D4:  MOVF   x87,W
0D3D6:  SUBLW  26
0D3D8:  BC    D40C
0D3DA:  XORLW  FF
0D3DC:  BNZ   D3E4
0D3DE:  MOVF   x86,W
0D3E0:  SUBLW  0F
0D3E2:  BC    D40C
....................       { 
....................          tmpTimer++; 
0D3E4:  MOVLW  01
0D3E6:  ADDWF  x82,F
0D3E8:  BTFSC  FD8.0
0D3EA:  INCF   x83,F
0D3EC:  BTFSC  FD8.2
0D3EE:  INCF   x84,F
0D3F0:  BTFSC  FD8.2
0D3F2:  INCF   x85,F
....................          tmpCtr++; 
0D3F4:  INCF   x8D,F
....................          set_ticks(tmpValue); 
0D3F6:  MOVLB  7
0D3F8:  CLRF   x34
0D3FA:  CLRF   x33
0D3FC:  MOVFF  590,732
0D400:  MOVFF  58F,731
0D404:  MOVLB  0
0D406:  CALL   45A2
0D40A:  MOVLB  5
....................       } 
....................  
....................       if( tmpCtr >= 3 ) 
0D40C:  MOVF   x8D,W
0D40E:  SUBLW  02
0D410:  BC    D4B0
....................       {  
....................          powerDownTimeCtr-= tmpCtr; 
0D412:  MOVF   x8D,W
0D414:  SUBWF  x0B,F
0D416:  MOVLW  00
0D418:  SUBWFB x0C,F
....................          fprintf(STDOUT, "\r\n****Device inactivity detected*****\r\n"); 
0D41A:  MOVLW  D6
0D41C:  MOVWF  FF6
0D41E:  MOVLW  22
0D420:  MOVWF  FF7
0D422:  MOVLB  0
0D424:  CALL   2CA0
....................          fprintf(STDOUT, "****%lu second(s) to powerdown****\r\n\r\n", powerDownTimeCtr * 10); 
0D428:  MOVFF  50C,752
0D42C:  MOVFF  50B,751
0D430:  MOVLB  7
0D432:  CLRF   x54
0D434:  MOVLW  0A
0D436:  MOVWF  x53
0D438:  MOVLB  0
0D43A:  CALL   3DEA
0D43E:  MOVFF  02,702
0D442:  MOVFF  01,701
0D446:  MOVLW  FE
0D448:  MOVWF  FF6
0D44A:  MOVLW  22
0D44C:  MOVWF  FF7
0D44E:  CLRF   19
0D450:  BTFSC  FF2.7
0D452:  BSF    19.7
0D454:  BCF    FF2.7
0D456:  MOVLW  04
0D458:  MOVLB  9
0D45A:  MOVWF  x66
0D45C:  MOVLB  0
0D45E:  CALL   0AAC
0D462:  BTFSC  19.7
0D464:  BSF    FF2.7
0D466:  MOVLW  10
0D468:  MOVWF  FE9
0D46A:  CLRF   19
0D46C:  BTFSC  FF2.7
0D46E:  BSF    19.7
0D470:  BCF    FF2.7
0D472:  MOVFF  702,967
0D476:  MOVFF  701,966
0D47A:  CALL   0AD6
0D47E:  BTFSC  19.7
0D480:  BSF    FF2.7
0D482:  MOVLW  05
0D484:  MOVWF  FF6
0D486:  MOVLW  23
0D488:  MOVWF  FF7
0D48A:  CLRF   19
0D48C:  BTFSC  FF2.7
0D48E:  BSF    19.7
0D490:  BCF    FF2.7
0D492:  MOVLW  1F
0D494:  MOVLB  9
0D496:  MOVWF  x66
0D498:  MOVLB  0
0D49A:  CALL   0AAC
0D49E:  BTFSC  19.7
0D4A0:  BSF    FF2.7
....................          ShowPrompt(); 
0D4A2:  CALL   4E82
....................          tmpCtr = 0; 
0D4A6:  MOVLB  5
0D4A8:  CLRF   x8D
....................  
.................... #ifdef TURNOFF_AUTO_POWERDOWN         
.................... //***********************Turn on for testing purposes only, turn off when testing is done************************************ 
....................          powerDownTimeCtr = INACTIVITY_TIME_LIMIT;          
0D4AA:  CLRF   x0C
0D4AC:  MOVLW  1E
0D4AE:  MOVWF  x0B
.................... //***********************Turn on for testing purposes only, turn off when testing is done************************************ 
.................... #endif 
....................  
....................       } 
....................        
....................       if( !powerDownTimeCtr )          // 5 minutes time limit of inactivity allow 
0D4B0:  MOVF   x0B,W
0D4B2:  IORWF  x0C,W
0D4B4:  BNZ   D4EE
....................       { 
....................          fprintf(STDOUT, "\r\n****Exceed inactivity time limit, entering sleep mode****\r\n\r\n"); 
0D4B6:  MOVLW  26
0D4B8:  MOVWF  FF6
0D4BA:  MOVLW  23
0D4BC:  MOVWF  FF7
0D4BE:  MOVLB  0
0D4C0:  CALL   2CA0
....................          illumination_all_off(); 
0D4C4:  CALL   4344
....................          bleNotifyErrorSet(TIME_OUT); 
0D4C8:  MOVLW  64
0D4CA:  MOVLB  8
0D4CC:  MOVWF  x12
0D4CE:  MOVLB  0
0D4D0:  CALL   3A78
....................          ble_wait(TEN_SECONDS); 
0D4D4:  MOVLB  7
0D4D6:  CLRF   x58
0D4D8:  CLRF   x57
0D4DA:  MOVLW  27
0D4DC:  MOVWF  x56
0D4DE:  MOVLW  10
0D4E0:  MOVWF  x55
0D4E2:  MOVLB  0
0D4E4:  CALL   43F6
....................          shutDown(); 
0D4E8:  CALL   462E
0D4EC:  MOVLB  5
....................       } 
....................  
....................       if(transmit_reading_at_index != -1) 
0D4EE:  MOVLB  4
0D4F0:  INCFSZ x55,W
0D4F2:  BRA    D4FA
0D4F4:  INCFSZ x56,W
0D4F6:  BRA    D4FA
0D4F8:  BRA    D560
....................       { 
....................          struct reading r; 
....................          r = reading_fetch(transmit_reading_at_index); 
0D4FA:  MOVFF  456,738
0D4FE:  MOVFF  455,737
0D502:  MOVLB  0
0D504:  CALL   4F64
0D508:  MOVFF  02,03
0D50C:  MOVFF  01,FE1
0D510:  MOVFF  02,FE2
0D514:  MOVLW  06
0D516:  MOVWF  FEA
0D518:  MOVLW  92
0D51A:  MOVWF  FE9
0D51C:  MOVLW  12
0D51E:  MOVWF  01
0D520:  MOVFF  FE6,FEE
0D524:  DECFSZ 01,F
0D526:  BRA    D520
....................          uint8 * pointer = &r; 
0D528:  MOVLW  06
0D52A:  MOVLB  6
0D52C:  MOVWF  xA5
0D52E:  MOVLW  92
0D530:  MOVWF  xA4
....................  
....................          ble_cmd_attributes_write(BLE_HANDLE_READING, 0, sizeof(struct reading), pointer);        
0D532:  MOVLB  8
0D534:  CLRF   x14
0D536:  MOVLW  30
0D538:  MOVWF  x13
0D53A:  CLRF   x15
0D53C:  MOVLW  12
0D53E:  MOVWF  x16
0D540:  MOVFF  6A5,818
0D544:  MOVFF  6A4,817
0D548:  MOVLB  0
0D54A:  CALL   2E2E
....................          transmit_reading_at_index = -1; 
0D54E:  MOVLB  4
0D550:  SETF   x56
0D552:  SETF   x55
....................          while(!ble_log_process()); 
0D554:  MOVLB  0
0D556:  CALL   2D56
0D55A:  MOVF   01,F
0D55C:  BZ    D556
0D55E:  MOVLB  4
....................       } 
....................        
....................       switch( iosApp ) 
0D560:  MOVLB  0
0D562:  MOVF   xD0,W
0D564:  XORLW  01
0D566:  BZ    D582
0D568:  XORLW  03
0D56A:  BZ    D5CA
0D56C:  XORLW  01
0D56E:  BZ    D612
0D570:  XORLW  07
0D572:  BZ    D65E
0D574:  XORLW  FE
0D576:  BTFSC  FD8.2
0D578:  BRA    D672
0D57A:  XORLW  05
0D57C:  BTFSC  FD8.2
0D57E:  BRA    D83E
0D580:  BRA    D84C
....................       { 
....................          case IOS_REQUEST_START_KETONE_TEST: 
....................              
....................             iosApp = 0; 
0D582:  CLRF   xD0
....................           
....................             //Update bluetooth info 
....................             testResult.stepID = TEST_STARTED;             
0D584:  MOVLW  01
0D586:  MOVLB  2
0D588:  MOVWF  x19
....................             ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *)&testResult.stepID); 
0D58A:  MOVLB  8
0D58C:  CLRF   x14
0D58E:  MOVLW  3B
0D590:  MOVWF  x13
0D592:  CLRF   x15
0D594:  MOVLW  01
0D596:  MOVWF  x16
0D598:  MOVLW  02
0D59A:  MOVWF  x18
0D59C:  MOVLW  19
0D59E:  MOVWF  x17
0D5A0:  MOVLB  0
0D5A2:  CALL   2E2E
....................             bleNotifyErrorSet(NO_ERROR);                            
0D5A6:  MOVLB  8
0D5A8:  CLRF   x12
0D5AA:  MOVLB  0
0D5AC:  CALL   3A78
....................             fprintf(STDOUT, "Ketone test started\r\n");         
0D5B0:  MOVLW  66
0D5B2:  MOVWF  FF6
0D5B4:  MOVLW  23
0D5B6:  MOVWF  FF7
0D5B8:  CALL   2CA0
....................             performBreathTest( KETONE_TEST ); 
0D5BC:  MOVLW  02
0D5BE:  MOVLB  7
0D5C0:  MOVWF  x01
0D5C2:  MOVLB  0
0D5C4:  CALL   86CC
....................  
....................             break; 
0D5C8:  BRA    D84C
....................           
....................          case IOS_REQUEST_START_AMMONIA_TEST: 
....................             iosApp = 0; 
0D5CA:  CLRF   xD0
....................             //Update bluetooth info 
....................             testResult.stepID = TEST_STARTED;             
0D5CC:  MOVLW  01
0D5CE:  MOVLB  2
0D5D0:  MOVWF  x19
....................             ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *)&testResult.stepID); 
0D5D2:  MOVLB  8
0D5D4:  CLRF   x14
0D5D6:  MOVLW  3B
0D5D8:  MOVWF  x13
0D5DA:  CLRF   x15
0D5DC:  MOVLW  01
0D5DE:  MOVWF  x16
0D5E0:  MOVLW  02
0D5E2:  MOVWF  x18
0D5E4:  MOVLW  19
0D5E6:  MOVWF  x17
0D5E8:  MOVLB  0
0D5EA:  CALL   2E2E
....................             bleNotifyErrorSet(NO_ERROR);                            
0D5EE:  MOVLB  8
0D5F0:  CLRF   x12
0D5F2:  MOVLB  0
0D5F4:  CALL   3A78
....................              
....................             performBreathTest( AMMONIA_TEST ); 
0D5F8:  MOVLW  03
0D5FA:  MOVLB  7
0D5FC:  MOVWF  x01
0D5FE:  MOVLB  0
0D600:  CALL   86CC
....................             fprintf(STDOUT, "Ammonia test started\r\n");         
0D604:  MOVLW  7C
0D606:  MOVWF  FF6
0D608:  MOVLW  23
0D60A:  MOVWF  FF7
0D60C:  CALL   2CA0
....................  
....................             break; 
0D610:  BRA    D84C
....................           
....................          case IOS_REQUEST_RESET_USE_COUNTER:            
....................             iosApp = 0; 
0D612:  CLRF   xD0
0D614:  CLRF   19
0D616:  BTFSC  FF2.7
0D618:  BSF    19.7
0D61A:  BCF    FF2.7
....................             //Zero the use counter 
....................             write_ext_eeprom(CONFIG_MOUTHPIECE_USES, 0x0); 
0D61C:  MOVLB  9
0D61E:  CLRF   x75
0D620:  MOVLW  1C
0D622:  MOVWF  x74
0D624:  CLRF   x76
0D626:  MOVLB  0
0D628:  CALL   09EC
0D62C:  BTFSC  19.7
0D62E:  BSF    FF2.7
....................             //Update the useCount and the BLE handle 
....................             deviceStat.useCount = 0; 
0D630:  MOVLB  2
0D632:  CLRF   x33
0D634:  CLRF   x32
....................             ble_cmd_attributes_write(BLE_HANDLE_DEVICE_STAT, 0, sizeof(struct deviceInfoPara), (uint8 *)&deviceStat);        
0D636:  MOVLW  02
0D638:  MOVLB  7
0D63A:  MOVWF  x02
0D63C:  MOVLW  2A
0D63E:  MOVWF  x01
0D640:  MOVLB  8
0D642:  CLRF   x14
0D644:  MOVLW  15
0D646:  MOVWF  x13
0D648:  CLRF   x15
0D64A:  MOVLW  10
0D64C:  MOVWF  x16
0D64E:  MOVFF  702,818
0D652:  MOVFF  701,817
0D656:  MOVLB  0
0D658:  CALL   2E2E
....................             break;   
0D65C:  BRA    D84C
....................              
....................          case IOS_REQUEST_RESET_READINGS: 
....................             iosApp = 0; 
0D65E:  CLRF   xD0
....................             fprintf(STDOUT, "Reseting readings\r\n"); 
0D660:  MOVLW  94
0D662:  MOVWF  FF6
0D664:  MOVLW  23
0D666:  MOVWF  FF7
0D668:  CALL   2CA0
....................             readings_reset(); 
0D66C:  CALL   92D4
....................              
....................             break; 
0D670:  BRA    D84C
....................  
....................          case IOS_REQUEST_RESET_STATE_MACHINE:            
....................             int8  ctr; 
....................             uint8_t  *tmpTestResultPtr, *tmpTestStatPtr, *tmpTestTimePtr; 
....................              
....................             iosApp = 0; 
0D672:  CLRF   xD0
....................             tmpTestResultPtr = (uint8 *)&testResult; 
0D674:  MOVLW  02
0D676:  MOVLB  7
0D678:  MOVWF  x02
0D67A:  MOVLW  0E
0D67C:  MOVFF  702,6A8
0D680:  MOVFF  FE8,6A7
....................             tmpTestStatPtr = (uint8 *)&testStat; 
0D684:  MOVLW  02
0D686:  MOVWF  x02
0D688:  MOVLW  3A
0D68A:  MOVFF  702,6AA
0D68E:  MOVFF  FE8,6A9
....................             tmpTestTimePtr = (uint8 *)&testTime; 
0D692:  MOVLW  02
0D694:  MOVWF  x02
0D696:  MOVLW  1A
0D698:  MOVFF  702,6AC
0D69C:  MOVFF  FE8,6AB
....................              
....................             //Update the battery condition and update the device status 
....................             BatteryManagement(); 
0D6A0:  MOVLB  0
0D6A2:  CALL   3D4C
....................             deviceStat.batteryLevel = BatteryCapacity(); 
0D6A6:  CALL   3E0C
0D6AA:  MOVLB  2
0D6AC:  CLRF   x31
0D6AE:  MOVFF  01,230
....................             ble_cmd_attributes_write(BLE_HANDLE_DEVICE_STAT, 0, sizeof(deviceStat), (uint8 *)&deviceStat); 
0D6B2:  MOVLW  02
0D6B4:  MOVLB  7
0D6B6:  MOVWF  x02
0D6B8:  MOVLW  2A
0D6BA:  MOVWF  x01
0D6BC:  MOVLB  8
0D6BE:  CLRF   x14
0D6C0:  MOVLW  15
0D6C2:  MOVWF  x13
0D6C4:  CLRF   x15
0D6C6:  MOVLW  10
0D6C8:  MOVWF  x16
0D6CA:  MOVFF  702,818
0D6CE:  MOVFF  701,817
0D6D2:  MOVLB  0
0D6D4:  CALL   2E2E
....................             ble_wait( 150 ); 
0D6D8:  MOVLB  7
0D6DA:  CLRF   x58
0D6DC:  CLRF   x57
0D6DE:  CLRF   x56
0D6E0:  MOVLW  96
0D6E2:  MOVWF  x55
0D6E4:  MOVLB  0
0D6E6:  CALL   43F6
....................     
....................             //Clear and update the BLE handle 
....................             for( ctr = 0; ctr < 18; ctr++ ) 
0D6EA:  MOVLB  6
0D6EC:  CLRF   xA6
0D6EE:  BTFSC  xA6.7
0D6F0:  BRA    D6F8
0D6F2:  MOVF   xA6,W
0D6F4:  SUBLW  11
0D6F6:  BNC   D712
....................                tmpTestResultPtr[ctr] = 0; 
0D6F8:  CLRF   03
0D6FA:  MOVF   xA6,W
0D6FC:  MOVWF  00
0D6FE:  BTFSC  FE8.7
0D700:  DECF   03,F
0D702:  ADDWF  xA7,W
0D704:  MOVWF  FE9
0D706:  MOVF   xA8,W
0D708:  ADDWFC 03,W
0D70A:  MOVWF  FEA
0D70C:  CLRF   FEF
0D70E:  INCF   xA6,F
0D710:  BRA    D6EE
....................                 
....................             ble_cmd_attributes_write(BLE_HANDLE_TEST_REPORT, 0, 18, (uint8*)&testResult); 
0D712:  MOVLW  02
0D714:  MOVLB  7
0D716:  MOVWF  x02
0D718:  MOVLW  0E
0D71A:  MOVWF  x01
0D71C:  MOVLB  8
0D71E:  CLRF   x14
0D720:  MOVLW  21
0D722:  MOVWF  x13
0D724:  CLRF   x15
0D726:  MOVLW  12
0D728:  MOVWF  x16
0D72A:  MOVFF  702,818
0D72E:  MOVFF  701,817
0D732:  MOVLB  0
0D734:  CALL   2E2E
....................             ble_wait( 150 ); 
0D738:  MOVLB  7
0D73A:  CLRF   x58
0D73C:  CLRF   x57
0D73E:  CLRF   x56
0D740:  MOVLW  96
0D742:  MOVWF  x55
0D744:  MOVLB  0
0D746:  CALL   43F6
....................              
....................             for( ctr = 0; ctr < sizeof(testStat); ctr++ ) 
0D74A:  MOVLB  6
0D74C:  CLRF   xA6
0D74E:  BTFSC  xA6.7
0D750:  BRA    D758
0D752:  MOVF   xA6,W
0D754:  SUBLW  0D
0D756:  BNC   D772
....................                tmpTestStatPtr[ctr] = 0; 
0D758:  CLRF   03
0D75A:  MOVF   xA6,W
0D75C:  MOVWF  00
0D75E:  BTFSC  FE8.7
0D760:  DECF   03,F
0D762:  ADDWF  xA9,W
0D764:  MOVWF  FE9
0D766:  MOVF   xAA,W
0D768:  ADDWFC 03,W
0D76A:  MOVWF  FEA
0D76C:  CLRF   FEF
0D76E:  INCF   xA6,F
0D770:  BRA    D74E
....................                 
....................             ble_cmd_attributes_write(BLE_HANDLE_TEST_STAT, 0, sizeof(testStat), (uint8*)&testStat); 
0D772:  MOVLW  02
0D774:  MOVLB  7
0D776:  MOVWF  x02
0D778:  MOVLW  3A
0D77A:  MOVWF  x01
0D77C:  MOVLB  8
0D77E:  CLRF   x14
0D780:  MOVLW  1D
0D782:  MOVWF  x13
0D784:  CLRF   x15
0D786:  MOVLW  0E
0D788:  MOVWF  x16
0D78A:  MOVFF  702,818
0D78E:  MOVFF  701,817
0D792:  MOVLB  0
0D794:  CALL   2E2E
....................             ble_wait( 150 );                
0D798:  MOVLB  7
0D79A:  CLRF   x58
0D79C:  CLRF   x57
0D79E:  CLRF   x56
0D7A0:  MOVLW  96
0D7A2:  MOVWF  x55
0D7A4:  MOVLB  0
0D7A6:  CALL   43F6
....................                 
....................             for( ctr = 0; ctr < sizeof(testTime); ctr++ ) 
0D7AA:  MOVLB  6
0D7AC:  CLRF   xA6
0D7AE:  BTFSC  xA6.7
0D7B0:  BRA    D7B8
0D7B2:  MOVF   xA6,W
0D7B4:  SUBLW  0F
0D7B6:  BNC   D7D2
....................                tmpTestTimePtr[ctr] = 0; 
0D7B8:  CLRF   03
0D7BA:  MOVF   xA6,W
0D7BC:  MOVWF  00
0D7BE:  BTFSC  FE8.7
0D7C0:  DECF   03,F
0D7C2:  ADDWF  xAB,W
0D7C4:  MOVWF  FE9
0D7C6:  MOVF   xAC,W
0D7C8:  ADDWFC 03,W
0D7CA:  MOVWF  FEA
0D7CC:  CLRF   FEF
0D7CE:  INCF   xA6,F
0D7D0:  BRA    D7AE
....................    
....................             ble_cmd_attributes_write(BLE_HANDLE_TEST_STAGE, 0, sizeof(testTime), (uint8*)&testTime); 
0D7D2:  MOVLW  02
0D7D4:  MOVLB  7
0D7D6:  MOVWF  x02
0D7D8:  MOVLW  1A
0D7DA:  MOVWF  x01
0D7DC:  MOVLB  8
0D7DE:  CLRF   x14
0D7E0:  MOVLW  19
0D7E2:  MOVWF  x13
0D7E4:  CLRF   x15
0D7E6:  MOVLW  10
0D7E8:  MOVWF  x16
0D7EA:  MOVFF  702,818
0D7EE:  MOVFF  701,817
0D7F2:  MOVLB  0
0D7F4:  CALL   2E2E
....................             ble_wait( 150 ); 
0D7F8:  MOVLB  7
0D7FA:  CLRF   x58
0D7FC:  CLRF   x57
0D7FE:  CLRF   x56
0D800:  MOVLW  96
0D802:  MOVWF  x55
0D804:  MOVLB  0
0D806:  CALL   43F6
....................              
....................             ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &testResult.stepID); 
0D80A:  MOVLB  8
0D80C:  CLRF   x14
0D80E:  MOVLW  3B
0D810:  MOVWF  x13
0D812:  CLRF   x15
0D814:  MOVLW  01
0D816:  MOVWF  x16
0D818:  MOVLW  02
0D81A:  MOVWF  x18
0D81C:  MOVLW  19
0D81E:  MOVWF  x17
0D820:  MOVLB  0
0D822:  CALL   2E2E
....................             bleNotifyErrorResetErrorBits(); 
0D826:  CALL   4768
....................             ble_wait( 150 ); 
0D82A:  MOVLB  7
0D82C:  CLRF   x58
0D82E:  CLRF   x57
0D830:  CLRF   x56
0D832:  MOVLW  96
0D834:  MOVWF  x55
0D836:  MOVLB  0
0D838:  CALL   43F6
....................  
....................             break; 
0D83C:  BRA    D84C
....................           
....................          case IOS_REQUEST_START_FIRMWARE_UPDATE: 
....................             iosApp = 0; 
0D83E:  CLRF   xD0
....................             fprintf(STDOUT, "Firmware update started\r\n"); 
0D840:  MOVLW  A8
0D842:  MOVWF  FF6
0D844:  MOVLW  23
0D846:  MOVWF  FF7
0D848:  CALL   2CA0
....................             //Firmware update code here 
....................             //****************************** 
....................             //****************************** 
....................             //****************************** 
....................             break; 
....................              
....................          default: 
....................           
....................       } 
....................  
....................       if(kbhit(STDOUT))  
0D84C:  GOTO   94F0
0D850:  BTFSS  00.0
0D852:  GOTO   EFA0
....................       { 
....................          uint8 c = fgetc(STDOUT); 
0D856:  CALL   9500
0D85A:  MOVFF  01,6AD
....................  
....................          if(c != 13)  
0D85E:  MOVLB  6
0D860:  MOVF   xAD,W
0D862:  SUBLW  0D
0D864:  BZ    D888
....................          { 
....................             fputc(c, STDOUT); 
0D866:  MOVF   xAD,W
0D868:  MOVLB  0
0D86A:  CALL   9526
....................             buffer[buffer_index] = c; 
0D86E:  CLRF   03
0D870:  MOVLB  6
0D872:  MOVF   x91,W
0D874:  ADDLW  91
0D876:  MOVWF  FE9
0D878:  MOVLW  05
0D87A:  ADDWFC 03,W
0D87C:  MOVWF  FEA
0D87E:  MOVFF  6AD,FEF
....................             buffer_index++; 
0D882:  INCF   x91,F
....................          }  
0D884:  GOTO   EFA2
....................         
....................          else 
....................          { 
....................             // Enter Key Hit 
....................             fputc('\r', STDOUT); 
0D888:  MOVLW  0D
0D88A:  MOVLB  0
0D88C:  CALL   9526
....................             fputc('\n', STDOUT); 
0D890:  MOVLW  0A
0D892:  CALL   9526
....................             buffer[buffer_index] = 0; 
0D896:  CLRF   03
0D898:  MOVLB  6
0D89A:  MOVF   x91,W
0D89C:  ADDLW  91
0D89E:  MOVWF  FE9
0D8A0:  MOVLW  05
0D8A2:  ADDWFC 03,W
0D8A4:  MOVWF  FEA
0D8A6:  CLRF   FEF
....................             buffer_index = 0; 
0D8A8:  CLRF   x91
....................  
....................             for(;;)  
....................             { 
....................              
....................  
.................... #ifdef STATE_TEST             
....................                if(strcmp(buffer, (unsigned char *)"tt") == 0)  
....................                { 
....................                   uint8    stateID; 
.................... /* 
....................                   stateID = HARDWARE_CHECK; 
....................                    
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Code Hardware Check 0x%x \r\n", stateID); 
....................  
....................                   bleNotifyErrorSet(HARDWARE_FAIL); 
....................                   fprintf(STDOUT, "Error Code - Hardware Fail 0x%x \r\n", HARDWARE_FAIL); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
.................... */ 
....................                   stateID = TEST_STARTED; 
....................                    
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Code Start Test 0x%x \r\n", stateID); 
....................                    
....................                   bleNotifyErrorSet(HARDWARE_FAIL); 
....................                   fprintf(STDOUT, "Error Code - Hardware Fail 0x%x \r\n", HARDWARE_FAIL); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................  
....................                   stateID = INSERT_CARTRIDGE; 
....................                    
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Code Insert Cartridge 0x%x \r\n", stateID); 
....................                    
....................                   bleNotifyErrorSet(BAD_CATRIDGE); 
....................                   fprintf(STDOUT, "Error Code - Bad Catridge 0x%x \r\n", BAD_CATRIDGE); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................                    
....................                   stateID = BLOW; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Code Blow 0x%x \r\n", stateID); 
....................                    
....................                   bleNotifyErrorSet(BAD_BLOW_VOLUME); 
....................                   fprintf(STDOUT, "Error Code - Bad Blow Volume 0x%x \r\n", BAD_BLOW_VOLUME); 
....................                    
....................                   bleNotifyErrorSet(BAD_BLOW_PRESSURE); 
....................                   fprintf(STDOUT, "Error Code - Bad Blow Pressure 0x%x \r\n", BAD_BLOW_PRESSURE); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................                    
....................                   stateID = WET; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Code Wet 0x%x \r\n", stateID); 
....................                    
....................                   bleNotifyErrorSet(NO_WETTING); 
....................                   fprintf(STDOUT, "Error Code - No Wetting 0x%x \r\n", NO_WETTING); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................                    
....................                   stateID = ANALYZE_BREATH_SAMPLE; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Analyze Breath Sample 0x%x \r\n", stateID); 
....................                    
....................                   bleNotifyErrorSet(BAD_SCORE_); 
....................                   fprintf(STDOUT, "Error Code - Bad Score 0x%x \r\n", BAD_SCORE_); 
....................                    
....................                   bleNotifyErrorSet(CARTRIDGE_REMOVED_DURING_ANALYSIS); 
....................                   fprintf(STDOUT, "Error Code - Cartridge removes during analysis 0x%x \r\n", CARTRIDGE_REMOVED_DURING_ANALYSIS); 
....................                    
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                    
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................                    
....................                   stateID = REMOVE_CARTRIDGE; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Remove Cartridge 0x%x \r\n", stateID); 
....................                                      
....................                   bleNotifyErrorSet(CARTRIDGE_NOT_REMOVED); 
....................                   fprintf(STDOUT, "Error Code - Cartridge not removes 0x%x \r\n", CARTRIDGE_NOT_REMOVED); 
....................                                      
....................                   bleNotifyErrorSet(TIME_OUT); 
....................                   fprintf(STDOUT, "Error Code - Timeout 0x%x \r\n", TIME_OUT); 
....................                                      
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No Error 0x%x \r\n", NO_ERROR); 
....................                    
....................                   stateID = TEST_COMPLETED; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Test Completed 0x%x \r\n", stateID); 
....................                                      
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No error 0x%x \r\n", NO_ERROR); 
....................  
....................                   stateID = SEND_RESULTS; 
....................                   ble_cmd_attributes_write(BLE_HANDLE_STATE_CODE, 0, 1, (uint8 *) &stateID); 
....................                   fprintf(STDOUT, "State Send Result 0x%x \r\n", stateID); 
....................                                      
....................                   bleNotifyErrorSet(NO_ERROR); 
....................                   fprintf(STDOUT, "Error Code - No error 0x%x \r\n", NO_ERROR); 
....................  
....................                   break; 
....................                } 
.................... #endif             
....................              
....................              
.................... #ifdef SOFTWARE_DEBUG             
....................                if(strcmp(buffer, (unsigned char *)"testStage") == 0)  
....................                { 
....................                   fprintf(STDOUT, "\r\n**Testing testState Structure**\r\n"); 
....................                   testStage(); 
....................                   break; 
....................                } 
....................                 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"testStats") == 0)  
....................                { 
....................                   fprintf(STDOUT, "\r\n**Testing testState Structure**\r\n"); 
....................                   testStats(); 
....................                   break; 
....................                } 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"testReport") == 0)  
....................                { 
....................                   fprintf(STDOUT, "\r\n**Testing testReport Structure**\r\n"); 
....................                   testReport(); 
....................                   break; 
....................                } 
.................... #endif                
....................                 
....................                if(strcmp(buffer, (unsigned char *)"pd") == 0) 
0D8AA:  MOVLW  70
0D8AC:  MOVWF  xAE
0D8AE:  MOVLW  64
0D8B0:  MOVWF  xAF
0D8B2:  CLRF   xB0
0D8B4:  MOVLW  05
0D8B6:  MOVLB  7
0D8B8:  MOVWF  x06
0D8BA:  MOVLW  91
0D8BC:  MOVWF  x05
0D8BE:  MOVLW  06
0D8C0:  MOVWF  x08
0D8C2:  MOVLW  AE
0D8C4:  MOVWF  x07
0D8C6:  MOVLB  0
0D8C8:  CALL   952E
0D8CC:  MOVF   01,F
0D8CE:  BNZ   D8E4
....................                { 
....................                   fprintf(STDOUT, "\r\n****Sleep Mode****\r\n"); 
0D8D0:  MOVLW  C2
0D8D2:  MOVWF  FF6
0D8D4:  MOVLW  23
0D8D6:  MOVWF  FF7
0D8D8:  CALL   2CA0
....................                   shutDown(); 
0D8DC:  CALL   462E
....................                   break; 
0D8E0:  GOTO   EF90
....................                } 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"help") == 0)  
0D8E4:  MOVLW  68
0D8E6:  MOVLB  6
0D8E8:  MOVWF  xAE
0D8EA:  MOVLW  65
0D8EC:  MOVWF  xAF
0D8EE:  MOVLW  6C
0D8F0:  MOVWF  xB0
0D8F2:  MOVLW  70
0D8F4:  MOVWF  xB1
0D8F6:  CLRF   xB2
0D8F8:  MOVLW  05
0D8FA:  MOVLB  7
0D8FC:  MOVWF  x06
0D8FE:  MOVLW  91
0D900:  MOVWF  x05
0D902:  MOVLW  06
0D904:  MOVWF  x08
0D906:  MOVLW  AE
0D908:  MOVWF  x07
0D90A:  MOVLB  0
0D90C:  CALL   952E
0D910:  MOVF   01,F
0D912:  BTFSS  FD8.2
0D914:  BRA    DA76
....................                { 
....................                   fprintf(STDOUT, " \r\n\r\n  Type the following command \r\n" ); 
0D916:  MOVLW  DA
0D918:  MOVWF  FF6
0D91A:  MOVLW  23
0D91C:  MOVWF  FF7
0D91E:  CALL   2CA0
....................                   fprintf(STDOUT, "------------------------------\r\n\r\n" ); 
0D922:  MOVLW  00
0D924:  MOVWF  FF6
0D926:  MOVLW  24
0D928:  MOVWF  FF7
0D92A:  CALL   2CA0
....................                   fprintf(STDOUT, "  bright730=  - set the led 730 brightness \r\n"); 
0D92E:  MOVLW  24
0D930:  MOVWF  FF6
0D932:  MOVLW  24
0D934:  MOVWF  FF7
0D936:  CALL   2CA0
....................                   fprintf(STDOUT, "  bright588=  - set the led 588 brightness \r\n"); 
0D93A:  MOVLW  52
0D93C:  MOVWF  FF6
0D93E:  MOVLW  24
0D940:  MOVWF  FF7
0D942:  CALL   2CA0
....................                   fprintf(STDOUT, "  bright475=  - set the led 475 brightness \r\n"); 
0D946:  MOVLW  80
0D948:  MOVWF  FF6
0D94A:  MOVLW  24
0D94C:  MOVWF  FF7
0D94E:  CALL   2CA0
....................                   fprintf(STDOUT, "  bt          - get the led brightness values \r\n"); 
0D952:  MOVLW  AE
0D954:  MOVWF  FF6
0D956:  MOVLW  24
0D958:  MOVWF  FF7
0D95A:  CALL   2CA0
....................                   fprintf(STDOUT, "  calibrate   - calibrate the unit \r\n"); 
0D95E:  MOVLW  E0
0D960:  MOVWF  FF6
0D962:  MOVLW  24
0D964:  MOVWF  FF7
0D966:  CALL   2CA0
....................                   fprintf(STDOUT, "  ct          - check the cartridge condition \r\n"); 
0D96A:  MOVLW  06
0D96C:  MOVWF  FF6
0D96E:  MOVLW  25
0D970:  MOVWF  FF7
0D972:  CALL   2CA0
....................                   fprintf(STDOUT, "  ft          - perform ketone test \r\n"); 
0D976:  MOVLW  38
0D978:  MOVWF  FF6
0D97A:  MOVLW  25
0D97C:  MOVWF  FF7
0D97E:  CALL   2CA0
....................                   fprintf(STDOUT, "  identify    - identify unit \r\n"); 
0D982:  MOVLW  60
0D984:  MOVWF  FF6
0D986:  MOVLW  25
0D988:  MOVWF  FF7
0D98A:  CALL   2CA0
....................                   fprintf(STDOUT, "  ble.reset   - reset bluetooth \r\n"); 
0D98E:  MOVLW  82
0D990:  MOVWF  FF6
0D992:  MOVLW  25
0D994:  MOVWF  FF7
0D996:  CALL   2CA0
....................                   fprintf(STDOUT, "  intercept=  - set the intercept value \r\n"); 
0D99A:  MOVLW  A6
0D99C:  MOVWF  FF6
0D99E:  MOVLW  25
0D9A0:  MOVWF  FF7
0D9A2:  CALL   2CA0
....................                   fprintf(STDOUT, "  intercept   - get the intercept value \r\n"); 
0D9A6:  MOVLW  D2
0D9A8:  MOVWF  FF6
0D9AA:  MOVLW  25
0D9AC:  MOVWF  FF7
0D9AE:  CALL   2CA0
....................                   fprintf(STDOUT, "  play        - check the sound \r\n"); 
0D9B2:  MOVLW  FE
0D9B4:  MOVWF  FF6
0D9B6:  MOVLW  25
0D9B8:  MOVWF  FF7
0D9BA:  CALL   2CA0
....................                   delay_ms(50); 
0D9BE:  MOVLW  32
0D9C0:  MOVLB  8
0D9C2:  MOVWF  x18
0D9C4:  MOVLB  0
0D9C6:  CALL   2D2E
....................                   fprintf(STDOUT, "  rp          - print all save test results \r\n"); 
0D9CA:  MOVLW  22
0D9CC:  MOVWF  FF6
0D9CE:  MOVLW  26
0D9D0:  MOVWF  FF7
0D9D2:  CALL   2CA0
....................                   fprintf(STDOUT, "  rr          - clear all save test results \r\n"); 
0D9D6:  MOVLW  52
0D9D8:  MOVWF  FF6
0D9DA:  MOVLW  26
0D9DC:  MOVWF  FF7
0D9DE:  CALL   2CA0
....................                   fprintf(STDOUT, "  rs          - auto generate 10 test results for testing purpose  \r\n"); 
0D9E2:  MOVLW  82
0D9E4:  MOVWF  FF6
0D9E6:  MOVLW  26
0D9E8:  MOVWF  FF7
0D9EA:  CALL   2CA0
....................                   fprintf(STDOUT, "  sbv         - set new breath volume \r\n"); 
0D9EE:  MOVLW  C8
0D9F0:  MOVWF  FF6
0D9F2:  MOVLW  26
0D9F4:  MOVWF  FF7
0D9F6:  CALL   2CA0
....................                   fprintf(STDOUT, "  selftest    - perform a self test \r\n"); 
0D9FA:  MOVLW  F2
0D9FC:  MOVWF  FF6
0D9FE:  MOVLW  26
0DA00:  MOVWF  FF7
0DA02:  CALL   2CA0
....................                   fprintf(STDOUT, "  serial=     - set the unit serial number \r\n"); 
0DA06:  MOVLW  1A
0DA08:  MOVWF  FF6
0DA0A:  MOVLW  27
0DA0C:  MOVWF  FF7
0DA0E:  CALL   2CA0
....................                   fprintf(STDOUT, "  serial      - get the unit serial number \r\n"); 
0DA12:  MOVLW  48
0DA14:  MOVWF  FF6
0DA16:  MOVLW  27
0DA18:  MOVWF  FF7
0DA1A:  CALL   2CA0
....................                   fprintf(STDOUT, "  setled      - set the led brightness automatically \r\n"); 
0DA1E:  MOVLW  76
0DA20:  MOVWF  FF6
0DA22:  MOVLW  27
0DA24:  MOVWF  FF7
0DA26:  CALL   2CA0
....................                   fprintf(STDOUT, "  slope=      - set the slope value \r\n"); 
0DA2A:  MOVLW  AE
0DA2C:  MOVWF  FF6
0DA2E:  MOVLW  27
0DA30:  MOVWF  FF7
0DA32:  CALL   2CA0
....................                   fprintf(STDOUT, "  slope       - get the slope value \r\n"); 
0DA36:  MOVLW  D6
0DA38:  MOVWF  FF6
0DA3A:  MOVLW  27
0DA3C:  MOVWF  FF7
0DA3E:  CALL   2CA0
....................                   fprintf(STDOUT, "  time=       - set the time and date \r\n"); 
0DA42:  MOVLW  FE
0DA44:  MOVWF  FF6
0DA46:  MOVLW  27
0DA48:  MOVWF  FF7
0DA4A:  CALL   2CA0
....................                   fprintf(STDOUT, "  voltest     - compute breath volume \r\n"); 
0DA4E:  MOVLW  28
0DA50:  MOVWF  FF6
0DA52:  MOVLW  28
0DA54:  MOVWF  FF7
0DA56:  CALL   2CA0
....................                    
....................                   fprintf(STDOUT, two_new_lines_resp); 
0DA5A:  MOVLW  01
0DA5C:  MOVWF  FEA
0DA5E:  MOVLW  F2
0DA60:  MOVWF  FE9
0DA62:  CALL   2D08
....................                   fprintf(STDOUT, two_new_lines_resp); 
0DA66:  MOVLW  01
0DA68:  MOVWF  FEA
0DA6A:  MOVLW  F2
0DA6C:  MOVWF  FE9
0DA6E:  CALL   2D08
....................                   break; 
0DA72:  GOTO   EF90
....................                } 
....................           
....................                if(strcmp(buffer, (unsigned char *)"voltest") == 0)  
0DA76:  MOVLW  06
0DA78:  MOVWF  FEA
0DA7A:  MOVLW  AE
0DA7C:  MOVWF  FE9
0DA7E:  MOVLW  08
0DA80:  MOVWF  01
0DA82:  CLRF   FF7
0DA84:  MOVLW  00
0DA86:  CALL   00C6
0DA8A:  TBLRD*-
0DA8C:  TBLRD*+
0DA8E:  MOVFF  FF5,FEE
0DA92:  DECFSZ 01,F
0DA94:  BRA    DA8C
0DA96:  MOVLW  05
0DA98:  MOVLB  7
0DA9A:  MOVWF  x06
0DA9C:  MOVLW  91
0DA9E:  MOVWF  x05
0DAA0:  MOVLW  06
0DAA2:  MOVWF  x08
0DAA4:  MOVLW  AE
0DAA6:  MOVWF  x07
0DAA8:  MOVLB  0
0DAAA:  CALL   952E
0DAAE:  MOVF   01,F
0DAB0:  BNZ   DACA
....................                { 
....................                   rslt = Compute_Breath_Volume( &gas_sensor ); 
0DAB2:  MOVLW  04
0DAB4:  MOVLB  7
0DAB6:  MOVWF  x02
0DAB8:  MOVLW  C3
0DABA:  MOVWF  x01
0DABC:  MOVLB  0
0DABE:  GOTO   9D38
0DAC2:  MOVFF  01,58E
....................                   break; 
0DAC6:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"selftest") == 0)  
0DACA:  MOVLW  06
0DACC:  MOVWF  FEA
0DACE:  MOVLW  AE
0DAD0:  MOVWF  FE9
0DAD2:  MOVLW  09
0DAD4:  MOVWF  01
0DAD6:  CLRF   FF7
0DAD8:  MOVLW  00
0DADA:  CALL   00DE
0DADE:  TBLRD*-
0DAE0:  TBLRD*+
0DAE2:  MOVFF  FF5,FEE
0DAE6:  DECFSZ 01,F
0DAE8:  BRA    DAE0
0DAEA:  MOVLW  05
0DAEC:  MOVLB  7
0DAEE:  MOVWF  x06
0DAF0:  MOVLW  91
0DAF2:  MOVWF  x05
0DAF4:  MOVLW  06
0DAF6:  MOVWF  x08
0DAF8:  MOVLW  AE
0DAFA:  MOVWF  x07
0DAFC:  MOVLB  0
0DAFE:  CALL   952E
0DB02:  MOVF   01,F
0DB04:  BNZ   DB0E
....................                { 
....................                   selfTest(); 
0DB06:  CALL   47AE
....................                   break; 
0DB0A:  GOTO   EF90
....................                } 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"identify") == 0)  
0DB0E:  MOVLW  06
0DB10:  MOVWF  FEA
0DB12:  MOVLW  AE
0DB14:  MOVWF  FE9
0DB16:  MOVLW  09
0DB18:  MOVWF  01
0DB1A:  CLRF   FF7
0DB1C:  MOVLW  00
0DB1E:  CALL   00F8
0DB22:  TBLRD*-
0DB24:  TBLRD*+
0DB26:  MOVFF  FF5,FEE
0DB2A:  DECFSZ 01,F
0DB2C:  BRA    DB24
0DB2E:  MOVLW  05
0DB30:  MOVLB  7
0DB32:  MOVWF  x06
0DB34:  MOVLW  91
0DB36:  MOVWF  x05
0DB38:  MOVLW  06
0DB3A:  MOVWF  x08
0DB3C:  MOVLW  AE
0DB3E:  MOVWF  x07
0DB40:  MOVLB  0
0DB42:  CALL   952E
0DB46:  MOVF   01,F
0DB48:  BTFSS  FD8.2
0DB4A:  BRA    DC6C
....................                { 
....................                   fprintf(STDOUT, "Voyager 4.0 Prototype,R%d.%d.%d,", 
....................                      FIRMWARE_VERSION_MAJOR, 
....................                      FIRMWARE_VERSION_MINOR, 
....................                      FIRMWARE_VERSION_REVISION); 
0DB4C:  MOVLW  52
0DB4E:  MOVWF  FF6
0DB50:  MOVLW  28
0DB52:  MOVWF  FF7
0DB54:  CLRF   19
0DB56:  BTFSC  FF2.7
0DB58:  BSF    19.7
0DB5A:  BCF    FF2.7
0DB5C:  MOVLW  17
0DB5E:  MOVLB  9
0DB60:  MOVWF  x66
0DB62:  MOVLB  0
0DB64:  CALL   0AAC
0DB68:  BTFSC  19.7
0DB6A:  BSF    FF2.7
0DB6C:  MOVLB  8
0DB6E:  CLRF   x12
0DB70:  MOVLW  18
0DB72:  MOVWF  x13
0DB74:  MOVLB  0
0DB76:  CALL   2AEC
0DB7A:  MOVLW  2E
0DB7C:  BTFSS  FA4.4
0DB7E:  BRA    DB7C
0DB80:  MOVWF  F73
0DB82:  MOVLW  41
0DB84:  MOVLB  8
0DB86:  MOVWF  x12
0DB88:  MOVLW  18
0DB8A:  MOVWF  x13
0DB8C:  MOVLB  0
0DB8E:  CALL   2AEC
0DB92:  MOVLW  2E
0DB94:  BTFSS  FA4.4
0DB96:  BRA    DB94
0DB98:  MOVWF  F73
0DB9A:  MOVLW  02
0DB9C:  MOVLB  8
0DB9E:  MOVWF  x12
0DBA0:  MOVLW  18
0DBA2:  MOVWF  x13
0DBA4:  MOVLB  0
0DBA6:  CALL   2AEC
0DBAA:  MOVLW  2C
0DBAC:  BTFSS  FA4.4
0DBAE:  BRA    DBAC
0DBB0:  MOVWF  F73
....................  
....................                   uint8 serial[6]; 
....................                   config_serial_get(serial); 
0DBB2:  MOVLW  06
0DBB4:  MOVLB  7
0DBB6:  MOVWF  x26
0DBB8:  MOVLW  C7
0DBBA:  MOVWF  x25
0DBBC:  MOVLB  0
0DBBE:  CALL   2F32
....................     
....................                   for(uint8 i = 0; i < 6; i++)  
0DBC2:  MOVLB  6
0DBC4:  CLRF   xCD
0DBC6:  MOVF   xCD,W
0DBC8:  SUBLW  05
0DBCA:  BNC   DBF0
....................                   { 
....................                      fprintf(STDOUT, "%u", serial[i]); 
0DBCC:  CLRF   03
0DBCE:  MOVF   xCD,W
0DBD0:  ADDLW  C7
0DBD2:  MOVWF  FE9
0DBD4:  MOVLW  06
0DBD6:  ADDWFC 03,W
0DBD8:  MOVWF  FEA
0DBDA:  MOVFF  FEF,813
0DBDE:  MOVLW  1B
0DBE0:  MOVLB  8
0DBE2:  MOVWF  x14
0DBE4:  MOVLB  0
0DBE6:  CALL   39DC
0DBEA:  MOVLB  6
0DBEC:  INCF   xCD,F
0DBEE:  BRA    DBC6
....................                   } 
....................  
....................                   fprintf(STDOUT, ",%2X%2X%2X%2X%2X%2X\r\n", BleModuleId[0], BleModuleId[1], BleModuleId[2], BleModuleId[3], BleModuleId[4], BleModuleId[5]); 
0DBF0:  MOVLW  2C
0DBF2:  BTFSS  FA4.4
0DBF4:  BRA    DBF2
0DBF6:  MOVWF  F73
0DBF8:  MOVFF  34A,74B
0DBFC:  MOVLW  37
0DBFE:  MOVLB  7
0DC00:  MOVWF  x4C
0DC02:  MOVLB  0
0DC04:  CALL   2CC2
0DC08:  MOVFF  34B,74B
0DC0C:  MOVLW  37
0DC0E:  MOVLB  7
0DC10:  MOVWF  x4C
0DC12:  MOVLB  0
0DC14:  CALL   2CC2
0DC18:  MOVFF  34C,74B
0DC1C:  MOVLW  37
0DC1E:  MOVLB  7
0DC20:  MOVWF  x4C
0DC22:  MOVLB  0
0DC24:  CALL   2CC2
0DC28:  MOVFF  34D,74B
0DC2C:  MOVLW  37
0DC2E:  MOVLB  7
0DC30:  MOVWF  x4C
0DC32:  MOVLB  0
0DC34:  CALL   2CC2
0DC38:  MOVFF  34E,74B
0DC3C:  MOVLW  37
0DC3E:  MOVLB  7
0DC40:  MOVWF  x4C
0DC42:  MOVLB  0
0DC44:  CALL   2CC2
0DC48:  MOVFF  34F,74B
0DC4C:  MOVLW  37
0DC4E:  MOVLB  7
0DC50:  MOVWF  x4C
0DC52:  MOVLB  0
0DC54:  CALL   2CC2
0DC58:  MOVLW  0D
0DC5A:  BTFSS  FA4.4
0DC5C:  BRA    DC5A
0DC5E:  MOVWF  F73
0DC60:  MOVLW  0A
0DC62:  BTFSS  FA4.4
0DC64:  BRA    DC62
0DC66:  MOVWF  F73
....................              
....................                   break; 
0DC68:  GOTO   EF90
....................                } 
.................... #ifdef BASE_40 
....................                if(strcmp(buffer, (unsigned char *)"testmode") == 0)  
....................                { 
....................                   if (TestMode == 0)  
....................                   { 
....................                      TestMode = 1; 
....................                      fprintf(STDOUT, "!!!! TEST MODE ACTIVATED !!!!\r\n\r\n"); 
....................                   } 
....................              
....................                   else  
....................                      fprintf(STDOUT, "[ERROR] Already in TEST MODE!\r\n"); 
....................                 
....................                   break; 
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"normalmode") == 0)  
....................                { 
....................                   if (TestMode != 0)  
....................                   { 
....................                      TestMode = 0; 
....................                      fprintf(STDOUT, "Back to normal operating mode\r\n\r\n"); 
....................                   } 
....................                 
....................                   else  
....................                   { 
....................                      fprintf(STDOUT, "[ERROR] TEST MODE was not active!\r\n"); 
....................                   }   
....................                 
....................                   break; 
....................                } 
.................... #endif                
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"ble.reset") == 0)  
0DC6C:  MOVLW  06
0DC6E:  MOVWF  FEA
0DC70:  MOVLW  AE
0DC72:  MOVWF  FE9
0DC74:  MOVLW  0A
0DC76:  MOVWF  01
0DC78:  CLRF   FF7
0DC7A:  MOVLW  00
0DC7C:  CALL   0112
0DC80:  TBLRD*-
0DC82:  TBLRD*+
0DC84:  MOVFF  FF5,FEE
0DC88:  DECFSZ 01,F
0DC8A:  BRA    DC82
0DC8C:  MOVLW  05
0DC8E:  MOVLB  7
0DC90:  MOVWF  x06
0DC92:  MOVLW  91
0DC94:  MOVWF  x05
0DC96:  MOVLW  06
0DC98:  MOVWF  x08
0DC9A:  MOVLW  AE
0DC9C:  MOVWF  x07
0DC9E:  MOVLB  0
0DCA0:  CALL   952E
0DCA4:  MOVF   01,F
0DCA6:  BNZ   DCBC
....................                { 
....................                   ble_configure(); 
0DCA8:  CALL   2F72
....................                   fprintf(STDOUT, "BLE Re-Activated\r\n"); 
0DCAC:  MOVLW  74
0DCAE:  MOVWF  FF6
0DCB0:  MOVLW  28
0DCB2:  MOVWF  FF7
0DCB4:  CALL   2CA0
....................                   break; 
0DCB8:  GOTO   EF90
....................                } 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"sbv") == 0)  
0DCBC:  MOVLW  73
0DCBE:  MOVLB  6
0DCC0:  MOVWF  xAE
0DCC2:  MOVLW  62
0DCC4:  MOVWF  xAF
0DCC6:  MOVLW  76
0DCC8:  MOVWF  xB0
0DCCA:  CLRF   xB1
0DCCC:  MOVLW  05
0DCCE:  MOVLB  7
0DCD0:  MOVWF  x06
0DCD2:  MOVLW  91
0DCD4:  MOVWF  x05
0DCD6:  MOVLW  06
0DCD8:  MOVWF  x08
0DCDA:  MOVLW  AE
0DCDC:  MOVWF  x07
0DCDE:  MOVLB  0
0DCE0:  CALL   952E
0DCE4:  MOVF   01,F
0DCE6:  BNZ   DDA4
....................                { 
....................                   tmpValue = get_Int16(); 
0DCE8:  CALL   C226
0DCEC:  MOVFF  02,590
0DCF0:  MOVFF  01,58F
....................                   fprintf(STDOUT, "\r\nReset breath volume new value : %ld \r\n", tmpValue ); 
0DCF4:  MOVLW  88
0DCF6:  MOVWF  FF6
0DCF8:  MOVLW  28
0DCFA:  MOVWF  FF7
0DCFC:  CLRF   19
0DCFE:  BTFSC  FF2.7
0DD00:  BSF    19.7
0DD02:  BCF    FF2.7
0DD04:  MOVLW  22
0DD06:  MOVLB  9
0DD08:  MOVWF  x66
0DD0A:  MOVLB  0
0DD0C:  CALL   0AAC
0DD10:  BTFSC  19.7
0DD12:  BSF    FF2.7
0DD14:  MOVLW  10
0DD16:  MOVWF  FE9
0DD18:  MOVFF  590,74C
0DD1C:  MOVFF  58F,74B
0DD20:  CALL   3C60
0DD24:  MOVLW  AD
0DD26:  MOVWF  FF6
0DD28:  MOVLW  28
0DD2A:  MOVWF  FF7
0DD2C:  CLRF   19
0DD2E:  BTFSC  FF2.7
0DD30:  BSF    19.7
0DD32:  BCF    FF2.7
0DD34:  MOVLW  03
0DD36:  MOVLB  9
0DD38:  MOVWF  x66
0DD3A:  MOVLB  0
0DD3C:  CALL   0AAC
0DD40:  BTFSC  19.7
0DD42:  BSF    FF2.7
....................                   setBreathVolume( tmpValue ); 
0DD44:  MOVFF  590,71B
0DD48:  MOVFF  58F,71A
0DD4C:  CALL   3BA8
....................                   fprintf(STDOUT, "\r\nBreath volume settings: %ld \r\n", breathVolume ); 
0DD50:  MOVLW  B2
0DD52:  MOVWF  FF6
0DD54:  MOVLW  28
0DD56:  MOVWF  FF7
0DD58:  CLRF   19
0DD5A:  BTFSC  FF2.7
0DD5C:  BSF    19.7
0DD5E:  BCF    FF2.7
0DD60:  MOVLW  1A
0DD62:  MOVLB  9
0DD64:  MOVWF  x66
0DD66:  MOVLB  0
0DD68:  CALL   0AAC
0DD6C:  BTFSC  19.7
0DD6E:  BSF    FF2.7
0DD70:  MOVLW  10
0DD72:  MOVWF  FE9
0DD74:  MOVFF  204,74C
0DD78:  MOVFF  203,74B
0DD7C:  CALL   3C60
0DD80:  MOVLW  CF
0DD82:  MOVWF  FF6
0DD84:  MOVLW  28
0DD86:  MOVWF  FF7
0DD88:  CLRF   19
0DD8A:  BTFSC  FF2.7
0DD8C:  BSF    19.7
0DD8E:  BCF    FF2.7
0DD90:  MOVLW  03
0DD92:  MOVLB  9
0DD94:  MOVWF  x66
0DD96:  MOVLB  0
0DD98:  CALL   0AAC
0DD9C:  BTFSC  19.7
0DD9E:  BSF    FF2.7
....................                   break; 
0DDA0:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
.................... #ifdef BASE_40 
....................                if(strcmp(buffer, (unsigned char *)"temperature") == 0)  
....................                { 
.................... //                ShowTemperature(); 
....................                   break; 
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"ble.address") == 0)  
....................                { 
....................                   fprintf(STDOUT, "\r\nBLE Address = %2X%2X%2X%2X%2X%2X\r\n", BleModuleId[0], BleModuleId[1], BleModuleId[2], BleModuleId[3], BleModuleId[4], BleModuleId[5]); 
....................                   break; 
....................                } 
.................... #endif 
....................  
....................                if(strcmp(buffer, (unsigned char *)"serial=") == 0)  
0DDA4:  MOVLW  06
0DDA6:  MOVWF  FEA
0DDA8:  MOVLW  AE
0DDAA:  MOVWF  FE9
0DDAC:  MOVLW  08
0DDAE:  MOVWF  01
0DDB0:  CLRF   FF7
0DDB2:  MOVLW  00
0DDB4:  CALL   012C
0DDB8:  TBLRD*-
0DDBA:  TBLRD*+
0DDBC:  MOVFF  FF5,FEE
0DDC0:  DECFSZ 01,F
0DDC2:  BRA    DDBA
0DDC4:  MOVLW  05
0DDC6:  MOVLB  7
0DDC8:  MOVWF  x06
0DDCA:  MOVLW  91
0DDCC:  MOVWF  x05
0DDCE:  MOVLW  06
0DDD0:  MOVWF  x08
0DDD2:  MOVLW  AE
0DDD4:  MOVWF  x07
0DDD6:  MOVLB  0
0DDD8:  CALL   952E
0DDDC:  MOVF   01,F
0DDDE:  BNZ   DE8C
....................                { 
....................                   uint8 serial[6]; 
....................  
....................                   for(uint8 i = 0; i < 6; i++)  
0DDE0:  MOVLB  6
0DDE2:  CLRF   xD4
0DDE4:  MOVF   xD4,W
0DDE6:  SUBLW  05
0DDE8:  BNC   DE68
....................                   { 
....................                      fprintf(STDOUT, "\r\nSerial %u of 6: ", i); 
0DDEA:  MOVLW  D4
0DDEC:  MOVWF  FF6
0DDEE:  MOVLW  28
0DDF0:  MOVWF  FF7
0DDF2:  CLRF   19
0DDF4:  BTFSC  FF2.7
0DDF6:  BSF    19.7
0DDF8:  BCF    FF2.7
0DDFA:  MOVLW  09
0DDFC:  MOVLB  9
0DDFE:  MOVWF  x66
0DE00:  MOVLB  0
0DE02:  CALL   0AAC
0DE06:  BTFSC  19.7
0DE08:  BSF    FF2.7
0DE0A:  MOVFF  6D4,813
0DE0E:  MOVLW  1B
0DE10:  MOVLB  8
0DE12:  MOVWF  x14
0DE14:  MOVLB  0
0DE16:  CALL   39DC
0DE1A:  MOVLW  DF
0DE1C:  MOVWF  FF6
0DE1E:  MOVLW  28
0DE20:  MOVWF  FF7
0DE22:  CLRF   19
0DE24:  BTFSC  FF2.7
0DE26:  BSF    19.7
0DE28:  BCF    FF2.7
0DE2A:  MOVLW  07
0DE2C:  MOVLB  9
0DE2E:  MOVWF  x66
0DE30:  MOVLB  0
0DE32:  CALL   0AAC
0DE36:  BTFSC  19.7
0DE38:  BSF    FF2.7
....................                      serial[i] = get_Int8(); 
0DE3A:  CLRF   03
0DE3C:  MOVLB  6
0DE3E:  MOVF   xD4,W
0DE40:  ADDLW  CE
0DE42:  MOVWF  01
0DE44:  MOVLW  06
0DE46:  ADDWFC 03,F
0DE48:  MOVFF  01,701
0DE4C:  MOVFF  03,702
0DE50:  MOVLB  0
0DE52:  CALL   C42A
0DE56:  MOVFF  702,FEA
0DE5A:  MOVFF  701,FE9
0DE5E:  MOVFF  01,FEF
0DE62:  MOVLB  6
0DE64:  INCF   xD4,F
0DE66:  BRA    DDE4
....................                   } 
....................  
....................                   fprintf(STDOUT, "\r\n"); 
0DE68:  MOVLW  0D
0DE6A:  BTFSS  FA4.4
0DE6C:  BRA    DE6A
0DE6E:  MOVWF  F73
0DE70:  MOVLW  0A
0DE72:  BTFSS  FA4.4
0DE74:  BRA    DE72
0DE76:  MOVWF  F73
....................                   config_serial_set(serial); 
0DE78:  MOVLW  06
0DE7A:  MOVLB  7
0DE7C:  MOVWF  x02
0DE7E:  MOVLW  CE
0DE80:  MOVWF  x01
0DE82:  MOVLB  0
0DE84:  GOTO   C458
....................                   break; 
0DE88:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"serial") == 0)  
0DE8C:  MOVLW  06
0DE8E:  MOVWF  FEA
0DE90:  MOVLW  AE
0DE92:  MOVWF  FE9
0DE94:  MOVLW  07
0DE96:  MOVWF  01
0DE98:  CLRF   FF7
0DE9A:  MOVLW  00
0DE9C:  CALL   0144
0DEA0:  TBLRD*-
0DEA2:  TBLRD*+
0DEA4:  MOVFF  FF5,FEE
0DEA8:  DECFSZ 01,F
0DEAA:  BRA    DEA2
0DEAC:  MOVLW  05
0DEAE:  MOVLB  7
0DEB0:  MOVWF  x06
0DEB2:  MOVLW  91
0DEB4:  MOVWF  x05
0DEB6:  MOVLW  06
0DEB8:  MOVWF  x08
0DEBA:  MOVLW  AE
0DEBC:  MOVWF  x07
0DEBE:  MOVLB  0
0DEC0:  CALL   952E
0DEC4:  MOVF   01,F
0DEC6:  BNZ   DF28
....................                { 
....................                   uint8 serial[6]; 
....................                   config_serial_get(serial); 
0DEC8:  MOVLW  06
0DECA:  MOVLB  7
0DECC:  MOVWF  x26
0DECE:  MOVLW  D5
0DED0:  MOVWF  x25
0DED2:  MOVLB  0
0DED4:  CALL   2F32
....................                   fprintf(STDOUT, "Serial: "); 
0DED8:  MOVLW  E8
0DEDA:  MOVWF  FF6
0DEDC:  MOVLW  28
0DEDE:  MOVWF  FF7
0DEE0:  CALL   2CA0
....................                    
....................                   for(uint8 i = 0; i < 6; i++)  
0DEE4:  MOVLB  6
0DEE6:  CLRF   xDB
0DEE8:  MOVF   xDB,W
0DEEA:  SUBLW  05
0DEEC:  BNC   DF12
....................                      fprintf(STDOUT, "%u", serial[i]); 
0DEEE:  CLRF   03
0DEF0:  MOVF   xDB,W
0DEF2:  ADDLW  D5
0DEF4:  MOVWF  FE9
0DEF6:  MOVLW  06
0DEF8:  ADDWFC 03,W
0DEFA:  MOVWF  FEA
0DEFC:  MOVFF  FEF,813
0DF00:  MOVLW  1B
0DF02:  MOVLB  8
0DF04:  MOVWF  x14
0DF06:  MOVLB  0
0DF08:  CALL   39DC
0DF0C:  MOVLB  6
0DF0E:  INCF   xDB,F
0DF10:  BRA    DEE8
....................  
....................                   fprintf(STDOUT, "\r\n"); 
0DF12:  MOVLW  0D
0DF14:  BTFSS  FA4.4
0DF16:  BRA    DF14
0DF18:  MOVWF  F73
0DF1A:  MOVLW  0A
0DF1C:  BTFSS  FA4.4
0DF1E:  BRA    DF1C
0DF20:  MOVWF  F73
....................                   break; 
0DF22:  MOVLB  0
0DF24:  GOTO   EF90
....................                } 
....................  
....................         //////////////////////////////////////////////// 
.................... #ifdef BASE_40 
....................                if(strcmp(buffer, (unsigned char *)"mouthpiece") == 0)  
....................                {   
....................                   config_mouthpiece_get(); 
....................                   break; 
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"mouthpiece=") == 0)  
....................                { 
....................                   fprintf(STDOUT, "Mouthpiece Uses: "); 
....................                   uint8 value = get_Int8(); 
....................                   config_mouthpiece_set(value); 
....................                   fprintf(STDOUT, "\r\n"); 
....................                   break; 
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"mouthpiece+") == 0)  
....................                { 
....................                   config_mouthpiece_increment(); 
....................                   fprintf(STDOUT, "Mouthpiece Uses Incremented\r\n"); 
....................                   break; 
....................                } 
.................... #endif         
....................         //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"intercept=") == 0)  
0DF28:  MOVLW  06
0DF2A:  MOVWF  FEA
0DF2C:  MOVLW  AE
0DF2E:  MOVWF  FE9
0DF30:  MOVLW  0B
0DF32:  MOVWF  01
0DF34:  CLRF   FF7
0DF36:  MOVLW  00
0DF38:  CALL   015C
0DF3C:  TBLRD*-
0DF3E:  TBLRD*+
0DF40:  MOVFF  FF5,FEE
0DF44:  DECFSZ 01,F
0DF46:  BRA    DF3E
0DF48:  MOVLW  05
0DF4A:  MOVLB  7
0DF4C:  MOVWF  x06
0DF4E:  MOVLW  91
0DF50:  MOVWF  x05
0DF52:  MOVLW  06
0DF54:  MOVWF  x08
0DF56:  MOVLW  AE
0DF58:  MOVWF  x07
0DF5A:  MOVLB  0
0DF5C:  CALL   952E
0DF60:  MOVF   01,F
0DF62:  BNZ   DFA6
....................                { 
....................                   ConfigWriteFloat(CONFIG_INTERCEPT, prompt_float()); 
0DF64:  CALL   C7B4
0DF68:  MOVFF  03,704
0DF6C:  MOVFF  02,703
0DF70:  MOVFF  01,702
0DF74:  MOVFF  00,701
0DF78:  CLRF   19
0DF7A:  BTFSC  FF2.7
0DF7C:  BSF    19.7
0DF7E:  BCF    FF2.7
0DF80:  MOVLB  9
0DF82:  CLRF   x6B
0DF84:  MOVLW  0E
0DF86:  MOVWF  x6A
0DF88:  MOVFF  03,96F
0DF8C:  MOVFF  02,96E
0DF90:  MOVFF  01,96D
0DF94:  MOVFF  00,96C
0DF98:  MOVLB  0
0DF9A:  CALL   0A60
0DF9E:  BTFSC  19.7
0DFA0:  BSF    FF2.7
....................                   break; 
0DFA2:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"intercept") == 0)  
0DFA6:  MOVLW  06
0DFA8:  MOVWF  FEA
0DFAA:  MOVLW  AE
0DFAC:  MOVWF  FE9
0DFAE:  MOVLW  0A
0DFB0:  MOVWF  01
0DFB2:  CLRF   FF7
0DFB4:  MOVLW  00
0DFB6:  CALL   0178
0DFBA:  TBLRD*-
0DFBC:  TBLRD*+
0DFBE:  MOVFF  FF5,FEE
0DFC2:  DECFSZ 01,F
0DFC4:  BRA    DFBC
0DFC6:  MOVLW  05
0DFC8:  MOVLB  7
0DFCA:  MOVWF  x06
0DFCC:  MOVLW  91
0DFCE:  MOVWF  x05
0DFD0:  MOVLW  06
0DFD2:  MOVWF  x08
0DFD4:  MOVLW  AE
0DFD6:  MOVWF  x07
0DFD8:  MOVLB  0
0DFDA:  CALL   952E
0DFDE:  MOVF   01,F
0DFE0:  BNZ   E054
....................                { 
....................                   fprintf(STDOUT, "Intercept: %.3f\r\n", ConfigReadFloat(CONFIG_INTERCEPT)); 
0DFE2:  MOVLB  7
0DFE4:  CLRF   x54
0DFE6:  MOVLW  0E
0DFE8:  MOVWF  x53
0DFEA:  MOVLB  0
0DFEC:  CALL   3B00
0DFF0:  MOVFF  03,704
0DFF4:  MOVFF  02,703
0DFF8:  MOVFF  01,702
0DFFC:  MOVFF  00,701
0E000:  MOVLW  F2
0E002:  MOVWF  FF6
0E004:  MOVLW  28
0E006:  MOVWF  FF7
0E008:  CLRF   19
0E00A:  BTFSC  FF2.7
0E00C:  BSF    19.7
0E00E:  BCF    FF2.7
0E010:  MOVLW  0B
0E012:  MOVLB  9
0E014:  MOVWF  x66
0E016:  MOVLB  0
0E018:  CALL   0AAC
0E01C:  BTFSC  19.7
0E01E:  BSF    FF2.7
0E020:  MOVLW  89
0E022:  MOVWF  FE9
0E024:  MOVFF  704,815
0E028:  MOVFF  703,814
0E02C:  MOVFF  702,813
0E030:  MOVFF  701,812
0E034:  MOVLW  03
0E036:  MOVLB  8
0E038:  MOVWF  x16
0E03A:  MOVLB  0
0E03C:  CALL   40FE
0E040:  MOVLW  0D
0E042:  BTFSS  FA4.4
0E044:  BRA    E042
0E046:  MOVWF  F73
0E048:  MOVLW  0A
0E04A:  BTFSS  FA4.4
0E04C:  BRA    E04A
0E04E:  MOVWF  F73
....................                   break; 
0E050:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"slope=") == 0)  
0E054:  MOVLW  06
0E056:  MOVWF  FEA
0E058:  MOVLW  AE
0E05A:  MOVWF  FE9
0E05C:  MOVLW  07
0E05E:  MOVWF  01
0E060:  CLRF   FF7
0E062:  MOVLW  00
0E064:  CALL   0192
0E068:  TBLRD*-
0E06A:  TBLRD*+
0E06C:  MOVFF  FF5,FEE
0E070:  DECFSZ 01,F
0E072:  BRA    E06A
0E074:  MOVLW  05
0E076:  MOVLB  7
0E078:  MOVWF  x06
0E07A:  MOVLW  91
0E07C:  MOVWF  x05
0E07E:  MOVLW  06
0E080:  MOVWF  x08
0E082:  MOVLW  AE
0E084:  MOVWF  x07
0E086:  MOVLB  0
0E088:  CALL   952E
0E08C:  MOVF   01,F
0E08E:  BNZ   E0D2
....................                { 
....................                   ConfigWriteFloat(CONFIG_SLOPE, prompt_float()); 
0E090:  CALL   C7B4
0E094:  MOVFF  03,704
0E098:  MOVFF  02,703
0E09C:  MOVFF  01,702
0E0A0:  MOVFF  00,701
0E0A4:  CLRF   19
0E0A6:  BTFSC  FF2.7
0E0A8:  BSF    19.7
0E0AA:  BCF    FF2.7
0E0AC:  MOVLB  9
0E0AE:  CLRF   x6B
0E0B0:  MOVLW  0A
0E0B2:  MOVWF  x6A
0E0B4:  MOVFF  03,96F
0E0B8:  MOVFF  02,96E
0E0BC:  MOVFF  01,96D
0E0C0:  MOVFF  00,96C
0E0C4:  MOVLB  0
0E0C6:  CALL   0A60
0E0CA:  BTFSC  19.7
0E0CC:  BSF    FF2.7
....................                   break; 
0E0CE:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"slope") == 0)  
0E0D2:  MOVLW  73
0E0D4:  MOVLB  6
0E0D6:  MOVWF  xAE
0E0D8:  MOVLW  6C
0E0DA:  MOVWF  xAF
0E0DC:  MOVLW  6F
0E0DE:  MOVWF  xB0
0E0E0:  MOVLW  70
0E0E2:  MOVWF  xB1
0E0E4:  MOVLW  65
0E0E6:  MOVWF  xB2
0E0E8:  CLRF   xB3
0E0EA:  MOVLW  05
0E0EC:  MOVLB  7
0E0EE:  MOVWF  x06
0E0F0:  MOVLW  91
0E0F2:  MOVWF  x05
0E0F4:  MOVLW  06
0E0F6:  MOVWF  x08
0E0F8:  MOVLW  AE
0E0FA:  MOVWF  x07
0E0FC:  MOVLB  0
0E0FE:  CALL   952E
0E102:  MOVF   01,F
0E104:  BNZ   E178
....................                { 
....................                   fprintf(STDOUT, "Slope: %.3f\r\n", ConfigReadFloat(CONFIG_SLOPE)); 
0E106:  MOVLB  7
0E108:  CLRF   x54
0E10A:  MOVLW  0A
0E10C:  MOVWF  x53
0E10E:  MOVLB  0
0E110:  CALL   3B00
0E114:  MOVFF  03,704
0E118:  MOVFF  02,703
0E11C:  MOVFF  01,702
0E120:  MOVFF  00,701
0E124:  MOVLW  04
0E126:  MOVWF  FF6
0E128:  MOVLW  29
0E12A:  MOVWF  FF7
0E12C:  CLRF   19
0E12E:  BTFSC  FF2.7
0E130:  BSF    19.7
0E132:  BCF    FF2.7
0E134:  MOVLW  07
0E136:  MOVLB  9
0E138:  MOVWF  x66
0E13A:  MOVLB  0
0E13C:  CALL   0AAC
0E140:  BTFSC  19.7
0E142:  BSF    FF2.7
0E144:  MOVLW  89
0E146:  MOVWF  FE9
0E148:  MOVFF  704,815
0E14C:  MOVFF  703,814
0E150:  MOVFF  702,813
0E154:  MOVFF  701,812
0E158:  MOVLW  03
0E15A:  MOVLB  8
0E15C:  MOVWF  x16
0E15E:  MOVLB  0
0E160:  CALL   40FE
0E164:  MOVLW  0D
0E166:  BTFSS  FA4.4
0E168:  BRA    E166
0E16A:  MOVWF  F73
0E16C:  MOVLW  0A
0E16E:  BTFSS  FA4.4
0E170:  BRA    E16E
0E172:  MOVWF  F73
....................                   break; 
0E174:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"config.enable.dynamicwb") == 0)  
0E178:  MOVLW  06
0E17A:  MOVWF  FEA
0E17C:  MOVLW  AE
0E17E:  MOVWF  FE9
0E180:  MOVLW  18
0E182:  MOVWF  01
0E184:  CLRF   FF7
0E186:  MOVLW  00
0E188:  CALL   01AA
0E18C:  TBLRD*-
0E18E:  TBLRD*+
0E190:  MOVFF  FF5,FEE
0E194:  DECFSZ 01,F
0E196:  BRA    E18E
0E198:  MOVLW  05
0E19A:  MOVLB  7
0E19C:  MOVWF  x06
0E19E:  MOVLW  91
0E1A0:  MOVWF  x05
0E1A2:  MOVLW  06
0E1A4:  MOVWF  x08
0E1A6:  MOVLW  AE
0E1A8:  MOVWF  x07
0E1AA:  MOVLB  0
0E1AC:  CALL   952E
0E1B0:  MOVF   01,F
0E1B2:  BNZ   E1D6
0E1B4:  CLRF   19
0E1B6:  BTFSC  FF2.7
0E1B8:  BSF    19.7
0E1BA:  BCF    FF2.7
....................                { 
....................                   write_ext_eeprom(CONFIG_DYNAMIC_WHITEBALANCE_ENABLED, 1); 
0E1BC:  MOVLB  9
0E1BE:  CLRF   x75
0E1C0:  MOVLW  22
0E1C2:  MOVWF  x74
0E1C4:  MOVLW  01
0E1C6:  MOVWF  x76
0E1C8:  MOVLB  0
0E1CA:  CALL   09EC
0E1CE:  BTFSC  19.7
0E1D0:  BSF    FF2.7
....................                   break; 
0E1D2:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"config.disable.dynamicwb") == 0)  
0E1D6:  MOVLW  06
0E1D8:  MOVWF  FEA
0E1DA:  MOVLW  AE
0E1DC:  MOVWF  FE9
0E1DE:  MOVLW  19
0E1E0:  MOVWF  01
0E1E2:  CLRF   FF7
0E1E4:  MOVLW  00
0E1E6:  CALL   01D2
0E1EA:  TBLRD*-
0E1EC:  TBLRD*+
0E1EE:  MOVFF  FF5,FEE
0E1F2:  DECFSZ 01,F
0E1F4:  BRA    E1EC
0E1F6:  MOVLW  05
0E1F8:  MOVLB  7
0E1FA:  MOVWF  x06
0E1FC:  MOVLW  91
0E1FE:  MOVWF  x05
0E200:  MOVLW  06
0E202:  MOVWF  x08
0E204:  MOVLW  AE
0E206:  MOVWF  x07
0E208:  MOVLB  0
0E20A:  CALL   952E
0E20E:  MOVF   01,F
0E210:  BNZ   E232
0E212:  CLRF   19
0E214:  BTFSC  FF2.7
0E216:  BSF    19.7
0E218:  BCF    FF2.7
....................                { 
....................                   write_ext_eeprom(CONFIG_DYNAMIC_WHITEBALANCE_ENABLED, 0); 
0E21A:  MOVLB  9
0E21C:  CLRF   x75
0E21E:  MOVLW  22
0E220:  MOVWF  x74
0E222:  CLRF   x76
0E224:  MOVLB  0
0E226:  CALL   09EC
0E22A:  BTFSC  19.7
0E22C:  BSF    FF2.7
....................                   break; 
0E22E:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"config.check.dynamicwb") == 0)  
0E232:  MOVLW  06
0E234:  MOVWF  FEA
0E236:  MOVLW  AE
0E238:  MOVWF  FE9
0E23A:  MOVLW  17
0E23C:  MOVWF  01
0E23E:  CLRF   FF7
0E240:  MOVLW  00
0E242:  CALL   01FC
0E246:  TBLRD*-
0E248:  TBLRD*+
0E24A:  MOVFF  FF5,FEE
0E24E:  DECFSZ 01,F
0E250:  BRA    E248
0E252:  MOVLW  05
0E254:  MOVLB  7
0E256:  MOVWF  x06
0E258:  MOVLW  91
0E25A:  MOVWF  x05
0E25C:  MOVLW  06
0E25E:  MOVWF  x08
0E260:  MOVLW  AE
0E262:  MOVWF  x07
0E264:  MOVLB  0
0E266:  CALL   952E
0E26A:  MOVF   01,F
0E26C:  BNZ   E2C4
....................                { 
....................                   fprintf(STDOUT, "Dyanamic White Balance Enabled: %d\r\n", read_ext_eeprom(CONFIG_DYNAMIC_WHITEBALANCE_ENABLED)); 
0E26E:  MOVLB  7
0E270:  CLRF   x5F
0E272:  MOVLW  22
0E274:  MOVWF  x5E
0E276:  MOVLB  0
0E278:  CALL   2C1A
0E27C:  MOVFF  01,701
0E280:  MOVLW  12
0E282:  MOVWF  FF6
0E284:  MOVLW  29
0E286:  MOVWF  FF7
0E288:  CLRF   19
0E28A:  BTFSC  FF2.7
0E28C:  BSF    19.7
0E28E:  BCF    FF2.7
0E290:  MOVLW  20
0E292:  MOVLB  9
0E294:  MOVWF  x66
0E296:  MOVLB  0
0E298:  CALL   0AAC
0E29C:  BTFSC  19.7
0E29E:  BSF    FF2.7
0E2A0:  MOVFF  701,812
0E2A4:  MOVLW  18
0E2A6:  MOVLB  8
0E2A8:  MOVWF  x13
0E2AA:  MOVLB  0
0E2AC:  CALL   2AEC
0E2B0:  MOVLW  0D
0E2B2:  BTFSS  FA4.4
0E2B4:  BRA    E2B2
0E2B6:  MOVWF  F73
0E2B8:  MOVLW  0A
0E2BA:  BTFSS  FA4.4
0E2BC:  BRA    E2BA
0E2BE:  MOVWF  F73
....................                   break; 
0E2C0:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
.................... #ifdef BASE_40 
....................                if(strcmp(buffer, (unsigned char *)"reading.new") == 0)  
....................                { 
....................                   fprintf(STDOUT, "Reading Value: "); 
....................                   float32 value = get_float(); 
....................  
....................                   testResult.score = f_PICtoIEEE(value); 
....................                   testResult.stepID = FULLTEST_UNKNOWN; 
....................                   reading_save( &testResult, &cmdReceived.time ); 
....................  
....................                   fprintf(STDOUT, "\r\n"); 
....................                   break; 
....................                } 
.................... #endif 
....................                if( (strcmp(buffer, (unsigned char *)"reading.simulate") == 0) || (strcmp(buffer, (unsigned char *)"rs") == 0) ) 
0E2C4:  MOVLW  06
0E2C6:  MOVWF  FEA
0E2C8:  MOVLW  AE
0E2CA:  MOVWF  FE9
0E2CC:  MOVLW  11
0E2CE:  MOVWF  01
0E2D0:  CLRF   FF7
0E2D2:  MOVLW  00
0E2D4:  CALL   0224
0E2D8:  TBLRD*-
0E2DA:  TBLRD*+
0E2DC:  MOVFF  FF5,FEE
0E2E0:  DECFSZ 01,F
0E2E2:  BRA    E2DA
0E2E4:  MOVLW  05
0E2E6:  MOVLB  7
0E2E8:  MOVWF  x06
0E2EA:  MOVLW  91
0E2EC:  MOVWF  x05
0E2EE:  MOVLW  06
0E2F0:  MOVWF  x08
0E2F2:  MOVLW  AE
0E2F4:  MOVWF  x07
0E2F6:  MOVLB  0
0E2F8:  CALL   952E
0E2FC:  MOVF   01,F
0E2FE:  BZ    E328
0E300:  MOVLW  72
0E302:  MOVLB  6
0E304:  MOVWF  xAE
0E306:  MOVLW  73
0E308:  MOVWF  xAF
0E30A:  CLRF   xB0
0E30C:  MOVLW  05
0E30E:  MOVLB  7
0E310:  MOVWF  x06
0E312:  MOVLW  91
0E314:  MOVWF  x05
0E316:  MOVLW  06
0E318:  MOVWF  x08
0E31A:  MOVLW  AE
0E31C:  MOVWF  x07
0E31E:  MOVLB  0
0E320:  CALL   952E
0E324:  MOVF   01,F
0E326:  BNZ   E340
....................                { 
....................  
....................                   reading_simulate(); 
0E328:  GOTO   C834
....................                   fprintf(STDOUT, "\r\n"); 
0E32C:  MOVLW  0D
0E32E:  BTFSS  FA4.4
0E330:  BRA    E32E
0E332:  MOVWF  F73
0E334:  MOVLW  0A
0E336:  BTFSS  FA4.4
0E338:  BRA    E336
0E33A:  MOVWF  F73
....................                   break; 
0E33C:  GOTO   EF90
....................                } 
....................  
....................                if( (strcmp(buffer, (unsigned char *)"readings.print") == 0) || (strcmp(buffer, (unsigned char *)"rp") == 0) ) 
0E340:  MOVLW  06
0E342:  MOVWF  FEA
0E344:  MOVLW  AE
0E346:  MOVWF  FE9
0E348:  MOVLW  0F
0E34A:  MOVWF  01
0E34C:  CLRF   FF7
0E34E:  MOVLW  00
0E350:  CALL   0246
0E354:  TBLRD*-
0E356:  TBLRD*+
0E358:  MOVFF  FF5,FEE
0E35C:  DECFSZ 01,F
0E35E:  BRA    E356
0E360:  MOVLW  05
0E362:  MOVLB  7
0E364:  MOVWF  x06
0E366:  MOVLW  91
0E368:  MOVWF  x05
0E36A:  MOVLW  06
0E36C:  MOVWF  x08
0E36E:  MOVLW  AE
0E370:  MOVWF  x07
0E372:  MOVLB  0
0E374:  CALL   952E
0E378:  MOVF   01,F
0E37A:  BZ    E3A4
0E37C:  MOVLW  72
0E37E:  MOVLB  6
0E380:  MOVWF  xAE
0E382:  MOVLW  70
0E384:  MOVWF  xAF
0E386:  CLRF   xB0
0E388:  MOVLW  05
0E38A:  MOVLB  7
0E38C:  MOVWF  x06
0E38E:  MOVLW  91
0E390:  MOVWF  x05
0E392:  MOVLW  06
0E394:  MOVWF  x08
0E396:  MOVLW  AE
0E398:  MOVWF  x07
0E39A:  MOVLB  0
0E39C:  CALL   952E
0E3A0:  MOVF   01,F
0E3A2:  BNZ   E3AC
....................                { 
....................                   readings_print(); 
0E3A4:  GOTO   CAEE
....................                   break; 
0E3A8:  GOTO   EF90
....................                }   
....................  
....................                if( (strcmp(buffer, (unsigned char *)"readings.reset") == 0) || (strcmp(buffer, (unsigned char *)"rr") == 0) ) 
0E3AC:  MOVLW  06
0E3AE:  MOVWF  FEA
0E3B0:  MOVLW  AE
0E3B2:  MOVWF  FE9
0E3B4:  MOVLW  0F
0E3B6:  MOVWF  01
0E3B8:  CLRF   FF7
0E3BA:  MOVLW  00
0E3BC:  CALL   0266
0E3C0:  TBLRD*-
0E3C2:  TBLRD*+
0E3C4:  MOVFF  FF5,FEE
0E3C8:  DECFSZ 01,F
0E3CA:  BRA    E3C2
0E3CC:  MOVLW  05
0E3CE:  MOVLB  7
0E3D0:  MOVWF  x06
0E3D2:  MOVLW  91
0E3D4:  MOVWF  x05
0E3D6:  MOVLW  06
0E3D8:  MOVWF  x08
0E3DA:  MOVLW  AE
0E3DC:  MOVWF  x07
0E3DE:  MOVLB  0
0E3E0:  CALL   952E
0E3E4:  MOVF   01,F
0E3E6:  BZ    E40E
0E3E8:  MOVLW  72
0E3EA:  MOVLB  6
0E3EC:  MOVWF  xAE
0E3EE:  MOVWF  xAF
0E3F0:  CLRF   xB0
0E3F2:  MOVLW  05
0E3F4:  MOVLB  7
0E3F6:  MOVWF  x06
0E3F8:  MOVLW  91
0E3FA:  MOVWF  x05
0E3FC:  MOVLW  06
0E3FE:  MOVWF  x08
0E400:  MOVLW  AE
0E402:  MOVWF  x07
0E404:  MOVLB  0
0E406:  CALL   952E
0E40A:  MOVF   01,F
0E40C:  BNZ   E422
....................                { 
....................                   fprintf(STDOUT, "Reseting readings\r\n"); 
0E40E:  MOVLW  38
0E410:  MOVWF  FF6
0E412:  MOVLW  29
0E414:  MOVWF  FF7
0E416:  CALL   2CA0
....................                   readings_reset(); 
0E41A:  CALL   92D4
....................                   break; 
0E41E:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if((strcmp(buffer, (unsigned char *)"cartridge") == 0) || (strcmp(buffer, (unsigned char *)"ct") == 0))  
0E422:  MOVLW  06
0E424:  MOVWF  FEA
0E426:  MOVLW  AE
0E428:  MOVWF  FE9
0E42A:  MOVLW  0A
0E42C:  MOVWF  01
0E42E:  CLRF   FF7
0E430:  MOVLW  00
0E432:  CALL   0286
0E436:  TBLRD*-
0E438:  TBLRD*+
0E43A:  MOVFF  FF5,FEE
0E43E:  DECFSZ 01,F
0E440:  BRA    E438
0E442:  MOVLW  05
0E444:  MOVLB  7
0E446:  MOVWF  x06
0E448:  MOVLW  91
0E44A:  MOVWF  x05
0E44C:  MOVLW  06
0E44E:  MOVWF  x08
0E450:  MOVLW  AE
0E452:  MOVWF  x07
0E454:  MOVLB  0
0E456:  CALL   952E
0E45A:  MOVF   01,F
0E45C:  BZ    E486
0E45E:  MOVLW  63
0E460:  MOVLB  6
0E462:  MOVWF  xAE
0E464:  MOVLW  74
0E466:  MOVWF  xAF
0E468:  CLRF   xB0
0E46A:  MOVLW  05
0E46C:  MOVLB  7
0E46E:  MOVWF  x06
0E470:  MOVLW  91
0E472:  MOVWF  x05
0E474:  MOVLW  06
0E476:  MOVWF  x08
0E478:  MOVLW  AE
0E47A:  MOVWF  x07
0E47C:  MOVLB  0
0E47E:  CALL   952E
0E482:  MOVF   01,F
0E484:  BNZ   E48E
....................                { 
....................                   check_bad_or_used_cartridge(); 
0E486:  CALL   501C
....................                   break; 
0E48A:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"play") == 0)  
0E48E:  MOVLW  70
0E490:  MOVLB  6
0E492:  MOVWF  xAE
0E494:  MOVLW  6C
0E496:  MOVWF  xAF
0E498:  MOVLW  61
0E49A:  MOVWF  xB0
0E49C:  MOVLW  79
0E49E:  MOVWF  xB1
0E4A0:  CLRF   xB2
0E4A2:  MOVLW  05
0E4A4:  MOVLB  7
0E4A6:  MOVWF  x06
0E4A8:  MOVLW  91
0E4AA:  MOVWF  x05
0E4AC:  MOVLW  06
0E4AE:  MOVWF  x08
0E4B0:  MOVLW  AE
0E4B2:  MOVWF  x07
0E4B4:  MOVLB  0
0E4B6:  CALL   952E
0E4BA:  MOVF   01,F
0E4BC:  BNZ   E4D2
....................                { 
....................                   fprintf(STDOUT, "Jingle bells\r\n"); 
0E4BE:  MOVLW  4C
0E4C0:  MOVWF  FF6
0E4C2:  MOVLW  29
0E4C4:  MOVWF  FF7
0E4C6:  CALL   2CA0
....................                   play(); 
0E4CA:  GOTO   CE8C
....................                   break; 
0E4CE:  GOTO   EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"bright730=") == 0)  
0E4D2:  MOVLW  06
0E4D4:  MOVWF  FEA
0E4D6:  MOVLW  AE
0E4D8:  MOVWF  FE9
0E4DA:  MOVLW  0B
0E4DC:  MOVWF  01
0E4DE:  CLRF   FF7
0E4E0:  MOVLW  00
0E4E2:  CALL   02A0
0E4E6:  TBLRD*-
0E4E8:  TBLRD*+
0E4EA:  MOVFF  FF5,FEE
0E4EE:  DECFSZ 01,F
0E4F0:  BRA    E4E8
0E4F2:  MOVLW  05
0E4F4:  MOVLB  7
0E4F6:  MOVWF  x06
0E4F8:  MOVLW  91
0E4FA:  MOVWF  x05
0E4FC:  MOVLW  06
0E4FE:  MOVWF  x08
0E500:  MOVLW  AE
0E502:  MOVWF  x07
0E504:  MOVLB  0
0E506:  CALL   952E
0E50A:  MOVF   01,F
0E50C:  BNZ   E54A
....................                { 
....................                   ConfigWriteByte(CONFIG_LED730_BRIGHTNESS_ADDRESS, get_Int8());    
0E50E:  CALL   C42A
0E512:  MOVFF  01,701
0E516:  MOVLB  7
0E518:  CLRF   x4C
0E51A:  CLRF   x4B
0E51C:  MOVFF  01,74D
0E520:  MOVLB  0
0E522:  CALL   556C
....................                   fprintf(STDOUT, "\r\n"); 
0E526:  MOVLW  0D
0E528:  BTFSS  FA4.4
0E52A:  BRA    E528
0E52C:  MOVWF  F73
0E52E:  MOVLW  0A
0E530:  BTFSS  FA4.4
0E532:  BRA    E530
0E534:  MOVWF  F73
....................                   LedProperties.LevelBrightness730 = ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS); 
0E536:  MOVLB  7
0E538:  CLRF   x53
0E53A:  CLRF   x52
0E53C:  MOVLB  0
0E53E:  CALL   429C
0E542:  MOVFF  01,50D
....................                   break; 
0E546:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"bright588=") == 0)  
0E54A:  MOVLW  06
0E54C:  MOVWF  FEA
0E54E:  MOVLW  AE
0E550:  MOVWF  FE9
0E552:  MOVLW  0B
0E554:  MOVWF  01
0E556:  CLRF   FF7
0E558:  MOVLW  00
0E55A:  CALL   02BC
0E55E:  TBLRD*-
0E560:  TBLRD*+
0E562:  MOVFF  FF5,FEE
0E566:  DECFSZ 01,F
0E568:  BRA    E560
0E56A:  MOVLW  05
0E56C:  MOVLB  7
0E56E:  MOVWF  x06
0E570:  MOVLW  91
0E572:  MOVWF  x05
0E574:  MOVLW  06
0E576:  MOVWF  x08
0E578:  MOVLW  AE
0E57A:  MOVWF  x07
0E57C:  MOVLB  0
0E57E:  CALL   952E
0E582:  MOVF   01,F
0E584:  BNZ   E5C6
....................                { 
....................                   ConfigWriteByte(CONFIG_LED588_BRIGHTNESS_ADDRESS, get_Int8()); 
0E586:  CALL   C42A
0E58A:  MOVFF  01,701
0E58E:  MOVLB  7
0E590:  CLRF   x4C
0E592:  MOVLW  01
0E594:  MOVWF  x4B
0E596:  MOVFF  01,74D
0E59A:  MOVLB  0
0E59C:  CALL   556C
....................                   fprintf(STDOUT, "\r\n"); 
0E5A0:  MOVLW  0D
0E5A2:  BTFSS  FA4.4
0E5A4:  BRA    E5A2
0E5A6:  MOVWF  F73
0E5A8:  MOVLW  0A
0E5AA:  BTFSS  FA4.4
0E5AC:  BRA    E5AA
0E5AE:  MOVWF  F73
....................                   LedProperties.LevelBrightness588 = ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS); 
0E5B0:  MOVLB  7
0E5B2:  CLRF   x53
0E5B4:  MOVLW  01
0E5B6:  MOVWF  x52
0E5B8:  MOVLB  0
0E5BA:  CALL   429C
0E5BE:  MOVFF  01,50E
....................                   break; 
0E5C2:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"bright475=") == 0)  
0E5C6:  MOVLW  06
0E5C8:  MOVWF  FEA
0E5CA:  MOVLW  AE
0E5CC:  MOVWF  FE9
0E5CE:  MOVLW  0B
0E5D0:  MOVWF  01
0E5D2:  CLRF   FF7
0E5D4:  MOVLW  00
0E5D6:  CALL   02D8
0E5DA:  TBLRD*-
0E5DC:  TBLRD*+
0E5DE:  MOVFF  FF5,FEE
0E5E2:  DECFSZ 01,F
0E5E4:  BRA    E5DC
0E5E6:  MOVLW  05
0E5E8:  MOVLB  7
0E5EA:  MOVWF  x06
0E5EC:  MOVLW  91
0E5EE:  MOVWF  x05
0E5F0:  MOVLW  06
0E5F2:  MOVWF  x08
0E5F4:  MOVLW  AE
0E5F6:  MOVWF  x07
0E5F8:  MOVLB  0
0E5FA:  CALL   952E
0E5FE:  MOVF   01,F
0E600:  BNZ   E642
....................                { 
....................                   ConfigWriteByte(CONFIG_LED475_BRIGHTNESS_ADDRESS, get_Int8()); 
0E602:  CALL   C42A
0E606:  MOVFF  01,701
0E60A:  MOVLB  7
0E60C:  CLRF   x4C
0E60E:  MOVLW  02
0E610:  MOVWF  x4B
0E612:  MOVFF  01,74D
0E616:  MOVLB  0
0E618:  CALL   556C
....................                   fprintf(STDOUT, "\r\n"); 
0E61C:  MOVLW  0D
0E61E:  BTFSS  FA4.4
0E620:  BRA    E61E
0E622:  MOVWF  F73
0E624:  MOVLW  0A
0E626:  BTFSS  FA4.4
0E628:  BRA    E626
0E62A:  MOVWF  F73
....................                   LedProperties.LevelBrightness475 = ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS); 
0E62C:  MOVLB  7
0E62E:  CLRF   x53
0E630:  MOVLW  02
0E632:  MOVWF  x52
0E634:  MOVLB  0
0E636:  CALL   429C
0E63A:  MOVFF  01,50F
....................                   break; 
0E63E:  GOTO   EF90
....................                } 
....................  
....................                if((strcmp(buffer, (unsigned char *)"brightness") == 0) || (strcmp(buffer, (unsigned char *)"bt") == 0))  
0E642:  MOVLW  06
0E644:  MOVWF  FEA
0E646:  MOVLW  AE
0E648:  MOVWF  FE9
0E64A:  MOVLW  0B
0E64C:  MOVWF  01
0E64E:  CLRF   FF7
0E650:  MOVLW  00
0E652:  CALL   02F4
0E656:  TBLRD*-
0E658:  TBLRD*+
0E65A:  MOVFF  FF5,FEE
0E65E:  DECFSZ 01,F
0E660:  BRA    E658
0E662:  MOVLW  05
0E664:  MOVLB  7
0E666:  MOVWF  x06
0E668:  MOVLW  91
0E66A:  MOVWF  x05
0E66C:  MOVLW  06
0E66E:  MOVWF  x08
0E670:  MOVLW  AE
0E672:  MOVWF  x07
0E674:  MOVLB  0
0E676:  CALL   952E
0E67A:  MOVF   01,F
0E67C:  BZ    E6A6
0E67E:  MOVLW  62
0E680:  MOVLB  6
0E682:  MOVWF  xAE
0E684:  MOVLW  74
0E686:  MOVWF  xAF
0E688:  CLRF   xB0
0E68A:  MOVLW  05
0E68C:  MOVLB  7
0E68E:  MOVWF  x06
0E690:  MOVLW  91
0E692:  MOVWF  x05
0E694:  MOVLW  06
0E696:  MOVWF  x08
0E698:  MOVLW  AE
0E69A:  MOVWF  x07
0E69C:  MOVLB  0
0E69E:  CALL   952E
0E6A2:  MOVF   01,F
0E6A4:  BNZ   E6AE
....................                { 
....................                   get_LED_Brightness(); 
0E6A6:  CALL   558A
....................                   break; 
0E6AA:  GOTO   EF90
....................                } 
....................           
....................                if(strcmp(buffer, (unsigned char *)"led475") == 0)  
0E6AE:  MOVLW  06
0E6B0:  MOVWF  FEA
0E6B2:  MOVLW  AE
0E6B4:  MOVWF  FE9
0E6B6:  MOVLW  07
0E6B8:  MOVWF  01
0E6BA:  CLRF   FF7
0E6BC:  MOVLW  00
0E6BE:  CALL   0310
0E6C2:  TBLRD*-
0E6C4:  TBLRD*+
0E6C6:  MOVFF  FF5,FEE
0E6CA:  DECFSZ 01,F
0E6CC:  BRA    E6C4
0E6CE:  MOVLW  05
0E6D0:  MOVLB  7
0E6D2:  MOVWF  x06
0E6D4:  MOVLW  91
0E6D6:  MOVWF  x05
0E6D8:  MOVLW  06
0E6DA:  MOVWF  x08
0E6DC:  MOVLW  AE
0E6DE:  MOVWF  x07
0E6E0:  MOVLB  0
0E6E2:  CALL   952E
0E6E6:  MOVF   01,F
0E6E8:  BNZ   E724
....................                { 
....................                   illumination_brightness(ConfigReadByte(CONFIG_LED475_BRIGHTNESS_ADDRESS)); 
0E6EA:  MOVLB  7
0E6EC:  CLRF   x53
0E6EE:  MOVLW  02
0E6F0:  MOVWF  x52
0E6F2:  MOVLB  0
0E6F4:  CALL   429C
0E6F8:  MOVFF  01,701
0E6FC:  MOVFF  01,812
0E700:  CALL   42F2
....................                   fprintf(STDOUT, "LED 475 on\r\n"); 
0E704:  MOVLW  5C
0E706:  MOVWF  FF6
0E708:  MOVLW  29
0E70A:  MOVWF  FF7
0E70C:  CALL   2CA0
....................                   illumination_use(ILLUMINATION_475); 
0E710:  MOVLW  7C
0E712:  MOVLB  8
0E714:  MOVWF  x13
0E716:  MOVLW  04
0E718:  MOVWF  x12
0E71A:  MOVLB  0
0E71C:  CALL   4394
....................                   break; 
0E720:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"led588") == 0)  
0E724:  MOVLW  06
0E726:  MOVWF  FEA
0E728:  MOVLW  AE
0E72A:  MOVWF  FE9
0E72C:  MOVLW  07
0E72E:  MOVWF  01
0E730:  CLRF   FF7
0E732:  MOVLW  00
0E734:  CALL   0328
0E738:  TBLRD*-
0E73A:  TBLRD*+
0E73C:  MOVFF  FF5,FEE
0E740:  DECFSZ 01,F
0E742:  BRA    E73A
0E744:  MOVLW  05
0E746:  MOVLB  7
0E748:  MOVWF  x06
0E74A:  MOVLW  91
0E74C:  MOVWF  x05
0E74E:  MOVLW  06
0E750:  MOVWF  x08
0E752:  MOVLW  AE
0E754:  MOVWF  x07
0E756:  MOVLB  0
0E758:  CALL   952E
0E75C:  MOVF   01,F
0E75E:  BNZ   E79A
....................                { 
....................                   illumination_brightness(ConfigReadByte(CONFIG_LED588_BRIGHTNESS_ADDRESS)); 
0E760:  MOVLB  7
0E762:  CLRF   x53
0E764:  MOVLW  01
0E766:  MOVWF  x52
0E768:  MOVLB  0
0E76A:  CALL   429C
0E76E:  MOVFF  01,701
0E772:  MOVFF  01,812
0E776:  CALL   42F2
....................                   fprintf(STDOUT, "LED 588 on\r\n"); 
0E77A:  MOVLW  6A
0E77C:  MOVWF  FF6
0E77E:  MOVLW  29
0E780:  MOVWF  FF7
0E782:  CALL   2CA0
....................                   illumination_use(ILLUMINATION_588); 
0E786:  MOVLW  7C
0E788:  MOVLB  8
0E78A:  MOVWF  x13
0E78C:  MOVLW  10
0E78E:  MOVWF  x12
0E790:  MOVLB  0
0E792:  CALL   4394
....................                   break; 
0E796:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"led730") == 0)  
0E79A:  MOVLW  06
0E79C:  MOVWF  FEA
0E79E:  MOVLW  AE
0E7A0:  MOVWF  FE9
0E7A2:  MOVLW  07
0E7A4:  MOVWF  01
0E7A6:  CLRF   FF7
0E7A8:  MOVLW  00
0E7AA:  CALL   0340
0E7AE:  TBLRD*-
0E7B0:  TBLRD*+
0E7B2:  MOVFF  FF5,FEE
0E7B6:  DECFSZ 01,F
0E7B8:  BRA    E7B0
0E7BA:  MOVLW  05
0E7BC:  MOVLB  7
0E7BE:  MOVWF  x06
0E7C0:  MOVLW  91
0E7C2:  MOVWF  x05
0E7C4:  MOVLW  06
0E7C6:  MOVWF  x08
0E7C8:  MOVLW  AE
0E7CA:  MOVWF  x07
0E7CC:  MOVLB  0
0E7CE:  CALL   952E
0E7D2:  MOVF   01,F
0E7D4:  BNZ   E80E
....................                { 
....................                   illumination_brightness(ConfigReadByte(CONFIG_LED730_BRIGHTNESS_ADDRESS)); 
0E7D6:  MOVLB  7
0E7D8:  CLRF   x53
0E7DA:  CLRF   x52
0E7DC:  MOVLB  0
0E7DE:  CALL   429C
0E7E2:  MOVFF  01,701
0E7E6:  MOVFF  01,812
0E7EA:  CALL   42F2
....................                   fprintf(STDOUT, "LED 730 on\r\n"); 
0E7EE:  MOVLW  78
0E7F0:  MOVWF  FF6
0E7F2:  MOVLW  29
0E7F4:  MOVWF  FF7
0E7F6:  CALL   2CA0
....................                   illumination_use(ILLUMINATION_730); 
0E7FA:  MOVLW  7C
0E7FC:  MOVLB  8
0E7FE:  MOVWF  x13
0E800:  MOVLW  05
0E802:  MOVWF  x12
0E804:  MOVLB  0
0E806:  CALL   4394
....................                   break; 
0E80A:  GOTO   EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"ledoff") == 0)  
0E80E:  MOVLW  06
0E810:  MOVWF  FEA
0E812:  MOVLW  AE
0E814:  MOVWF  FE9
0E816:  MOVLW  07
0E818:  MOVWF  01
0E81A:  CLRF   FF7
0E81C:  MOVLW  00
0E81E:  CALL   0358
0E822:  TBLRD*-
0E824:  TBLRD*+
0E826:  MOVFF  FF5,FEE
0E82A:  DECFSZ 01,F
0E82C:  BRA    E824
0E82E:  MOVLW  05
0E830:  MOVLB  7
0E832:  MOVWF  x06
0E834:  MOVLW  91
0E836:  MOVWF  x05
0E838:  MOVLW  06
0E83A:  MOVWF  x08
0E83C:  MOVLW  AE
0E83E:  MOVWF  x07
0E840:  MOVLB  0
0E842:  CALL   952E
0E846:  MOVF   01,F
0E848:  BNZ   E85C
....................                { 
....................                   fprintf(STDOUT, "LED off\r\n"); 
0E84A:  MOVLW  86
0E84C:  MOVWF  FF6
0E84E:  MOVLW  29
0E850:  MOVWF  FF7
0E852:  CALL   2CA0
....................                   illumination_all_off(); 
0E856:  CALL   4344
....................                   break; 
0E85A:  BRA    EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"read1") == 0)  
0E85C:  MOVLW  72
0E85E:  MOVLB  6
0E860:  MOVWF  xAE
0E862:  MOVLW  65
0E864:  MOVWF  xAF
0E866:  MOVLW  61
0E868:  MOVWF  xB0
0E86A:  MOVLW  64
0E86C:  MOVWF  xB1
0E86E:  MOVLW  31
0E870:  MOVWF  xB2
0E872:  CLRF   xB3
0E874:  MOVLW  05
0E876:  MOVLB  7
0E878:  MOVWF  x06
0E87A:  MOVLW  91
0E87C:  MOVWF  x05
0E87E:  MOVLW  06
0E880:  MOVWF  x08
0E882:  MOVLW  AE
0E884:  MOVWF  x07
0E886:  MOVLB  0
0E888:  CALL   952E
0E88C:  MOVF   01,F
0E88E:  BNZ   E8EA
....................                { 
....................                   fprintf(STDOUT, "Reading: %lu\r\n", photodiode()); 
0E890:  CALL   4FFC
0E894:  MOVFF  02,702
0E898:  MOVFF  01,701
0E89C:  MOVLW  90
0E89E:  MOVWF  FF6
0E8A0:  MOVLW  29
0E8A2:  MOVWF  FF7
0E8A4:  CLRF   19
0E8A6:  BTFSC  FF2.7
0E8A8:  BSF    19.7
0E8AA:  BCF    FF2.7
0E8AC:  MOVLW  09
0E8AE:  MOVLB  9
0E8B0:  MOVWF  x66
0E8B2:  MOVLB  0
0E8B4:  CALL   0AAC
0E8B8:  BTFSC  19.7
0E8BA:  BSF    FF2.7
0E8BC:  MOVLW  10
0E8BE:  MOVWF  FE9
0E8C0:  CLRF   19
0E8C2:  BTFSC  FF2.7
0E8C4:  BSF    19.7
0E8C6:  BCF    FF2.7
0E8C8:  MOVFF  702,967
0E8CC:  MOVFF  701,966
0E8D0:  CALL   0AD6
0E8D4:  BTFSC  19.7
0E8D6:  BSF    FF2.7
0E8D8:  MOVLW  0D
0E8DA:  BTFSS  FA4.4
0E8DC:  BRA    E8DA
0E8DE:  MOVWF  F73
0E8E0:  MOVLW  0A
0E8E2:  BTFSS  FA4.4
0E8E4:  BRA    E8E2
0E8E6:  MOVWF  F73
....................                   break; 
0E8E8:  BRA    EF90
....................                } 
....................                 
....................                if(strcmp(buffer, (unsigned char *)"read10") == 0) 
0E8EA:  MOVLW  06
0E8EC:  MOVWF  FEA
0E8EE:  MOVLW  AE
0E8F0:  MOVWF  FE9
0E8F2:  MOVLW  07
0E8F4:  MOVWF  01
0E8F6:  CLRF   FF7
0E8F8:  MOVLW  00
0E8FA:  CALL   0370
0E8FE:  TBLRD*-
0E900:  TBLRD*+
0E902:  MOVFF  FF5,FEE
0E906:  DECFSZ 01,F
0E908:  BRA    E900
0E90A:  MOVLW  05
0E90C:  MOVLB  7
0E90E:  MOVWF  x06
0E910:  MOVLW  91
0E912:  MOVWF  x05
0E914:  MOVLW  06
0E916:  MOVWF  x08
0E918:  MOVLW  AE
0E91A:  MOVWF  x07
0E91C:  MOVLB  0
0E91E:  CALL   952E
0E922:  MOVF   01,F
0E924:  BTFSS  FD8.2
0E926:  BRA    EA80
....................                { 
....................                   int32 sum = 0; 
....................                   int32 count = 10; 
0E928:  MOVLB  6
0E92A:  CLRF   xDF
0E92C:  CLRF   xDE
0E92E:  CLRF   xDD
0E930:  CLRF   xDC
0E932:  CLRF   xE3
0E934:  CLRF   xE2
0E936:  CLRF   xE1
0E938:  MOVLW  0A
0E93A:  MOVWF  xE0
....................                 
....................                   for(int i = 0; i < count; i++)  
0E93C:  CLRF   xE4
0E93E:  MOVFF  6E4,00
0E942:  CLRF   01
0E944:  CLRF   02
0E946:  CLRF   03
0E948:  BTFSS  00.7
0E94A:  BRA    E952
0E94C:  DECF   01,F
0E94E:  DECF   02,F
0E950:  DECF   03,F
0E952:  BTFSS  03.7
0E954:  BRA    E95C
0E956:  BTFSS  xE3.7
0E958:  BRA    E97E
0E95A:  BRA    E960
0E95C:  BTFSC  xE3.7
0E95E:  BRA    E9C0
0E960:  MOVF   03,W
0E962:  SUBWF  xE3,W
0E964:  BNC   E9C0
0E966:  BNZ   E97E
0E968:  MOVF   02,W
0E96A:  SUBWF  xE2,W
0E96C:  BNC   E9C0
0E96E:  BNZ   E97E
0E970:  MOVF   01,W
0E972:  SUBWF  xE1,W
0E974:  BNC   E9C0
0E976:  BNZ   E97E
0E978:  MOVF   xE0,W
0E97A:  SUBWF  00,W
0E97C:  BC    E9C0
....................                   { 
....................                      sum += photodiode(); 
0E97E:  MOVLB  0
0E980:  CALL   4FFC
0E984:  MOVFF  02,03
0E988:  MOVFF  01,00
0E98C:  MOVFF  02,01
0E990:  CLRF   02
0E992:  CLRF   03
0E994:  BTFSS  01.7
0E996:  BRA    E99C
0E998:  DECF   02,F
0E99A:  DECF   03,F
0E99C:  MOVF   00,W
0E99E:  MOVLB  6
0E9A0:  ADDWF  xDC,F
0E9A2:  MOVF   01,W
0E9A4:  ADDWFC xDD,F
0E9A6:  MOVF   02,W
0E9A8:  ADDWFC xDE,F
0E9AA:  MOVF   03,W
0E9AC:  ADDWFC xDF,F
....................                      delay_ms(20); 
0E9AE:  MOVLW  14
0E9B0:  MOVLB  8
0E9B2:  MOVWF  x18
0E9B4:  MOVLB  0
0E9B6:  CALL   2D2E
0E9BA:  MOVLB  6
0E9BC:  INCF   xE4,F
0E9BE:  BRA    E93E
....................                   } 
....................  
....................                   fprintf(STDOUT, "Reading (10-avg): %.4f\r\n", (double)sum/(double)count); 
0E9C0:  MOVFF  6DF,831
0E9C4:  MOVFF  6DE,830
0E9C8:  MOVFF  6DD,82F
0E9CC:  MOVFF  6DC,82E
0E9D0:  MOVLB  0
0E9D2:  CALL   9982
0E9D6:  MOVFF  03,704
0E9DA:  MOVFF  02,703
0E9DE:  MOVFF  01,702
0E9E2:  MOVFF  00,701
0E9E6:  MOVFF  6E3,831
0E9EA:  MOVFF  6E2,830
0E9EE:  MOVFF  6E1,82F
0E9F2:  MOVFF  6E0,82E
0E9F6:  CALL   9982
0E9FA:  MOVFF  704,819
0E9FE:  MOVFF  703,818
0EA02:  MOVFF  702,817
0EA06:  MOVFF  701,816
0EA0A:  MOVFF  03,81D
0EA0E:  MOVFF  02,81C
0EA12:  MOVFF  01,81B
0EA16:  MOVFF  00,81A
0EA1A:  CALL   6272
0EA1E:  MOVFF  03,704
0EA22:  MOVFF  02,703
0EA26:  MOVFF  01,702
0EA2A:  MOVFF  00,701
0EA2E:  MOVLW  A0
0EA30:  MOVWF  FF6
0EA32:  MOVLW  29
0EA34:  MOVWF  FF7
0EA36:  CLRF   19
0EA38:  BTFSC  FF2.7
0EA3A:  BSF    19.7
0EA3C:  BCF    FF2.7
0EA3E:  MOVLW  12
0EA40:  MOVLB  9
0EA42:  MOVWF  x66
0EA44:  MOVLB  0
0EA46:  CALL   0AAC
0EA4A:  BTFSC  19.7
0EA4C:  BSF    FF2.7
0EA4E:  MOVLW  89
0EA50:  MOVWF  FE9
0EA52:  MOVFF  704,815
0EA56:  MOVFF  703,814
0EA5A:  MOVFF  702,813
0EA5E:  MOVFF  701,812
0EA62:  MOVLW  04
0EA64:  MOVLB  8
0EA66:  MOVWF  x16
0EA68:  MOVLB  0
0EA6A:  CALL   40FE
0EA6E:  MOVLW  0D
0EA70:  BTFSS  FA4.4
0EA72:  BRA    EA70
0EA74:  MOVWF  F73
0EA76:  MOVLW  0A
0EA78:  BTFSS  FA4.4
0EA7A:  BRA    EA78
0EA7C:  MOVWF  F73
....................                   break; 
0EA7E:  BRA    EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"readcsv") == 0)  
0EA80:  MOVLW  06
0EA82:  MOVWF  FEA
0EA84:  MOVLW  AE
0EA86:  MOVWF  FE9
0EA88:  MOVLW  08
0EA8A:  MOVWF  01
0EA8C:  CLRF   FF7
0EA8E:  MOVLW  00
0EA90:  CALL   0388
0EA94:  TBLRD*-
0EA96:  TBLRD*+
0EA98:  MOVFF  FF5,FEE
0EA9C:  DECFSZ 01,F
0EA9E:  BRA    EA96
0EAA0:  MOVLW  05
0EAA2:  MOVLB  7
0EAA4:  MOVWF  x06
0EAA6:  MOVLW  91
0EAA8:  MOVWF  x05
0EAAA:  MOVLW  06
0EAAC:  MOVWF  x08
0EAAE:  MOVLW  AE
0EAB0:  MOVWF  x07
0EAB2:  MOVLB  0
0EAB4:  CALL   952E
0EAB8:  MOVF   01,F
0EABA:  BNZ   EACE
....................                { 
....................                   float32 con; 
....................                   readings_csv(&con); 
0EABC:  MOVLW  06
0EABE:  MOVLB  7
0EAC0:  MOVWF  x38
0EAC2:  MOVLW  E5
0EAC4:  MOVWF  x37
0EAC6:  MOVLB  0
0EAC8:  CALL   7BEA
....................                   break; 
0EACC:  BRA    EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"calibrate") == 0)  
0EACE:  MOVLW  06
0EAD0:  MOVWF  FEA
0EAD2:  MOVLW  AE
0EAD4:  MOVWF  FE9
0EAD6:  MOVLW  0A
0EAD8:  MOVWF  01
0EADA:  CLRF   FF7
0EADC:  MOVLW  00
0EADE:  CALL   03A0
0EAE2:  TBLRD*-
0EAE4:  TBLRD*+
0EAE6:  MOVFF  FF5,FEE
0EAEA:  DECFSZ 01,F
0EAEC:  BRA    EAE4
0EAEE:  MOVLW  05
0EAF0:  MOVLB  7
0EAF2:  MOVWF  x06
0EAF4:  MOVLW  91
0EAF6:  MOVWF  x05
0EAF8:  MOVLW  06
0EAFA:  MOVWF  x08
0EAFC:  MOVLW  AE
0EAFE:  MOVWF  x07
0EB00:  MOVLB  0
0EB02:  CALL   952E
0EB06:  MOVF   01,F
0EB08:  BNZ   EB3C
....................                { 
....................                   fprintf(STDOUT, "\r\n"); 
0EB0A:  MOVLW  0D
0EB0C:  BTFSS  FA4.4
0EB0E:  BRA    EB0C
0EB10:  MOVWF  F73
0EB12:  MOVLW  0A
0EB14:  BTFSS  FA4.4
0EB16:  BRA    EB14
0EB18:  MOVWF  F73
....................                   ShowPrompt(); 
0EB1A:  CALL   4E82
....................                   fprintf(STDOUT, "Executing calibration...\r\n"); 
0EB1E:  MOVLW  BA
0EB20:  MOVWF  FF6
0EB22:  MOVLW  29
0EB24:  MOVWF  FF7
0EB26:  CALL   2CA0
....................                   status = performBreathTest( CALIBRATION_TEST  ); 
0EB2A:  MOVLW  01
0EB2C:  MOVLB  7
0EB2E:  MOVWF  x01
0EB30:  MOVLB  0
0EB32:  CALL   86CC
0EB36:  MOVFF  01,58A
....................                   break; 
0EB3A:  BRA    EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if( (strcmp(buffer, (unsigned char *)"fulltest") == 0) || (strcmp(buffer, (unsigned char *)"ft") == 0) )  
0EB3C:  MOVLW  06
0EB3E:  MOVWF  FEA
0EB40:  MOVLW  AE
0EB42:  MOVWF  FE9
0EB44:  MOVLW  09
0EB46:  MOVWF  01
0EB48:  CLRF   FF7
0EB4A:  MOVLW  00
0EB4C:  CALL   03BA
0EB50:  TBLRD*-
0EB52:  TBLRD*+
0EB54:  MOVFF  FF5,FEE
0EB58:  DECFSZ 01,F
0EB5A:  BRA    EB52
0EB5C:  MOVLW  05
0EB5E:  MOVLB  7
0EB60:  MOVWF  x06
0EB62:  MOVLW  91
0EB64:  MOVWF  x05
0EB66:  MOVLW  06
0EB68:  MOVWF  x08
0EB6A:  MOVLW  AE
0EB6C:  MOVWF  x07
0EB6E:  MOVLB  0
0EB70:  CALL   952E
0EB74:  MOVF   01,F
0EB76:  BZ    EBA0
0EB78:  MOVLW  66
0EB7A:  MOVLB  6
0EB7C:  MOVWF  xAE
0EB7E:  MOVLW  74
0EB80:  MOVWF  xAF
0EB82:  CLRF   xB0
0EB84:  MOVLW  05
0EB86:  MOVLB  7
0EB88:  MOVWF  x06
0EB8A:  MOVLW  91
0EB8C:  MOVWF  x05
0EB8E:  MOVLW  06
0EB90:  MOVWF  x08
0EB92:  MOVLW  AE
0EB94:  MOVWF  x07
0EB96:  MOVLB  0
0EB98:  CALL   952E
0EB9C:  MOVF   01,F
0EB9E:  BNZ   EBCC
....................                { 
....................                   status = performBreathTest( KETONE_TEST ); 
0EBA0:  MOVLW  02
0EBA2:  MOVLB  7
0EBA4:  MOVWF  x01
0EBA6:  MOVLB  0
0EBA8:  CALL   86CC
0EBAC:  MOVFF  01,58A
....................                    
....................                   if( status != PASS ) 
0EBB0:  MOVLB  5
0EBB2:  DECFSZ x8A,W
0EBB4:  BRA    EBB8
0EBB6:  BRA    EBC8
....................                      fprintf(STDOUT, "******  Ketone Detection Test failed  ******\r\n"); 
0EBB8:  MOVLW  D6
0EBBA:  MOVWF  FF6
0EBBC:  MOVLW  29
0EBBE:  MOVWF  FF7
0EBC0:  MOVLB  0
0EBC2:  CALL   2CA0
0EBC6:  MOVLB  5
....................                 
....................                   break; 
0EBC8:  MOVLB  0
0EBCA:  BRA    EF90
....................                } 
....................  
....................          //////////////////////////////////////////////// 
....................  
....................                if(strcmp(buffer, (unsigned char *)"reading") == 0)  
0EBCC:  MOVLW  06
0EBCE:  MOVWF  FEA
0EBD0:  MOVLW  AE
0EBD2:  MOVWF  FE9
0EBD4:  MOVLW  08
0EBD6:  MOVWF  01
0EBD8:  CLRF   FF7
0EBDA:  MOVLW  00
0EBDC:  CALL   03D4
0EBE0:  TBLRD*-
0EBE2:  TBLRD*+
0EBE4:  MOVFF  FF5,FEE
0EBE8:  DECFSZ 01,F
0EBEA:  BRA    EBE2
0EBEC:  MOVLW  05
0EBEE:  MOVLB  7
0EBF0:  MOVWF  x06
0EBF2:  MOVLW  91
0EBF4:  MOVWF  x05
0EBF6:  MOVLW  06
0EBF8:  MOVWF  x08
0EBFA:  MOVLW  AE
0EBFC:  MOVWF  x07
0EBFE:  MOVLB  0
0EC00:  CALL   952E
0EC04:  MOVF   01,F
0EC06:  BTFSS  FD8.2
0EC08:  BRA    EE98
....................                { 
....................     
....................                   fprintf(STDOUT, "Duration: "); 
0EC0A:  MOVLW  06
0EC0C:  MOVWF  FF6
0EC0E:  MOVLW  2A
0EC10:  MOVWF  FF7
0EC12:  CALL   2CA0
....................                   int16 value = get_Int16(); 
0EC16:  CALL   C226
0EC1A:  MOVFF  02,6EA
0EC1E:  MOVFF  01,6E9
....................     
....................                   fprintf(STDOUT, "\r\nbright730: "); 
0EC22:  MOVLW  12
0EC24:  MOVWF  FF6
0EC26:  MOVLW  2A
0EC28:  MOVWF  FF7
0EC2A:  CALL   2CA0
....................                   int16 brightness730 = get_Int16(); 
0EC2E:  CALL   C226
0EC32:  MOVFF  02,6EC
0EC36:  MOVFF  01,6EB
....................  
....................                   fprintf(STDOUT, "\r\nbright588: "); 
0EC3A:  MOVLW  20
0EC3C:  MOVWF  FF6
0EC3E:  MOVLW  2A
0EC40:  MOVWF  FF7
0EC42:  CALL   2CA0
....................                   int16 brightness588 = get_Int16(); 
0EC46:  CALL   C226
0EC4A:  MOVFF  02,6EE
0EC4E:  MOVFF  01,6ED
....................  
....................                   fprintf(STDOUT, "\r\nbright475: "); 
0EC52:  MOVLW  2E
0EC54:  MOVWF  FF6
0EC56:  MOVLW  2A
0EC58:  MOVWF  FF7
0EC5A:  CALL   2CA0
....................                   int16 brightness475 = get_Int16(); 
0EC5E:  CALL   C226
0EC62:  MOVFF  02,6F0
0EC66:  MOVFF  01,6EF
....................                   fprintf(STDOUT, "\r\nindex, LED730, LED588, LED475\r\n"); 
0EC6A:  MOVLW  3C
0EC6C:  MOVWF  FF6
0EC6E:  MOVLW  2A
0EC70:  MOVWF  FF7
0EC72:  CALL   2CA0
....................     
....................                   for(int16 i = 0; i < value / 3; i++)  
0EC76:  MOVLB  6
0EC78:  CLRF   xF2
0EC7A:  CLRF   xF1
0EC7C:  MOVFF  6EA,74C
0EC80:  MOVFF  6E9,74B
0EC84:  MOVLB  7
0EC86:  CLRF   x4E
0EC88:  MOVLW  03
0EC8A:  MOVWF  x4D
0EC8C:  MOVLB  0
0EC8E:  CALL   54F4
0EC92:  MOVFF  02,03
0EC96:  MOVF   01,W
0EC98:  MOVLB  6
0EC9A:  BTFSS  xF2.7
0EC9C:  BRA    ECA4
0EC9E:  BTFSS  03.7
0ECA0:  BRA    ECBA
0ECA2:  BRA    ECA8
0ECA4:  BTFSC  03.7
0ECA6:  BRA    EE94
0ECA8:  MOVF   xF2,W
0ECAA:  SUBWF  03,W
0ECAC:  BTFSS  FD8.0
0ECAE:  BRA    EE94
0ECB0:  BNZ   ECBA
0ECB2:  MOVF   01,W
0ECB4:  SUBWF  xF1,W
0ECB6:  BTFSC  FD8.0
0ECB8:  BRA    EE94
....................                   { 
....................                      illumination_brightness(brightness730); 
0ECBA:  MOVFF  6EB,812
0ECBE:  MOVLB  0
0ECC0:  CALL   42F2
....................                      illumination_use(ILLUMINATION_730); 
0ECC4:  MOVLW  7C
0ECC6:  MOVLB  8
0ECC8:  MOVWF  x13
0ECCA:  MOVLW  05
0ECCC:  MOVWF  x12
0ECCE:  MOVLB  0
0ECD0:  CALL   4394
....................                      ble_wait(45); 
0ECD4:  MOVLB  7
0ECD6:  CLRF   x58
0ECD8:  CLRF   x57
0ECDA:  CLRF   x56
0ECDC:  MOVLW  2D
0ECDE:  MOVWF  x55
0ECE0:  MOVLB  0
0ECE2:  CALL   43F6
....................                      int16 led730 = photodiode(); 
0ECE6:  CALL   4FFC
0ECEA:  MOVFF  02,6F4
0ECEE:  MOVFF  01,6F3
....................                      ble_wait(5); 
0ECF2:  MOVLB  7
0ECF4:  CLRF   x58
0ECF6:  CLRF   x57
0ECF8:  CLRF   x56
0ECFA:  MOVLW  05
0ECFC:  MOVWF  x55
0ECFE:  MOVLB  0
0ED00:  CALL   43F6
....................    
....................                      illumination_brightness(brightness588); 
0ED04:  MOVFF  6ED,812
0ED08:  CALL   42F2
....................                      illumination_use(ILLUMINATION_588); 
0ED0C:  MOVLW  7C
0ED0E:  MOVLB  8
0ED10:  MOVWF  x13
0ED12:  MOVLW  10
0ED14:  MOVWF  x12
0ED16:  MOVLB  0
0ED18:  CALL   4394
....................                      ble_wait(45); 
0ED1C:  MOVLB  7
0ED1E:  CLRF   x58
0ED20:  CLRF   x57
0ED22:  CLRF   x56
0ED24:  MOVLW  2D
0ED26:  MOVWF  x55
0ED28:  MOVLB  0
0ED2A:  CALL   43F6
....................                      int16 led588 = photodiode(); 
0ED2E:  CALL   4FFC
0ED32:  MOVFF  02,6F6
0ED36:  MOVFF  01,6F5
....................                      ble_wait(5); 
0ED3A:  MOVLB  7
0ED3C:  CLRF   x58
0ED3E:  CLRF   x57
0ED40:  CLRF   x56
0ED42:  MOVLW  05
0ED44:  MOVWF  x55
0ED46:  MOVLB  0
0ED48:  CALL   43F6
....................  
....................                      illumination_brightness(brightness475); 
0ED4C:  MOVFF  6EF,812
0ED50:  CALL   42F2
....................                      illumination_use(ILLUMINATION_475); 
0ED54:  MOVLW  7C
0ED56:  MOVLB  8
0ED58:  MOVWF  x13
0ED5A:  MOVLW  04
0ED5C:  MOVWF  x12
0ED5E:  MOVLB  0
0ED60:  CALL   4394
....................                      ble_wait(45); 
0ED64:  MOVLB  7
0ED66:  CLRF   x58
0ED68:  CLRF   x57
0ED6A:  CLRF   x56
0ED6C:  MOVLW  2D
0ED6E:  MOVWF  x55
0ED70:  MOVLB  0
0ED72:  CALL   43F6
....................                      int16 led475 = photodiode(); 
0ED76:  CALL   4FFC
0ED7A:  MOVFF  02,6F8
0ED7E:  MOVFF  01,6F7
....................                      ble_wait(5); 
0ED82:  MOVLB  7
0ED84:  CLRF   x58
0ED86:  CLRF   x57
0ED88:  CLRF   x56
0ED8A:  MOVLW  05
0ED8C:  MOVWF  x55
0ED8E:  MOVLB  0
0ED90:  CALL   43F6
....................  
....................                      illumination_all_off(); 
0ED94:  CALL   4344
....................                      delay_ms(2850); 
0ED98:  MOVLW  0F
0ED9A:  MOVLB  7
0ED9C:  MOVWF  x01
0ED9E:  MOVLW  BE
0EDA0:  MOVLB  8
0EDA2:  MOVWF  x18
0EDA4:  MOVLB  0
0EDA6:  CALL   2D2E
0EDAA:  MOVLB  7
0EDAC:  DECFSZ x01,F
0EDAE:  BRA    ED9E
0EDB0:  CLRF   19
0EDB2:  BTFSC  FF2.7
0EDB4:  BSF    19.7
0EDB6:  BCF    FF2.7
....................     
....................                      int16 row = i * 3; 
0EDB8:  MOVFF  6F2,96B
0EDBC:  MOVFF  6F1,96A
0EDC0:  MOVLB  9
0EDC2:  CLRF   x6D
0EDC4:  MOVLW  03
0EDC6:  MOVWF  x6C
0EDC8:  MOVLB  0
0EDCA:  CALL   0C48
0EDCE:  BTFSC  19.7
0EDD0:  BSF    FF2.7
0EDD2:  MOVFF  02,6FA
0EDD6:  MOVFF  01,6F9
....................                      fprintf(STDOUT, "%lu, %lu, %lu, %lu\r\n", row, led730, led588, led475); 
0EDDA:  MOVLW  10
0EDDC:  MOVWF  FE9
0EDDE:  CLRF   19
0EDE0:  BTFSC  FF2.7
0EDE2:  BSF    19.7
0EDE4:  BCF    FF2.7
0EDE6:  MOVFF  6FA,967
0EDEA:  MOVFF  6F9,966
0EDEE:  CALL   0AD6
0EDF2:  BTFSC  19.7
0EDF4:  BSF    FF2.7
0EDF6:  MOVLW  2C
0EDF8:  BTFSS  FA4.4
0EDFA:  BRA    EDF8
0EDFC:  MOVWF  F73
0EDFE:  MOVLW  20
0EE00:  BTFSS  FA4.4
0EE02:  BRA    EE00
0EE04:  MOVWF  F73
0EE06:  MOVLW  10
0EE08:  MOVWF  FE9
0EE0A:  CLRF   19
0EE0C:  BTFSC  FF2.7
0EE0E:  BSF    19.7
0EE10:  BCF    FF2.7
0EE12:  MOVFF  6F4,967
0EE16:  MOVFF  6F3,966
0EE1A:  CALL   0AD6
0EE1E:  BTFSC  19.7
0EE20:  BSF    FF2.7
0EE22:  MOVLW  2C
0EE24:  BTFSS  FA4.4
0EE26:  BRA    EE24
0EE28:  MOVWF  F73
0EE2A:  MOVLW  20
0EE2C:  BTFSS  FA4.4
0EE2E:  BRA    EE2C
0EE30:  MOVWF  F73
0EE32:  MOVLW  10
0EE34:  MOVWF  FE9
0EE36:  CLRF   19
0EE38:  BTFSC  FF2.7
0EE3A:  BSF    19.7
0EE3C:  BCF    FF2.7
0EE3E:  MOVFF  6F6,967
0EE42:  MOVFF  6F5,966
0EE46:  CALL   0AD6
0EE4A:  BTFSC  19.7
0EE4C:  BSF    FF2.7
0EE4E:  MOVLW  2C
0EE50:  BTFSS  FA4.4
0EE52:  BRA    EE50
0EE54:  MOVWF  F73
0EE56:  MOVLW  20
0EE58:  BTFSS  FA4.4
0EE5A:  BRA    EE58
0EE5C:  MOVWF  F73
0EE5E:  MOVLW  10
0EE60:  MOVWF  FE9
0EE62:  CLRF   19
0EE64:  BTFSC  FF2.7
0EE66:  BSF    19.7
0EE68:  BCF    FF2.7
0EE6A:  MOVFF  6F8,967
0EE6E:  MOVFF  6F7,966
0EE72:  CALL   0AD6
0EE76:  BTFSC  19.7
0EE78:  BSF    FF2.7
0EE7A:  MOVLW  0D
0EE7C:  BTFSS  FA4.4
0EE7E:  BRA    EE7C
0EE80:  MOVWF  F73
0EE82:  MOVLW  0A
0EE84:  BTFSS  FA4.4
0EE86:  BRA    EE84
0EE88:  MOVWF  F73
0EE8A:  MOVLB  6
0EE8C:  INCF   xF1,F
0EE8E:  BTFSC  FD8.2
0EE90:  INCF   xF2,F
0EE92:  BRA    EC7C
....................                   } 
....................             
....................                   break; 
0EE94:  MOVLB  0
0EE96:  BRA    EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"setled") == 0) 
0EE98:  MOVLW  06
0EE9A:  MOVWF  FEA
0EE9C:  MOVLW  AE
0EE9E:  MOVWF  FE9
0EEA0:  MOVLW  07
0EEA2:  MOVWF  01
0EEA4:  CLRF   FF7
0EEA6:  MOVLW  00
0EEA8:  CALL   03EC
0EEAC:  TBLRD*-
0EEAE:  TBLRD*+
0EEB0:  MOVFF  FF5,FEE
0EEB4:  DECFSZ 01,F
0EEB6:  BRA    EEAE
0EEB8:  MOVLW  05
0EEBA:  MOVLB  7
0EEBC:  MOVWF  x06
0EEBE:  MOVLW  91
0EEC0:  MOVWF  x05
0EEC2:  MOVLW  06
0EEC4:  MOVWF  x08
0EEC6:  MOVLW  AE
0EEC8:  MOVWF  x07
0EECA:  MOVLB  0
0EECC:  CALL   952E
0EED0:  MOVF   01,F
0EED2:  BNZ   EF44
....................                { 
....................                   int16 bt730, bt588, bt475; 
....................              
....................                   bt730 = bt588 = bt475 = LED_BRIGHTNESS_DEFAULT_VALUE; 
0EED4:  MOVLB  7
0EED6:  CLRF   x00
0EED8:  MOVLW  32
0EEDA:  MOVLB  6
0EEDC:  MOVWF  xFF
0EEDE:  MOVFF  700,6FE
0EEE2:  MOVFF  6FF,6FD
0EEE6:  MOVFF  6FE,6FC
0EEEA:  MOVFF  6FD,6FB
....................                    
....................                   fprintf(STDOUT, "\r\nSet LED brightness index\r\n"); 
0EEEE:  MOVLW  5E
0EEF0:  MOVWF  FF6
0EEF2:  MOVLW  2A
0EEF4:  MOVWF  FF7
0EEF6:  MOVLB  0
0EEF8:  CALL   2CA0
....................                   fprintf(STDOUT, "****************************\r\n"); 
0EEFC:  MOVLW  7C
0EEFE:  MOVWF  FF6
0EF00:  MOVLW  2A
0EF02:  MOVWF  FF7
0EF04:  CALL   2CA0
....................                   status = autoSetLEDBrightness(bt730, bt588, bt475); 
0EF08:  MOVFF  6FC,732
0EF0C:  MOVFF  6FB,731
0EF10:  MOVFF  6FE,734
0EF14:  MOVFF  6FD,733
0EF18:  MOVFF  700,736
0EF1C:  MOVFF  6FF,735
0EF20:  CALL   56B4
0EF24:  MOVFF  01,58A
....................              
....................                   if( status != PASS ) 
0EF28:  MOVLB  5
0EF2A:  DECFSZ x8A,W
0EF2C:  BRA    EF30
0EF2E:  BRA    EF40
....................                      fprintf(STDOUT, "***** Auto brightness setting for LED730, LED588, LED475 failed *****\r\n"); 
0EF30:  MOVLW  9C
0EF32:  MOVWF  FF6
0EF34:  MOVLW  2A
0EF36:  MOVWF  FF7
0EF38:  MOVLB  0
0EF3A:  CALL   2CA0
0EF3E:  MOVLB  5
....................  
....................                   break; 
0EF40:  MOVLB  0
0EF42:  BRA    EF90
....................                } 
....................  
....................                if(strcmp(buffer, (unsigned char *)"caltest") == 0) 
0EF44:  MOVLW  06
0EF46:  MOVWF  FEA
0EF48:  MOVLW  AE
0EF4A:  MOVWF  FE9
0EF4C:  MOVLW  08
0EF4E:  MOVWF  01
0EF50:  CLRF   FF7
0EF52:  MOVLW  00
0EF54:  CALL   0404
0EF58:  TBLRD*-
0EF5A:  TBLRD*+
0EF5C:  MOVFF  FF5,FEE
0EF60:  DECFSZ 01,F
0EF62:  BRA    EF5A
0EF64:  MOVLW  05
0EF66:  MOVLB  7
0EF68:  MOVWF  x06
0EF6A:  MOVLW  91
0EF6C:  MOVWF  x05
0EF6E:  MOVLW  06
0EF70:  MOVWF  x08
0EF72:  MOVLW  AE
0EF74:  MOVWF  x07
0EF76:  MOVLB  0
0EF78:  CALL   952E
0EF7C:  MOVF   01,F
0EF7E:  BNZ   EF86
....................                { 
....................                   Calibrate(); 
0EF80:  CALL   7E5E
....................                   break; 
0EF84:  BRA    EF90
....................                } 
....................                
....................                break; 
0EF86:  BRA    EF90
0EF88:  MOVLB  6
0EF8A:  GOTO   D8AA
0EF8E:  MOVLB  0
....................             } 
....................           
....................             //////////////////////////////////////////////// 
....................             powerDownTimeCtr = INACTIVITY_TIME_LIMIT;          //Reset power down counter to 5 minutes  
0EF90:  MOVLB  5
0EF92:  CLRF   x0C
0EF94:  MOVLW  1E
0EF96:  MOVWF  x0B
....................             tmpCtr = 0; 
0EF98:  CLRF   x8D
....................             ShowPrompt(); 
0EF9A:  MOVLB  0
0EF9C:  CALL   4E82
0EFA0:  MOVLB  6
....................          } 
....................       } 
0EFA2:  MOVLB  0
0EFA4:  GOTO   D3B6
....................    } 
.................... } 
*
0EFA8:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
